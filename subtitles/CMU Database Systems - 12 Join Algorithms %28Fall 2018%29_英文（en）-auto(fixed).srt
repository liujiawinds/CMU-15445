1
00:00:00,730 --> 00:00:10,690
[Music]

2
00:00:10,690 --> 00:00:10,700


3
00:00:10,700 --> 00:00:18,740
maybe on the Jill's neck okay today

4
00:00:18,740 --> 00:00:18,750
 

5
00:00:18,750 --> 00:00:20,269
we're talk about joins and for

6
00:00:20,269 --> 00:00:20,279

7
00:00:20,279 --> 00:00:23,779
administrative things as I said project

8
00:00:23,779 --> 00:00:23,789
 

9
00:00:23,789 --> 00:00:25,970
to check when one is due today I did a

10
00:00:25,970 --> 00:00:25,980
 

11
00:00:25,980 --> 00:00:27,319
quick show of hands as he see was

12
00:00:27,319 --> 00:00:27,329
 

13
00:00:27,329 --> 00:00:28,310
actually finished but it's more people

14
00:00:28,310 --> 00:00:28,320
 

15
00:00:28,320 --> 00:00:29,839
I've come in the room who's actually

16
00:00:29,839 --> 00:00:29,849
 

17
00:00:29,849 --> 00:00:31,489
done this and got a hundred percent

18
00:00:31,489 --> 00:00:31,499
 

19
00:00:31,499 --> 00:00:34,340
there we go alright more people okay who

20
00:00:34,340 --> 00:00:34,350
 

21
00:00:34,350 --> 00:00:41,060
has not started good nobody alright the

22
00:00:41,060 --> 00:00:41,070
 

23
00:00:41,070 --> 00:00:42,710
other thing too is that there's no class

24
00:00:42,710 --> 00:00:42,720
 

25
00:00:42,720 --> 00:00:46,250
this Wednesday I had to deal with my

26
00:00:46,250 --> 00:00:46,260
 

27
00:00:46,260 --> 00:00:48,770
parole officer so I can't come to class

28
00:00:48,770 --> 00:00:48,780
 

29
00:00:48,780 --> 00:00:50,210
so that's gonna be entirely cancel and

30
00:00:50,210 --> 00:00:50,220
 

31
00:00:50,220 --> 00:00:51,860
use the time obviously to work on your

32
00:00:51,860 --> 00:00:51,870
 

33
00:00:51,870 --> 00:00:53,420
assignment but of course no one's gonna

34
00:00:53,420 --> 00:00:53,430
 

35
00:00:53,430 --> 00:00:56,150
do that but that's okay and then the

36
00:00:56,150 --> 00:00:56,160
 

37
00:00:56,160 --> 00:00:58,940
midterm exam will be in class in this

38
00:00:58,940 --> 00:00:58,950
 

39
00:00:58,950 --> 00:01:02,150
room Wednesday next week on October 17th

40
00:01:02,150 --> 00:01:02,160
 

41
00:01:02,160 --> 00:01:04,160
and it will cover everything up to and

42
00:01:04,160 --> 00:01:04,170
 

43
00:01:04,170 --> 00:01:05,509
including what we're talking about today

44
00:01:05,509 --> 00:01:05,519
 

45
00:01:05,519 --> 00:01:08,209
so on Mondays lecture next week

46
00:01:08,209 --> 00:01:08,219

47
00:01:08,219 --> 00:01:09,739
I think there's query optimization we

48
00:01:09,739 --> 00:01:09,749
 

49
00:01:09,749 --> 00:01:11,630
won't discuss that will be covered in

50
00:01:11,630 --> 00:01:11,640
 

51
00:01:11,640 --> 00:01:13,819
the exam at all and there's a homework

52
00:01:13,819 --> 00:01:13,829
 

53
00:01:13,829 --> 00:01:15,889
going out today on joint algorithms that

54
00:01:15,889 --> 00:01:15,899
 

55
00:01:15,899 --> 00:01:17,870
will begin germane to what's on the exam

56
00:01:17,870 --> 00:01:17,880
 

57
00:01:17,880 --> 00:01:21,319
so I'll post a study guide with again

58
00:01:21,319 --> 00:01:21,329
 

59
00:01:21,329 --> 00:01:22,940
again just to list the chapters and

60
00:01:22,940 --> 00:01:22,950
 

61
00:01:22,950 --> 00:01:24,169
homework problems that you should be

62
00:01:24,169 --> 00:01:24,179

63
00:01:24,179 --> 00:01:28,309
looking at I can also provide in the for

64
00:01:28,309 --> 00:01:28,319
 

65
00:01:28,319 --> 00:01:30,559
the textbook I think the odd problems

66
00:01:30,559 --> 00:01:30,569
 

67
00:01:30,569 --> 00:01:32,690
the answers are solutions are on the

68
00:01:32,690 --> 00:01:32,700
 

69
00:01:32,700 --> 00:01:33,800
internet so if you want to sort of do a

70
00:01:33,800 --> 00:01:33,810

71
00:01:33,810 --> 00:01:37,550
further you know further problems and

72
00:01:37,550 --> 00:01:37,560
 

73
00:01:37,560 --> 00:01:39,190
prepare for the exams you can do that

74
00:01:39,190 --> 00:01:39,200
 

75
00:01:39,200 --> 00:01:43,309
and then you can show up with a one page

76
00:01:43,309 --> 00:01:43,319
 

77
00:01:43,319 --> 00:01:45,260
or sorry a one sheet double-sided

78
00:01:45,260 --> 00:01:45,270
 

79
00:01:45,270 --> 00:01:48,139
handwritten notes with whatever you want

80
00:01:48,139 --> 00:01:48,149

81
00:01:48,149 --> 00:01:50,840
on it right can handwritten doesn't you

82
00:01:50,840 --> 00:01:50,850
 

83
00:01:50,850 --> 00:01:52,160
know you don't take the slide and try to

84
00:01:52,160 --> 00:01:52,170
 

85
00:01:52,170 --> 00:01:53,719
condense them down the small as possible

86
00:01:53,719 --> 00:01:53,729
 

87
00:01:53,729 --> 00:01:55,219
that's the urine running because I think

88
00:01:55,219 --> 00:01:55,229
 

89
00:01:55,229 --> 00:01:58,459
you'll get more out of it that way okay

90
00:01:58,459 --> 00:01:58,469
 

91
00:01:58,469 --> 00:02:01,099
and then also bring your ID and if you

92
00:02:01,099 --> 00:02:01,109
 

93
00:02:01,109 --> 00:02:01,999
have any

94
00:02:01,999 --> 00:02:02,009

95
00:02:02,009 --> 00:02:05,269
I think there's what if you need any

96
00:02:05,269 --> 00:02:05,279

97
00:02:05,279 --> 00:02:07,969
extra time or it have a medical issue

98
00:02:07,969 --> 00:02:07,979
 

99
00:02:07,979 --> 00:02:10,040
you need to deal with frit exam you know

100
00:02:10,040 --> 00:02:10,050
 

101
00:02:10,050 --> 00:02:11,510
please email me now we'll get that

102
00:02:11,510 --> 00:02:11,520
 

103
00:02:11,520 --> 00:02:14,750
tanker as soon as possible okay all

104
00:02:14,750 --> 00:02:14,760
 

105
00:02:14,760 --> 00:02:15,680
right

106
00:02:15,680 --> 00:02:15,690
 

107
00:02:15,690 --> 00:02:20,960
so the entire lecture today is going to

108
00:02:20,960 --> 00:02:20,970
 

109
00:02:20,970 --> 00:02:27,380
be on joins this is probably the almost

110
00:02:27,380 --> 00:02:27,390
 

111
00:02:27,390 --> 00:02:29,060
a difficult but the most challenging

112
00:02:29,060 --> 00:02:29,070
 

113
00:02:29,070 --> 00:02:30,560
aspect of building a database system of

114
00:02:30,560 --> 00:02:30,570
 

115
00:02:30,570 --> 00:02:32,540
relational data system is supporting

116
00:02:32,540 --> 00:02:32,550
 

117
00:02:32,550 --> 00:02:35,810
joints and doing this efficiently you

118
00:02:35,810 --> 00:02:35,820
 

119
00:02:35,820 --> 00:02:37,310
know the the the nose Siegel guys when

120
00:02:37,310 --> 00:02:37,320
 

121
00:02:37,320 --> 00:02:38,780
they came out they said Oh joins are

122
00:02:38,780 --> 00:02:38,790
 

123
00:02:38,790 --> 00:02:42,470
slow we're not gonna do joins some of

124
00:02:42,470 --> 00:02:42,480
 

125
00:02:42,480 --> 00:02:44,750
them are certain add joins not quite

126
00:02:44,750 --> 00:02:44,760
 

127
00:02:44,760 --> 00:02:47,150
well but that's okay but this isn't

128
00:02:47,150 --> 00:02:47,160
 

129
00:02:47,160 --> 00:02:49,460
really gonna be the most expensive thing

130
00:02:49,460 --> 00:02:49,470
 

131
00:02:49,470 --> 00:02:51,020
where the data system is gonna be

132
00:02:51,020 --> 00:02:51,030
 

133
00:02:51,030 --> 00:02:54,530
spending most their time on in in in for

134
00:02:54,530 --> 00:02:54,540
 

135
00:02:54,540 --> 00:02:56,420
analytical workloads for all it to be

136
00:02:56,420 --> 00:02:56,430
 

137
00:02:56,430 --> 00:02:58,880
workloads they're usually you know doing

138
00:02:58,880 --> 00:02:58,890
 

139
00:02:58,890 --> 00:03:01,430
single key lookups or the doing joins we

140
00:03:01,430 --> 00:03:01,440
 

141
00:03:01,440 --> 00:03:02,930
can use index nested loop join which

142
00:03:02,930 --> 00:03:02,940

143
00:03:02,940 --> 00:03:04,670
we'll see in a second so joins aren't

144
00:03:04,670 --> 00:03:04,680
 

145
00:03:04,680 --> 00:03:06,230
that expensive in ultimate workloads

146
00:03:06,230 --> 00:03:06,240
 

147
00:03:06,240 --> 00:03:07,460
because you're just not joining large

148
00:03:07,460 --> 00:03:07,470
 

149
00:03:07,470 --> 00:03:10,130
segmented data in analytical workloads

150
00:03:10,130 --> 00:03:10,140
 

151
00:03:10,140 --> 00:03:12,620
this is totally the case where you know

152
00:03:12,620 --> 00:03:12,630
 

153
00:03:12,630 --> 00:03:14,090
we've done our own profiling I've seen

154
00:03:14,090 --> 00:03:14,100
 

155
00:03:14,100 --> 00:03:15,800
reports and other things where an

156
00:03:15,800 --> 00:03:15,810
 

157
00:03:15,810 --> 00:03:17,450
overwhelming majority maybe over even

158
00:03:17,450 --> 00:03:17,460
 

159
00:03:17,460 --> 00:03:19,940
50% of the time that Davidson is doing

160
00:03:19,940 --> 00:03:19,950
 

161
00:03:19,950 --> 00:03:22,550
work - excuse queries well we spent in

162
00:03:22,550 --> 00:03:22,560

163
00:03:22,560 --> 00:03:24,260
joint algorithms so it's really

164
00:03:24,260 --> 00:03:24,270
 

165
00:03:24,270 --> 00:03:27,500
important for us to get this right so to

166
00:03:27,500 --> 00:03:27,510
 

167
00:03:27,510 --> 00:03:29,630
understand sort of at a high level the

168
00:03:29,630 --> 00:03:29,640
 

169
00:03:29,640 --> 00:03:32,630
why we actually have to do the joins we

170
00:03:32,630 --> 00:03:32,640
 

171
00:03:32,640 --> 00:03:33,680
talked about this in the beginning of

172
00:03:33,680 --> 00:03:33,690
 

173
00:03:33,690 --> 00:03:35,870
the class when we talked about how we

174
00:03:35,870 --> 00:03:35,880
 

175
00:03:35,880 --> 00:03:39,290
would normalize tables to reduce the

176
00:03:39,290 --> 00:03:39,300
 

177
00:03:39,300 --> 00:03:41,060
amount of redundant and unnecessary

178
00:03:41,060 --> 00:03:41,070
 

179
00:03:41,070 --> 00:03:44,660
repetition of data in our in our

180
00:03:44,660 --> 00:03:44,670
 

181
00:03:44,670 --> 00:03:47,120
database and so the way to sort of think

182
00:03:47,120 --> 00:03:47,130
 

183
00:03:47,130 --> 00:03:49,130
about this is like we have our original

184
00:03:49,130 --> 00:03:49,140
 

185
00:03:49,140 --> 00:03:52,040
tuples and there may be columns or

186
00:03:52,040 --> 00:03:52,050
 

187
00:03:52,050 --> 00:03:53,750
attributes where we're repeating data

188
00:03:53,750 --> 00:03:53,760

189
00:03:53,760 --> 00:03:55,760
and then we're going to normalize them

190
00:03:55,760 --> 00:03:55,770
 

191
00:03:55,770 --> 00:03:58,640
essentially split them up into two

192
00:03:58,640 --> 00:03:58,650
 

193
00:03:58,650 --> 00:04:01,070
separate tables so that we don't repeat

194
00:04:01,070 --> 00:04:01,080
 

195
00:04:01,080 --> 00:04:03,350
this information so the join algorithm

196
00:04:03,350 --> 00:04:03,360
 

197
00:04:03,360 --> 00:04:04,490
so the join operator is essentially

198
00:04:04,490 --> 00:04:04,500
 

199
00:04:04,500 --> 00:04:05,690
putting them back together to

200
00:04:05,690 --> 00:04:05,700
 

201
00:04:05,700 --> 00:04:08,600
reconstruct the original tuples all

202
00:04:08,600 --> 00:04:08,610
 

203
00:04:08,610 --> 00:04:09,680
right and we need to talk about normal

204
00:04:09,680 --> 00:04:09,690
 

205
00:04:09,690 --> 00:04:11,800
forms because I didn't I didn't want to

206
00:04:11,800 --> 00:04:11,810
 

207
00:04:11,810 --> 00:04:16,190
to sort of be torture you guys with that

208
00:04:16,190 --> 00:04:16,200
 

209
00:04:16,200 --> 00:04:19,190
information but the high-level concept

210
00:04:19,190 --> 00:04:19,200
 

211
00:04:19,200 --> 00:04:20,630
is pretty pretty basic and this is

212
00:04:20,630 --> 00:04:20,640
 

213
00:04:20,640 --> 00:04:22,400
actually the example database we looked

214
00:04:22,400 --> 00:04:22,410
 

215
00:04:22,410 --> 00:04:23,719
at the very beginning of the lecture

216
00:04:23,719 --> 00:04:23,729
 

217
00:04:23,729 --> 00:04:25,520
right we want to keep track of our music

218
00:04:25,520 --> 00:04:25,530
 

219
00:04:25,530 --> 00:04:27,200
store we have artists that put out

220
00:04:27,200 --> 00:04:27,210
 

221
00:04:27,210 --> 00:04:29,000
albums and we said that we're gonna have

222
00:04:29,000 --> 00:04:29,010
 

223
00:04:29,010 --> 00:04:29,460
this cross

224
00:04:29,460 --> 00:04:29,470

225
00:04:29,470 --> 00:04:31,590
in stable art of artists album it has a

226
00:04:31,590 --> 00:04:31,600
 

227
00:04:31,600 --> 00:04:34,050
foreign key reference from be from the

228
00:04:34,050 --> 00:04:34,060
 

229
00:04:34,060 --> 00:04:37,080
artists table to end the album table we

230
00:04:37,080 --> 00:04:37,090
 

231
00:04:37,090 --> 00:04:38,490
did this because there may be some

232
00:04:38,490 --> 00:04:38,500
 

233
00:04:38,500 --> 00:04:41,790
albums where we would have multiple

234
00:04:41,790 --> 00:04:41,800
 

235
00:04:41,800 --> 00:04:44,580
artists appearing on it and instead of

236
00:04:44,580 --> 00:04:44,590
 

237
00:04:44,590 --> 00:04:46,410
having you know an entry we're repeating

238
00:04:46,410 --> 00:04:46,420
 

239
00:04:46,420 --> 00:04:47,520
the album information over and over

240
00:04:47,520 --> 00:04:47,530
 

241
00:04:47,530 --> 00:04:49,530
again we can again normalize it by

242
00:04:49,530 --> 00:04:49,540
 

243
00:04:49,540 --> 00:04:50,940
breaking it up based on these foreign

244
00:04:50,940 --> 00:04:50,950
 

245
00:04:50,950 --> 00:04:54,570
keys and and then now we have one entry

246
00:04:54,570 --> 00:04:54,580
 

247
00:04:54,580 --> 00:04:56,100
for the album one entry for the artist

248
00:04:56,100 --> 00:04:56,110
 

249
00:04:56,110 --> 00:04:58,770
even though there may be too many met

250
00:04:58,770 --> 00:04:58,780
 

251
00:04:58,780 --> 00:05:00,150
many to many relationship between the

252
00:05:00,150 --> 00:05:00,160
 

253
00:05:00,160 --> 00:05:02,760
two of them so normalization is the

254
00:05:02,760 --> 00:05:02,770
 

255
00:05:02,770 --> 00:05:04,200
process of designing your application

256
00:05:04,200 --> 00:05:04,210
 

257
00:05:04,210 --> 00:05:06,480
your applications database at a logical

258
00:05:06,480 --> 00:05:06,490
 

259
00:05:06,490 --> 00:05:10,100
level and splitting it up into

260
00:05:10,100 --> 00:05:10,110
 

261
00:05:10,110 --> 00:05:13,110
normalized tables and then joins are

262
00:05:13,110 --> 00:05:13,120
 

263
00:05:13,120 --> 00:05:14,570
essentially just putting back together

264
00:05:14,570 --> 00:05:14,580
 

265
00:05:14,580 --> 00:05:17,400
right so that that's what we're trying

266
00:05:17,400 --> 00:05:17,410
 

267
00:05:17,410 --> 00:05:20,100
to do today so today's class we're going

268
00:05:20,100 --> 00:05:20,110
 

269
00:05:20,110 --> 00:05:23,640
to focus on the the algorithms for

270
00:05:23,640 --> 00:05:23,650
 

271
00:05:23,650 --> 00:05:25,800
joining two tables specific we're gonna

272
00:05:25,800 --> 00:05:25,810

273
00:05:25,810 --> 00:05:27,330
focus on joining two tables with an

274
00:05:27,330 --> 00:05:27,340
 

275
00:05:27,340 --> 00:05:29,370
equijoin because that can be the the

276
00:05:29,370 --> 00:05:29,380
 

277
00:05:29,380 --> 00:05:31,470
most common approach we're not going to

278
00:05:31,470 --> 00:05:31,480
 

279
00:05:31,480 --> 00:05:33,240
talk about there are ways to do K way

280
00:05:33,240 --> 00:05:33,250
 

281
00:05:33,250 --> 00:05:35,190
joins or multiples of more than two

282
00:05:35,190 --> 00:05:35,200
 

283
00:05:35,200 --> 00:05:38,159
table joins excuse me we're not gonna

284
00:05:38,159 --> 00:05:38,169
 

285
00:05:38,169 --> 00:05:39,420
cover that in this class we'll cover

286
00:05:39,420 --> 00:05:39,430
 

287
00:05:39,430 --> 00:05:41,220
that in the advanced class this is the

288
00:05:41,220 --> 00:05:41,230
 

289
00:05:41,230 --> 00:05:43,050
most common type of join and you know I

290
00:05:43,050 --> 00:05:43,060
 

291
00:05:43,060 --> 00:05:44,550
can't say exactly exactly how many

292
00:05:44,550 --> 00:05:44,560
 

293
00:05:44,560 --> 00:05:45,870
numbers we're about percentage but

294
00:05:45,870 --> 00:05:45,880
 

295
00:05:45,880 --> 00:05:47,340
workloads that look like this if you're

296
00:05:47,340 --> 00:05:47,350
 

297
00:05:47,350 --> 00:05:49,200
doing join you're most always going to

298
00:05:49,200 --> 00:05:49,210
 

299
00:05:49,210 --> 00:05:53,840
be doing a inter equi-join so the

300
00:05:53,840 --> 00:05:53,850
 

301
00:05:53,850 --> 00:05:55,830
reoccurring theme we'll see as we talk

302
00:05:55,830 --> 00:05:55,840
 

303
00:05:55,840 --> 00:05:57,450
about these different algorithms is that

304
00:05:57,450 --> 00:05:57,460
 

305
00:05:57,460 --> 00:05:59,640
your own is always going to want to put

306
00:05:59,640 --> 00:05:59,650
 

307
00:05:59,650 --> 00:06:02,760
these the the the smallest table that

308
00:06:02,760 --> 00:06:02,770
 

309
00:06:02,770 --> 00:06:04,560
you're trying to join and smallest in

310
00:06:04,560 --> 00:06:04,570
 

311
00:06:04,570 --> 00:06:06,060
terms of number tuples that are being

312
00:06:06,060 --> 00:06:06,070
 

313
00:06:06,070 --> 00:06:08,280
fed into the join operator you're always

314
00:06:08,280 --> 00:06:08,290
 

315
00:06:08,290 --> 00:06:10,500
want to put that as the outer table I'll

316
00:06:10,500 --> 00:06:10,510
 

317
00:06:10,510 --> 00:06:11,969
explain what an outer table is in a

318
00:06:11,969 --> 00:06:11,979
 

319
00:06:11,979 --> 00:06:13,560
second because this is always going to

320
00:06:13,560 --> 00:06:13,570
 

321
00:06:13,570 --> 00:06:16,890
produce the the best the best execution

322
00:06:16,890 --> 00:06:16,900
 

323
00:06:16,900 --> 00:06:18,840
time the lowest cost of doing the join

324
00:06:18,840 --> 00:06:18,850
 

325
00:06:18,850 --> 00:06:21,270
as possible so before we get into the

326
00:06:21,270 --> 00:06:21,280
 

327
00:06:21,280 --> 00:06:22,620
actual algorithms don't spend time

328
00:06:22,620 --> 00:06:22,630
 

329
00:06:22,630 --> 00:06:23,909
talking about two additional things

330
00:06:23,909 --> 00:06:23,919
 

331
00:06:23,919 --> 00:06:25,680
we've got to talk about what these joint

332
00:06:25,680 --> 00:06:25,690
 

333
00:06:25,690 --> 00:06:26,850
operators are actually gonna produce as

334
00:06:26,850 --> 00:06:26,860
 

335
00:06:26,860 --> 00:06:28,890
output and then we can talk about how

336
00:06:28,890 --> 00:06:28,900
 

337
00:06:28,900 --> 00:06:30,210
we're going to determine whether one

338
00:06:30,210 --> 00:06:30,220
 

339
00:06:30,220 --> 00:06:31,710
algorithms better another what are we

340
00:06:31,710 --> 00:06:31,720
 

341
00:06:31,720 --> 00:06:33,510
going to use for our criteria determine

342
00:06:33,510 --> 00:06:33,520
 

343
00:06:33,520 --> 00:06:35,909
what's the cost of executing a query or

344
00:06:35,909 --> 00:06:35,919
 

345
00:06:35,919 --> 00:06:40,020
start executing a joint so say that we

346
00:06:40,020 --> 00:06:40,030
 

347
00:06:40,030 --> 00:06:41,640
have this sample query like this we're

348
00:06:41,640 --> 00:06:41,650
 

349
00:06:41,650 --> 00:06:42,900
doing a equi-join

350
00:06:42,900 --> 00:06:42,910
 

351
00:06:42,910 --> 00:06:43,500
on our

352
00:06:43,500 --> 00:06:43,510

353
00:06:43,510 --> 00:06:48,330
on the r ID equals SI b and we're gonna

354
00:06:48,330 --> 00:06:48,340
 

355
00:06:48,340 --> 00:06:50,190
have a joint operator in our query plan

356
00:06:50,190 --> 00:06:50,200

357
00:06:50,200 --> 00:06:52,080
that's going to produce some output and

358
00:06:52,080 --> 00:06:52,090
 

359
00:06:52,090 --> 00:06:53,730
shove it up to the projection operator

360
00:06:53,730 --> 00:06:53,740
 

361
00:06:53,740 --> 00:06:54,600
above it

362
00:06:54,600 --> 00:06:54,610
 

363
00:06:54,610 --> 00:06:56,370
and we talked a little bit about this

364
00:06:56,370 --> 00:06:56,380

365
00:06:56,380 --> 00:06:57,540
when we talk about query processing

366
00:06:57,540 --> 00:06:57,550
 

367
00:06:57,550 --> 00:06:59,490
about what the output of these operators

368
00:06:59,490 --> 00:06:59,500
 

369
00:06:59,500 --> 00:07:02,400
look like but in the case of joins it's

370
00:07:02,400 --> 00:07:02,410
 

371
00:07:02,410 --> 00:07:03,750
this is you can actually have the most

372
00:07:03,750 --> 00:07:03,760
 

373
00:07:03,760 --> 00:07:06,810
variance because it's a bunch of nth

374
00:07:06,810 --> 00:07:06,820
 

375
00:07:06,820 --> 00:07:08,280
ways you can do these things and it

376
00:07:08,280 --> 00:07:08,290
 

377
00:07:08,290 --> 00:07:09,690
really depends on things like what query

378
00:07:09,690 --> 00:07:09,700
 

379
00:07:09,700 --> 00:07:11,520
processing model you're using whether

380
00:07:11,520 --> 00:07:11,530
 

381
00:07:11,530 --> 00:07:13,920
it's vectorized materialization or the

382
00:07:13,920 --> 00:07:13,930
 

383
00:07:13,930 --> 00:07:15,750
iterator model depends on most of the

384
00:07:15,750 --> 00:07:15,760
 

385
00:07:15,760 --> 00:07:17,490
storage model if your column stores a

386
00:07:17,490 --> 00:07:17,500
 

387
00:07:17,500 --> 00:07:19,800
roast or then it also depends on what

388
00:07:19,800 --> 00:07:19,810
 

389
00:07:19,810 --> 00:07:21,900
the query actually looks like meaning

390
00:07:21,900 --> 00:07:21,910
 

391
00:07:21,910 --> 00:07:24,510
what data are we going to need above the

392
00:07:24,510 --> 00:07:24,520
 

393
00:07:24,520 --> 00:07:26,130
joint operator in our query plan and

394
00:07:26,130 --> 00:07:26,140

395
00:07:26,140 --> 00:07:28,080
that'll determine what we need to

396
00:07:28,080 --> 00:07:28,090

397
00:07:28,090 --> 00:07:31,920
produce as our output so we talked about

398
00:07:31,920 --> 00:07:31,930
 

399
00:07:31,930 --> 00:07:33,720
this before right we talked about the

400
00:07:33,720 --> 00:07:33,730
 

401
00:07:33,730 --> 00:07:35,780
concept of latent materialization in

402
00:07:35,780 --> 00:07:35,790
 

403
00:07:35,790 --> 00:07:38,850
inappropriate processing models and we

404
00:07:38,850 --> 00:07:38,860
 

405
00:07:38,860 --> 00:07:41,190
said that the sort of most easiest way

406
00:07:41,190 --> 00:07:41,200
 

407
00:07:41,200 --> 00:07:44,280
to do to produce output

408
00:07:44,280 --> 00:07:44,290
 

409
00:07:44,290 --> 00:07:46,860
it's just copy all the data that you're

410
00:07:46,860 --> 00:07:46,870
 

411
00:07:46,870 --> 00:07:48,360
fed and fed it into your operator and

412
00:07:48,360 --> 00:07:48,370
 

413
00:07:48,370 --> 00:07:51,180
shove it as your output all right so say

414
00:07:51,180 --> 00:07:51,190
 

415
00:07:51,190 --> 00:07:52,890
that in this example here we're joining

416
00:07:52,890 --> 00:07:52,900
 

417
00:07:52,900 --> 00:07:55,560
you know R and s together then we have

418
00:07:55,560 --> 00:07:55,570
 

419
00:07:55,570 --> 00:07:58,290
one two point R and two tuples in s so

420
00:07:58,290 --> 00:07:58,300
 

421
00:07:58,300 --> 00:07:59,490
our joint operator would essentially

422
00:07:59,490 --> 00:07:59,500
 

423
00:07:59,500 --> 00:08:01,800
just concatenate all the attributes of

424
00:08:01,800 --> 00:08:01,810
 

425
00:08:01,810 --> 00:08:04,380
our and all the attributes s for every

426
00:08:04,380 --> 00:08:04,390
 

427
00:08:04,390 --> 00:08:06,210
tuple that that's produced in our output

428
00:08:06,210 --> 00:08:06,220
 

429
00:08:06,220 --> 00:08:09,090
and then we shove that up through in the

430
00:08:09,090 --> 00:08:09,100
 

431
00:08:09,100 --> 00:08:12,540
query plan right and in this case here

432
00:08:12,540 --> 00:08:12,550
 

433
00:08:12,550 --> 00:08:15,000
we have a above that we have the

434
00:08:15,000 --> 00:08:15,010
 

435
00:08:15,010 --> 00:08:16,830
projection and the projection would know

436
00:08:16,830 --> 00:08:16,840
 

437
00:08:16,840 --> 00:08:20,100
that we only need to filter out the you

438
00:08:20,100 --> 00:08:20,110
 

439
00:08:20,110 --> 00:08:22,290
know the the data that we actually don't

440
00:08:22,290 --> 00:08:22,300
 

441
00:08:22,300 --> 00:08:23,670
need so in this case here we only need

442
00:08:23,670 --> 00:08:23,680
 

443
00:08:23,680 --> 00:08:25,770
our idea and see date so the projection

444
00:08:25,770 --> 00:08:25,780

445
00:08:25,780 --> 00:08:27,660
operator will just pull out those two

446
00:08:27,660 --> 00:08:27,670
 

447
00:08:27,670 --> 00:08:30,060
attributes so the advantage of this

448
00:08:30,060 --> 00:08:30,070
 

449
00:08:30,070 --> 00:08:32,190
approach is that you never have to go

450
00:08:32,190 --> 00:08:32,200
 

451
00:08:32,200 --> 00:08:35,400
back to the base table and get more data

452
00:08:35,400 --> 00:08:35,410
 

453
00:08:35,410 --> 00:08:37,050
because everything you need at this

454
00:08:37,050 --> 00:08:37,060
 

455
00:08:37,060 --> 00:08:39,060
point is that produce the rest of the

456
00:08:39,060 --> 00:08:39,070
 

457
00:08:39,070 --> 00:08:42,770
query plan is baked in this output here

458
00:08:42,770 --> 00:08:42,780
 

459
00:08:42,780 --> 00:08:45,320
but there may be some cases where you

460
00:08:45,320 --> 00:08:45,330
 

461
00:08:45,330 --> 00:08:47,850
you know at the table are really tables

462
00:08:47,850 --> 00:08:47,860
 

463
00:08:47,860 --> 00:08:50,190
really wide meaning there's a lot of

464
00:08:50,190 --> 00:08:50,200
 

465
00:08:50,200 --> 00:08:52,140
columns for both the init the the two

466
00:08:52,140 --> 00:08:52,150
 

467
00:08:52,150 --> 00:08:53,940
tables trying to join together it may

468
00:08:53,940 --> 00:08:53,950
 

469
00:08:53,950 --> 00:08:55,230
make sense to actually only produce a

470
00:08:55,230 --> 00:08:55,240
 

471
00:08:55,240 --> 00:08:57,810
subset of the output right in this case

472
00:08:57,810 --> 00:08:57,820
 

473
00:08:57,820 --> 00:09:00,360
here say FS had a bunch more attributes

474
00:09:00,360 --> 00:09:00,370
 

475
00:09:00,370 --> 00:09:02,720
I mean we only know we need value our ID

476
00:09:02,720 --> 00:09:02,730
 

477
00:09:02,730 --> 00:09:04,920
going up then maybe we don't want to

478
00:09:04,920 --> 00:09:04,930
 

479
00:09:04,930 --> 00:09:07,380
copy all the other crap into the join

480
00:09:07,380 --> 00:09:07,390
 

481
00:09:07,390 --> 00:09:08,670
operator and they have the join up or a

482
00:09:08,670 --> 00:09:08,680

483
00:09:08,680 --> 00:09:12,120
copy of it back out we talked about this

484
00:09:12,120 --> 00:09:12,130
 

485
00:09:12,130 --> 00:09:14,540
approach as well in the context of a

486
00:09:14,540 --> 00:09:14,550
 

487
00:09:14,550 --> 00:09:16,470
column store system where we can only

488
00:09:16,470 --> 00:09:16,480
 

489
00:09:16,480 --> 00:09:17,970
pass around maybe the record IDs our

490
00:09:17,970 --> 00:09:17,980
 

491
00:09:17,980 --> 00:09:20,370
offsets of the tuples from one operator

492
00:09:20,370 --> 00:09:20,380
 

493
00:09:20,380 --> 00:09:22,620
to the next and we do this because we

494
00:09:22,620 --> 00:09:22,630
 

495
00:09:22,630 --> 00:09:24,030
don't want have to copy large you know

496
00:09:24,030 --> 00:09:24,040
 

497
00:09:24,040 --> 00:09:27,360
glorg to 'pls going forward so in this

498
00:09:27,360 --> 00:09:27,370
 

499
00:09:27,370 --> 00:09:29,280
case here our join operator would only

500
00:09:29,280 --> 00:09:29,290
 

501
00:09:29,290 --> 00:09:32,190
produce the the keys that we joined on

502
00:09:32,190 --> 00:09:32,200
 

503
00:09:32,200 --> 00:09:35,790
and the record IDs of the matching

504
00:09:35,790 --> 00:09:35,800
 

505
00:09:35,800 --> 00:09:38,400
tuples and then we shove that up into

506
00:09:38,400 --> 00:09:38,410
 

507
00:09:38,410 --> 00:09:40,530
the query plan and then when we get into

508
00:09:40,530 --> 00:09:40,540

509
00:09:40,540 --> 00:09:43,890
our projection operator it knows that oh

510
00:09:43,890 --> 00:09:43,900
 

511
00:09:43,900 --> 00:09:46,530
I need see date from the s table so let

512
00:09:46,530 --> 00:09:46,540
 

513
00:09:46,540 --> 00:09:48,210
me go to the s table and pick out that

514
00:09:48,210 --> 00:09:48,220
 

515
00:09:48,220 --> 00:09:50,100
information if this is a column store

516
00:09:50,100 --> 00:09:50,110
 

517
00:09:50,110 --> 00:09:51,510
then this is super easy to do because

518
00:09:51,510 --> 00:09:51,520
 

519
00:09:51,520 --> 00:09:54,060
the C date column the creation date

520
00:09:54,060 --> 00:09:54,070
 

521
00:09:54,070 --> 00:09:55,980
column will be in US and its own

522
00:09:55,980 --> 00:09:55,990
 

523
00:09:55,990 --> 00:09:57,750
separate pages and we just jump to the

524
00:09:57,750 --> 00:09:57,760
 

525
00:09:57,760 --> 00:10:01,350
right all set for what we need for

526
00:10:01,350 --> 00:10:01,360
 

527
00:10:01,360 --> 00:10:02,790
others if it's a roast or this be kind

528
00:10:02,790 --> 00:10:02,800
 

529
00:10:02,800 --> 00:10:04,830
of you probably would not want to do

530
00:10:04,830 --> 00:10:04,840
 

531
00:10:04,840 --> 00:10:06,090
this because then you have to go back

532
00:10:06,090 --> 00:10:06,100
 

533
00:10:06,100 --> 00:10:07,710
and copy the entire tuple which would be

534
00:10:07,710 --> 00:10:07,720
 

535
00:10:07,720 --> 00:10:10,980
wasteful so no matter what what this

536
00:10:10,980 --> 00:10:10,990

537
00:10:10,990 --> 00:10:12,930
technique was called before we talked

538
00:10:12,930 --> 00:10:12,940
 

539
00:10:12,940 --> 00:10:17,000
about it we told a query processing

540
00:10:17,000 --> 00:10:17,010


541
00:10:17,010 --> 00:10:19,650
late materialization right we're

542
00:10:19,650 --> 00:10:19,660
 

543
00:10:19,660 --> 00:10:21,060
materializing the tuple that we need to

544
00:10:21,060 --> 00:10:21,070
 

545
00:10:21,070 --> 00:10:22,890
produce for the output as late as

546
00:10:22,890 --> 00:10:22,900
 

547
00:10:22,900 --> 00:10:25,920
possible in our query plan a lot of the

548
00:10:25,920 --> 00:10:25,930
 

549
00:10:25,930 --> 00:10:30,960
columnstore systems did this vertical is

550
00:10:30,960 --> 00:10:30,970
 

551
00:10:30,970 --> 00:10:32,460
really big on this as well but as

552
00:10:32,460 --> 00:10:32,470
 

553
00:10:32,470 --> 00:10:34,170
talking with them over the summer they

554
00:10:34,170 --> 00:10:34,180
 

555
00:10:34,180 --> 00:10:35,760
turns up they stop doing this because it

556
00:10:35,760 --> 00:10:35,770
 

557
00:10:35,770 --> 00:10:37,740
actually turned out to be too slow I

558
00:10:37,740 --> 00:10:37,750
 

559
00:10:37,750 --> 00:10:40,260
don't remember the full details but this

560
00:10:40,260 --> 00:10:40,270
 

561
00:10:40,270 --> 00:10:41,580
is one technique that people can use it

562
00:10:41,580 --> 00:10:41,590
 

563
00:10:41,590 --> 00:10:43,230
the Torn advantage you get from a column

564
00:10:43,230 --> 00:10:43,240

565
00:10:43,240 --> 00:10:44,490
store over a row store for doing

566
00:10:44,490 --> 00:10:44,500

567
00:10:44,500 --> 00:10:46,560
analytics again the way just a way to

568
00:10:46,560 --> 00:10:46,570
 

569
00:10:46,570 --> 00:10:48,210
think about this is we know what the

570
00:10:48,210 --> 00:10:48,220
 

571
00:10:48,220 --> 00:10:49,620
query plan is ahead of time because it's

572
00:10:49,620 --> 00:10:49,630
 

573
00:10:49,630 --> 00:10:51,060
sequel we know exactly what we're

574
00:10:51,060 --> 00:10:51,070
 

575
00:10:51,070 --> 00:10:52,500
executing we know what actually so we're

576
00:10:52,500 --> 00:10:52,510
 

577
00:10:52,510 --> 00:10:54,570
going to need and at the lowest level or

578
00:10:54,570 --> 00:10:54,580
 

579
00:10:54,580 --> 00:10:55,860
in our joint operator we can make

580
00:10:55,860 --> 00:10:55,870
 

581
00:10:55,870 --> 00:10:58,350
decisions about what we actually need to

582
00:10:58,350 --> 00:10:58,360
 

583
00:10:58,360 --> 00:10:59,970
maintain or produce from one Operator to

584
00:10:59,970 --> 00:10:59,980
 

585
00:10:59,980 --> 00:11:01,890
the next and no matter when we do our

586
00:11:01,890 --> 00:11:01,900
 

587
00:11:01,900 --> 00:11:04,199
joins because when we do a hash doing

588
00:11:04,199 --> 00:11:04,209

589
00:11:04,209 --> 00:11:05,520
we're going to populate a hash table and

590
00:11:05,520 --> 00:11:05,530
 

591
00:11:05,530 --> 00:11:07,410
then we don't want our hash table to get

592
00:11:07,410 --> 00:11:07,420
 

593
00:11:07,420 --> 00:11:08,790
too big because we're gonna run out of

594
00:11:08,790 --> 00:11:08,800
 

595
00:11:08,800 --> 00:11:09,929
memory so

596
00:11:09,929 --> 00:11:09,939
 

597
00:11:09,939 --> 00:11:11,699
we want to be we know just have the

598
00:11:11,699 --> 00:11:11,709
 

599
00:11:11,709 --> 00:11:13,139
minimum amount on information we need

600
00:11:13,139 --> 00:11:13,149
 

601
00:11:13,149 --> 00:11:15,059
inside our hash table to compute the

602
00:11:15,059 --> 00:11:15,069
 

603
00:11:15,069 --> 00:11:21,649
join and not a not weigh space oh crap

604
00:11:21,649 --> 00:11:21,659
 

605
00:11:21,659 --> 00:11:23,609
so now when we start talking about these

606
00:11:23,609 --> 00:11:23,619
 

607
00:11:23,619 --> 00:11:25,319
different joint algorithms the method

608
00:11:25,319 --> 00:11:25,329
 

609
00:11:25,329 --> 00:11:26,339
we're going to use to determine whether

610
00:11:26,339 --> 00:11:26,349
 

611
00:11:26,349 --> 00:11:27,929
one album is better than another

612
00:11:27,929 --> 00:11:27,939

613
00:11:27,939 --> 00:11:30,419
determine what the cost is is going to

614
00:11:30,419 --> 00:11:30,429
 

615
00:11:30,429 --> 00:11:35,189
be strictly based on disk i/o right as

616
00:11:35,189 --> 00:11:35,199
 

617
00:11:35,199 --> 00:11:38,759
we said in in this class going to disk

618
00:11:38,759 --> 00:11:38,769
 

619
00:11:38,769 --> 00:11:40,559
as always the most expensive thing so

620
00:11:40,559 --> 00:11:40,569
 

621
00:11:40,569 --> 00:11:42,629
when we you know we always want to

622
00:11:42,629 --> 00:11:42,639
 

623
00:11:42,639 --> 00:11:44,969
determine you know make choices about

624
00:11:44,969 --> 00:11:44,979
 

625
00:11:44,979 --> 00:11:46,679
our algorithms based on how much how

626
00:11:46,679 --> 00:11:46,689
 

627
00:11:46,689 --> 00:11:47,579
much we're gonna read and write from

628
00:11:47,579 --> 00:11:47,589
 

629
00:11:47,589 --> 00:11:50,249
disk once everything's in memory then

630
00:11:50,249 --> 00:11:50,259
 

631
00:11:50,259 --> 00:11:53,609
then you know the cost changes what the

632
00:11:53,609 --> 00:11:53,619
 

633
00:11:53,619 --> 00:11:56,249
cost metric we should use changes like

634
00:11:56,249 --> 00:11:56,259
 

635
00:11:56,259 --> 00:11:57,389
cache misses and other things like that

636
00:11:57,389 --> 00:11:57,399
 

637
00:11:57,399 --> 00:11:59,369
but for our purposes here the disk is

638
00:11:59,369 --> 00:11:59,379
 

639
00:11:59,379 --> 00:12:00,629
always the slowest thing so that's what

640
00:12:00,629 --> 00:12:00,639
 

641
00:12:00,639 --> 00:12:01,559
I mean that's what we're going to be

642
00:12:01,559 --> 00:12:01,569
 

643
00:12:01,569 --> 00:12:04,529
worried about so we're gonna use this

644
00:12:04,529 --> 00:12:04,539
 

645
00:12:04,539 --> 00:12:06,779
join query here as a running example

646
00:12:06,779 --> 00:12:06,789
 

647
00:12:06,789 --> 00:12:08,669
throughout the lecture and we're going

648
00:12:08,669 --> 00:12:08,679
 

649
00:12:08,679 --> 00:12:11,339
to say is that we define our cost

650
00:12:11,339 --> 00:12:11,349
 

651
00:12:11,349 --> 00:12:14,339
functions or cost formulas for these

652
00:12:14,339 --> 00:12:14,349
 

653
00:12:14,349 --> 00:12:16,529
Joran algorithms in terms of the number

654
00:12:16,529 --> 00:12:16,539
 

655
00:12:16,539 --> 00:12:18,179
of pages and tuples and in these two

656
00:12:18,179 --> 00:12:18,189
 

657
00:12:18,189 --> 00:12:19,859
tables so we're gonna say that those m

658
00:12:19,859 --> 00:12:19,869
 

659
00:12:19,869 --> 00:12:22,589
pages in table R and in total table or

660
00:12:22,589 --> 00:12:22,599
 

661
00:12:22,599 --> 00:12:26,099
has and lowercase M tuples and the N

662
00:12:26,099 --> 00:12:26,109
 

663
00:12:26,109 --> 00:12:28,739
pages and s and lowercase and tuples and

664
00:12:28,739 --> 00:12:28,749
 

665
00:12:28,749 --> 00:12:31,979
in that in that table as well so for

666
00:12:31,979 --> 00:12:31,989
 

667
00:12:31,989 --> 00:12:33,719
this class although I just talked about

668
00:12:33,719 --> 00:12:33,729
 

669
00:12:33,729 --> 00:12:36,179
the output of these joint operators

670
00:12:36,179 --> 00:12:36,189
 

671
00:12:36,189 --> 00:12:38,249
we're gonna ignore the cost of

672
00:12:38,249 --> 00:12:38,259
 

673
00:12:38,259 --> 00:12:41,669
outputting the the joint of the join up

674
00:12:41,669 --> 00:12:41,679
 

675
00:12:41,679 --> 00:12:44,460
operation in our calculations because

676
00:12:44,460 --> 00:12:44,470

677
00:12:44,470 --> 00:12:46,739
that depends on what the data looks like

678
00:12:46,739 --> 00:12:46,749
 

679
00:12:46,749 --> 00:12:49,019
and what your query is right we could

680
00:12:49,019 --> 00:12:49,029
 

681
00:12:49,029 --> 00:12:50,579
have a billion two blows fed as the

682
00:12:50,579 --> 00:12:50,589
 

683
00:12:50,589 --> 00:12:52,559
input into our joint operator but then

684
00:12:52,559 --> 00:12:52,569
 

685
00:12:52,569 --> 00:12:55,129
it only produces 1 1 1 2 plus is output

686
00:12:55,129 --> 00:12:55,139
 

687
00:12:55,139 --> 00:12:57,419
right and we don't know because we don't

688
00:12:57,419 --> 00:12:57,429
 

689
00:12:57,429 --> 00:12:58,739
know what the actual data is we're

690
00:12:58,739 --> 00:12:58,749
 

691
00:12:58,749 --> 00:13:00,299
trying to do this at our asymptotic

692
00:13:00,299 --> 00:13:00,309
 

693
00:13:00,309 --> 00:13:02,669
analysis at a high level this is also

694
00:13:02,669 --> 00:13:02,679
 

695
00:13:02,679 --> 00:13:04,259
the output the cost of producing the

696
00:13:04,259 --> 00:13:04,269
 

697
00:13:04,269 --> 00:13:06,809
output is gonna be the same from one

698
00:13:06,809 --> 00:13:06,819
 

699
00:13:06,819 --> 00:13:09,329
algorithm to the next like if I used a

700
00:13:09,329 --> 00:13:09,339
 

701
00:13:09,339 --> 00:13:10,679
nested loop joint and it produces the

702
00:13:10,679 --> 00:13:10,689
 

703
00:13:10,689 --> 00:13:12,509
billion 2 plus as output the same joint

704
00:13:12,509 --> 00:13:12,519
 

705
00:13:12,519 --> 00:13:15,449
algorithm sorry this the same joint

706
00:13:15,449 --> 00:13:15,459
 

707
00:13:15,459 --> 00:13:16,799
using a hash joint algorithm will

708
00:13:16,799 --> 00:13:16,809
 

709
00:13:16,809 --> 00:13:17,969
produce the same number of tuples

710
00:13:17,969 --> 00:13:17,979
 

711
00:13:17,979 --> 00:13:19,439
so therefore the output cost would be

712
00:13:19,439 --> 00:13:19,449
 

713
00:13:19,449 --> 00:13:21,629
the same there so we can ignore that

714
00:13:21,629 --> 00:13:21,639
 

715
00:13:21,639 --> 00:13:22,979
cost that is gonna be the same no matter

716
00:13:22,979 --> 00:13:22,989
 

717
00:13:22,989 --> 00:13:23,700
what

718
00:13:23,700 --> 00:13:23,710

719
00:13:23,710 --> 00:13:27,780
album we use so we also again don't know

720
00:13:27,780 --> 00:13:27,790

721
00:13:27,790 --> 00:13:29,430
we just get as I said we don't know how

722
00:13:29,430 --> 00:13:29,440
 

723
00:13:29,440 --> 00:13:30,570
much tuple how many people's were gonna

724
00:13:30,570 --> 00:13:30,580
 

725
00:13:30,580 --> 00:13:32,460
prove citrus output but we'll know this

726
00:13:32,460 --> 00:13:32,470
 

727
00:13:32,470 --> 00:13:33,900
we'll figure out well learn how to

728
00:13:33,900 --> 00:13:33,910
 

729
00:13:33,910 --> 00:13:35,010
compute this

730
00:13:35,010 --> 00:13:35,020

731
00:13:35,020 --> 00:13:36,750
on Monday next week when we talk about

732
00:13:36,750 --> 00:13:36,760
 

733
00:13:36,760 --> 00:13:38,430
query optimization well look top we have

734
00:13:38,430 --> 00:13:38,440
 

735
00:13:38,440 --> 00:13:41,400
derived for sistex from our tables and

736
00:13:41,400 --> 00:13:41,410
 

737
00:13:41,410 --> 00:13:43,290
use that to estimate the number of

738
00:13:43,290 --> 00:13:43,300
 

739
00:13:43,300 --> 00:13:44,790
tuples that we're going to use as input

740
00:13:44,790 --> 00:13:44,800
 

741
00:13:44,800 --> 00:13:46,110
an output for our our different

742
00:13:46,110 --> 00:13:46,120
 

743
00:13:46,120 --> 00:13:49,860
operators in the query planner so the

744
00:13:49,860 --> 00:13:49,870
 

745
00:13:49,870 --> 00:13:51,840
last thing to mention also too is that

746
00:13:51,840 --> 00:13:51,850
 

747
00:13:51,850 --> 00:13:54,269
as I said the beginning we're focused in

748
00:13:54,269 --> 00:13:54,279
 

749
00:13:54,279 --> 00:13:56,910
this class on the cost analysis of

750
00:13:56,910 --> 00:13:56,920
 

751
00:13:56,920 --> 00:13:58,050
equi-join

752
00:13:58,050 --> 00:13:58,060
 

753
00:13:58,060 --> 00:13:59,790
or inner joins between two tables

754
00:13:59,790 --> 00:13:59,800
 

755
00:13:59,800 --> 00:14:01,350
because again this is going to be the

756
00:14:01,350 --> 00:14:01,360
 

757
00:14:01,360 --> 00:14:03,720
most the most widely used joint

758
00:14:03,720 --> 00:14:03,730
 

759
00:14:03,730 --> 00:14:05,250
algorithm we're gonna have in our system

760
00:14:05,250 --> 00:14:05,260

761
00:14:05,260 --> 00:14:06,780
most queries are gonna actually execute

762
00:14:06,780 --> 00:14:06,790
 

763
00:14:06,790 --> 00:14:09,930
like this and we don't really care about

764
00:14:09,930 --> 00:14:09,940
 

765
00:14:09,940 --> 00:14:11,519
things like cross product because

766
00:14:11,519 --> 00:14:11,529
 

767
00:14:11,529 --> 00:14:12,750
there's not really any way to make those

768
00:14:12,750 --> 00:14:12,760
 

769
00:14:12,760 --> 00:14:14,790
things go faster right cross product is

770
00:14:14,790 --> 00:14:14,800
 

771
00:14:14,800 --> 00:14:16,710
just to for loops to combine all

772
00:14:16,710 --> 00:14:16,720
 

773
00:14:16,720 --> 00:14:18,930
possible you know tuples you create all

774
00:14:18,930 --> 00:14:18,940
 

775
00:14:18,940 --> 00:14:20,639
possible pairs of tuples in our two

776
00:14:20,639 --> 00:14:20,649
 

777
00:14:20,649 --> 00:14:22,829
tables so there's there's nothing really

778
00:14:22,829 --> 00:14:22,839
 

779
00:14:22,839 --> 00:14:25,380
we can do to make that go faster we're

780
00:14:25,380 --> 00:14:25,390
 

781
00:14:25,390 --> 00:14:28,170
in in our inner joins or Ecuadorians we

782
00:14:28,170 --> 00:14:28,180
 

783
00:14:28,180 --> 00:14:29,850
can be bit more careful how we staged

784
00:14:29,850 --> 00:14:29,860
 

785
00:14:29,860 --> 00:14:32,850
our data and and do better than sort of

786
00:14:32,850 --> 00:14:32,860
 

787
00:14:32,860 --> 00:14:36,390
the then that naive approach so we're

788
00:14:36,390 --> 00:14:36,400
 

789
00:14:36,400 --> 00:14:37,440
also not gonna talk about left outer

790
00:14:37,440 --> 00:14:37,450
 

791
00:14:37,450 --> 00:14:39,510
joins or sort of outer joins in general

792
00:14:39,510 --> 00:14:39,520
 

793
00:14:39,520 --> 00:14:40,680
we're focused on inner joins

794
00:14:40,680 --> 00:14:40,690

795
00:14:40,690 --> 00:14:42,870
I'll talk all about this when we talk

796
00:14:42,870 --> 00:14:42,880
 

797
00:14:42,880 --> 00:14:44,400
about sort merge because you'll see how

798
00:14:44,400 --> 00:14:44,410
 

799
00:14:44,410 --> 00:14:48,000
you can easily do left outer joins or

800
00:14:48,000 --> 00:14:48,010
 

801
00:14:48,010 --> 00:14:50,699
sort of outer joins the the basic

802
00:14:50,699 --> 00:14:50,709
 

803
00:14:50,709 --> 00:14:52,050
algorithms are the same you just maybe

804
00:14:52,050 --> 00:14:52,060
 

805
00:14:52,060 --> 00:14:53,930
do some extra strap like backtracking or

806
00:14:53,930 --> 00:14:53,940
 

807
00:14:53,940 --> 00:14:56,280
check a little bit more data than then

808
00:14:56,280 --> 00:14:56,290
 

809
00:14:56,290 --> 00:14:57,300
you wouldn't otherwise if you're doing

810
00:14:57,300 --> 00:14:57,310
 

811
00:14:57,310 --> 00:14:59,460
an inner join for all our algorithms can

812
00:14:59,460 --> 00:14:59,470
 

813
00:14:59,470 --> 00:15:01,500
we focus on inner joins with with

814
00:15:01,500 --> 00:15:01,510
 

815
00:15:01,510 --> 00:15:06,420
equi-join predicates alright so at a

816
00:15:06,420 --> 00:15:06,430
 

817
00:15:06,430 --> 00:15:08,130
high level there's three classes of join

818
00:15:08,130 --> 00:15:08,140
 

819
00:15:08,140 --> 00:15:10,500
algorithms there's nested loop join sort

820
00:15:10,500 --> 00:15:10,510
 

821
00:15:10,510 --> 00:15:12,480
merge join and hash join so we're gonna

822
00:15:12,480 --> 00:15:12,490
 

823
00:15:12,490 --> 00:15:14,760
spend most of our time at the end

824
00:15:14,760 --> 00:15:14,770
 

825
00:15:14,770 --> 00:15:16,530
talking on hash join but it's good to

826
00:15:16,530 --> 00:15:16,540
 

827
00:15:16,540 --> 00:15:18,060
understand these other joins because

828
00:15:18,060 --> 00:15:18,070
 

829
00:15:18,070 --> 00:15:20,220
there may be different scenarios where

830
00:15:20,220 --> 00:15:20,230
 

831
00:15:20,230 --> 00:15:22,260
you may want to use one versus another

832
00:15:22,260 --> 00:15:22,270
 

833
00:15:22,270 --> 00:15:24,720
for example the index nested loop join

834
00:15:24,720 --> 00:15:24,730

835
00:15:24,730 --> 00:15:26,190
is what you're almost always going to

836
00:15:26,190 --> 00:15:26,200
 

837
00:15:26,200 --> 00:15:28,680
want to use for all TP workloads because

838
00:15:28,680 --> 00:15:28,690
 

839
00:15:28,690 --> 00:15:30,030
you're gonna have an index available for

840
00:15:30,030 --> 00:15:30,040

841
00:15:30,040 --> 00:15:32,970
you all right I'll say in general that

842
00:15:32,970 --> 00:15:32,980
 

843
00:15:32,980 --> 00:15:34,319
the main spoiler that hash join it's

844
00:15:34,319 --> 00:15:34,329
 

845
00:15:34,329 --> 00:15:35,640
always gonna be fastest and we'll see

846
00:15:35,640 --> 00:15:35,650

847
00:15:35,650 --> 00:15:37,420
how to make it perform well

848
00:15:37,420 --> 00:15:37,430
 

849
00:15:37,430 --> 00:15:41,079
as we go along right so the most basic

850
00:15:41,079 --> 00:15:41,089
 

851
00:15:41,089 --> 00:15:45,070
join algorithm is called the the simple

852
00:15:45,070 --> 00:15:45,080
 

853
00:15:45,080 --> 00:15:46,810
nested loop join and I'm putting a

854
00:15:46,810 --> 00:15:46,820
 

855
00:15:46,820 --> 00:15:48,490
little slow marker here just to say that

856
00:15:48,490 --> 00:15:48,500
 

857
00:15:48,500 --> 00:15:49,870
again this is like the dumbest thing you

858
00:15:49,870 --> 00:15:49,880
 

859
00:15:49,880 --> 00:15:51,730
can do but it will produce the right

860
00:15:51,730 --> 00:15:51,740
 

861
00:15:51,740 --> 00:15:55,810
output so it's exactly as it sounds the

862
00:15:55,810 --> 00:15:55,820
 

863
00:15:55,820 --> 00:15:57,370
next loop join is comprised of two

864
00:15:57,370 --> 00:15:57,380
 

865
00:15:57,380 --> 00:16:01,480
nested for-loops so the first for loop

866
00:16:01,480 --> 00:16:01,490
 

867
00:16:01,490 --> 00:16:03,579
iterates over one table and for every

868
00:16:03,579 --> 00:16:03,589
 

869
00:16:03,589 --> 00:16:04,930
tuple in that table we're gonna iterate

870
00:16:04,930 --> 00:16:04,940
 

871
00:16:04,940 --> 00:16:07,360
over the second table and we check to

872
00:16:07,360 --> 00:16:07,370
 

873
00:16:07,370 --> 00:16:08,980
see whether the tuples match our joined

874
00:16:08,980 --> 00:16:08,990
 

875
00:16:08,990 --> 00:16:11,410
predicate and if so then we omit them as

876
00:16:11,410 --> 00:16:11,420
 

877
00:16:11,420 --> 00:16:14,560
our output and so the and the parlance

878
00:16:14,560 --> 00:16:14,570
 

879
00:16:14,570 --> 00:16:16,000
we're gonna use in describing all our

880
00:16:16,000 --> 00:16:16,010

881
00:16:16,010 --> 00:16:18,340
joint algorithms are the ideas of outer

882
00:16:18,340 --> 00:16:18,350
 

883
00:16:18,350 --> 00:16:21,490
outer versus inner table so it's exactly

884
00:16:21,490 --> 00:16:21,500
 

885
00:16:21,500 --> 00:16:24,310
as it looks so the outer for loop will

886
00:16:24,310 --> 00:16:24,320
 

887
00:16:24,320 --> 00:16:25,960
be iterating over the outer table and

888
00:16:25,960 --> 00:16:25,970
 

889
00:16:25,970 --> 00:16:27,310
then the inner for loop iterates over

890
00:16:27,310 --> 00:16:27,320

891
00:16:27,320 --> 00:16:29,530
the inner table so I'll use the inner

892
00:16:29,530 --> 00:16:29,540
 

893
00:16:29,540 --> 00:16:31,000
tape I'll use inner and outer table

894
00:16:31,000 --> 00:16:31,010
 

895
00:16:31,010 --> 00:16:32,199
multiple times throughout the lecture

896
00:16:32,199 --> 00:16:32,209
 

897
00:16:32,209 --> 00:16:34,650
and this is just just what it means so

898
00:16:34,650 --> 00:16:34,660
 

899
00:16:34,660 --> 00:16:39,040
why is this algorithm bad right sort of

900
00:16:39,040 --> 00:16:39,050
 

901
00:16:39,050 --> 00:16:42,100
obvious right for every single to but

902
00:16:42,100 --> 00:16:42,110
 

903
00:16:42,110 --> 00:16:44,800
we're gonna have in our our table are

904
00:16:44,800 --> 00:16:44,810
 

905
00:16:44,810 --> 00:16:47,380
we're gonna scan the entire inner table

906
00:16:47,380 --> 00:16:47,390
 

907
00:16:47,390 --> 00:16:51,630
from beginning to end all over again so

908
00:16:51,630 --> 00:16:51,640
 

909
00:16:51,640 --> 00:16:54,640
if you now compute the cost of this in

910
00:16:54,640 --> 00:16:54,650

911
00:16:54,650 --> 00:17:00,100
terms of pages it's gonna be m Big M

912
00:17:00,100 --> 00:17:00,110
 

913
00:17:00,110 --> 00:17:03,400
plus little m times n right so we had to

914
00:17:03,400 --> 00:17:03,410
 

915
00:17:03,410 --> 00:17:05,679
scan the outer table once we have it has

916
00:17:05,679 --> 00:17:05,689

917
00:17:05,689 --> 00:17:07,689
m pages so that's what that cost is and

918
00:17:07,689 --> 00:17:07,699
 

919
00:17:07,699 --> 00:17:10,750
then for every single tuple in the outer

920
00:17:10,750 --> 00:17:10,760
 

921
00:17:10,760 --> 00:17:12,850
table of which there's little case M of

922
00:17:12,850 --> 00:17:12,860
 

923
00:17:12,860 --> 00:17:15,760
M we're going to scan every single page

924
00:17:15,760 --> 00:17:15,770
 

925
00:17:15,770 --> 00:17:20,710
in in the outer table right so when you

926
00:17:20,710 --> 00:17:20,720

927
00:17:20,720 --> 00:17:23,049
actually now put numbers into this to

928
00:17:23,049 --> 00:17:23,059
 

929
00:17:23,059 --> 00:17:25,569
say we have our database has thousand

930
00:17:25,569 --> 00:17:25,579
 

931
00:17:25,579 --> 00:17:27,130
pages in the outer table with a hundred

932
00:17:27,130 --> 00:17:27,140
 

933
00:17:27,140 --> 00:17:29,799
thousand tuples and 500 pages and the

934
00:17:29,799 --> 00:17:29,809
 

935
00:17:29,809 --> 00:17:32,549
inner table with forty thousand tuples

936
00:17:32,549 --> 00:17:32,559
 

937
00:17:32,559 --> 00:17:34,600
when you run this formula with these

938
00:17:34,600 --> 00:17:34,610

939
00:17:34,610 --> 00:17:37,600
numbers you can see that for just doing

940
00:17:37,600 --> 00:17:37,610
 

941
00:17:37,610 --> 00:17:39,490
the simple nested loop join on these two

942
00:17:39,490 --> 00:17:39,500
 

943
00:17:39,500 --> 00:17:42,690
tables produces 50 million iOS and

944
00:17:42,690 --> 00:17:42,700
 

945
00:17:42,700 --> 00:17:45,510
assuming you have like even a fast SSD

946
00:17:45,510 --> 00:17:45,520
 

947
00:17:45,520 --> 00:17:47,950
where it's one tenth of a millisecond

948
00:17:47,950 --> 00:17:47,960
 

949
00:17:47,960 --> 00:17:49,310
per IO

950
00:17:49,310 --> 00:17:49,320

951
00:17:49,320 --> 00:17:52,039
then compute this join it takes one

952
00:17:52,039 --> 00:17:52,049

953
00:17:52,049 --> 00:17:56,240
point three hours right look that's

954
00:17:56,240 --> 00:17:56,250
 

955
00:17:56,250 --> 00:17:59,440
that's pretty bad right it's pretty slow

956
00:17:59,440 --> 00:17:59,450
 

957
00:17:59,450 --> 00:18:01,639
so what's one thing we could do to make

958
00:18:01,639 --> 00:18:01,649
 

959
00:18:01,649 --> 00:18:06,320
this go faster just just this algorithm

960
00:18:06,320 --> 00:18:06,330
 

961
00:18:06,330 --> 00:18:08,060
what's not what's a simple thing we can

962
00:18:08,060 --> 00:18:08,070
 

963
00:18:08,070 --> 00:18:08,710
do

964
00:18:08,710 --> 00:18:08,720

965
00:18:08,720 --> 00:18:15,940
what's that I thought somebody said swap

966
00:18:15,940 --> 00:18:15,950


967
00:18:15,950 --> 00:18:19,310
excellent yes perfect yes so as I said

968
00:18:19,310 --> 00:18:19,320
 

969
00:18:19,320 --> 00:18:20,480
in the beginning you always want to try

970
00:18:20,480 --> 00:18:20,490
 

971
00:18:20,490 --> 00:18:22,159
to make the smaller table be the outer

972
00:18:22,159 --> 00:18:22,169
 

973
00:18:22,169 --> 00:18:25,129
table so if we do that right table asks

974
00:18:25,129 --> 00:18:25,139
 

975
00:18:25,139 --> 00:18:26,389
is smaller than the table are so we use

976
00:18:26,389 --> 00:18:26,399
 

977
00:18:26,399 --> 00:18:29,810
s as the outer table now your your iOS

978
00:18:29,810 --> 00:18:29,820
 

979
00:18:29,820 --> 00:18:32,299
get down to 40 million and your total

980
00:18:32,299 --> 00:18:32,309
 

981
00:18:32,309 --> 00:18:43,369
time is still 1,1 hours yes why say say

982
00:18:43,369 --> 00:18:43,379
 

983
00:18:43,379 --> 00:18:56,240
it again sorry yeah sorry move that over

984
00:18:56,240 --> 00:18:56,250
 

985
00:18:56,250 --> 00:18:58,820
right one thank you you know squared

986
00:18:58,820 --> 00:18:58,830
 

987
00:18:58,830 --> 00:19:00,980
listen stick sit down actually no I

988
00:19:00,980 --> 00:19:00,990
 

989
00:19:00,990 --> 00:19:03,230
don't break this but yes just move it

990
00:19:03,230 --> 00:19:03,240
 

991
00:19:03,240 --> 00:19:06,499
over by one sorry it doesn't change it

992
00:19:06,499 --> 00:19:06,509
 

993
00:19:06,509 --> 00:19:10,369
though it's still gonna be our right so

994
00:19:10,369 --> 00:19:10,379
 

995
00:19:10,379 --> 00:19:12,619
right so we even if we swap the the

996
00:19:12,619 --> 00:19:12,629
 

997
00:19:12,629 --> 00:19:15,259
inner table with the outer table we're

998
00:19:15,259 --> 00:19:15,269
 

999
00:19:15,269 --> 00:19:16,820
still doing pretty crappy here right

1000
00:19:16,820 --> 00:19:16,830
 

1001
00:19:16,830 --> 00:19:18,259
because again we're doing the dumbest

1002
00:19:18,259 --> 00:19:18,269
 

1003
00:19:18,269 --> 00:19:21,710
thing we're ignoring the fact that we

1004
00:19:21,710 --> 00:19:21,720
 

1005
00:19:21,720 --> 00:19:23,749
actually can pack multiple tuples in a

1006
00:19:23,749 --> 00:19:23,759
 

1007
00:19:23,759 --> 00:19:25,519
single page we know this because you

1008
00:19:25,519 --> 00:19:25,529
 

1009
00:19:25,529 --> 00:19:27,860
guys put your own buffle manager so you

1010
00:19:27,860 --> 00:19:27,870
 

1011
00:19:27,870 --> 00:19:30,710
can have multiple tuples per page so in

1012
00:19:30,710 --> 00:19:30,720
 

1013
00:19:30,720 --> 00:19:32,180
this case is algorithm you're assuming

1014
00:19:32,180 --> 00:19:32,190
 

1015
00:19:32,190 --> 00:19:33,950
that for every single tuple it can be a

1016
00:19:33,950 --> 00:19:33,960
 

1017
00:19:33,960 --> 00:19:35,919
page fetch to go get that that tuple

1018
00:19:35,919 --> 00:19:35,929

1019
00:19:35,929 --> 00:19:39,230
right and so what you really want is

1020
00:19:39,230 --> 00:19:39,240
 

1021
00:19:39,240 --> 00:19:42,139
sort of a buffer or a page nested loop

1022
00:19:42,139 --> 00:19:42,149
 

1023
00:19:42,149 --> 00:19:44,659
join the textbook call is that a block

1024
00:19:44,659 --> 00:19:44,669
 

1025
00:19:44,669 --> 00:19:46,399
nested loop join the basic same idea

1026
00:19:46,399 --> 00:19:46,409
 

1027
00:19:46,409 --> 00:19:48,320
where now we're just going to iterate

1028
00:19:48,320 --> 00:19:48,330
 

1029
00:19:48,330 --> 00:19:50,990
over every single block in the outer

1030
00:19:50,990 --> 00:19:51,000
 

1031
00:19:51,000 --> 00:19:53,180
table and every single block in the

1032
00:19:53,180 --> 00:19:53,190
 

1033
00:19:53,190 --> 00:19:55,340
inner table and then within the page the

1034
00:19:55,340 --> 00:19:55,350
 

1035
00:19:55,350 --> 00:19:56,960
tuples within those two blocks or two

1036
00:19:56,960 --> 00:19:56,970
 

1037
00:19:56,970 --> 00:20:00,889
pages where then do our comparison right

1038
00:20:00,889 --> 00:20:00,899
 

1039
00:20:00,899 --> 00:20:03,350
so now in this case scenario now we have

1040
00:20:03,350 --> 00:20:03,360
 

1041
00:20:03,360 --> 00:20:05,840
or nested loops put together but it's

1042
00:20:05,840 --> 00:20:05,850
 

1043
00:20:05,850 --> 00:20:08,120
still you know sir you know there's at a

1044
00:20:08,120 --> 00:20:08,130
 

1045
00:20:08,130 --> 00:20:09,530
high level we're just iterating over the

1046
00:20:09,530 --> 00:20:09,540

1047
00:20:09,540 --> 00:20:11,000
outer table and is iterating over an

1048
00:20:11,000 --> 00:20:11,010
 

1049
00:20:11,010 --> 00:20:13,130
inner table but we're doing this on a

1050
00:20:13,130 --> 00:20:13,140
 

1051
00:20:13,140 --> 00:20:15,799
per block basis so now if we go back to

1052
00:20:15,799 --> 00:20:15,809
 

1053
00:20:15,809 --> 00:20:18,919
our formula instead of having little m

1054
00:20:18,919 --> 00:20:18,929
 

1055
00:20:18,929 --> 00:20:23,120
on on the inner part and for the inner

1056
00:20:23,120 --> 00:20:23,130
 

1057
00:20:23,130 --> 00:20:26,240
table now we have big out all right so

1058
00:20:26,240 --> 00:20:26,250
 

1059
00:20:26,250 --> 00:20:28,160
this is this is a little bit better but

1060
00:20:28,160 --> 00:20:28,170
 

1061
00:20:28,170 --> 00:20:30,140
still not great and of course as I said

1062
00:20:30,140 --> 00:20:30,150
 

1063
00:20:30,150 --> 00:20:33,110
the smaller one is always we're going to

1064
00:20:33,110 --> 00:20:33,120
 

1065
00:20:33,120 --> 00:20:34,669
want to put as the outer table so in

1066
00:20:34,669 --> 00:20:34,679
 

1067
00:20:34,679 --> 00:20:35,810
this case here it's the one with the

1068
00:20:35,810 --> 00:20:35,820
 

1069
00:20:35,820 --> 00:20:37,909
smaller number of pages not the smallest

1070
00:20:37,909 --> 00:20:37,919
 

1071
00:20:37,919 --> 00:20:42,110
number of tuples alright so again do our

1072
00:20:42,110 --> 00:20:42,120
 

1073
00:20:42,120 --> 00:20:45,470
formula now I got the thousand correct

1074
00:20:45,470 --> 00:20:45,480
 

1075
00:20:45,480 --> 00:20:50,180
okay so now if we do this and Big M plus

1076
00:20:50,180 --> 00:20:50,190
 

1077
00:20:50,190 --> 00:20:53,870
Big M times begin now we're doing five

1078
00:20:53,870 --> 00:20:53,880
 

1079
00:20:53,880 --> 00:20:56,299
hundred thousand iOS and we can computer

1080
00:20:56,299 --> 00:20:56,309
 

1081
00:20:56,309 --> 00:20:59,680
join at 50 seconds on a fast SSD right

1082
00:20:59,680 --> 00:20:59,690
 

1083
00:20:59,690 --> 00:21:03,110
this is better but we can still do

1084
00:21:03,110 --> 00:21:03,120
 

1085
00:21:03,120 --> 00:21:04,549
better than this right this is in this

1086
00:21:04,549 --> 00:21:04,559
 

1087
00:21:04,559 --> 00:21:06,950
case here we're assuming that we only

1088
00:21:06,950 --> 00:21:06,960
 

1089
00:21:06,960 --> 00:21:09,590
have three blocks or three buffer pages

1090
00:21:09,590 --> 00:21:09,600

1091
00:21:09,600 --> 00:21:11,840
we can use right we have one for the

1092
00:21:11,840 --> 00:21:11,850
 

1093
00:21:11,850 --> 00:21:14,360
outer table one for the inner table and

1094
00:21:14,360 --> 00:21:14,370
 

1095
00:21:14,370 --> 00:21:16,669
then one for our output right you always

1096
00:21:16,669 --> 00:21:16,679
 

1097
00:21:16,679 --> 00:21:20,000
need one for the output so if we have

1098
00:21:20,000 --> 00:21:20,010
 

1099
00:21:20,010 --> 00:21:21,710
multiple pages multiple buffers

1100
00:21:21,710 --> 00:21:21,720
 

1101
00:21:21,720 --> 00:21:25,400
available then we can use B minus two

1102
00:21:25,400 --> 00:21:25,410
 

1103
00:21:25,410 --> 00:21:28,039
pages to do the scan the outer table and

1104
00:21:28,039 --> 00:21:28,049
 

1105
00:21:28,049 --> 00:21:30,169
we have one page for the inner table and

1106
00:21:30,169 --> 00:21:30,179
 

1107
00:21:30,179 --> 00:21:33,710
then one page for our output all right

1108
00:21:33,710 --> 00:21:33,720
 

1109
00:21:33,720 --> 00:21:35,450
and now again the album basically looks

1110
00:21:35,450 --> 00:21:35,460
 

1111
00:21:35,460 --> 00:21:36,620
the same it's just now we have B minus

1112
00:21:36,620 --> 00:21:36,630
 

1113
00:21:36,630 --> 00:21:39,080
two pages for doing that for the topmost

1114
00:21:39,080 --> 00:21:39,090
 

1115
00:21:39,090 --> 00:21:42,200
for loop again now we're taking the pin

1116
00:21:42,200 --> 00:21:42,210
 

1117
00:21:42,210 --> 00:21:43,310
of the fact that we have a wonderful

1118
00:21:43,310 --> 00:21:43,320
 

1119
00:21:43,320 --> 00:21:45,650
manager that can provide us with some

1120
00:21:45,650 --> 00:21:45,660
 

1121
00:21:45,660 --> 00:21:47,330
extra space where we actually can start

1122
00:21:47,330 --> 00:21:47,340

1123
00:21:47,340 --> 00:21:51,320
paging in tuples or pages from our from

1124
00:21:51,320 --> 00:21:51,330
 

1125
00:21:51,330 --> 00:21:54,289
our table and try to read as much as we

1126
00:21:54,289 --> 00:21:54,299
 

1127
00:21:54,299 --> 00:21:57,020
can while it's in memory so now we use

1128
00:21:57,020 --> 00:21:57,030
 

1129
00:21:57,030 --> 00:21:59,419
this the fact that we have B minus two

1130
00:21:59,419 --> 00:21:59,429
 

1131
00:21:59,429 --> 00:22:01,430
pages for the outer table in our formula

1132
00:22:01,430 --> 00:22:01,440
 

1133
00:22:01,440 --> 00:22:04,130
we end up with this this cost we say Big

1134
00:22:04,130 --> 00:22:04,140
 

1135
00:22:04,140 --> 00:22:06,380
M plus the ceiling of M divided by B

1136
00:22:06,380 --> 00:22:06,390
 

1137
00:22:06,390 --> 00:22:15,500
minus two times n right if the entire

1138
00:22:15,500 --> 00:22:15,510


1139
00:22:15,510 --> 00:22:18,800
two tables so if the outer table v

1140
00:22:18,800 --> 00:22:18,810
 

1141
00:22:18,810 --> 00:22:21,320
entirely main memory right where b is

1142
00:22:21,320 --> 00:22:21,330
 

1143
00:22:21,330 --> 00:22:22,970
greater than n plus two because again we

1144
00:22:22,970 --> 00:22:22,980
 

1145
00:22:22,980 --> 00:22:24,680
always need two pages for the inner and

1146
00:22:24,680 --> 00:22:24,690
 

1147
00:22:24,690 --> 00:22:27,860
outer now we can get this down to 1,500

1148
00:22:27,860 --> 00:22:27,870
 

1149
00:22:27,870 --> 00:22:33,380
iOS right you still have to scan you get

1150
00:22:33,380 --> 00:22:33,390
 

1151
00:22:33,390 --> 00:22:35,210
to scan the entire outer table put

1152
00:22:35,210 --> 00:22:35,220
 

1153
00:22:35,220 --> 00:22:38,240
everything memory but now we for now you

1154
00:22:38,240 --> 00:22:38,250
 

1155
00:22:38,250 --> 00:22:41,000
just then just scan the inner table all

1156
00:22:41,000 --> 00:22:41,010
 

1157
00:22:41,010 --> 00:22:43,070
right so it's M plus n so now you can

1158
00:22:43,070 --> 00:22:43,080
 

1159
00:22:43,080 --> 00:22:45,890
now we're cuttings down quite a lot but

1160
00:22:45,890 --> 00:22:45,900
 

1161
00:22:45,900 --> 00:22:47,390
of course we saw this before when we

1162
00:22:47,390 --> 00:22:47,400
 

1163
00:22:47,400 --> 00:22:49,400
talked about sequential flooding this

1164
00:22:49,400 --> 00:22:49,410

1165
00:22:49,410 --> 00:22:50,930
assumes that no other query is running

1166
00:22:50,930 --> 00:22:50,940
 

1167
00:22:50,940 --> 00:22:52,040
but you don't care about throwing away

1168
00:22:52,040 --> 00:22:52,050
 

1169
00:22:52,050 --> 00:22:53,780
anything else in your in your in your

1170
00:22:53,780 --> 00:22:53,790
 

1171
00:22:53,790 --> 00:22:55,670
buffer pool this assumes that you can

1172
00:22:55,670 --> 00:22:55,680
 

1173
00:22:55,680 --> 00:22:57,140
dedicate all the Davises memory to

1174
00:22:57,140 --> 00:22:57,150
 

1175
00:22:57,150 --> 00:22:59,180
actually just your one query which may

1176
00:22:59,180 --> 00:22:59,190
 

1177
00:22:59,190 --> 00:23:01,400
or may not be the right thing depending

1178
00:23:01,400 --> 00:23:01,410
 

1179
00:23:01,410 --> 00:23:09,290
on on your workload so again these both

1180
00:23:09,290 --> 00:23:09,300
 

1181
00:23:09,300 --> 00:23:11,180
in all these examples the block nest

1182
00:23:11,180 --> 00:23:11,190
 

1183
00:23:11,190 --> 00:23:12,650
look joint of a simple nest Lutron at

1184
00:23:12,650 --> 00:23:12,660
 

1185
00:23:12,660 --> 00:23:13,790
the end of the day they're just

1186
00:23:13,790 --> 00:23:13,800

1187
00:23:13,800 --> 00:23:16,430
sequential scans right you're just

1188
00:23:16,430 --> 00:23:16,440
 

1189
00:23:16,440 --> 00:23:17,870
scanning through every sink tube or

1190
00:23:17,870 --> 00:23:17,880

1191
00:23:17,880 --> 00:23:19,400
every single block and just doing your

1192
00:23:19,400 --> 00:23:19,410
 

1193
00:23:19,410 --> 00:23:21,980
comparison that way there may be a

1194
00:23:21,980 --> 00:23:21,990
 

1195
00:23:21,990 --> 00:23:26,270
scenario though if we have a index

1196
00:23:26,270 --> 00:23:26,280
 

1197
00:23:26,280 --> 00:23:28,040
available to us right sequential Tina

1198
00:23:28,040 --> 00:23:28,050
 

1199
00:23:28,050 --> 00:23:30,200
sucks right we know it sucks and as we

1200
00:23:30,200 --> 00:23:30,210
 

1201
00:23:30,210 --> 00:23:32,680
said it's pressure on the buffer pool

1202
00:23:32,680 --> 00:23:32,690
 

1203
00:23:32,690 --> 00:23:36,470
memory manager that that may be taking

1204
00:23:36,470 --> 00:23:36,480
 

1205
00:23:36,480 --> 00:23:37,850
them away from other parts of the system

1206
00:23:37,850 --> 00:23:37,860
 

1207
00:23:37,860 --> 00:23:40,790
so if we have an index available to us

1208
00:23:40,790 --> 00:23:40,800
 

1209
00:23:40,800 --> 00:23:42,200
which is often the case if you have

1210
00:23:42,200 --> 00:23:42,210
 

1211
00:23:42,210 --> 00:23:44,780
foreign keys then we can use that index

1212
00:23:44,780 --> 00:23:44,790
 

1213
00:23:44,790 --> 00:23:47,530
to define matches and our inner table

1214
00:23:47,530 --> 00:23:47,540

1215
00:23:47,540 --> 00:23:49,610
right instead of actually doing this

1216
00:23:49,610 --> 00:23:49,620
 

1217
00:23:49,620 --> 00:23:51,110
crunch will scan on the inner table we

1218
00:23:51,110 --> 00:23:51,120
 

1219
00:23:51,120 --> 00:23:53,630
just probe the index to find the the the

1220
00:23:53,630 --> 00:23:53,640
 

1221
00:23:53,640 --> 00:23:55,220
one or the the small number of tuples

1222
00:23:55,220 --> 00:23:55,230
 

1223
00:23:55,230 --> 00:23:57,020
that we want and then we just do our

1224
00:23:57,020 --> 00:23:57,030
 

1225
00:23:57,030 --> 00:23:59,930
join for that so best-case scenario we

1226
00:23:59,930 --> 00:23:59,940
 

1227
00:23:59,940 --> 00:24:03,170
have anacs-- available to us if not we

1228
00:24:03,170 --> 00:24:03,180
 

1229
00:24:03,180 --> 00:24:04,430
can try and maybe build one on the fly

1230
00:24:04,430 --> 00:24:04,440
 

1231
00:24:04,440 --> 00:24:05,840
which is essentially what a hashed one

1232
00:24:05,840 --> 00:24:05,850
 

1233
00:24:05,850 --> 00:24:08,750
is doing I don't know of any system

1234
00:24:08,750 --> 00:24:08,760
 

1235
00:24:08,760 --> 00:24:10,070
actually well build a people stream

1236
00:24:10,070 --> 00:24:10,080
 

1237
00:24:10,080 --> 00:24:11,720
table on the fly everyone just does the

1238
00:24:11,720 --> 00:24:11,730
 

1239
00:24:11,730 --> 00:24:13,850
hash table but again at the high/low

1240
00:24:13,850 --> 00:24:13,860
 

1241
00:24:13,860 --> 00:24:18,020
it's the same idea so now our our four

1242
00:24:18,020 --> 00:24:18,030
 

1243
00:24:18,030 --> 00:24:20,240
loops look like this so for every single

1244
00:24:20,240 --> 00:24:20,250
 

1245
00:24:20,250 --> 00:24:22,730
tuple in the end the outer table we're

1246
00:24:22,730 --> 00:24:22,740
 

1247
00:24:22,740 --> 00:24:25,400
gonna against can do a probe in our

1248
00:24:25,400 --> 00:24:25,410

1249
00:24:25,410 --> 00:24:28,370
index or assuming they have an index on

1250
00:24:28,370 --> 00:24:28,380
 

1251
00:24:28,380 --> 00:24:29,260
a

1252
00:24:29,260 --> 00:24:29,270

1253
00:24:29,270 --> 00:24:31,420
some attributes some subset of Beatrix

1254
00:24:31,420 --> 00:24:31,430
 

1255
00:24:31,430 --> 00:24:34,000
for our joint King and then if we have a

1256
00:24:34,000 --> 00:24:34,010
 

1257
00:24:34,010 --> 00:24:37,090
match from an index then we omit them as

1258
00:24:37,090 --> 00:24:37,100

1259
00:24:37,100 --> 00:24:39,610
our output so what I'm showing here the

1260
00:24:39,610 --> 00:24:39,620
 

1261
00:24:39,620 --> 00:24:41,890
reason why you do the index probe then

1262
00:24:41,890 --> 00:24:41,900
 

1263
00:24:41,900 --> 00:24:43,270
still check to see whether they match

1264
00:24:43,270 --> 00:24:43,280

1265
00:24:43,280 --> 00:24:45,450
again because the index may only have

1266
00:24:45,450 --> 00:24:45,460

1267
00:24:45,460 --> 00:24:48,640
say the say our join key our joined is

1268
00:24:48,640 --> 00:24:48,650
 

1269
00:24:48,650 --> 00:24:50,830
on three attributes the index may only

1270
00:24:50,830 --> 00:24:50,840
 

1271
00:24:50,840 --> 00:24:53,710
have the first two so we'll go find the

1272
00:24:53,710 --> 00:24:53,720
 

1273
00:24:53,720 --> 00:24:56,950
matches then we go fetch the tuple then

1274
00:24:56,950 --> 00:24:56,960
 

1275
00:24:56,960 --> 00:24:58,330
go check to see whether the other key

1276
00:24:58,330 --> 00:24:58,340
 

1277
00:24:58,340 --> 00:25:04,360
matches are doing so for this the the

1278
00:25:04,360 --> 00:25:04,370
 

1279
00:25:04,370 --> 00:25:05,890
cost of the index probe we're going to

1280
00:25:05,890 --> 00:25:05,900

1281
00:25:05,900 --> 00:25:09,520
say is some constant C all right because

1282
00:25:09,520 --> 00:25:09,530
 

1283
00:25:09,530 --> 00:25:11,590
this depends on what the data structure

1284
00:25:11,590 --> 00:25:11,600
 

1285
00:25:11,600 --> 00:25:13,750
is depends on what the index looks like

1286
00:25:13,750 --> 00:25:13,760
 

1287
00:25:13,760 --> 00:25:15,550
depends on whether the thing is in

1288
00:25:15,550 --> 00:25:15,560
 

1289
00:25:15,560 --> 00:25:17,410
memory or not right we just say it's

1290
00:25:17,410 --> 00:25:17,420
 

1291
00:25:17,420 --> 00:25:18,940
some some fixed costs that'll be the

1292
00:25:18,940 --> 00:25:18,950
 

1293
00:25:18,950 --> 00:25:23,590
same for every single tuple we know the

1294
00:25:23,590 --> 00:25:23,600
 

1295
00:25:23,600 --> 00:25:27,790
case of a B plus tree it's log n we know

1296
00:25:27,790 --> 00:25:27,800
 

1297
00:25:27,800 --> 00:25:29,260
in the case of a hash table in best case

1298
00:25:29,260 --> 00:25:29,270
 

1299
00:25:29,270 --> 00:25:32,740
scenario it's a 1 right so again we just

1300
00:25:32,740 --> 00:25:32,750
 

1301
00:25:32,750 --> 00:25:37,090
say we just say it's C so now our cost

1302
00:25:37,090 --> 00:25:37,100

1303
00:25:37,100 --> 00:25:39,580
is going to be M big m for scanning

1304
00:25:39,580 --> 00:25:39,590
 

1305
00:25:39,590 --> 00:25:41,170
every single tuple in the outer table

1306
00:25:41,170 --> 00:25:41,180
 

1307
00:25:41,180 --> 00:25:43,780
which is unavoidable and then for every

1308
00:25:43,780 --> 00:25:43,790
 

1309
00:25:43,790 --> 00:25:46,390
single tuple in the outer table we do we

1310
00:25:46,390 --> 00:25:46,400
 

1311
00:25:46,400 --> 00:25:48,610
do one probe sorry it's it's the cost of

1312
00:25:48,610 --> 00:25:48,620
 

1313
00:25:48,620 --> 00:25:49,960
scanning every single page in the outer

1314
00:25:49,960 --> 00:25:49,970
 

1315
00:25:49,970 --> 00:25:52,150
table and then for every single tuple in

1316
00:25:52,150 --> 00:25:52,160
 

1317
00:25:52,160 --> 00:25:53,710
the outer table we're doing at least

1318
00:25:53,710 --> 00:25:53,720
 

1319
00:25:53,720 --> 00:25:56,620
we're doing exactly one probe into into

1320
00:25:56,620 --> 00:25:56,630
 

1321
00:25:56,630 --> 00:25:58,960
our index to find our matches so that's

1322
00:25:58,960 --> 00:25:58,970
 

1323
00:25:58,970 --> 00:26:00,070
why the formula comes out like this

1324
00:26:00,070 --> 00:26:00,080
 

1325
00:26:00,080 --> 00:26:04,020
right

1326
00:26:04,020 --> 00:26:04,030


1327
00:26:04,030 --> 00:26:07,030
so in nested loop join super simple to

1328
00:26:07,030 --> 00:26:07,040
 

1329
00:26:07,040 --> 00:26:08,800
understand you always try to pick the

1330
00:26:08,800 --> 00:26:08,810
 

1331
00:26:08,810 --> 00:26:10,630
smaller table as the outer as the outer

1332
00:26:10,630 --> 00:26:10,640
 

1333
00:26:10,640 --> 00:26:13,930
table and then you just do you know do a

1334
00:26:13,930 --> 00:26:13,940

1335
00:26:13,940 --> 00:26:15,580
central scan over the outer table and

1336
00:26:15,580 --> 00:26:15,590
 

1337
00:26:15,590 --> 00:26:17,020
you have to do is scrunch will scan or

1338
00:26:17,020 --> 00:26:17,030
 

1339
00:26:17,030 --> 00:26:19,480
index probe on the inner table anyone

1340
00:26:19,480 --> 00:26:19,490
 

1341
00:26:19,490 --> 00:26:21,130
try to put as much as the outer table in

1342
00:26:21,130 --> 00:26:21,140
 

1343
00:26:21,140 --> 00:26:24,160
memory as possible to be to reuse that

1344
00:26:24,160 --> 00:26:24,170

1345
00:26:24,170 --> 00:26:27,130
that data as your as you're doing your

1346
00:26:27,130 --> 00:26:27,140
 

1347
00:26:27,140 --> 00:26:29,890
scan on the on the inner table and if

1348
00:26:29,890 --> 00:26:29,900
 

1349
00:26:29,900 --> 00:26:30,760
you have an index on the inner table

1350
00:26:30,760 --> 00:26:30,770

1351
00:26:30,770 --> 00:26:33,100
then then that's great and she

1352
00:26:33,100 --> 00:26:33,110
 

1353
00:26:33,110 --> 00:26:34,990
definitely use that and David says my

1354
00:26:34,990 --> 00:26:35,000
 

1355
00:26:35,000 --> 00:26:36,370
optimizer try to try to always pick the

1356
00:26:36,370 --> 00:26:36,380
 

1357
00:26:36,380 --> 00:26:38,890
index

1358
00:26:38,890 --> 00:26:38,900


1359
00:26:38,900 --> 00:26:40,540
all right so any questions about about

1360
00:26:40,540 --> 00:26:40,550
 

1361
00:26:40,550 --> 00:26:44,049
Nestle loop join again it's the first

1362
00:26:44,049 --> 00:26:44,059
 

1363
00:26:44,059 --> 00:26:45,310
loop this is the first joint album and

1364
00:26:45,310 --> 00:26:45,320
 

1365
00:26:45,320 --> 00:26:46,660
everyone pretty much implements when

1366
00:26:46,660 --> 00:26:46,670
 

1367
00:26:46,670 --> 00:26:48,310
they may build a database system the

1368
00:26:48,310 --> 00:26:48,320
 

1369
00:26:48,320 --> 00:26:49,930
first time because it's the easiest one

1370
00:26:49,930 --> 00:26:49,940
 

1371
00:26:49,940 --> 00:26:56,710
Mabel man okay the next Casa joint

1372
00:26:56,710 --> 00:26:56,720
 

1373
00:26:56,720 --> 00:26:57,970
algorithms is called the sort merge join

1374
00:26:57,970 --> 00:26:57,980
 

1375
00:26:57,980 --> 00:27:00,070
so I think your textbook calls this

1376
00:27:00,070 --> 00:27:00,080
 

1377
00:27:00,080 --> 00:27:03,460
merge join I other textbooks call it

1378
00:27:03,460 --> 00:27:03,470
 

1379
00:27:03,470 --> 00:27:05,890
sort merge join they mean the same thing

1380
00:27:05,890 --> 00:27:05,900
 

1381
00:27:05,900 --> 00:27:07,600
and was sort of confusing about this is

1382
00:27:07,600 --> 00:27:07,610
 

1383
00:27:07,610 --> 00:27:10,510
like in the sort merge join you can use

1384
00:27:10,510 --> 00:27:10,520
 

1385
00:27:10,520 --> 00:27:12,190
the external merge sort algorithm to

1386
00:27:12,190 --> 00:27:12,200
 

1387
00:27:12,200 --> 00:27:13,360
sort your table so we talked about last

1388
00:27:13,360 --> 00:27:13,370
 

1389
00:27:13,370 --> 00:27:13,630
time

1390
00:27:13,630 --> 00:27:13,640
 

1391
00:27:13,640 --> 00:27:17,169
all right so but again they're all the

1392
00:27:17,169 --> 00:27:17,179
 

1393
00:27:17,179 --> 00:27:19,480
same so there's two phases so in the

1394
00:27:19,480 --> 00:27:19,490
 

1395
00:27:19,490 --> 00:27:21,910
first phase we're gonna sort both the

1396
00:27:21,910 --> 00:27:21,920
 

1397
00:27:21,920 --> 00:27:24,370
the inner and the outer table based on

1398
00:27:24,370 --> 00:27:24,380
 

1399
00:27:24,380 --> 00:27:27,880
the join keys and then when that's done

1400
00:27:27,880 --> 00:27:27,890
 

1401
00:27:27,890 --> 00:27:30,310
then we're gonna have these were

1402
00:27:30,310 --> 00:27:30,320
 

1403
00:27:30,320 --> 00:27:31,570
established these cursors at the

1404
00:27:31,570 --> 00:27:31,580
 

1405
00:27:31,580 --> 00:27:33,730
beginning of the two tables at the top

1406
00:27:33,730 --> 00:27:33,740
 

1407
00:27:33,740 --> 00:27:36,280
and then they're gonna walk down sort of

1408
00:27:36,280 --> 00:27:36,290
 

1409
00:27:36,290 --> 00:27:40,780
in in a proper order and doing

1410
00:27:40,780 --> 00:27:40,790
 

1411
00:27:40,790 --> 00:27:42,490
comparisons or wherever the cursor is

1412
00:27:42,490 --> 00:27:42,500
 

1413
00:27:42,500 --> 00:27:45,010
pointing at and to see whether we have a

1414
00:27:45,010 --> 00:27:45,020
 

1415
00:27:45,020 --> 00:27:47,680
match and begin the idea high-level idea

1416
00:27:47,680 --> 00:27:47,690
 

1417
00:27:47,690 --> 00:27:49,210
about this is that because we're sorting

1418
00:27:49,210 --> 00:27:49,220
 

1419
00:27:49,220 --> 00:27:53,049
things ahead of time when now we start

1420
00:27:53,049 --> 00:27:53,059
 

1421
00:27:53,059 --> 00:27:55,570
scanning the table with our cursor we

1422
00:27:55,570 --> 00:27:55,580
 

1423
00:27:55,580 --> 00:27:57,220
know that as the cursor moves down

1424
00:27:57,220 --> 00:27:57,230
 

1425
00:27:57,230 --> 00:27:59,440
because it's in sort of order we never

1426
00:27:59,440 --> 00:27:59,450
 

1427
00:27:59,450 --> 00:28:01,540
have to go back and look at previous

1428
00:28:01,540 --> 00:28:01,550
 

1429
00:28:01,550 --> 00:28:04,060
values we've examined before because we

1430
00:28:04,060 --> 00:28:04,070
 

1431
00:28:04,070 --> 00:28:06,040
know we know everything at that point is

1432
00:28:06,040 --> 00:28:06,050
 

1433
00:28:06,050 --> 00:28:08,770
is where every cursor is pointing at

1434
00:28:08,770 --> 00:28:08,780
 

1435
00:28:08,780 --> 00:28:10,240
everything below it or sorry everything

1436
00:28:10,240 --> 00:28:10,250
 

1437
00:28:10,250 --> 00:28:13,240
back above it is less or greater than

1438
00:28:13,240 --> 00:28:13,250
 

1439
00:28:13,250 --> 00:28:15,070
based on how you sort of it then what

1440
00:28:15,070 --> 00:28:15,080
 

1441
00:28:15,080 --> 00:28:17,080
we're looking at now so we never have to

1442
00:28:17,080 --> 00:28:17,090
 

1443
00:28:17,090 --> 00:28:18,850
go look at things we've looked at before

1444
00:28:18,850 --> 00:28:18,860
 

1445
00:28:18,860 --> 00:28:21,160
I'll show example what I mean by in the

1446
00:28:21,160 --> 00:28:21,170
 

1447
00:28:21,170 --> 00:28:23,169
second and again for the sort phase you

1448
00:28:23,169 --> 00:28:23,179
 

1449
00:28:23,179 --> 00:28:24,760
can use quicksort you can use heap sort

1450
00:28:24,760 --> 00:28:24,770
 

1451
00:28:24,770 --> 00:28:26,169
or you can use the external more sort

1452
00:28:26,169 --> 00:28:26,179

1453
00:28:26,179 --> 00:28:28,960
algorithm we talked at last class so

1454
00:28:28,960 --> 00:28:28,970
 

1455
00:28:28,970 --> 00:28:30,940
roughly the algorithm for the immerser

1456
00:28:30,940 --> 00:28:30,950
 

1457
00:28:30,950 --> 00:28:33,100
the sort merge-join looks like this so

1458
00:28:33,100 --> 00:28:33,110
 

1459
00:28:33,110 --> 00:28:34,870
in the first page you just sort the two

1460
00:28:34,870 --> 00:28:34,880
 

1461
00:28:34,880 --> 00:28:37,990
tables based on the join keys we know

1462
00:28:37,990 --> 00:28:38,000
 

1463
00:28:38,000 --> 00:28:39,700
how to do that from last class and then

1464
00:28:39,700 --> 00:28:39,710
 

1465
00:28:39,710 --> 00:28:42,370
you have these cursors on the sort of

1466
00:28:42,370 --> 00:28:42,380

1467
00:28:42,380 --> 00:28:44,500
tables that they're just going to scan

1468
00:28:44,500 --> 00:28:44,510
 

1469
00:28:44,510 --> 00:28:47,710
through the the two tables until either

1470
00:28:47,710 --> 00:28:47,720
 

1471
00:28:47,720 --> 00:28:50,860
one of them reaches the end and at the

1472
00:28:50,860 --> 00:28:50,870

1473
00:28:50,870 --> 00:28:53,740
at each age step it reached sort of

1474
00:28:53,740 --> 00:28:53,750
 

1475
00:28:53,750 --> 00:28:55,270
iteration through the wild up here if

1476
00:28:55,270 --> 00:28:55,280
 

1477
00:28:55,280 --> 00:28:57,910
the outer tapers cursor is greater than

1478
00:28:57,910 --> 00:28:57,920
 

1479
00:28:57,920 --> 00:28:59,200
the inner tables cursor then you

1480
00:28:59,200 --> 00:28:59,210

1481
00:28:59,210 --> 00:29:01,450
increment the inner tables cursor if the

1482
00:29:01,450 --> 00:29:01,460
 

1483
00:29:01,460 --> 00:29:03,070
outer tables cursor is less than the

1484
00:29:03,070 --> 00:29:03,080

1485
00:29:03,080 --> 00:29:04,420
inner tables cursor then you increment

1486
00:29:04,420 --> 00:29:04,430
 

1487
00:29:04,430 --> 00:29:07,390
the counter tables cursor otherwise you

1488
00:29:07,390 --> 00:29:07,400
 

1489
00:29:07,400 --> 00:29:09,220
check to see whether you have a match

1490
00:29:09,220 --> 00:29:09,230
 

1491
00:29:09,230 --> 00:29:11,470
and if so then you produce that as your

1492
00:29:11,470 --> 00:29:11,480
 

1493
00:29:11,480 --> 00:29:14,470
output from the join table the join

1494
00:29:14,470 --> 00:29:14,480
 

1495
00:29:14,480 --> 00:29:18,670
tuple and then you increment the the the

1496
00:29:18,670 --> 00:29:18,680
 

1497
00:29:18,680 --> 00:29:22,450
the inner tables cursor by one so again

1498
00:29:22,450 --> 00:29:22,460
 

1499
00:29:22,460 --> 00:29:23,710
the algorithm might be difficult to

1500
00:29:23,710 --> 00:29:23,720
 

1501
00:29:23,720 --> 00:29:24,520
follow up but let's look at this

1502
00:29:24,520 --> 00:29:24,530
 

1503
00:29:24,530 --> 00:29:27,550
visually again so these are the two

1504
00:29:27,550 --> 00:29:27,560
 

1505
00:29:27,560 --> 00:29:29,110
tables we want to sort for this for this

1506
00:29:29,110 --> 00:29:29,120
 

1507
00:29:29,120 --> 00:29:31,630
join query here so in the first phase we

1508
00:29:31,630 --> 00:29:31,640
 

1509
00:29:31,640 --> 00:29:33,970
do our sorting or do our sort on the on

1510
00:29:33,970 --> 00:29:33,980
 

1511
00:29:33,980 --> 00:29:35,860
the join key okay so this is just

1512
00:29:35,860 --> 00:29:35,870
 

1513
00:29:35,870 --> 00:29:37,420
running extra merge sort of quick sort

1514
00:29:37,420 --> 00:29:37,430
 

1515
00:29:37,430 --> 00:29:39,400
whatever you want and then we produce

1516
00:29:39,400 --> 00:29:39,410
 

1517
00:29:39,410 --> 00:29:43,090
our new tuples like this and then we

1518
00:29:43,090 --> 00:29:43,100
 

1519
00:29:43,100 --> 00:29:46,720
have two cursors start that at the top

1520
00:29:46,720 --> 00:29:46,730
 

1521
00:29:46,730 --> 00:29:48,970
of each of the two tables and they're

1522
00:29:48,970 --> 00:29:48,980
 

1523
00:29:48,980 --> 00:29:52,150
gonna again go down in in in step one by

1524
00:29:52,150 --> 00:29:52,160
 

1525
00:29:52,160 --> 00:29:54,580
one and do comparisons across with each

1526
00:29:54,580 --> 00:29:54,590
 

1527
00:29:54,590 --> 00:29:57,280
other to see whether we have a match so

1528
00:29:57,280 --> 00:29:57,290
 

1529
00:29:57,290 --> 00:29:58,870
in the very first step we're gonna check

1530
00:29:58,870 --> 00:29:58,880
 

1531
00:29:58,880 --> 00:30:01,000
to see whether and the outer tables

1532
00:30:01,000 --> 00:30:01,010
 

1533
00:30:01,010 --> 00:30:03,280
cursor the values pointing is the cursor

1534
00:30:03,280 --> 00:30:03,290
 

1535
00:30:03,290 --> 00:30:04,990
is pointing at in value of 100 the inner

1536
00:30:04,990 --> 00:30:05,000
 

1537
00:30:05,000 --> 00:30:06,700
tables cursor is pointing in value 100

1538
00:30:06,700 --> 00:30:06,710
 

1539
00:30:06,710 --> 00:30:08,800
these two are equal therefore we know we

1540
00:30:08,800 --> 00:30:08,810
 

1541
00:30:08,810 --> 00:30:10,900
have a match and we produce a tuple as

1542
00:30:10,900 --> 00:30:10,910
 

1543
00:30:10,910 --> 00:30:13,780
our output because we have a match then

1544
00:30:13,780 --> 00:30:13,790
 

1545
00:30:13,790 --> 00:30:15,610
we now increment the inner tables cursor

1546
00:30:15,610 --> 00:30:15,620
 

1547
00:30:15,620 --> 00:30:18,280
by 1 and do another comparison again we

1548
00:30:18,280 --> 00:30:18,290
 

1549
00:30:18,290 --> 00:30:19,690
don't move the outer table cursor here

1550
00:30:19,690 --> 00:30:19,700
 

1551
00:30:19,700 --> 00:30:22,900
so again now 100 equals 100 so we know

1552
00:30:22,900 --> 00:30:22,910
 

1553
00:30:22,910 --> 00:30:25,090
we have a match we produce our tuple in

1554
00:30:25,090 --> 00:30:25,100
 

1555
00:30:25,100 --> 00:30:27,310
the output table and then we increment

1556
00:30:27,310 --> 00:30:27,320
 

1557
00:30:27,320 --> 00:30:31,180
the inner tables cursor so now this

1558
00:30:31,180 --> 00:30:31,190
 

1559
00:30:31,190 --> 00:30:34,150
point we're comparing 1 100 and 200 but

1560
00:30:34,150 --> 00:30:34,160
 

1561
00:30:34,160 --> 00:30:37,120
since 200 is greater than 100 we know we

1562
00:30:37,120 --> 00:30:37,130
 

1563
00:30:37,130 --> 00:30:39,760
need to now move the outer tables cursor

1564
00:30:39,760 --> 00:30:39,770
 

1565
00:30:39,770 --> 00:30:42,610
by 1 and this is sort of I was saying

1566
00:30:42,610 --> 00:30:42,620
 

1567
00:30:42,620 --> 00:30:45,220
that we never have to backtrack so at

1568
00:30:45,220 --> 00:30:45,230
 

1569
00:30:45,230 --> 00:30:46,930
this point here we don't have a match

1570
00:30:46,930 --> 00:30:46,940
 

1571
00:30:46,940 --> 00:30:50,530
100 is not equal 200 so we know that for

1572
00:30:50,530 --> 00:30:50,540
 

1573
00:30:50,540 --> 00:30:53,200
the inner tables cursor we've already

1574
00:30:53,200 --> 00:30:53,210
 

1575
00:30:53,210 --> 00:30:54,910
looked at everything that comes before

1576
00:30:54,910 --> 00:30:54,920
 

1577
00:30:54,920 --> 00:30:56,980
it so now when we increment in here now

1578
00:30:56,980 --> 00:30:56,990
 

1579
00:30:56,990 --> 00:30:59,320
to 200 we never need to go back and look

1580
00:30:59,320 --> 00:30:59,330
 

1581
00:30:59,330 --> 00:31:01,150
at anything that we seen before because

1582
00:31:01,150 --> 00:31:01,160
 

1583
00:31:01,160 --> 00:31:02,470
it's good that everything's gonna be

1584
00:31:02,470 --> 00:31:02,480
 

1585
00:31:02,480 --> 00:31:04,030
less than whatever that cursor is

1586
00:31:04,030 --> 00:31:04,040
 

1587
00:31:04,040 --> 00:31:04,960
pointing at

1588
00:31:04,960 --> 00:31:04,970

1589
00:31:04,970 --> 00:31:07,120
so everything's gonna be less than 200

1590
00:31:07,120 --> 00:31:07,130

1591
00:31:07,130 --> 00:31:09,190
so we know there's nothing that we ever

1592
00:31:09,190 --> 00:31:09,200
 

1593
00:31:09,200 --> 00:31:11,290
need to compare again so I really only

1594
00:31:11,290 --> 00:31:11,300
 

1595
00:31:11,300 --> 00:31:14,230
have potentially examine the cursor only

1596
00:31:14,230 --> 00:31:14,240

1597
00:31:14,240 --> 00:31:18,820
looks at each tuple once it make them do

1598
00:31:18,820 --> 00:31:18,830
 

1599
00:31:18,830 --> 00:31:20,470
multiple persons with the tuple that

1600
00:31:20,470 --> 00:31:20,480
 

1601
00:31:20,480 --> 00:31:22,150
it's looking at but it never goes back

1602
00:31:22,150 --> 00:31:22,160
 

1603
00:31:22,160 --> 00:31:24,460
on local books to the other ones so now

1604
00:31:24,460 --> 00:31:24,470
 

1605
00:31:24,470 --> 00:31:26,410
we have 200 equals 200 we produce our

1606
00:31:26,410 --> 00:31:26,420
 

1607
00:31:26,420 --> 00:31:29,770
output we increment the inner tables

1608
00:31:29,770 --> 00:31:29,780
 

1609
00:31:29,780 --> 00:31:32,650
cursor now we have 200 not does not is

1610
00:31:32,650 --> 00:31:32,660
 

1611
00:31:32,660 --> 00:31:35,080
not equal to 400 and 200 is less than

1612
00:31:35,080 --> 00:31:35,090
 

1613
00:31:35,090 --> 00:31:37,330
400 so we increment the outer tables

1614
00:31:37,330 --> 00:31:37,340
 

1615
00:31:37,340 --> 00:31:40,870
cursor by 1 300 is less than 400 to be

1616
00:31:40,870 --> 00:31:40,880
 

1617
00:31:40,880 --> 00:31:43,420
incremented again and then now 400

1618
00:31:43,420 --> 00:31:43,430

1619
00:31:43,430 --> 00:31:45,580
equals 400 so we produce it with an

1620
00:31:45,580 --> 00:31:45,590
 

1621
00:31:45,590 --> 00:31:47,710
output increment the inner table and now

1622
00:31:47,710 --> 00:31:47,720
 

1623
00:31:47,720 --> 00:31:50,620
400 is equal 500 increment the outer

1624
00:31:50,620 --> 00:31:50,630
 

1625
00:31:50,630 --> 00:31:53,230
table 500 equals 500 we produce our

1626
00:31:53,230 --> 00:31:53,240
 

1627
00:31:53,240 --> 00:31:55,480
output so what happens next what happens

1628
00:31:55,480 --> 00:31:55,490

1629
00:31:55,490 --> 00:32:03,160
here what's that well he's just effect

1630
00:32:03,160 --> 00:32:03,170
 

1631
00:32:03,170 --> 00:32:05,200
let's say assuming this is this is this

1632
00:32:05,200 --> 00:32:05,210
 

1633
00:32:05,210 --> 00:32:08,470
is the entire table right he's right

1634
00:32:08,470 --> 00:32:08,480
 

1635
00:32:08,480 --> 00:32:10,450
this is it we're done right because we

1636
00:32:10,450 --> 00:32:10,460
 

1637
00:32:10,460 --> 00:32:13,060
reached the end of the inner table so it

1638
00:32:13,060 --> 00:32:13,070
 

1639
00:32:13,070 --> 00:32:14,650
doesn't matter that there's some some

1640
00:32:14,650 --> 00:32:14,660
 

1641
00:32:14,660 --> 00:32:16,480
more tuples here right

1642
00:32:16,480 --> 00:32:16,490
 

1643
00:32:16,490 --> 00:32:19,210
this thing will increment to nothing so

1644
00:32:19,210 --> 00:32:19,220
 

1645
00:32:19,220 --> 00:32:21,010
we know that there's there's nothing

1646
00:32:21,010 --> 00:32:21,020
 

1647
00:32:21,020 --> 00:32:22,390
else we could possibly look at because

1648
00:32:22,390 --> 00:32:22,400
 

1649
00:32:22,400 --> 00:32:24,310
again we don't backtrack so it doesn't

1650
00:32:24,310 --> 00:32:24,320
 

1651
00:32:24,320 --> 00:32:28,060
matter that we have a match here what

1652
00:32:28,060 --> 00:32:28,070
 

1653
00:32:28,070 --> 00:32:29,410
doesn't matter that these guys still

1654
00:32:29,410 --> 00:32:29,420
 

1655
00:32:29,420 --> 00:32:37,780
exist we don't care yes so he says those

1656
00:32:37,780 --> 00:32:37,790

1657
00:32:37,790 --> 00:32:46,240
two you can still match with the yes

1658
00:32:46,240 --> 00:32:46,250
 

1659
00:32:46,250 --> 00:32:50,590
right yes forgot about that yeah he's

1660
00:32:50,590 --> 00:32:50,600
 

1661
00:32:50,600 --> 00:32:52,480
right okay so this is technically wrong

1662
00:32:52,480 --> 00:32:52,490
 

1663
00:32:52,490 --> 00:32:56,020
so if this was 500 then this thing would

1664
00:32:56,020 --> 00:32:56,030

1665
00:32:56,030 --> 00:33:00,550
would go down and you have to increment

1666
00:33:00,550 --> 00:33:00,560
 

1667
00:33:00,560 --> 00:33:03,220
this one down not this one yeah so it's

1668
00:33:03,220 --> 00:33:03,230
 

1669
00:33:03,230 --> 00:33:04,660
letting me off if they deal with that

1670
00:33:04,660 --> 00:33:04,670
 

1671
00:33:04,670 --> 00:33:12,060
case yes

1672
00:33:12,060 --> 00:33:12,070


1673
00:33:12,070 --> 00:33:15,070
he's racing it was ID is a primary key

1674
00:33:15,070 --> 00:33:15,080
 

1675
00:33:15,080 --> 00:33:18,820
it's not b12 in this case here yeah it

1676
00:33:18,820 --> 00:33:18,830
 

1677
00:33:18,830 --> 00:33:20,740
is this is the primary key or it's a

1678
00:33:20,740 --> 00:33:20,750
 

1679
00:33:20,750 --> 00:33:27,220
unique key at least so yeah I'm getting

1680
00:33:27,220 --> 00:33:27,230
 

1681
00:33:27,230 --> 00:33:29,170
the cardinality so this is n 2 1 so

1682
00:33:29,170 --> 00:33:29,180
 

1683
00:33:29,180 --> 00:33:31,570
there's multiple tuples here from one

1684
00:33:31,570 --> 00:33:31,580

1685
00:33:31,580 --> 00:33:33,910
tuple here so if you know that then you

1686
00:33:33,910 --> 00:33:33,920
 

1687
00:33:33,920 --> 00:33:35,020
know that if you reach the end of this

1688
00:33:35,020 --> 00:33:35,030
 

1689
00:33:35,030 --> 00:33:36,760
you'll never have any other match

1690
00:33:36,760 --> 00:33:36,770
 

1691
00:33:36,770 --> 00:33:37,810
because you've already matched

1692
00:33:37,810 --> 00:33:37,820

1693
00:33:37,820 --> 00:33:40,660
everything right if it's end-to-end then

1694
00:33:40,660 --> 00:33:40,670
 

1695
00:33:40,670 --> 00:33:42,940
you would have to go to the very bottom

1696
00:33:42,940 --> 00:33:42,950
 

1697
00:33:42,950 --> 00:33:45,850
of this one here yeah that's the corner

1698
00:33:45,850 --> 00:33:45,860
 

1699
00:33:45,860 --> 00:33:47,380
case I forgot to discuss thank you

1700
00:33:47,380 --> 00:33:47,390
 

1701
00:33:47,390 --> 00:33:55,320
I'll fix that yes so you're back here

1702
00:33:55,320 --> 00:33:55,330
 

1703
00:33:55,330 --> 00:33:58,180
yeah so yeah it's question is say if

1704
00:33:58,180 --> 00:33:58,190

1705
00:33:58,190 --> 00:34:04,150
this was actually 100 not 200 right if

1706
00:34:04,150 --> 00:34:04,160
 

1707
00:34:04,160 --> 00:34:07,450
you if it's end and then yeah in this

1708
00:34:07,450 --> 00:34:07,460
 

1709
00:34:07,460 --> 00:34:08,649
case you would have to backtrack so you

1710
00:34:08,649 --> 00:34:08,659
 

1711
00:34:08,659 --> 00:34:13,419
have to know that all right you have to

1712
00:34:13,419 --> 00:34:13,429
 

1713
00:34:13,429 --> 00:34:16,030
know that all right in the value I'm

1714
00:34:16,030 --> 00:34:16,040
 

1715
00:34:16,040 --> 00:34:18,909
looking at this is 100 where did I stop

1716
00:34:18,909 --> 00:34:18,919
 

1717
00:34:18,919 --> 00:34:22,060
at same thing like where's the what's

1718
00:34:22,060 --> 00:34:22,070

1719
00:34:22,070 --> 00:34:24,250
the how far'd I have to go back to reset

1720
00:34:24,250 --> 00:34:24,260
 

1721
00:34:24,260 --> 00:34:27,100
to the current value so you have to say

1722
00:34:27,100 --> 00:34:27,110
 

1723
00:34:27,110 --> 00:34:28,870
all right there's 100 100 so I know that

1724
00:34:28,870 --> 00:34:28,880
 

1725
00:34:28,880 --> 00:34:30,909
if I have to reset I have to start back

1726
00:34:30,909 --> 00:34:30,919
 

1727
00:34:30,919 --> 00:34:33,159
up here same thing on here I like the

1728
00:34:33,159 --> 00:34:33,169
 

1729
00:34:33,169 --> 00:34:35,590
reset I come back it up it here so for

1730
00:34:35,590 --> 00:34:35,600
 

1731
00:34:35,600 --> 00:34:37,899
the basically would way work is on the

1732
00:34:37,899 --> 00:34:37,909
 

1733
00:34:37,909 --> 00:34:40,870
outer table for every single tuple sorry

1734
00:34:40,870 --> 00:34:40,880
 

1735
00:34:40,880 --> 00:34:42,370
you never backtrack on the outer table

1736
00:34:42,370 --> 00:34:42,380
 

1737
00:34:42,380 --> 00:34:43,570
you always backtrack on the inner table

1738
00:34:43,570 --> 00:34:43,580
 

1739
00:34:43,580 --> 00:34:47,470
so if I start at the outer table 100 100

1740
00:34:47,470 --> 00:34:47,480
 

1741
00:34:47,480 --> 00:34:50,470
I'm ash that next guy's 100 100 that

1742
00:34:50,470 --> 00:34:50,480

1743
00:34:50,480 --> 00:34:54,669
matches and then I go down to 200 and I

1744
00:34:54,669 --> 00:34:54,679

1745
00:34:54,679 --> 00:34:57,460
come down increment this by 1 and now

1746
00:34:57,460 --> 00:34:57,470
 

1747
00:34:57,470 --> 00:34:58,990
I'm at 100 again I have to know I have

1748
00:34:58,990 --> 00:34:59,000
 

1749
00:34:59,000 --> 00:35:01,150
to go back on the inner table to start

1750
00:35:01,150 --> 00:35:01,160
 

1751
00:35:01,160 --> 00:35:03,820
100 again and scan down again so this

1752
00:35:03,820 --> 00:35:03,830
 

1753
00:35:03,830 --> 00:35:05,440
Maxima meditative to maintain if you

1754
00:35:05,440 --> 00:35:05,450
 

1755
00:35:05,450 --> 00:35:10,890
have if you're doing end-to-end joints

1756
00:35:10,890 --> 00:35:10,900


1757
00:35:10,900 --> 00:35:17,530
but at a high level the cost is no worst

1758
00:35:17,530 --> 00:35:17,540
 

1759
00:35:17,540 --> 00:35:19,300
case scenario they're exactly the same

1760
00:35:19,300 --> 00:35:19,310
 

1761
00:35:19,310 --> 00:35:20,110
then it's just 2

1762
00:35:20,110 --> 00:35:20,120
 

1763
00:35:20,120 --> 00:35:23,560
scans over and over again but we'll keep

1764
00:35:23,560 --> 00:35:23,570
 

1765
00:35:23,570 --> 00:35:26,440
it simple eyes ever clear what I was

1766
00:35:26,440 --> 00:35:26,450
 

1767
00:35:26,450 --> 00:35:28,630
saying there right in this example here

1768
00:35:28,630 --> 00:35:28,640
 

1769
00:35:28,640 --> 00:35:30,490
we never the backtrack because we know

1770
00:35:30,490 --> 00:35:30,500
 

1771
00:35:30,500 --> 00:35:33,130
it's a one end joint so for every one

1772
00:35:33,130 --> 00:35:33,140
 

1773
00:35:33,140 --> 00:35:35,290
tuple on this table there can be

1774
00:35:35,290 --> 00:35:35,300
 

1775
00:35:35,300 --> 00:35:38,380
multiple tuples on this table but not

1776
00:35:38,380 --> 00:35:38,390
 

1777
00:35:38,390 --> 00:35:39,160
vice versa

1778
00:35:39,160 --> 00:35:39,170

1779
00:35:39,170 --> 00:35:41,680
so as we scan down we never have the

1780
00:35:41,680 --> 00:35:41,690
 

1781
00:35:41,690 --> 00:35:44,470
backtrack if it's n - n then you had the

1782
00:35:44,470 --> 00:35:44,480
 

1783
00:35:44,480 --> 00:35:47,860
backtrack on the on the inner table -

1784
00:35:47,860 --> 00:35:47,870
 

1785
00:35:47,870 --> 00:35:49,480
you know as you go down on the outer

1786
00:35:49,480 --> 00:35:49,490
 

1787
00:35:49,490 --> 00:35:51,940
table but you instead of having to

1788
00:35:51,940 --> 00:35:51,950
 

1789
00:35:51,950 --> 00:35:52,900
include sometimes we'll scan every

1790
00:35:52,900 --> 00:35:52,910
 

1791
00:35:52,910 --> 00:35:54,430
single time you can just can only

1792
00:35:54,430 --> 00:35:54,440
 

1793
00:35:54,440 --> 00:35:56,170
backtrack to the point where you just

1794
00:35:56,170 --> 00:35:56,180
 

1795
00:35:56,180 --> 00:35:57,910
you know the values that you need to do

1796
00:35:57,910 --> 00:35:57,920
 

1797
00:35:57,920 --> 00:36:02,950
your compare something start okay and

1798
00:36:02,950 --> 00:36:02,960
 

1799
00:36:02,960 --> 00:36:04,990
then get some weird you know the cost

1800
00:36:04,990 --> 00:36:05,000
 

1801
00:36:05,000 --> 00:36:06,250
analysis can get weird because you know

1802
00:36:06,250 --> 00:36:06,260
 

1803
00:36:06,260 --> 00:36:07,930
if you're if you're backtracking across

1804
00:36:07,930 --> 00:36:07,940

1805
00:36:07,940 --> 00:36:09,580
page boundaries then you're fetching in

1806
00:36:09,580 --> 00:36:09,590
 

1807
00:36:09,590 --> 00:36:12,160
pages again and again we're keeping

1808
00:36:12,160 --> 00:36:12,170

1809
00:36:12,170 --> 00:36:16,390
simple ignoring that all right so the

1810
00:36:16,390 --> 00:36:16,400
 

1811
00:36:16,400 --> 00:36:18,100
cost for this right we have the sort

1812
00:36:18,100 --> 00:36:18,110
 

1813
00:36:18,110 --> 00:36:21,040
cost of the outer table the surplus or

1814
00:36:21,040 --> 00:36:21,050
 

1815
00:36:21,050 --> 00:36:22,900
inner table and that's just the formula

1816
00:36:22,900 --> 00:36:22,910
 

1817
00:36:22,910 --> 00:36:24,310
we had from last class when we talked

1818
00:36:24,310 --> 00:36:24,320
 

1819
00:36:24,320 --> 00:36:25,990
about concerning a merge sort and then

1820
00:36:25,990 --> 00:36:26,000
 

1821
00:36:26,000 --> 00:36:27,610
we have our merge cost and get best case

1822
00:36:27,610 --> 00:36:27,620
 

1823
00:36:27,620 --> 00:36:30,010
scenario it's just going to scan on the

1824
00:36:30,010 --> 00:36:30,020
 

1825
00:36:30,020 --> 00:36:31,360
outer table and switch gain on the inner

1826
00:36:31,360 --> 00:36:31,370
 

1827
00:36:31,370 --> 00:36:33,880
table n plus n so the total cost of

1828
00:36:33,880 --> 00:36:33,890
 

1829
00:36:33,890 --> 00:36:35,470
these is just the combination of these

1830
00:36:35,470 --> 00:36:35,480
 

1831
00:36:35,480 --> 00:36:39,040
two formulas so again using our example

1832
00:36:39,040 --> 00:36:39,050
 

1833
00:36:39,050 --> 00:36:40,690
database and now say we have a hundred

1834
00:36:40,690 --> 00:36:40,700
 

1835
00:36:40,700 --> 00:36:43,480
buffer pages to do to our joins sorry do

1836
00:36:43,480 --> 00:36:43,490

1837
00:36:43,490 --> 00:36:46,180
our sorts for both R and s that means we

1838
00:36:46,180 --> 00:36:46,190
 

1839
00:36:46,190 --> 00:36:48,730
can sort them in just two passes so the

1840
00:36:48,730 --> 00:36:48,740
 

1841
00:36:48,740 --> 00:36:51,520
cost of sorting R is 3000 the cost of

1842
00:36:51,520 --> 00:36:51,530
 

1843
00:36:51,530 --> 00:36:54,880
sorting s is 1350 the merge cost is just

1844
00:36:54,880 --> 00:36:54,890
 

1845
00:36:54,890 --> 00:36:58,600
1500 so the total cost of the merge plus

1846
00:36:58,600 --> 00:36:58,610
 

1847
00:36:58,610 --> 00:37:01,600
sorry this sort plus the merge is 5,800

1848
00:37:01,600 --> 00:37:01,610
 

1849
00:37:01,610 --> 00:37:04,360
and that roughly comes out to be 59

1850
00:37:04,360 --> 00:37:04,370
 

1851
00:37:04,370 --> 00:37:06,210
seconds if you're doing this on an SSD

1852
00:37:06,210 --> 00:37:06,220
 

1853
00:37:06,220 --> 00:37:07,780
so we're getting a little bit better

1854
00:37:07,780 --> 00:37:07,790
 

1855
00:37:07,790 --> 00:37:10,060
right we were I forget we were had

1856
00:37:10,060 --> 00:37:10,070
 

1857
00:37:10,070 --> 00:37:12,430
before with the with with the other

1858
00:37:12,430 --> 00:37:12,440
 

1859
00:37:12,440 --> 00:37:14,080
joins but it was a roughly around a

1860
00:37:14,080 --> 00:37:14,090
 

1861
00:37:14,090 --> 00:37:15,700
second so now we're getting into sub

1862
00:37:15,700 --> 00:37:15,710
 

1863
00:37:15,710 --> 00:37:22,960
second numbers here all right so the the

1864
00:37:22,960 --> 00:37:22,970
 

1865
00:37:22,970 --> 00:37:25,000
worst case scenario is sort of example

1866
00:37:25,000 --> 00:37:25,010
 

1867
00:37:25,010 --> 00:37:27,550
we briefly talked about aware you have

1868
00:37:27,550 --> 00:37:27,560

1869
00:37:27,560 --> 00:37:30,730
to do backtracking on on the outer table

1870
00:37:30,730 --> 00:37:30,740

1871
00:37:30,740 --> 00:37:33,410
so now essentially becomes the

1872
00:37:33,410 --> 00:37:33,420
 

1873
00:37:33,420 --> 00:37:36,799
the you you play the cost of sorting but

1874
00:37:36,799 --> 00:37:36,809

1875
00:37:36,809 --> 00:37:38,329
then all your attributes are the same

1876
00:37:38,329 --> 00:37:38,339

1877
00:37:38,339 --> 00:37:40,789
for the two tables so you're just doing

1878
00:37:40,789 --> 00:37:40,799
 

1879
00:37:40,799 --> 00:37:42,980
for every single page in the outer table

1880
00:37:42,980 --> 00:37:42,990
 

1881
00:37:42,990 --> 00:37:44,870
you're doing completes Winchell scan on

1882
00:37:44,870 --> 00:37:44,880
 

1883
00:37:44,880 --> 00:37:46,730
the inner table then you backtrack on

1884
00:37:46,730 --> 00:37:46,740
 

1885
00:37:46,740 --> 00:37:48,589
the inner table go down to the next page

1886
00:37:48,589 --> 00:37:48,599
 

1887
00:37:48,599 --> 00:37:50,900
and do it all over again so in the worst

1888
00:37:50,900 --> 00:37:50,910
 

1889
00:37:50,910 --> 00:37:53,630
case scenario for the server's join it

1890
00:37:53,630 --> 00:37:53,640
 

1891
00:37:53,640 --> 00:37:56,870
be M times n plus plus your cost all

1892
00:37:56,870 --> 00:37:56,880
 

1893
00:37:56,880 --> 00:37:59,720
right so again we'll see this on Monday

1894
00:37:59,720 --> 00:37:59,730
 

1895
00:37:59,730 --> 00:38:00,770
next week we talked about query

1896
00:38:00,770 --> 00:38:00,780
 

1897
00:38:00,780 --> 00:38:02,569
optimization the database system tries

1898
00:38:02,569 --> 00:38:02,579
 

1899
00:38:02,579 --> 00:38:04,970
to maintain internal statistics about

1900
00:38:04,970 --> 00:38:04,980

1901
00:38:04,980 --> 00:38:07,220
your database about your tables to make

1902
00:38:07,220 --> 00:38:07,230
 

1903
00:38:07,230 --> 00:38:09,859
decisions about oh my my distribution my

1904
00:38:09,859 --> 00:38:09,869
 

1905
00:38:09,869 --> 00:38:12,020
values is really crappy so therefore I

1906
00:38:12,020 --> 00:38:12,030
 

1907
00:38:12,030 --> 00:38:13,579
don't want to do the sort merge drawing

1908
00:38:13,579 --> 00:38:13,589
 

1909
00:38:13,589 --> 00:38:15,500
because I know I'm just gonna be waiting

1910
00:38:15,500 --> 00:38:15,510
 

1911
00:38:15,510 --> 00:38:17,480
to do wasted i/o because I'm not getting

1912
00:38:17,480 --> 00:38:17,490
 

1913
00:38:17,490 --> 00:38:19,609
any benefit of actually sorting I would

1914
00:38:19,609 --> 00:38:19,619
 

1915
00:38:19,619 --> 00:38:21,289
say that this case this particular

1916
00:38:21,289 --> 00:38:21,299
 

1917
00:38:21,299 --> 00:38:23,690
example is super rare right because

1918
00:38:23,690 --> 00:38:23,700
 

1919
00:38:23,700 --> 00:38:24,980
think about what this action would be

1920
00:38:24,980 --> 00:38:24,990
 

1921
00:38:24,990 --> 00:38:27,950
there's be two tables that you want to

1922
00:38:27,950 --> 00:38:27,960
 

1923
00:38:27,960 --> 00:38:30,230
join where they have one value in this

1924
00:38:30,230 --> 00:38:30,240
 

1925
00:38:30,240 --> 00:38:32,240
column and they're exactly the same for

1926
00:38:32,240 --> 00:38:32,250
 

1927
00:38:32,250 --> 00:38:34,819
every single tuple I am I don't want say

1928
00:38:34,819 --> 00:38:34,829
 

1929
00:38:34,829 --> 00:38:35,900
it never happens because people do

1930
00:38:35,900 --> 00:38:35,910
 

1931
00:38:35,910 --> 00:38:38,120
stupid things all the time but like you

1932
00:38:38,120 --> 00:38:38,130
 

1933
00:38:38,130 --> 00:38:41,420
know in in you know in a real

1934
00:38:41,420 --> 00:38:41,430
 

1935
00:38:41,430 --> 00:38:43,220
application you I don't think you this

1936
00:38:43,220 --> 00:38:43,230
 

1937
00:38:43,230 --> 00:38:48,680
is B unlikely all right so when is to

1938
00:38:48,680 --> 00:38:48,690
 

1939
00:38:48,690 --> 00:38:50,510
sort merge-join useful well obviously

1940
00:38:50,510 --> 00:38:50,520
 

1941
00:38:50,520 --> 00:38:53,059
when the tables are already sorted on

1942
00:38:53,059 --> 00:38:53,069
 

1943
00:38:53,069 --> 00:38:55,130
your join key and if you're doing like

1944
00:38:55,130 --> 00:38:55,140
 

1945
00:38:55,140 --> 00:38:57,079
an index organized table then you don't

1946
00:38:57,079 --> 00:38:57,089

1947
00:38:57,089 --> 00:38:58,520
actually have any sort cost because it's

1948
00:38:58,520 --> 00:38:58,530
 

1949
00:38:58,530 --> 00:38:59,690
already sorted on the thing you want to

1950
00:38:59,690 --> 00:38:59,700
 

1951
00:38:59,700 --> 00:39:02,180
join in anyway so that that's an added

1952
00:39:02,180 --> 00:39:02,190
 

1953
00:39:02,190 --> 00:39:04,460
bonus right you cut that into entirely

1954
00:39:04,460 --> 00:39:04,470

1955
00:39:04,470 --> 00:39:06,680
and it's just then it's just the cost of

1956
00:39:06,680 --> 00:39:06,690
 

1957
00:39:06,690 --> 00:39:10,910
two sequential scans also if your if

1958
00:39:10,910 --> 00:39:10,920
 

1959
00:39:10,920 --> 00:39:12,530
your query requires the output to be

1960
00:39:12,530 --> 00:39:12,540
 

1961
00:39:12,540 --> 00:39:14,690
sorted on your join key then you're

1962
00:39:14,690 --> 00:39:14,700
 

1963
00:39:14,700 --> 00:39:16,400
killing two birds with one stone because

1964
00:39:16,400 --> 00:39:16,410
 

1965
00:39:16,410 --> 00:39:20,059
now you're do the the join and it'll

1966
00:39:20,059 --> 00:39:20,069
 

1967
00:39:20,069 --> 00:39:21,680
it'll produce output that's already

1968
00:39:21,680 --> 00:39:21,690

1969
00:39:21,690 --> 00:39:23,390
sorted on the thing that that's in your

1970
00:39:23,390 --> 00:39:23,400
 

1971
00:39:23,400 --> 00:39:25,549
order by clause so then you don't have

1972
00:39:25,549 --> 00:39:25,559
 

1973
00:39:25,559 --> 00:39:27,200
to do any extra sorting for the order by

1974
00:39:27,200 --> 00:39:27,210
 

1975
00:39:27,210 --> 00:39:29,809
it's already sorted all right so again

1976
00:39:29,809 --> 00:39:29,819
 

1977
00:39:29,819 --> 00:39:31,160
the optimizer the David system can

1978
00:39:31,160 --> 00:39:31,170
 

1979
00:39:31,170 --> 00:39:32,599
recognize oh I have an order by Clause

1980
00:39:32,599 --> 00:39:32,609
 

1981
00:39:32,609 --> 00:39:34,670
for my join and the order by ascending

1982
00:39:34,670 --> 00:39:34,680
 

1983
00:39:34,680 --> 00:39:37,220
I'm joining on so just don't do just do

1984
00:39:37,220 --> 00:39:37,230
 

1985
00:39:37,230 --> 00:39:39,230
sort merge and then don't do the order

1986
00:39:39,230 --> 00:39:39,240
 

1987
00:39:39,240 --> 00:39:41,120
by and you cut out an operator entirely

1988
00:39:41,120 --> 00:39:41,130

1989
00:39:41,130 --> 00:39:45,829
entirely from your query plan all right

1990
00:39:45,829 --> 00:39:45,839
 

1991
00:39:45,839 --> 00:39:51,630
so again the the the in the output so

1992
00:39:51,630 --> 00:39:51,640
 

1993
00:39:51,640 --> 00:39:52,980
the input for these operators could be

1994
00:39:52,980 --> 00:39:52,990

1995
00:39:52,990 --> 00:39:56,940
either on the Davidson will know I'm

1996
00:39:56,940 --> 00:39:56,950
 

1997
00:39:56,950 --> 00:39:58,530
getting data from this from this

1998
00:39:58,530 --> 00:39:58,540
 

1999
00:39:58,540 --> 00:40:00,420
operator below me in the tree and I'm

2000
00:40:00,420 --> 00:40:00,430

2001
00:40:00,430 --> 00:40:02,010
gonna know the physical properties of

2002
00:40:02,010 --> 00:40:02,020

2003
00:40:02,020 --> 00:40:03,240
that data I'll know whether it's

2004
00:40:03,240 --> 00:40:03,250
 

2005
00:40:03,250 --> 00:40:05,310
actually been already sorted or not so

2006
00:40:05,310 --> 00:40:05,320
 

2007
00:40:05,320 --> 00:40:08,250
uses that in its determination to decide

2008
00:40:08,250 --> 00:40:08,260
 

2009
00:40:08,260 --> 00:40:10,170
whether it wants to do assert merge-join

2010
00:40:10,170 --> 00:40:10,180
 

2011
00:40:10,180 --> 00:40:15,390
or another algorithm okay alright so any

2012
00:40:15,390 --> 00:40:15,400
 

2013
00:40:15,400 --> 00:40:18,800
questions about sort merge-join

2014
00:40:18,800 --> 00:40:18,810


2015
00:40:18,810 --> 00:40:22,109
okay so let's notice our time talk my

2016
00:40:22,109 --> 00:40:22,119
 

2017
00:40:22,119 --> 00:40:25,200
heroines so they said hash join is the

2018
00:40:25,200 --> 00:40:25,210
 

2019
00:40:25,210 --> 00:40:26,910
most portent algorithm this is where

2020
00:40:26,910 --> 00:40:26,920
 

2021
00:40:26,920 --> 00:40:28,950
most major analytical databases are

2022
00:40:28,950 --> 00:40:28,960

2023
00:40:28,960 --> 00:40:32,060
gonna spending most of their time

2024
00:40:32,060 --> 00:40:32,070
 

2025
00:40:32,070 --> 00:40:34,230
because in general this always turns out

2026
00:40:34,230 --> 00:40:34,240
 

2027
00:40:34,240 --> 00:40:39,050
to be the best so the basic idea is that

2028
00:40:39,050 --> 00:40:39,060
 

2029
00:40:39,060 --> 00:40:41,609
it's almost like the index nested loop

2030
00:40:41,609 --> 00:40:41,619
 

2031
00:40:41,619 --> 00:40:44,700
join where well how about we'll build a

2032
00:40:44,700 --> 00:40:44,710
 

2033
00:40:44,710 --> 00:40:47,670
hash table on the fly and then we use

2034
00:40:47,670 --> 00:40:47,680
 

2035
00:40:47,680 --> 00:40:51,900
that to probe the in the inner table to

2036
00:40:51,900 --> 00:40:51,910
 

2037
00:40:51,910 --> 00:40:55,290
see whether we have have a match so the

2038
00:40:55,290 --> 00:40:55,300
 

2039
00:40:55,300 --> 00:40:56,250
way to think about this and why this

2040
00:40:56,250 --> 00:40:56,260
 

2041
00:40:56,260 --> 00:40:59,880
works is that if we have if we're doing

2042
00:40:59,880 --> 00:40:59,890
 

2043
00:40:59,890 --> 00:41:02,700
a join on two tuples and their

2044
00:41:02,700 --> 00:41:02,710
 

2045
00:41:02,710 --> 00:41:05,490
attributes match alright meaning say

2046
00:41:05,490 --> 00:41:05,500
 

2047
00:41:05,500 --> 00:41:06,510
again we're doing equi-join just

2048
00:41:06,510 --> 00:41:06,520
 

2049
00:41:06,520 --> 00:41:09,480
something equal something if we men hash

2050
00:41:09,480 --> 00:41:09,490
 

2051
00:41:09,490 --> 00:41:11,220
those attributes that we're doing our

2052
00:41:11,220 --> 00:41:11,230
 

2053
00:41:11,230 --> 00:41:13,770
joint on the hash will happen produce

2054
00:41:13,770 --> 00:41:13,780
 

2055
00:41:13,780 --> 00:41:15,359
the same the hash function will produce

2056
00:41:15,359 --> 00:41:15,369
 

2057
00:41:15,369 --> 00:41:18,510
the same hash value as well so if two

2058
00:41:18,510 --> 00:41:18,520
 

2059
00:41:18,520 --> 00:41:20,520
values an unhatched form equal are the

2060
00:41:20,520 --> 00:41:20,530
 

2061
00:41:20,530 --> 00:41:22,710
same then two values in their hashed

2062
00:41:22,710 --> 00:41:22,720
 

2063
00:41:22,720 --> 00:41:24,630
form will have to be the same so we can

2064
00:41:24,630 --> 00:41:24,640
 

2065
00:41:24,640 --> 00:41:28,050
rely on this aspect of that to then do

2066
00:41:28,050 --> 00:41:28,060
 

2067
00:41:28,060 --> 00:41:30,300
our join so we can just do our join on

2068
00:41:30,300 --> 00:41:30,310
 

2069
00:41:30,310 --> 00:41:31,770
the hash attributes rather than the

2070
00:41:31,770 --> 00:41:31,780
 

2071
00:41:31,780 --> 00:41:33,839
actual role actors themselves so at a

2072
00:41:33,839 --> 00:41:33,849
 

2073
00:41:33,849 --> 00:41:35,160
high level that's essentially what we're

2074
00:41:35,160 --> 00:41:35,170
 

2075
00:41:35,170 --> 00:41:39,770
trying to do in a hash joint so we have

2076
00:41:39,770 --> 00:41:39,780
 

2077
00:41:39,780 --> 00:41:43,680
two phases so in the in the first phase

2078
00:41:43,680 --> 00:41:43,690
 

2079
00:41:43,690 --> 00:41:46,109
we're going to build a hash table on the

2080
00:41:46,109 --> 00:41:46,119
 

2081
00:41:46,119 --> 00:41:49,890
outer relation outer table using some

2082
00:41:49,890 --> 00:41:49,900
 

2083
00:41:49,900 --> 00:41:51,300
hash mulching it doesn't matter what it

2084
00:41:51,300 --> 00:41:51,310
 

2085
00:41:51,310 --> 00:41:54,300
is murmur hash murmur hash city hash

2086
00:41:54,300 --> 00:41:54,310
 

2087
00:41:54,310 --> 00:41:56,700
whatever whatever you want to use

2088
00:41:56,700 --> 00:41:56,710
 

2089
00:41:56,710 --> 00:41:59,309
and then the second phase is then we

2090
00:41:59,309 --> 00:41:59,319
 

2091
00:41:59,319 --> 00:42:02,309
just do a scrunchy scan over it in a

2092
00:42:02,309 --> 00:42:02,319
 

2093
00:42:02,319 --> 00:42:04,500
relation and for every single tuple

2094
00:42:04,500 --> 00:42:04,510
 

2095
00:42:04,510 --> 00:42:07,260
we're gonna hash the join key attributes

2096
00:42:07,260 --> 00:42:07,270
 

2097
00:42:07,270 --> 00:42:09,120
of that tuple with our same hash

2098
00:42:09,120 --> 00:42:09,130
 

2099
00:42:09,130 --> 00:42:10,710
function we using the first base and

2100
00:42:10,710 --> 00:42:10,720
 

2101
00:42:10,720 --> 00:42:13,319
that'll tell us that'll that'll point us

2102
00:42:13,319 --> 00:42:13,329
 

2103
00:42:13,329 --> 00:42:15,030
to some location in our hash table and

2104
00:42:15,030 --> 00:42:15,040
 

2105
00:42:15,040 --> 00:42:16,950
we can use that to determine whether we

2106
00:42:16,950 --> 00:42:16,960
 

2107
00:42:16,960 --> 00:42:20,520
have a match so just like we don't care

2108
00:42:20,520 --> 00:42:20,530
 

2109
00:42:20,530 --> 00:42:22,589
what hash function we use we don't

2110
00:42:22,589 --> 00:42:22,599
 

2111
00:42:22,599 --> 00:42:23,940
actually care what what hash table we

2112
00:42:23,940 --> 00:42:23,950
 

2113
00:42:23,950 --> 00:42:26,220
use we can use linear hashing cuckoo

2114
00:42:26,220 --> 00:42:26,230
 

2115
00:42:26,230 --> 00:42:28,799
hashing Robinhood hashing right it

2116
00:42:28,799 --> 00:42:28,809
 

2117
00:42:28,809 --> 00:42:30,240
doesn't matter as long as we can make

2118
00:42:30,240 --> 00:42:30,250
 

2119
00:42:30,250 --> 00:42:32,040
sure that we we hash something and it

2120
00:42:32,040 --> 00:42:32,050
 

2121
00:42:32,050 --> 00:42:33,450
jumps to a particular spot in our table

2122
00:42:33,450 --> 00:42:33,460
 

2123
00:42:33,460 --> 00:42:34,349
and when you find the thing that we're

2124
00:42:34,349 --> 00:42:34,359
 

2125
00:42:34,359 --> 00:42:36,020
looking for

2126
00:42:36,020 --> 00:42:36,030
 

2127
00:42:36,030 --> 00:42:38,730
so the basic hash showing album again

2128
00:42:38,730 --> 00:42:38,740
 

2129
00:42:38,740 --> 00:42:41,180
visually looks like this again the the

2130
00:42:41,180 --> 00:42:41,190
 

2131
00:42:41,190 --> 00:42:43,500
algorithm is that you just build a hash

2132
00:42:43,500 --> 00:42:43,510
 

2133
00:42:43,510 --> 00:42:45,990
table HTR on the outer table and then

2134
00:42:45,990 --> 00:42:46,000
 

2135
00:42:46,000 --> 00:42:47,400
for every single table every single

2136
00:42:47,400 --> 00:42:47,410
 

2137
00:42:47,410 --> 00:42:49,260
tuple an inner table you're just gonna

2138
00:42:49,260 --> 00:42:49,270
 

2139
00:42:49,270 --> 00:42:52,620
hash it and look up in the hash table to

2140
00:42:52,620 --> 00:42:52,630
 

2141
00:42:52,630 --> 00:42:54,809
see whether you have a match so again we

2142
00:42:54,809 --> 00:42:54,819
 

2143
00:42:54,819 --> 00:42:55,890
just do a special scan of the outer

2144
00:42:55,890 --> 00:42:55,900
 

2145
00:42:55,900 --> 00:42:58,980
table populate HTR and then do a special

2146
00:42:58,980 --> 00:42:58,990
 

2147
00:42:58,990 --> 00:43:01,319
scan on the inner table and this probe

2148
00:43:01,319 --> 00:43:01,329
 

2149
00:43:01,329 --> 00:43:02,730
inside the hash table to see whether

2150
00:43:02,730 --> 00:43:02,740
 

2151
00:43:02,740 --> 00:43:05,400
they have a match right that's it pretty

2152
00:43:05,400 --> 00:43:05,410
 

2153
00:43:05,410 --> 00:43:07,289
straightforward same thing almost as

2154
00:43:07,289 --> 00:43:07,299
 

2155
00:43:07,299 --> 00:43:11,039
like the index nested loop join except

2156
00:43:11,039 --> 00:43:11,049
 

2157
00:43:11,049 --> 00:43:12,870
in the index in this loop join we had

2158
00:43:12,870 --> 00:43:12,880

2159
00:43:12,880 --> 00:43:15,120
the index on the inner table where in

2160
00:43:15,120 --> 00:43:15,130
 

2161
00:43:15,130 --> 00:43:16,680
this case we're building that the hash

2162
00:43:16,680 --> 00:43:16,690
 

2163
00:43:16,690 --> 00:43:21,180
table on the outer table alright so what

2164
00:43:21,180 --> 00:43:21,190
 

2165
00:43:21,190 --> 00:43:22,319
do we actually put in our hash table

2166
00:43:22,319 --> 00:43:22,329
 

2167
00:43:22,329 --> 00:43:24,390
well again the key is just going to be

2168
00:43:24,390 --> 00:43:24,400
 

2169
00:43:24,400 --> 00:43:25,859
the attributes that we're doing our

2170
00:43:25,859 --> 00:43:25,869
 

2171
00:43:25,869 --> 00:43:28,470
joint on right it has to be it's only

2172
00:43:28,470 --> 00:43:28,480
 

2173
00:43:28,480 --> 00:43:30,030
works if you're doing equi-join there

2174
00:43:30,030 --> 00:43:30,040
 

2175
00:43:30,040 --> 00:43:31,710
are quality predicates because we want

2176
00:43:31,710 --> 00:43:31,720
 

2177
00:43:31,720 --> 00:43:33,000
to know where whether something equals

2178
00:43:33,000 --> 00:43:33,010
 

2179
00:43:33,010 --> 00:43:35,579
something if we have an inequality if we

2180
00:43:35,579 --> 00:43:35,589
 

2181
00:43:35,589 --> 00:43:38,280
have a less than or greater than

2182
00:43:38,280 --> 00:43:38,290
 

2183
00:43:38,290 --> 00:43:39,809
then the hash join doesn't work because

2184
00:43:39,809 --> 00:43:39,819
 

2185
00:43:39,819 --> 00:43:41,900
we can't actually do that comparison

2186
00:43:41,900 --> 00:43:41,910
 

2187
00:43:41,910 --> 00:43:44,940
with our in the hash table right it

2188
00:43:44,940 --> 00:43:44,950
 

2189
00:43:44,950 --> 00:43:47,819
always has to be an exact match and then

2190
00:43:47,819 --> 00:43:47,829
 

2191
00:43:47,829 --> 00:43:49,319
what we actually put in the value

2192
00:43:49,319 --> 00:43:49,329
 

2193
00:43:49,329 --> 00:43:51,270
portion of the payload of a hash table

2194
00:43:51,270 --> 00:43:51,280

2195
00:43:51,280 --> 00:43:53,370
can depends on the implementation and it

2196
00:43:53,370 --> 00:43:53,380
 

2197
00:43:53,380 --> 00:43:55,920
depends on what the what the output of

2198
00:43:55,920 --> 00:43:55,930
 

2199
00:43:55,930 --> 00:43:59,339
the operator should be so you can put

2200
00:43:59,339 --> 00:43:59,349
 

2201
00:43:59,349 --> 00:44:03,990
the entire tuple if you want and we said

2202
00:44:03,990 --> 00:44:04,000
 

2203
00:44:04,000 --> 00:44:06,120
that we wanted to do this because we'd

2204
00:44:06,120 --> 00:44:06,130
 

2205
00:44:06,130 --> 00:44:07,500
avoid having to go back and get more

2206
00:44:07,500 --> 00:44:07,510
 

2207
00:44:07,510 --> 00:44:11,490
data so if we build our hash

2208
00:44:11,490 --> 00:44:11,500
 

2209
00:44:11,500 --> 00:44:16,140
if we have our joint key piece if we if

2210
00:44:16,140 --> 00:44:16,150
 

2211
00:44:16,150 --> 00:44:18,269
we want to make our joint key or the

2212
00:44:18,269 --> 00:44:18,279
 

2213
00:44:18,279 --> 00:44:20,579
thing work hashing on be a subset of the

2214
00:44:20,579 --> 00:44:20,589
 

2215
00:44:20,589 --> 00:44:21,809
joint keys which you could do if you

2216
00:44:21,809 --> 00:44:21,819
 

2217
00:44:21,819 --> 00:44:23,279
wanted to then we still have to maintain

2218
00:44:23,279 --> 00:44:23,289
 

2219
00:44:23,289 --> 00:44:24,690
the rest of the joint key inside right

2220
00:44:24,690 --> 00:44:24,700
 

2221
00:44:24,700 --> 00:44:26,730
and inside the payload because then we

2222
00:44:26,730 --> 00:44:26,740
 

2223
00:44:26,740 --> 00:44:29,160
have to do a valuation inside of that

2224
00:44:29,160 --> 00:44:29,170
 

2225
00:44:29,170 --> 00:44:30,839
anyway we have to do that anyway

2226
00:44:30,839 --> 00:44:30,849
 

2227
00:44:30,849 --> 00:44:32,430
actually if we hash the entire joint key

2228
00:44:32,430 --> 00:44:32,440
 

2229
00:44:32,440 --> 00:44:34,559
or not because we could have collisions

2230
00:44:34,559 --> 00:44:34,569
 

2231
00:44:34,569 --> 00:44:35,430
and we have to go and then make sure

2232
00:44:35,430 --> 00:44:35,440
 

2233
00:44:35,440 --> 00:44:37,349
that we actually have an exact match the

2234
00:44:37,349 --> 00:44:37,359
 

2235
00:44:37,359 --> 00:44:40,019
side side of the hash table this

2236
00:44:40,019 --> 00:44:40,029

2237
00:44:40,029 --> 00:44:44,730
obviously takes up more space and it may

2238
00:44:44,730 --> 00:44:44,740
 

2239
00:44:44,740 --> 00:44:46,799
cause our hash table to overflow and you

2240
00:44:46,799 --> 00:44:46,809
 

2241
00:44:46,809 --> 00:44:48,359
know I have long chains or other things

2242
00:44:48,359 --> 00:44:48,369

2243
00:44:48,369 --> 00:44:50,910
that you know requires to allocate more

2244
00:44:50,910 --> 00:44:50,920
 

2245
00:44:50,920 --> 00:44:53,519
pages or we could use the tuple

2246
00:44:53,519 --> 00:44:53,529
 

2247
00:44:53,529 --> 00:44:55,259
identifier or the record ID all set that

2248
00:44:55,259 --> 00:44:55,269
 

2249
00:44:55,269 --> 00:44:56,839
we talked at the beginning which one do

2250
00:44:56,839 --> 00:44:56,849
 

2251
00:44:56,849 --> 00:44:59,009
materialization we said this will be

2252
00:44:59,009 --> 00:44:59,019
 

2253
00:44:59,019 --> 00:45:01,710
better for column stores because you're

2254
00:45:01,710 --> 00:45:01,720
 

2255
00:45:01,720 --> 00:45:02,999
only reading in data bit you actually

2256
00:45:02,999 --> 00:45:03,009
 

2257
00:45:03,009 --> 00:45:05,789
need but you may have to go fetch that

2258
00:45:05,789 --> 00:45:05,799
 

2259
00:45:05,799 --> 00:45:08,249
data later on up in the query plan

2260
00:45:08,249 --> 00:45:08,259
 

2261
00:45:08,259 --> 00:45:11,150
depending on what what you actually need

2262
00:45:11,150 --> 00:45:11,160

2263
00:45:11,160 --> 00:45:16,019
so if everything fits in memory then our

2264
00:45:16,019 --> 00:45:16,029
 

2265
00:45:16,029 --> 00:45:18,809
hatchling is super fast because we just

2266
00:45:18,809 --> 00:45:18,819
 

2267
00:45:18,819 --> 00:45:21,930
ripped through the the outer table that

2268
00:45:21,930 --> 00:45:21,940

2269
00:45:21,940 --> 00:45:23,640
our hash table then ripped through the

2270
00:45:23,640 --> 00:45:23,650
 

2271
00:45:23,650 --> 00:45:26,279
inner table and the hash table entirely

2272
00:45:26,279 --> 00:45:26,289
 

2273
00:45:26,289 --> 00:45:28,079
baby there and we just probe inside of

2274
00:45:28,079 --> 00:45:28,089
 

2275
00:45:28,089 --> 00:45:30,210
it and find things that we want of

2276
00:45:30,210 --> 00:45:30,220
 

2277
00:45:30,220 --> 00:45:32,039
course we said that this is not always

2278
00:45:32,039 --> 00:45:32,049
 

2279
00:45:32,049 --> 00:45:35,880
the case of in large databases so we

2280
00:45:35,880 --> 00:45:35,890
 

2281
00:45:35,890 --> 00:45:37,440
this is why we have a bubble manager it

2282
00:45:37,440 --> 00:45:37,450
 

2283
00:45:37,450 --> 00:45:39,359
allows tomato spill things out the disk

2284
00:45:39,359 --> 00:45:39,369
 

2285
00:45:39,369 --> 00:45:42,690
as needed but just like we don't want

2286
00:45:42,690 --> 00:45:42,700
 

2287
00:45:42,700 --> 00:45:44,700
the operating system to control what we

2288
00:45:44,700 --> 00:45:44,710
 

2289
00:45:44,710 --> 00:45:47,039
swap in and out of memory we actually

2290
00:45:47,039 --> 00:45:47,049
 

2291
00:45:47,049 --> 00:45:48,930
don't want the buffalo manager just to

2292
00:45:48,930 --> 00:45:48,940
 

2293
00:45:48,940 --> 00:45:50,490
make its own decisions but what's the

2294
00:45:50,490 --> 00:45:50,500
 

2295
00:45:50,500 --> 00:45:54,210
swap in and out okay because they may

2296
00:45:54,210 --> 00:45:54,220
 

2297
00:45:54,220 --> 00:45:56,009
end up swapping things out we don't want

2298
00:45:56,009 --> 00:45:56,019
 

2299
00:45:56,019 --> 00:45:59,519
to as we're doing our joint let me tell

2300
00:45:59,519 --> 00:45:59,529
 

2301
00:45:59,529 --> 00:46:04,259
you guys why why is that the case so

2302
00:46:04,259 --> 00:46:04,269
 

2303
00:46:04,269 --> 00:46:05,789
what is it about the halberd you are

2304
00:46:05,789 --> 00:46:05,799

2305
00:46:05,799 --> 00:46:08,819
saying say we put our hash table now

2306
00:46:08,819 --> 00:46:08,829
 

2307
00:46:08,829 --> 00:46:11,880
we're doing our probe actually both

2308
00:46:11,880 --> 00:46:11,890
 

2309
00:46:11,890 --> 00:46:13,410
those cases on the build side and the

2310
00:46:13,410 --> 00:46:13,420
 

2311
00:46:13,420 --> 00:46:15,749
probe side what is the access pattern of

2312
00:46:15,749 --> 00:46:15,759
 

2313
00:46:15,759 --> 00:46:20,250
our hat our hashing function looks like

2314
00:46:20,250 --> 00:46:20,260


2315
00:46:20,260 --> 00:46:21,900
it's random right because you're taking

2316
00:46:21,900 --> 00:46:21,910
 

2317
00:46:21,910 --> 00:46:24,060
whatever value have hashing it to some

2318
00:46:24,060 --> 00:46:24,070
 

2319
00:46:24,070 --> 00:46:25,740
random location of memory and it's we

2320
00:46:25,740 --> 00:46:25,750
 

2321
00:46:25,750 --> 00:46:29,670
can't predict this ahead of time so if

2322
00:46:29,670 --> 00:46:29,680
 

2323
00:46:29,680 --> 00:46:31,980
we just let the the the the buffle

2324
00:46:31,980 --> 00:46:31,990
 

2325
00:46:31,990 --> 00:46:33,750
manager decide oh I'll just use LRU or

2326
00:46:33,750 --> 00:46:33,760
 

2327
00:46:33,760 --> 00:46:36,090
clock decide what what to swap out or

2328
00:46:36,090 --> 00:46:36,100

2329
00:46:36,100 --> 00:46:39,780
vicked from my buffer pool it may end up

2330
00:46:39,780 --> 00:46:39,790
 

2331
00:46:39,790 --> 00:46:42,630
putting out something that the next hash

2332
00:46:42,630 --> 00:46:42,640
 

2333
00:46:42,640 --> 00:46:44,670
the next hashman the next key would

2334
00:46:44,670 --> 00:46:44,680

2335
00:46:44,680 --> 00:46:46,980
actually need

2336
00:46:46,980 --> 00:46:46,990

2337
00:46:46,990 --> 00:46:49,289
Mart about this and try to stage things

2338
00:46:49,289 --> 00:46:49,299
 

2339
00:46:49,299 --> 00:46:52,769
in smaller chunks there we can try to

2340
00:46:52,769 --> 00:46:52,779
 

2341
00:46:52,779 --> 00:46:54,029
get everything to fit in memory and we

2342
00:46:54,029 --> 00:46:54,039
 

2343
00:46:54,039 --> 00:46:56,670
don't have we don't have this problem of

2344
00:46:56,670 --> 00:46:56,680
 

2345
00:46:56,680 --> 00:46:58,769
things thrashing because the buffle

2346
00:46:58,769 --> 00:46:58,779
 

2347
00:46:58,779 --> 00:47:00,450
manager is removing things that we

2348
00:47:00,450 --> 00:47:00,460
 

2349
00:47:00,460 --> 00:47:04,289
actually need so the out of them we're

2350
00:47:04,289 --> 00:47:04,299
 

2351
00:47:04,299 --> 00:47:07,710
gonna use to handle hash joins that are

2352
00:47:07,710 --> 00:47:07,720
 

2353
00:47:07,720 --> 00:47:08,549
large in the matter memory that's

2354
00:47:08,549 --> 00:47:08,559
 

2355
00:47:08,559 --> 00:47:09,990
available to us is called the grace hash

2356
00:47:09,990 --> 00:47:10,000
 

2357
00:47:10,000 --> 00:47:13,349
join so it's called grace hash join

2358
00:47:13,349 --> 00:47:13,359
 

2359
00:47:13,359 --> 00:47:16,109
because there was a project in the 1980s

2360
00:47:16,109 --> 00:47:16,119
 

2361
00:47:16,119 --> 00:47:19,289
at the University of Tokyo for a

2362
00:47:19,289 --> 00:47:19,299
 

2363
00:47:19,299 --> 00:47:21,980
database database machine called grace

2364
00:47:21,980 --> 00:47:21,990
 

2365
00:47:21,990 --> 00:47:25,650
and in the the system doesn't exist

2366
00:47:25,650 --> 00:47:25,660
 

2367
00:47:25,660 --> 00:47:27,180
anymore and never got commercialized

2368
00:47:27,180 --> 00:47:27,190
 

2369
00:47:27,190 --> 00:47:29,519
but the they have a paper at the time

2370
00:47:29,519 --> 00:47:29,529
 

2371
00:47:29,529 --> 00:47:31,859
that describes how to do the hash join

2372
00:47:31,859 --> 00:47:31,869
 

2373
00:47:31,869 --> 00:47:33,779
I'm going to show you and then for

2374
00:47:33,779 --> 00:47:33,789
 

2375
00:47:33,789 --> 00:47:35,579
struggle purposes everyone just calls it

2376
00:47:35,579 --> 00:47:35,589
 

2377
00:47:35,589 --> 00:47:39,510
the grace hashed one so the basic idea

2378
00:47:39,510 --> 00:47:39,520
 

2379
00:47:39,520 --> 00:47:42,470
is a lot similar to what we saw in the

2380
00:47:42,470 --> 00:47:42,480
 

2381
00:47:42,480 --> 00:47:44,760
external merge sort we're going to break

2382
00:47:44,760 --> 00:47:44,770
 

2383
00:47:44,770 --> 00:47:48,839
up the in the problem to smaller chunks

2384
00:47:48,839 --> 00:47:48,849
 

2385
00:47:48,849 --> 00:47:51,690
that can fit in memory and then we can

2386
00:47:51,690 --> 00:47:51,700
 

2387
00:47:51,700 --> 00:47:53,430
do the join on those the chunks that fit

2388
00:47:53,430 --> 00:47:53,440
 

2389
00:47:53,440 --> 00:47:55,140
memory and not worry about fetching

2390
00:47:55,140 --> 00:47:55,150
 

2391
00:47:55,150 --> 00:47:57,170
other pages that will never ever match

2392
00:47:57,170 --> 00:47:57,180
 

2393
00:47:57,180 --> 00:47:59,880
so the basic idea is that instead of

2394
00:47:59,880 --> 00:47:59,890
 

2395
00:47:59,890 --> 00:48:01,650
just building a hash table for one sided

2396
00:48:01,650 --> 00:48:01,660
 

2397
00:48:01,660 --> 00:48:03,870
we're actually gonna hash the other side

2398
00:48:03,870 --> 00:48:03,880
 

2399
00:48:03,880 --> 00:48:06,000
as well and put things in partitions or

2400
00:48:06,000 --> 00:48:06,010
 

2401
00:48:06,010 --> 00:48:07,859
buckets and then come back and build

2402
00:48:07,859 --> 00:48:07,869
 

2403
00:48:07,869 --> 00:48:09,390
hash tables on just what's in those

2404
00:48:09,390 --> 00:48:09,400

2405
00:48:09,400 --> 00:48:13,260
buckets so again as I said this is the

2406
00:48:13,260 --> 00:48:13,270
 

2407
00:48:13,270 --> 00:48:15,180
picture of from the website I think it's

2408
00:48:15,180 --> 00:48:15,190
 

2409
00:48:15,190 --> 00:48:16,620
the only picture I could find online of

2410
00:48:16,620 --> 00:48:16,630
 

2411
00:48:16,630 --> 00:48:19,740
the the grace database machine who here

2412
00:48:19,740 --> 00:48:19,750
 

2413
00:48:19,750 --> 00:48:20,549
has actually ever heard of the term

2414
00:48:20,549 --> 00:48:20,559
 

2415
00:48:20,559 --> 00:48:24,690
database machine before nobody who here

2416
00:48:24,690 --> 00:48:24,700
 

2417
00:48:24,700 --> 00:48:25,589
has ever heard the term database

2418
00:48:25,589 --> 00:48:25,599
 

2419
00:48:25,599 --> 00:48:31,890
appliance nobody okay so the way to

2420
00:48:31,890 --> 00:48:31,900
 

2421
00:48:31,900 --> 00:48:33,420
think about this is a database appliance

2422
00:48:33,420 --> 00:48:33,430
 

2423
00:48:33,430 --> 00:48:35,519
it's like instead of the you know is say

2424
00:48:35,519 --> 00:48:35,529
 

2425
00:48:35,529 --> 00:48:38,059
I want to set up my sequel or Postgres

2426
00:48:38,059 --> 00:48:38,069
 

2427
00:48:38,069 --> 00:48:40,230
what I could do is I could go buy a

2428
00:48:40,230 --> 00:48:40,240
 

2429
00:48:40,240 --> 00:48:43,380
machine from supermicro or Dell or EMC

2430
00:48:43,380 --> 00:48:43,390
 

2431
00:48:43,390 --> 00:48:46,109
you know set it up load the operating

2432
00:48:46,109 --> 00:48:46,119
 

2433
00:48:46,119 --> 00:48:47,730
system then download the David system

2434
00:48:47,730 --> 00:48:47,740
 

2435
00:48:47,740 --> 00:48:49,049
software install the David system and

2436
00:48:49,049 --> 00:48:49,059

2437
00:48:49,059 --> 00:48:50,579
sort of set it up myself right that's

2438
00:48:50,579 --> 00:48:50,589
 

2439
00:48:50,589 --> 00:48:52,529
what most people do a database appliance

2440
00:48:52,529 --> 00:48:52,539
 

2441
00:48:52,539 --> 00:48:54,900
would be you'd buy a machine already

2442
00:48:54,900 --> 00:48:54,910
 

2443
00:48:54,910 --> 00:48:57,450
pre-configured and tuned for your

2444
00:48:57,450 --> 00:48:57,460
 

2445
00:48:57,460 --> 00:48:59,579
database you know for whatever Davises

2446
00:48:59,579 --> 00:48:59,589
 

2447
00:48:59,589 --> 00:49:00,839
you want to run

2448
00:49:00,839 --> 00:49:00,849

2449
00:49:00,849 --> 00:49:03,210
and it sort of you know it's sort of

2450
00:49:03,210 --> 00:49:03,220
 

2451
00:49:03,220 --> 00:49:05,880
yeah it's been set up for the exact

2452
00:49:05,880 --> 00:49:05,890
 

2453
00:49:05,890 --> 00:49:07,710
harbor that you're running it on and so

2454
00:49:07,710 --> 00:49:07,720
 

2455
00:49:07,720 --> 00:49:08,849
that way you don't worry about how to

2456
00:49:08,849 --> 00:49:08,859
 

2457
00:49:08,859 --> 00:49:10,319
set up how much but purported memory to

2458
00:49:10,319 --> 00:49:10,329
 

2459
00:49:10,329 --> 00:49:12,029
use or how much to tune it for the OS

2460
00:49:12,029 --> 00:49:12,039
 

2461
00:49:12,039 --> 00:49:13,829
and other things all that's done it's

2462
00:49:13,829 --> 00:49:13,839
 

2463
00:49:13,839 --> 00:49:16,799
sort of like a like a battery batteries

2464
00:49:16,799 --> 00:49:16,809
 

2465
00:49:16,809 --> 00:49:18,390
included database system where that

2466
00:49:18,390 --> 00:49:18,400
 

2467
00:49:18,400 --> 00:49:21,599
comes on its own hardware alright so a

2468
00:49:21,599 --> 00:49:21,609
 

2469
00:49:21,609 --> 00:49:23,309
database machine was this this sort of

2470
00:49:23,309 --> 00:49:23,319
 

2471
00:49:23,319 --> 00:49:26,249
movement in the 1980s where people would

2472
00:49:26,249 --> 00:49:26,259
 

2473
00:49:26,259 --> 00:49:27,749
sort of build like an appliance where

2474
00:49:27,749 --> 00:49:27,759
 

2475
00:49:27,759 --> 00:49:29,539
it's sort of like I was a pre-configured

2476
00:49:29,539 --> 00:49:29,549
 

2477
00:49:29,549 --> 00:49:32,190
you know one rack unit that would have

2478
00:49:32,190 --> 00:49:32,200
 

2479
00:49:32,200 --> 00:49:34,109
Davis isn't pre-installed but they went

2480
00:49:34,109 --> 00:49:34,119
 

2481
00:49:34,119 --> 00:49:35,370
a bit farther and they actually had

2482
00:49:35,370 --> 00:49:35,380
 

2483
00:49:35,380 --> 00:49:38,039
specialized Hardware on it not FPGA GPUs

2484
00:49:38,039 --> 00:49:38,049
 

2485
00:49:38,049 --> 00:49:40,920
there's no custom hardware that was that

2486
00:49:40,920 --> 00:49:40,930

2487
00:49:40,930 --> 00:49:42,589
the data system could take advantage of

2488
00:49:42,589 --> 00:49:42,599
 

2489
00:49:42,599 --> 00:49:44,759
right and this was thought at the time

2490
00:49:44,759 --> 00:49:44,769
 

2491
00:49:44,769 --> 00:49:46,650
early 1980s but this was the future of

2492
00:49:46,650 --> 00:49:46,660
 

2493
00:49:46,660 --> 00:49:47,940
databases that everyone's gonna have is

2494
00:49:47,940 --> 00:49:47,950
 

2495
00:49:47,950 --> 00:49:50,039
these these custom hardware thing

2496
00:49:50,039 --> 00:49:50,049
 

2497
00:49:50,049 --> 00:49:52,410
machines that the day says we could

2498
00:49:52,410 --> 00:49:52,420
 

2499
00:49:52,420 --> 00:49:53,640
exploit and get much better performance

2500
00:49:53,640 --> 00:49:53,650
 

2501
00:49:53,650 --> 00:49:55,799
and he could on commodity hardware all

2502
00:49:55,799 --> 00:49:55,809
 

2503
00:49:55,809 --> 00:49:57,950
right of course that didn't pan out

2504
00:49:57,950 --> 00:49:57,960
 

2505
00:49:57,960 --> 00:50:01,769
right because with Moore's law always

2506
00:50:01,769 --> 00:50:01,779
 

2507
00:50:01,779 --> 00:50:02,910
getting better and better especially in

2508
00:50:02,910 --> 00:50:02,920
 

2509
00:50:02,920 --> 00:50:05,279
the 1980s less so now the whatever

2510
00:50:05,279 --> 00:50:05,289
 

2511
00:50:05,289 --> 00:50:06,719
advantage you had by the time you

2512
00:50:06,719 --> 00:50:06,729
 

2513
00:50:06,729 --> 00:50:08,489
manufactured a database machine that had

2514
00:50:08,489 --> 00:50:08,499
 

2515
00:50:08,499 --> 00:50:09,719
specialized hardware to do whatever you

2516
00:50:09,719 --> 00:50:09,729

2517
00:50:09,729 --> 00:50:11,729
wanted to do so for example a lot of

2518
00:50:11,729 --> 00:50:11,739
 

2519
00:50:11,739 --> 00:50:13,319
these systems has specialized hardware

2520
00:50:13,319 --> 00:50:13,329
 

2521
00:50:13,329 --> 00:50:15,630
they do hash joins by the time you

2522
00:50:15,630 --> 00:50:15,640
 

2523
00:50:15,640 --> 00:50:17,729
actually got that in production you know

2524
00:50:17,729 --> 00:50:17,739
 

2525
00:50:17,739 --> 00:50:20,809
Intel came out with a better chip that

2526
00:50:20,809 --> 00:50:20,819

2527
00:50:20,819 --> 00:50:23,190
could you know outperform whatever you

2528
00:50:23,190 --> 00:50:23,200
 

2529
00:50:23,200 --> 00:50:25,769
could act you were doing before I say

2530
00:50:25,769 --> 00:50:25,779
 

2531
00:50:25,779 --> 00:50:28,109
these things never really took off least

2532
00:50:28,109 --> 00:50:28,119
 

2533
00:50:28,119 --> 00:50:29,759
a customized Hardware database

2534
00:50:29,759 --> 00:50:29,769
 

2535
00:50:29,769 --> 00:50:31,410
appliances still exist as a bunch of

2536
00:50:31,410 --> 00:50:31,420
 

2537
00:50:31,420 --> 00:50:33,749
different examples here of different

2538
00:50:33,749 --> 00:50:33,759
 

2539
00:50:33,759 --> 00:50:35,609
manufacturers that sell stuff so the

2540
00:50:35,609 --> 00:50:35,619
 

2541
00:50:35,619 --> 00:50:37,799
first one is IBM selling you you know

2542
00:50:37,799 --> 00:50:37,809
 

2543
00:50:37,809 --> 00:50:40,859
z/os machine to run db2 there was a

2544
00:50:40,859 --> 00:50:40,869
 

2545
00:50:40,869 --> 00:50:42,479
startup out of San Francisco called

2546
00:50:42,479 --> 00:50:42,489
 

2547
00:50:42,489 --> 00:50:44,430
cluster it's selling an appliance of a

2548
00:50:44,430 --> 00:50:44,440
 

2549
00:50:44,440 --> 00:50:46,829
tune my sequel or my sequel like

2550
00:50:46,829 --> 00:50:46,839
 

2551
00:50:46,839 --> 00:50:48,690
database system and of course Oracle is

2552
00:50:48,690 --> 00:50:48,700
 

2553
00:50:48,700 --> 00:50:50,459
probably most famous one they'll sell

2554
00:50:50,459 --> 00:50:50,469
 

2555
00:50:50,469 --> 00:50:52,349
you lots of hardware that's that comes

2556
00:50:52,349 --> 00:50:52,359
 

2557
00:50:52,359 --> 00:50:53,910
with a system already pre-configured and

2558
00:50:53,910 --> 00:50:53,920
 

2559
00:50:53,920 --> 00:50:56,309
running on it like Exadata is you know

2560
00:50:56,309 --> 00:50:56,319
 

2561
00:50:56,319 --> 00:50:58,920
hundreds there's accident bring them a

2562
00:50:58,920 --> 00:50:58,930
 

2563
00:50:58,930 --> 00:51:00,839
lot of money basically selling these

2564
00:51:00,839 --> 00:51:00,849
 

2565
00:51:00,849 --> 00:51:03,779
these appliances so again grace was not

2566
00:51:03,779 --> 00:51:03,789
 

2567
00:51:03,789 --> 00:51:05,579
an appliance it was it was the day

2568
00:51:05,579 --> 00:51:05,589
 

2569
00:51:05,589 --> 00:51:06,719
today's machine which is an appliance

2570
00:51:06,719 --> 00:51:06,729
 

2571
00:51:06,729 --> 00:51:09,809
plus extra stuff of course I mean nobody

2572
00:51:09,809 --> 00:51:09,819
 

2573
00:51:09,819 --> 00:51:11,640
nobody still uses this but everyone

2574
00:51:11,640 --> 00:51:11,650
 

2575
00:51:11,650 --> 00:51:13,739
still uses the grace hash join so that's

2576
00:51:13,739 --> 00:51:13,749
 

2577
00:51:13,749 --> 00:51:15,240
we're going to cover

2578
00:51:15,240 --> 00:51:15,250
 

2579
00:51:15,250 --> 00:51:17,860
so I don't know what the textbook calls

2580
00:51:17,860 --> 00:51:17,870
 

2581
00:51:17,870 --> 00:51:19,210
this it might call this grace hash

2582
00:51:19,210 --> 00:51:19,220
 

2583
00:51:19,220 --> 00:51:20,590
strong and I call it like partition hash

2584
00:51:20,590 --> 00:51:20,600

2585
00:51:20,600 --> 00:51:22,780
one basic idea is the same

2586
00:51:22,780 --> 00:51:22,790
 

2587
00:51:22,790 --> 00:51:24,550
I think Wikipedia might call its grace

2588
00:51:24,550 --> 00:51:24,560

2589
00:51:24,560 --> 00:51:27,970
hash run all right so as he said on the

2590
00:51:27,970 --> 00:51:27,980
 

2591
00:51:27,980 --> 00:51:30,520
regular hash join we would just scan the

2592
00:51:30,520 --> 00:51:30,530
 

2593
00:51:30,530 --> 00:51:32,680
outer table builder hash table and then

2594
00:51:32,680 --> 00:51:32,690
 

2595
00:51:32,690 --> 00:51:33,730
have the inner table to do a special

2596
00:51:33,730 --> 00:51:33,740
 

2597
00:51:33,740 --> 00:51:35,530
scan and just probe inside of that but

2598
00:51:35,530 --> 00:51:35,540
 

2599
00:51:35,540 --> 00:51:36,520
here we're trying to do is we're gonna

2600
00:51:36,520 --> 00:51:36,530
 

2601
00:51:36,530 --> 00:51:39,580
try to divide up the the outer it's out

2602
00:51:39,580 --> 00:51:39,590
 

2603
00:51:39,590 --> 00:51:42,520
on inner tables into buckets that can

2604
00:51:42,520 --> 00:51:42,530
 

2605
00:51:42,530 --> 00:51:45,730
fit into memory and then we'll build

2606
00:51:45,730 --> 00:51:45,740
 

2607
00:51:45,740 --> 00:51:48,300
hash tables on just those buckets just

2608
00:51:48,300 --> 00:51:48,310
 

2609
00:51:48,310 --> 00:51:51,760
build a hash table on the bucket all

2610
00:51:51,760 --> 00:51:51,770
 

2611
00:51:51,770 --> 00:51:54,070
right so we do a special scan on the

2612
00:51:54,070 --> 00:51:54,080
 

2613
00:51:54,080 --> 00:51:56,290
outer table again we're not building a

2614
00:51:56,290 --> 00:51:56,300
 

2615
00:51:56,300 --> 00:51:59,380
hash table actually least not pH to you

2616
00:51:59,380 --> 00:51:59,390
 

2617
00:51:59,390 --> 00:52:03,180
this should be buckets so we're gonna

2618
00:52:03,180 --> 00:52:03,190
 

2619
00:52:03,190 --> 00:52:05,350
nice the same thing right so it's a hash

2620
00:52:05,350 --> 00:52:05,360

2621
00:52:05,360 --> 00:52:06,910
table we're doing we're gonna build

2622
00:52:06,910 --> 00:52:06,920
 

2623
00:52:06,920 --> 00:52:09,310
buckets same thing on the other side and

2624
00:52:09,310 --> 00:52:09,320
 

2625
00:52:09,320 --> 00:52:11,320
then these things can now get swapped

2626
00:52:11,320 --> 00:52:11,330
 

2627
00:52:11,330 --> 00:52:12,550
out to disk but the way to think about

2628
00:52:12,550 --> 00:52:12,560
 

2629
00:52:12,560 --> 00:52:13,780
this is because again we're using the

2630
00:52:13,780 --> 00:52:13,790
 

2631
00:52:13,790 --> 00:52:16,330
same hash function on both sides we know

2632
00:52:16,330 --> 00:52:16,340
 

2633
00:52:16,340 --> 00:52:19,120
that it sort of at every level there

2634
00:52:19,120 --> 00:52:19,130
 

2635
00:52:19,130 --> 00:52:21,880
will be tuples that will match so

2636
00:52:21,880 --> 00:52:21,890
 

2637
00:52:21,890 --> 00:52:24,460
because you know in hash function one we

2638
00:52:24,460 --> 00:52:24,470

2639
00:52:24,470 --> 00:52:26,860
use puts things in this level here any

2640
00:52:26,860 --> 00:52:26,870
 

2641
00:52:26,870 --> 00:52:28,960
tuples over here with the same value

2642
00:52:28,960 --> 00:52:28,970
 

2643
00:52:28,970 --> 00:52:31,780
will end up in this level as well now

2644
00:52:31,780 --> 00:52:31,790
 

2645
00:52:31,790 --> 00:52:33,100
we'll have collisions therefore we'll

2646
00:52:33,100 --> 00:52:33,110
 

2647
00:52:33,110 --> 00:52:34,720
have keys that hash to the same bucket

2648
00:52:34,720 --> 00:52:34,730
 

2649
00:52:34,730 --> 00:52:37,780
but that's okay the main idea here is

2650
00:52:37,780 --> 00:52:37,790
 

2651
00:52:37,790 --> 00:52:40,510
that at a one level going across we know

2652
00:52:40,510 --> 00:52:40,520
 

2653
00:52:40,520 --> 00:52:41,980
that there's nothing in these other ones

2654
00:52:41,980 --> 00:52:41,990
 

2655
00:52:41,990 --> 00:52:43,720
that we had to examine to look for a

2656
00:52:43,720 --> 00:52:43,730
 

2657
00:52:43,730 --> 00:52:46,390
joint we sort of put everybody in this

2658
00:52:46,390 --> 00:52:46,400
 

2659
00:52:46,400 --> 00:52:50,440
in the same location the same level so

2660
00:52:50,440 --> 00:52:50,450
 

2661
00:52:50,450 --> 00:52:54,220
now what we do is now we do a just a

2662
00:52:54,220 --> 00:52:54,230
 

2663
00:52:54,230 --> 00:52:56,890
simple nested for loop over just the

2664
00:52:56,890 --> 00:52:56,900
 

2665
00:52:56,900 --> 00:52:59,290
buckets themselves right we said the hat

2666
00:52:59,290 --> 00:52:59,300
 

2667
00:52:59,300 --> 00:53:00,730
the nested loop joined was okay when

2668
00:53:00,730 --> 00:53:00,740
 

2669
00:53:00,740 --> 00:53:02,650
everything fit in memory so because

2670
00:53:02,650 --> 00:53:02,660
 

2671
00:53:02,660 --> 00:53:04,420
these buckets will put in memory then we

2672
00:53:04,420 --> 00:53:04,430
 

2673
00:53:04,430 --> 00:53:06,790
just iterate over to each of them and

2674
00:53:06,790 --> 00:53:06,800
 

2675
00:53:06,800 --> 00:53:09,720
check to see whether we have a match

2676
00:53:09,720 --> 00:53:09,730
 

2677
00:53:09,730 --> 00:53:14,500
right yes

2678
00:53:14,500 --> 00:53:14,510


2679
00:53:14,510 --> 00:53:17,080
he's question is is this just reducing

2680
00:53:17,080 --> 00:53:17,090
 

2681
00:53:17,090 --> 00:53:19,930
the range of the hash function yes in

2682
00:53:19,930 --> 00:53:19,940
 

2683
00:53:19,940 --> 00:53:28,120
some ways yes right yes yes sir in the

2684
00:53:28,120 --> 00:53:28,130
 

2685
00:53:28,130 --> 00:53:30,940
regular hash joint without without this

2686
00:53:30,940 --> 00:53:30,950
 

2687
00:53:30,950 --> 00:53:34,810
this step you Hashem to you no location

2688
00:53:34,810 --> 00:53:34,820
 

2689
00:53:34,820 --> 00:53:36,370
and then if you have a lot of collisions

2690
00:53:36,370 --> 00:53:36,380
 

2691
00:53:36,380 --> 00:53:37,450
you're essentially gonna be doing the

2692
00:53:37,450 --> 00:53:37,460
 

2693
00:53:37,460 --> 00:53:40,090
same central scan you know whether it's

2694
00:53:40,090 --> 00:53:40,100
 

2695
00:53:40,100 --> 00:53:42,070
a linear probing or the chain hash table

2696
00:53:42,070 --> 00:53:42,080

2697
00:53:42,080 --> 00:53:43,480
you're just doing spectral scan to see

2698
00:53:43,480 --> 00:53:43,490
 

2699
00:53:43,490 --> 00:53:45,910
whether you have a match it's so this is

2700
00:53:45,910 --> 00:53:45,920
 

2701
00:53:45,920 --> 00:53:46,900
actually do the same thing we're just

2702
00:53:46,900 --> 00:53:46,910

2703
00:53:46,910 --> 00:53:48,940
hashing both sides it's like a almost

2704
00:53:48,940 --> 00:53:48,950
 

2705
00:53:48,950 --> 00:53:50,020
like a divide and conquer kind of

2706
00:53:50,020 --> 00:53:50,030
 

2707
00:53:50,030 --> 00:53:52,330
approach hey and let's talk about

2708
00:53:52,330 --> 00:53:52,340
 

2709
00:53:52,340 --> 00:53:54,400
parallelization later on but you can

2710
00:53:54,400 --> 00:53:54,410
 

2711
00:53:54,410 --> 00:53:56,290
pair easily a paralyzes you can have one

2712
00:53:56,290 --> 00:53:56,300
 

2713
00:53:56,300 --> 00:53:59,470
thread do the join across each level and

2714
00:53:59,470 --> 00:53:59,480
 

2715
00:53:59,480 --> 00:54:01,330
again the main ideas here is that at

2716
00:54:01,330 --> 00:54:01,340
 

2717
00:54:01,340 --> 00:54:02,920
this level here there's nothing in these

2718
00:54:02,920 --> 00:54:02,930
 

2719
00:54:02,930 --> 00:54:04,060
other levels we'd have to care about

2720
00:54:04,060 --> 00:54:04,070
 

2721
00:54:04,070 --> 00:54:05,290
because the hash function always put us

2722
00:54:05,290 --> 00:54:05,300
 

2723
00:54:05,300 --> 00:54:11,230
in the right location all right so

2724
00:54:11,230 --> 00:54:11,240
 

2725
00:54:11,240 --> 00:54:12,490
what's potential ones potential problem

2726
00:54:12,490 --> 00:54:12,500
 

2727
00:54:12,500 --> 00:54:14,650
with this so this is work this works

2728
00:54:14,650 --> 00:54:14,660
 

2729
00:54:14,660 --> 00:54:18,490
great we say that now if our hash table

2730
00:54:18,490 --> 00:54:18,500
 

2731
00:54:18,500 --> 00:54:21,070
doesn't fit memory we just do these

2732
00:54:21,070 --> 00:54:21,080
 

2733
00:54:21,080 --> 00:54:22,780
buckets potentially swap these out the

2734
00:54:22,780 --> 00:54:22,790
 

2735
00:54:22,790 --> 00:54:24,880
disk and then we bring in the buckets

2736
00:54:24,880 --> 00:54:24,890
 

2737
00:54:24,890 --> 00:54:27,760
for each level one by one and and do our

2738
00:54:27,760 --> 00:54:27,770
 

2739
00:54:27,770 --> 00:54:29,950
four loops but what's the problem with

2740
00:54:29,950 --> 00:54:29,960
 

2741
00:54:29,960 --> 00:54:35,320
this potentially exactly what are the

2742
00:54:35,320 --> 00:54:35,330
 

2743
00:54:35,330 --> 00:54:37,750
buckets don't fit memory right so the

2744
00:54:37,750 --> 00:54:37,760
 

2745
00:54:37,760 --> 00:54:39,340
buckets don't fit memory then you have

2746
00:54:39,340 --> 00:54:39,350
 

2747
00:54:39,350 --> 00:54:41,770
to you have to maybe split them up a

2748
00:54:41,770 --> 00:54:41,780
 

2749
00:54:41,780 --> 00:54:43,930
more so this is called recursive

2750
00:54:43,930 --> 00:54:43,940

2751
00:54:43,940 --> 00:54:45,460
partitioning the idea is that again

2752
00:54:45,460 --> 00:54:45,470
 

2753
00:54:45,470 --> 00:54:47,620
we're just gonna keep partitioning over

2754
00:54:47,620 --> 00:54:47,630
 

2755
00:54:47,630 --> 00:54:49,660
and over again our buckets are smaller

2756
00:54:49,660 --> 00:54:49,670
 

2757
00:54:49,670 --> 00:54:51,610
smaller chunks till we get something

2758
00:54:51,610 --> 00:54:51,620
 

2759
00:54:51,620 --> 00:54:53,520
about fit memory and then we can do our

2760
00:54:53,520 --> 00:54:53,530
 

2761
00:54:53,530 --> 00:54:57,520
simple nested for loop joint so basic

2762
00:54:57,520 --> 00:54:57,530

2763
00:54:57,530 --> 00:54:59,980
idea here is that if we recognize that

2764
00:54:59,980 --> 00:54:59,990
 

2765
00:54:59,990 --> 00:55:02,410
one of our buckets is going to overflow

2766
00:55:02,410 --> 00:55:02,420
 

2767
00:55:02,420 --> 00:55:05,830
or get too big then we'll apply another

2768
00:55:05,830 --> 00:55:05,840
 

2769
00:55:05,840 --> 00:55:07,930
hash function on it that's not the same

2770
00:55:07,930 --> 00:55:07,940
 

2771
00:55:07,940 --> 00:55:09,580
as our first hash function and again

2772
00:55:09,580 --> 00:55:09,590
 

2773
00:55:09,590 --> 00:55:10,990
when I say different hash function it's

2774
00:55:10,990 --> 00:55:11,000
 

2775
00:55:11,000 --> 00:55:13,570
it's if we use murmur hash for the first

2776
00:55:13,570 --> 00:55:13,580
 

2777
00:55:13,580 --> 00:55:14,650
hash function it will use murmur hash

2778
00:55:14,650 --> 00:55:14,660
 

2779
00:55:14,660 --> 00:55:17,350
again for the second hash function what

2780
00:55:17,350 --> 00:55:17,360
 

2781
00:55:17,360 --> 00:55:18,700
is providing it with a different salt

2782
00:55:18,700 --> 00:55:18,710
 

2783
00:55:18,710 --> 00:55:21,010
key right so that it produces a

2784
00:55:21,010 --> 00:55:21,020
 

2785
00:55:21,020 --> 00:55:23,260
different distribution of hash hash keys

2786
00:55:23,260 --> 00:55:23,270
 

2787
00:55:23,270 --> 00:55:27,390
for the same values right so we're

2788
00:55:27,390 --> 00:55:27,400

2789
00:55:27,400 --> 00:55:29,130
take out bucket using another hash

2790
00:55:29,130 --> 00:55:29,140
 

2791
00:55:29,140 --> 00:55:32,160
function hash it all again and then

2792
00:55:32,160 --> 00:55:32,170
 

2793
00:55:32,170 --> 00:55:34,620
spill those out the desk and then now

2794
00:55:34,620 --> 00:55:34,630
 

2795
00:55:34,630 --> 00:55:37,799
when we come back and do our join we

2796
00:55:37,799 --> 00:55:37,809
 

2797
00:55:37,809 --> 00:55:39,660
just have to recognize that whether we

2798
00:55:39,660 --> 00:55:39,670
 

2799
00:55:39,670 --> 00:55:42,359
what level or how deep do we do our

2800
00:55:42,359 --> 00:55:42,369
 

2801
00:55:42,369 --> 00:55:44,130
recursive partitioning to determine what

2802
00:55:44,130 --> 00:55:44,140
 

2803
00:55:44,140 --> 00:55:45,329
hash function we should be you should be

2804
00:55:45,329 --> 00:55:45,339
 

2805
00:55:45,339 --> 00:55:49,500
using to find the matching tuple so

2806
00:55:49,500 --> 00:55:49,510
 

2807
00:55:49,510 --> 00:55:51,299
going back to our example here so again

2808
00:55:51,299 --> 00:55:51,309
 

2809
00:55:51,309 --> 00:55:54,599
say that we building on the outer table

2810
00:55:54,599 --> 00:55:54,609

2811
00:55:54,609 --> 00:55:57,750
we first do hashing we still rehash

2812
00:55:57,750 --> 00:55:57,760
 

2813
00:55:57,760 --> 00:55:58,890
everything the buckets in the first hash

2814
00:55:58,890 --> 00:55:58,900
 

2815
00:55:58,900 --> 00:56:01,079
table and we see that this air inter

2816
00:56:01,079 --> 00:56:01,089
 

2817
00:56:01,089 --> 00:56:03,539
bucket here at level one it's it's

2818
00:56:03,539 --> 00:56:03,549
 

2819
00:56:03,549 --> 00:56:06,120
overflowing so we're gonna go ahead and

2820
00:56:06,120 --> 00:56:06,130
 

2821
00:56:06,130 --> 00:56:08,010
hash it again with another hash function

2822
00:56:08,010 --> 00:56:08,020
 

2823
00:56:08,020 --> 00:56:11,819
to split it out even further right and

2824
00:56:11,819 --> 00:56:11,829
 

2825
00:56:11,829 --> 00:56:14,789
so the way to now think about in terms

2826
00:56:14,789 --> 00:56:14,799
 

2827
00:56:14,799 --> 00:56:17,670
of levels the the first and the last one

2828
00:56:17,670 --> 00:56:17,680
 

2829
00:56:17,680 --> 00:56:19,380
are still at the level they were

2830
00:56:19,380 --> 00:56:19,390

2831
00:56:19,390 --> 00:56:21,660
assigned with when they started but the

2832
00:56:21,660 --> 00:56:21,670
 

2833
00:56:21,670 --> 00:56:24,240
inner one here it's now you know 1 Prime

2834
00:56:24,240 --> 00:56:24,250
 

2835
00:56:24,250 --> 00:56:26,640
1 double prime 1 triple prime just to

2836
00:56:26,640 --> 00:56:26,650
 

2837
00:56:26,650 --> 00:56:29,549
saying that it began at level 1 but then

2838
00:56:29,549 --> 00:56:29,559
 

2839
00:56:29,559 --> 00:56:30,950
we applied a second hash function

2840
00:56:30,950 --> 00:56:30,960
 

2841
00:56:30,960 --> 00:56:33,559
announcements fill up even further

2842
00:56:33,559 --> 00:56:33,569
 

2843
00:56:33,569 --> 00:56:35,579
of course now again you may be thinking

2844
00:56:35,579 --> 00:56:35,589
 

2845
00:56:35,589 --> 00:56:38,910
or what happens if that if I have a

2846
00:56:38,910 --> 00:56:38,920
 

2847
00:56:38,920 --> 00:56:40,230
second hash function or all the

2848
00:56:40,230 --> 00:56:40,240

2849
00:56:40,240 --> 00:56:41,519
batteries that here are the same and

2850
00:56:41,519 --> 00:56:41,529
 

2851
00:56:41,529 --> 00:56:42,420
everything's gonna hash to the same

2852
00:56:42,420 --> 00:56:42,430
 

2853
00:56:42,430 --> 00:56:45,029
thing anyway so can I just you know

2854
00:56:45,029 --> 00:56:45,039
 

2855
00:56:45,039 --> 00:56:47,339
would I be stuck an infinite loop again

2856
00:56:47,339 --> 00:56:47,349
 

2857
00:56:47,349 --> 00:56:48,839
in that case there's nothing you can do

2858
00:56:48,839 --> 00:56:48,849
 

2859
00:56:48,849 --> 00:56:51,359
right so you just have to bite you know

2860
00:56:51,359 --> 00:56:51,369
 

2861
00:56:51,369 --> 00:56:53,390
bike the cost of just doing special scan

2862
00:56:53,390 --> 00:56:53,400
 

2863
00:56:53,400 --> 00:56:56,460
or start doing it you know the block

2864
00:56:56,460 --> 00:56:56,470
 

2865
00:56:56,470 --> 00:56:59,039
nests of loop join to fetch in the pages

2866
00:56:59,039 --> 00:56:59,049
 

2867
00:56:59,049 --> 00:57:01,380
one by one right just for this this one

2868
00:57:01,380 --> 00:57:01,390
 

2869
00:57:01,390 --> 00:57:03,569
level I mean data systems would

2870
00:57:03,569 --> 00:57:03,579
 

2871
00:57:03,579 --> 00:57:05,010
recognize this that if I hash him this

2872
00:57:05,010 --> 00:57:05,020
 

2873
00:57:05,020 --> 00:57:07,740
again everybody's the same so I breaking

2874
00:57:07,740 --> 00:57:07,750
 

2875
00:57:07,750 --> 00:57:09,470
this up even further doesn't help me

2876
00:57:09,470 --> 00:57:09,480
 

2877
00:57:09,480 --> 00:57:12,990
alright so now on the inner table then

2878
00:57:12,990 --> 00:57:13,000
 

2879
00:57:13,000 --> 00:57:14,400
we start off taking the first hash

2880
00:57:14,400 --> 00:57:14,410
 

2881
00:57:14,410 --> 00:57:17,630
function we split everything up into

2882
00:57:17,630 --> 00:57:17,640
 

2883
00:57:17,640 --> 00:57:21,990
into chunks like this right against for

2884
00:57:21,990 --> 00:57:22,000
 

2885
00:57:22,000 --> 00:57:23,609
the outer one and that the top one in

2886
00:57:23,609 --> 00:57:23,619
 

2887
00:57:23,619 --> 00:57:25,920
the bottom one we know that on the other

2888
00:57:25,920 --> 00:57:25,930
 

2889
00:57:25,930 --> 00:57:28,529
side they just got mapped to the same

2890
00:57:28,529 --> 00:57:28,539
 

2891
00:57:28,539 --> 00:57:31,500
location with the same hash function but

2892
00:57:31,500 --> 00:57:31,510
 

2893
00:57:31,510 --> 00:57:33,150
if we have anything that goes to level

2894
00:57:33,150 --> 00:57:33,160
 

2895
00:57:33,160 --> 00:57:35,700
one then we know that we need to split

2896
00:57:35,700 --> 00:57:35,710
 

2897
00:57:35,710 --> 00:57:37,230
this again with the second hash function

2898
00:57:37,230 --> 00:57:37,240
 

2899
00:57:37,240 --> 00:57:39,710
and and write it out like that

2900
00:57:39,710 --> 00:57:39,720
 

2901
00:57:39,720 --> 00:57:40,970
all right so then now when we do our

2902
00:57:40,970 --> 00:57:40,980
 

2903
00:57:40,980 --> 00:57:43,430
comparison right we're only comparing

2904
00:57:43,430 --> 00:57:43,440
 

2905
00:57:43,440 --> 00:57:47,630
across the same level here right this

2906
00:57:47,630 --> 00:57:47,640
 

2907
00:57:47,640 --> 00:57:49,040
sort of like the extendable hash table

2908
00:57:49,040 --> 00:57:49,050
 

2909
00:57:49,050 --> 00:57:50,720
or linear hash table we kept track of

2910
00:57:50,720 --> 00:57:50,730
 

2911
00:57:50,730 --> 00:57:51,890
what hash function we should use

2912
00:57:51,890 --> 00:57:51,900
 

2913
00:57:51,900 --> 00:57:53,329
depending on you know where the split

2914
00:57:53,329 --> 00:57:53,339
 

2915
00:57:53,339 --> 00:57:57,980
pointer was or how deep the the the the

2916
00:57:57,980 --> 00:57:57,990

2917
00:57:57,990 --> 00:58:02,740
local death was for a particular bucket

2918
00:58:02,740 --> 00:58:02,750


2919
00:58:02,750 --> 00:58:05,260
all right so what's the cost of this

2920
00:58:05,260 --> 00:58:05,270
 

2921
00:58:05,270 --> 00:58:08,089
well assuming we have enough buffers

2922
00:58:08,089 --> 00:58:08,099
 

2923
00:58:08,099 --> 00:58:11,089
then the cost is the essentially the

2924
00:58:11,089 --> 00:58:11,099
 

2925
00:58:11,099 --> 00:58:14,329
three central scans on both tables right

2926
00:58:14,329 --> 00:58:14,339
 

2927
00:58:14,339 --> 00:58:17,240
three times n plus n all right because

2928
00:58:17,240 --> 00:58:17,250
 

2929
00:58:17,250 --> 00:58:19,670
yeah the partitioning phase you have to

2930
00:58:19,670 --> 00:58:19,680
 

2931
00:58:19,680 --> 00:58:22,609
read both table in both tables in and

2932
00:58:22,609 --> 00:58:22,619
 

2933
00:58:22,619 --> 00:58:26,329
write them both out so it's to to scan

2934
00:58:26,329 --> 00:58:26,339
 

2935
00:58:26,339 --> 00:58:28,730
in one scan in and one write out so it's

2936
00:58:28,730 --> 00:58:28,740
 

2937
00:58:28,740 --> 00:58:31,520
2 M plus n then now when you do your

2938
00:58:31,520 --> 00:58:31,530
 

2939
00:58:31,530 --> 00:58:34,640
probing phase again it's just a simple

2940
00:58:34,640 --> 00:58:34,650
 

2941
00:58:34,650 --> 00:58:36,589
nested loop join like what the block

2942
00:58:36,589 --> 00:58:36,599
 

2943
00:58:36,599 --> 00:58:38,569
nested loop join and so it's once

2944
00:58:38,569 --> 00:58:38,579
 

2945
00:58:38,579 --> 00:58:40,040
question scan or every page on the outer

2946
00:58:40,040 --> 00:58:40,050
 

2947
00:58:40,050 --> 00:58:41,690
table and once question can moment on

2948
00:58:41,690 --> 00:58:41,700

2949
00:58:41,700 --> 00:58:43,880
the inner table again the idea here is

2950
00:58:43,880 --> 00:58:43,890
 

2951
00:58:43,890 --> 00:58:45,980
that for every single page on the inner

2952
00:58:45,980 --> 00:58:45,990
 

2953
00:58:45,990 --> 00:58:47,950
table within a level within my buckets I

2954
00:58:47,950 --> 00:58:47,960
 

2955
00:58:47,960 --> 00:58:50,960
only have to go look at the pages that

2956
00:58:50,960 --> 00:58:50,970
 

2957
00:58:50,970 --> 00:58:52,609
correspond to and the inner table at the

2958
00:58:52,609 --> 00:58:52,619
 

2959
00:58:52,619 --> 00:58:54,410
same bucket I don't cook the ones the

2960
00:58:54,410 --> 00:58:54,420
 

2961
00:58:54,420 --> 00:58:56,510
ones above me and I'll go to the ones

2962
00:58:56,510 --> 00:58:56,520
 

2963
00:58:56,520 --> 00:58:59,210
below me so it's just in two sequential

2964
00:58:59,210 --> 00:58:59,220
 

2965
00:58:59,220 --> 00:59:01,609
scans sorry this is a complete central

2966
00:59:01,609 --> 00:59:01,619
 

2967
00:59:01,619 --> 00:59:03,800
scan on both the inner and the outer in

2968
00:59:03,800 --> 00:59:03,810
 

2969
00:59:03,810 --> 00:59:08,329
the part in the probing page so let's

2970
00:59:08,329 --> 00:59:08,339
 

2971
00:59:08,339 --> 00:59:11,030
see now this in terms of cost so again

2972
00:59:11,030 --> 00:59:11,040
 

2973
00:59:11,040 --> 00:59:15,020
three times n plus n so 3 times 1500 is

2974
00:59:15,020 --> 00:59:15,030
 

2975
00:59:15,030 --> 00:59:18,380
4,500 iOS so we knew now scan on the

2976
00:59:18,380 --> 00:59:18,390
 

2977
00:59:18,390 --> 00:59:21,559
fastest is D and 0,45 seconds we're in

2978
00:59:21,559 --> 00:59:21,569
 

2979
00:59:21,569 --> 00:59:24,319
the sort merge-join case it was zero

2980
00:59:24,319 --> 00:59:24,329
 

2981
00:59:24,329 --> 00:59:30,540
point five nine seconds right so

2982
00:59:30,540 --> 00:59:30,550


2983
00:59:30,550 --> 00:59:33,720
this is why again the the the hash joint

2984
00:59:33,720 --> 00:59:33,730
 

2985
00:59:33,730 --> 00:59:36,000
is always going to be preferred cuz it's

2986
00:59:36,000 --> 00:59:36,010
 

2987
00:59:36,010 --> 00:59:38,280
always gonna be I'm sorry this almost

2988
00:59:38,280 --> 00:59:38,290
 

2989
00:59:38,290 --> 00:59:39,870
always gonna be faster than the the

2990
00:59:39,870 --> 00:59:39,880
 

2991
00:59:39,880 --> 00:59:42,000
servers join in and definitely almost

2992
00:59:42,000 --> 00:59:42,010
 

2993
00:59:42,010 --> 00:59:43,680
always faster than the the nested loop

2994
00:59:43,680 --> 00:59:43,690
 

2995
00:59:43,690 --> 00:59:45,240
join unless you have an index and you're

2996
00:59:45,240 --> 00:59:45,250
 

2997
00:59:45,250 --> 00:59:49,370
only joining a small number of things so

2998
00:59:49,370 --> 00:59:49,380
 

2999
00:59:49,380 --> 00:59:52,830
the if the database system knows the

3000
00:59:52,830 --> 00:59:52,840
 

3001
00:59:52,840 --> 00:59:57,540
size of the outer table then it can use

3002
00:59:57,540 --> 00:59:57,550

3003
00:59:57,550 --> 01:00:00,360
the static hash table right we can just

3004
01:00:00,360 --> 01:00:00,370
 

3005
01:00:00,370 --> 01:00:02,730
pick a you know linear probing hash

3006
01:00:02,730 --> 01:00:02,740
 

3007
01:00:02,740 --> 01:00:05,010
table which is really fast and say well

3008
01:00:05,010 --> 01:00:05,020
 

3009
01:00:05,020 --> 01:00:07,260
I know that I'd fit everything without

3010
01:00:07,260 --> 01:00:07,270
 

3011
01:00:07,270 --> 01:00:09,180
having complete wraparound with having a

3012
01:00:09,180 --> 01:00:09,190
 

3013
01:00:09,190 --> 01:00:11,730
large number of collisions based on what

3014
01:00:11,730 --> 01:00:11,740
 

3015
01:00:11,740 --> 01:00:13,230
I think I'm gonna actually get a need so

3016
01:00:13,230 --> 01:00:13,240
 

3017
01:00:13,240 --> 01:00:15,210
that's the best-case scenario that's

3018
01:00:15,210 --> 01:00:15,220
 

3019
01:00:15,220 --> 01:00:17,640
what data is I'm gonna try to do but the

3020
01:00:17,640 --> 01:00:17,650
 

3021
01:00:17,650 --> 01:00:20,010
issue is that this we'll see you next

3022
01:00:20,010 --> 01:00:20,020
 

3023
01:00:20,020 --> 01:00:22,680
class you have to estimate how many

3024
01:00:22,680 --> 01:00:22,690
 

3025
01:00:22,690 --> 01:00:25,440
tuples do you think you're gonna have as

3026
01:00:25,440 --> 01:00:25,450
 

3027
01:00:25,450 --> 01:00:28,170
your input and if you're just getting

3028
01:00:28,170 --> 01:00:28,180
 

3029
01:00:28,180 --> 01:00:29,970
the tape the data directly from your

3030
01:00:29,970 --> 01:00:29,980
 

3031
01:00:29,980 --> 01:00:31,230
access methods at the bottom of the tree

3032
01:00:31,230 --> 01:00:31,240
 

3033
01:00:31,240 --> 01:00:33,690
that may actually you it may not be hard

3034
01:00:33,690 --> 01:00:33,700
 

3035
01:00:33,700 --> 01:00:35,220
to actually compute that but if you're

3036
01:00:35,220 --> 01:00:35,230
 

3037
01:00:35,230 --> 01:00:36,810
doing a joint after joint after joining

3038
01:00:36,810 --> 01:00:36,820
 

3039
01:00:36,820 --> 01:00:38,850
up here join if you get it wrong at the

3040
01:00:38,850 --> 01:00:38,860
 

3041
01:00:38,860 --> 01:00:40,350
bottom that you can get really wrong at

3042
01:00:40,350 --> 01:00:40,360
 

3043
01:00:40,360 --> 01:00:43,260
the top so you may be under provisioning

3044
01:00:43,260 --> 01:00:43,270
 

3045
01:00:43,270 --> 01:00:46,020
or besides your hash table and you may

3046
01:00:46,020 --> 01:00:46,030
 

3047
01:00:46,030 --> 01:00:47,910
have to do you know to double the size

3048
01:00:47,910 --> 01:00:47,920
 

3049
01:00:47,920 --> 01:00:51,540
if you have too many collisions so this

3050
01:00:51,540 --> 01:00:51,550
 

3051
01:00:51,550 --> 01:00:53,610
is you could use you know the dynamic

3052
01:00:53,610 --> 01:00:53,620
 

3053
01:00:53,620 --> 01:00:54,930
hash table is like Stanwell hashing on

3054
01:00:54,930 --> 01:00:54,940
 

3055
01:00:54,940 --> 01:00:57,390
linear hashing if you don't know the

3056
01:00:57,390 --> 01:00:57,400
 

3057
01:00:57,400 --> 01:00:59,730
size but you're as we saw before you're

3058
01:00:59,730 --> 01:00:59,740
 

3059
01:00:59,740 --> 01:01:01,950
gonna pay a computational overhead to

3060
01:01:01,950 --> 01:01:01,960
 

3061
01:01:01,960 --> 01:01:04,860
maintain to be able to figure out you

3062
01:01:04,860 --> 01:01:04,870
 

3063
01:01:04,870 --> 01:01:06,030
know what buckets things should actually

3064
01:01:06,030 --> 01:01:06,040
 

3065
01:01:06,040 --> 01:01:08,370
be in in both of those schemes where in

3066
01:01:08,370 --> 01:01:08,380
 

3067
01:01:08,380 --> 01:01:09,510
the linear probing you don't have to do

3068
01:01:09,510 --> 01:01:09,520

3069
01:01:09,520 --> 01:01:12,540
that so most agencies I'm gonna try to

3070
01:01:12,540 --> 01:01:12,550
 

3071
01:01:12,550 --> 01:01:15,210
do a static hash table but if you get it

3072
01:01:15,210 --> 01:01:15,220
 

3073
01:01:15,220 --> 01:01:17,400
wrong then you know you're paid

3074
01:01:17,400 --> 01:01:17,410
 

3075
01:01:17,410 --> 01:01:19,470
apparently up doubling the size it's

3076
01:01:19,470 --> 01:01:19,480
 

3077
01:01:19,480 --> 01:01:21,210
really only for internal metadata you

3078
01:01:21,210 --> 01:01:21,220

3079
01:01:21,220 --> 01:01:22,680
use something like extendable hashing or

3080
01:01:22,680 --> 01:01:22,690

3081
01:01:22,690 --> 01:01:24,210
linear fashion like your Buffalo

3082
01:01:24,210 --> 01:01:24,220
 

3083
01:01:24,220 --> 01:01:27,450
management you guys been doing okay so

3084
01:01:27,450 --> 01:01:27,460
 

3085
01:01:27,460 --> 01:01:30,950
any questions about hash tones

3086
01:01:30,950 --> 01:01:30,960
 

3087
01:01:30,960 --> 01:01:34,710
pretty simple to understand the again

3088
01:01:34,710 --> 01:01:34,720
 

3089
01:01:34,720 --> 01:01:36,270
and from our point of view we really

3090
01:01:36,270 --> 01:01:36,280
 

3091
01:01:36,280 --> 01:01:38,730
only care about this guy your cost so

3092
01:01:38,730 --> 01:01:38,740
 

3093
01:01:38,740 --> 01:01:40,380
the recursive partitioning approach is

3094
01:01:40,380 --> 01:01:40,390

3095
01:01:40,390 --> 01:01:42,210
pretty much the only really optimization

3096
01:01:42,210 --> 01:01:42,220
 

3097
01:01:42,220 --> 01:01:43,830
we have available to us

3098
01:01:43,830 --> 01:01:43,840
 

3099
01:01:43,840 --> 01:01:47,100
we'll see the case in in the advanced

3100
01:01:47,100 --> 01:01:47,110
 

3101
01:01:47,110 --> 01:01:49,770
class when we do in memory joins you

3102
01:01:49,770 --> 01:01:49,780
 

3103
01:01:49,780 --> 01:01:51,240
start to care about where the data

3104
01:01:51,240 --> 01:01:51,250
 

3105
01:01:51,250 --> 01:01:53,550
actually is located like like what CPU

3106
01:01:53,550 --> 01:01:53,560
 

3107
01:01:53,560 --> 01:01:56,010
socket or what level in your cache right

3108
01:01:56,010 --> 01:01:56,020
 

3109
01:01:56,020 --> 01:01:57,120
for our purposes we don't care about

3110
01:01:57,120 --> 01:01:57,130
 

3111
01:01:57,130 --> 01:02:00,960
this to summarize again the cost all

3112
01:02:00,960 --> 01:02:00,970
 

3113
01:02:00,970 --> 01:02:03,090
these different algorithms again we said

3114
01:02:03,090 --> 01:02:03,100
 

3115
01:02:03,100 --> 01:02:05,970
that using our running example in the

3116
01:02:05,970 --> 01:02:05,980
 

3117
01:02:05,980 --> 01:02:07,470
worst case scenario the simpleness loop

3118
01:02:07,470 --> 01:02:07,480
 

3119
01:02:07,480 --> 01:02:10,320
join it took one point three hours we do

3120
01:02:10,320 --> 01:02:10,330
 

3121
01:02:10,330 --> 01:02:11,790
things and blocks were down to 50

3122
01:02:11,790 --> 01:02:11,800
 

3123
01:02:11,800 --> 01:02:13,590
seconds you do the in excess of join I

3124
01:02:13,590 --> 01:02:13,600
 

3125
01:02:13,600 --> 01:02:15,120
don't know where I got 20 seconds from

3126
01:02:15,120 --> 01:02:15,130
 

3127
01:02:15,130 --> 01:02:18,690
okay said log in you know right it's a

3128
01:02:18,690 --> 01:02:18,700
 

3129
01:02:18,700 --> 01:02:20,580
little bit better but then the sort

3130
01:02:20,580 --> 01:02:20,590
 

3131
01:02:20,590 --> 01:02:22,140
Maurice join and that and the hash join

3132
01:02:22,140 --> 01:02:22,150
 

3133
01:02:22,150 --> 01:02:25,830
is is even less than that this actually

3134
01:02:25,830 --> 01:02:25,840
 

3135
01:02:25,840 --> 01:02:26,880
might be wrong I don't know where I got

3136
01:02:26,880 --> 01:02:26,890
 

3137
01:02:26,890 --> 01:02:31,560
this from hmm because that shouldn't be

3138
01:02:31,560 --> 01:02:31,570
 

3139
01:02:31,570 --> 01:02:32,220
a login

3140
01:02:32,220 --> 01:02:32,230
 

3141
01:02:32,230 --> 01:02:36,350
all right I'll fix that later okay so

3142
01:02:36,350 --> 01:02:36,360
 

3143
01:02:36,360 --> 01:02:38,640
the main takeaway from all this the hash

3144
01:02:38,640 --> 01:02:38,650
 

3145
01:02:38,650 --> 01:02:40,170
join is almost always be better than

3146
01:02:40,170 --> 01:02:40,180
 

3147
01:02:40,180 --> 01:02:43,590
sorting and unless you know that the

3148
01:02:43,590 --> 01:02:43,600
 

3149
01:02:43,600 --> 01:02:46,890
output needs to be sorted or the data

3150
01:02:46,890 --> 01:02:46,900
 

3151
01:02:46,900 --> 01:02:48,180
you're feeding into it is already sorted

3152
01:02:48,180 --> 01:02:48,190
 

3153
01:02:48,190 --> 01:02:54,120
on what you want the a good database

3154
01:02:54,120 --> 01:02:54,130
 

3155
01:02:54,130 --> 01:02:55,800
system we don't have time to open up

3156
01:02:55,800 --> 01:02:55,810
 

3157
01:02:55,810 --> 01:02:58,260
Postgres but a good data assessment can

3158
01:02:58,260 --> 01:02:58,270
 

3159
01:02:58,270 --> 01:02:59,490
actually support all these different

3160
01:02:59,490 --> 01:02:59,500
 

3161
01:02:59,500 --> 01:03:01,620
algorithms and can try to figure out

3162
01:03:01,620 --> 01:03:01,630
 

3163
01:03:01,630 --> 01:03:02,790
which one is the best for your

3164
01:03:02,790 --> 01:03:02,800
 

3165
01:03:02,800 --> 01:03:05,670
particular workload so Postgres sequel

3166
01:03:05,670 --> 01:03:05,680
 

3167
01:03:05,680 --> 01:03:07,920
server oracle all the major data systems

3168
01:03:07,920 --> 01:03:07,930
 

3169
01:03:07,930 --> 01:03:10,580
can do sort merge nested loop join and

3170
01:03:10,580 --> 01:03:10,590
 

3171
01:03:10,590 --> 01:03:13,530
hashed joins and then on the fly for

3172
01:03:13,530 --> 01:03:13,540
 

3173
01:03:13,540 --> 01:03:14,790
each query they figure out what they

3174
01:03:14,790 --> 01:03:14,800
 

3175
01:03:14,800 --> 01:03:17,760
want to use and then and the day almost

3176
01:03:17,760 --> 01:03:17,770
 

3177
01:03:17,770 --> 01:03:19,680
always comes out to be a hash drawn

3178
01:03:19,680 --> 01:03:19,690
 

3179
01:03:19,690 --> 01:03:21,540
unless you have an index already my

3180
01:03:21,540 --> 01:03:21,550

3181
01:03:21,550 --> 01:03:23,220
sequel I don't know if actually supports

3182
01:03:23,220 --> 01:03:23,230

3183
01:03:23,230 --> 01:03:24,420
hash joins I thought they did and

3184
01:03:24,420 --> 01:03:24,430
 

3185
01:03:24,430 --> 01:03:26,040
someone tell me they did we can check

3186
01:03:26,040 --> 01:03:26,050
 

3187
01:03:26,050 --> 01:03:29,760
the documentation again it might be in

3188
01:03:29,760 --> 01:03:29,770
 

3189
01:03:29,770 --> 01:03:32,910
the a conversion aid but I don't know so

3190
01:03:32,910 --> 01:03:32,920
 

3191
01:03:32,920 --> 01:03:35,460
and then sequel like I said I think

3192
01:03:35,460 --> 01:03:35,470

3193
01:03:35,470 --> 01:03:36,990
sigil like my only support nested loop

3194
01:03:36,990 --> 01:03:37,000
 

3195
01:03:37,000 --> 01:03:40,800
joins okay so next class we're gonna

3196
01:03:40,800 --> 01:03:40,810
 

3197
01:03:40,810 --> 01:03:42,870
talk about you know I'm sort of looting

3198
01:03:42,870 --> 01:03:42,880
 

3199
01:03:42,880 --> 01:03:45,030
to this all throughout today's today's

3200
01:03:45,030 --> 01:03:45,040

3201
01:03:45,040 --> 01:03:47,640
lecture was next nights we'll talk about

3202
01:03:47,640 --> 01:03:47,650
 

3203
01:03:47,650 --> 01:03:49,770
how this impacts me to decide which

3204
01:03:49,770 --> 01:03:49,780

3205
01:03:49,780 --> 01:03:52,380
album wants to use per operator and I'll

3206
01:03:52,380 --> 01:03:52,390
 

3207
01:03:52,390 --> 01:03:53,670
get even more complicated when we talk

3208
01:03:53,670 --> 01:03:53,680
 

3209
01:03:53,680 --> 01:03:54,930
about joins because it's not it's more

3210
01:03:54,930 --> 01:03:54,940

3211
01:03:54,940 --> 01:03:56,820
than just saying do I want sort merge

3212
01:03:56,820 --> 01:03:56,830
 

3213
01:03:56,830 --> 01:03:57,360
versus

3214
01:03:57,360 --> 01:03:57,370
 

3215
01:03:57,370 --> 01:03:59,460
- join it's actually making decisions

3216
01:03:59,460 --> 01:03:59,470
 

3217
01:03:59,470 --> 01:04:00,720
about what should be the inner table

3218
01:04:00,720 --> 01:04:00,730
 

3219
01:04:00,730 --> 01:04:02,940
versus the outer table and how should I

3220
01:04:02,940 --> 01:04:02,950
 

3221
01:04:02,950 --> 01:04:05,600
order my my joint operations so a

3222
01:04:05,600 --> 01:04:05,610
 

3223
01:04:05,610 --> 01:04:07,560
five-way think about this type of joint

3224
01:04:07,560 --> 01:04:07,570
 

3225
01:04:07,570 --> 01:04:09,960
table a B and C together should I join a

3226
01:04:09,960 --> 01:04:09,970
 

3227
01:04:09,970 --> 01:04:12,330
and B first or B and C first or in a

3228
01:04:12,330 --> 01:04:12,340
 

3229
01:04:12,340 --> 01:04:14,460
later like all these kind of things can

3230
01:04:14,460 --> 01:04:14,470
 

3231
01:04:14,470 --> 01:04:15,450
actually make a big difference in

3232
01:04:15,450 --> 01:04:15,460
 

3233
01:04:15,460 --> 01:04:18,210
performance and you actually made out

3234
01:04:18,210 --> 01:04:18,220
 

3235
01:04:18,220 --> 01:04:19,920
overshadow the benefit you get from

3236
01:04:19,920 --> 01:04:19,930

3237
01:04:19,930 --> 01:04:23,210
using sort mergers as a hash joint right

3238
01:04:23,210 --> 01:04:23,220
 

3239
01:04:23,220 --> 01:04:28,260
right so no class on Wednesday I will

3240
01:04:28,260 --> 01:04:28,270
 

3241
01:04:28,270 --> 01:05:11,340
post the the week and then do today by

3242
01:05:11,340 --> 01:05:11,350
 

3243
01:05:11,350 --> 01:05:17,400
the 640 it's the real treat with your

3244
01:05:17,400 --> 01:05:17,410
 

3245
01:05:17,410 --> 01:05:20,910
drinking by 12 they will make sure

3246
01:05:20,910 --> 01:05:20,920
 

3247
01:05:20,920 --> 01:05:23,100
but sane eyes are straight so it really

3248
01:05:23,100 --> 01:05:23,110
 

3249
01:05:23,110 --> 01:05:25,530
don't matter

