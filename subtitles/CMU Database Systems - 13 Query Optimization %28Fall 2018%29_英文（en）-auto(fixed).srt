1
00:00:00,730 --> 00:00:13,600
[Music]

2
00:00:13,600 --> 00:00:13,610


3
00:00:13,610 --> 00:00:18,200
Tyrael the things that guys docket

4
00:00:18,200 --> 00:00:18,210

5
00:00:18,210 --> 00:00:21,109
obviously the midterm is this Wednesday

6
00:00:21,109 --> 00:00:21,119
 

7
00:00:21,119 --> 00:00:26,059
in class I posted the the URL to the

8
00:00:26,059 --> 00:00:26,069
 

9
00:00:26,069 --> 00:00:29,569
study guide on online in Piazza and then

10
00:00:29,569 --> 00:00:29,579
 

11
00:00:29,579 --> 00:00:31,370
at the end of this class we'll have a

12
00:00:31,370 --> 00:00:31,380
 

13
00:00:31,380 --> 00:00:34,100
review of the midterm go over the topics

14
00:00:34,100 --> 00:00:34,110
 

15
00:00:34,110 --> 00:00:35,060
at a high level

16
00:00:35,060 --> 00:00:35,070

17
00:00:35,070 --> 00:00:37,220
alright and then we'll cover everything

18
00:00:37,220 --> 00:00:37,230
 

19
00:00:37,230 --> 00:00:38,869
you need to like you know what you need

20
00:00:38,869 --> 00:00:38,879
 

21
00:00:38,879 --> 00:00:41,060
to bring and show up and do okay and

22
00:00:41,060 --> 00:00:41,070
 

23
00:00:41,070 --> 00:00:44,750
then project number two checkpoint 2 is

24
00:00:44,750 --> 00:00:44,760
 

25
00:00:44,760 --> 00:00:48,919
due this Friday at midnight quick show

26
00:00:48,919 --> 00:00:48,929
 

27
00:00:48,929 --> 00:00:50,209
of hands who here is done

28
00:00:50,209 --> 00:00:50,219
 

29
00:00:50,219 --> 00:00:53,779
checkpoint 2 done the entire thing we

30
00:00:53,779 --> 00:00:53,789
 

31
00:00:53,789 --> 00:00:56,150
got one okay don't be so meek he's done

32
00:00:56,150 --> 00:00:56,160
 

33
00:00:56,160 --> 00:00:58,369
okay who here has not started on

34
00:00:58,369 --> 00:00:58,379
 

35
00:00:58,379 --> 00:01:01,639
checkpoint two I saw a hand okay it's

36
00:01:01,639 --> 00:01:01,649
 

37
00:01:01,649 --> 00:01:03,709
okay all right fine okay again this is

38
00:01:03,709 --> 00:01:03,719
 

39
00:01:03,719 --> 00:01:05,780
why I may do on Friday and I realize you

40
00:01:05,780 --> 00:01:05,790
 

41
00:01:05,790 --> 00:01:07,250
guys have midterms in other classes so

42
00:01:07,250 --> 00:01:07,260
 

43
00:01:07,260 --> 00:01:11,420
that's why we push it off them okay so

44
00:01:11,420 --> 00:01:11,430
 

45
00:01:11,430 --> 00:01:12,650
the other thing I want to go over real

46
00:01:12,650 --> 00:01:12,660
 

47
00:01:12,660 --> 00:01:16,100
quickly is some administrative stuff so

48
00:01:16,100 --> 00:01:16,110
 

49
00:01:16,110 --> 00:01:18,620
these are the department basically got

50
00:01:18,620 --> 00:01:18,630
 

51
00:01:18,630 --> 00:01:19,880
back to me and they want me to curse

52
00:01:19,880 --> 00:01:19,890
 

53
00:01:19,890 --> 00:01:21,920
less in this class so I'm gonna try to

54
00:01:21,920 --> 00:01:21,930
 

55
00:01:21,930 --> 00:01:25,070
do that I can't always promise it but we

56
00:01:25,070 --> 00:01:25,080
 

57
00:01:25,080 --> 00:01:26,390
uh there's some other things going on

58
00:01:26,390 --> 00:01:26,400
 

59
00:01:26,400 --> 00:01:27,230
that I think you're actually kind of

60
00:01:27,230 --> 00:01:27,240
 

61
00:01:27,240 --> 00:01:29,000
interesting kind of relevant so first is

62
00:01:29,000 --> 00:01:29,010
 

63
00:01:29,010 --> 00:01:31,160
that I found that there's a Chinese

64
00:01:31,160 --> 00:01:31,170

65
00:01:31,170 --> 00:01:33,350
version of YouTube that's basically

66
00:01:33,350 --> 00:01:33,360
 

67
00:01:33,360 --> 00:01:38,990
copying all our our our videos right so

68
00:01:38,990 --> 00:01:39,000
 

69
00:01:39,000 --> 00:01:41,240
good for them okay and then the other

70
00:01:41,240 --> 00:01:41,250
 

71
00:01:41,250 --> 00:01:43,010
thing is too because you know not that I

72
00:01:43,010 --> 00:01:43,020
 

73
00:01:43,020 --> 00:01:45,200
post this on youtube just for just

74
00:01:45,200 --> 00:01:45,210
 

75
00:01:45,210 --> 00:01:47,210
pickles right I do it because I wouldn't

76
00:01:47,210 --> 00:01:47,220
 

77
00:01:47,220 --> 00:01:49,280
you guys have access to to everything we

78
00:01:49,280 --> 00:01:49,290
 

79
00:01:49,290 --> 00:01:51,170
get a lot of email or these I get email

80
00:01:51,170 --> 00:01:51,180
 

81
00:01:51,180 --> 00:01:53,080
from people complaining about the course

82
00:01:53,080 --> 00:01:53,090
 

83
00:01:53,090 --> 00:01:56,150
so this is I'm like the list here hold

84
00:01:56,150 --> 00:01:56,160
 

85
00:01:56,160 --> 00:02:00,590
up sorry I don't use their names every

86
00:02:00,590 --> 00:02:00,600
 

87
00:02:00,600 --> 00:02:02,140
okay sorry

88
00:02:02,140 --> 00:02:02,150
 

89
00:02:02,150 --> 00:02:06,820
so this is this is Jael in Seattle he

90
00:02:06,820 --> 00:02:06,830
 

91
00:02:06,830 --> 00:02:09,219
basically says that we're all full he

92
00:02:09,219 --> 00:02:09,229
 

93
00:02:09,229 --> 00:02:10,450
doesn't like us and he give you back

94
00:02:10,450 --> 00:02:10,460
 

95
00:02:10,460 --> 00:02:11,650
your money

96
00:02:11,650 --> 00:02:11,660
 

97
00:02:11,660 --> 00:02:15,190
this is CM in in San Jose

98
00:02:15,190 --> 00:02:15,200
 

99
00:02:15,200 --> 00:02:18,640
he says I'm a joker I have I smell the

100
00:02:18,640 --> 00:02:18,650
 

101
00:02:18,650 --> 00:02:20,770
guy of diarrhea whatever like so it is

102
00:02:20,770 --> 00:02:20,780

103
00:02:20,780 --> 00:02:22,330
true I did have a medical problem where

104
00:02:22,330 --> 00:02:22,340
 

105
00:02:22,340 --> 00:02:24,610
had bad hygiene a year before but I'm on

106
00:02:24,610 --> 00:02:24,620

107
00:02:24,620 --> 00:02:27,070
medicine now so this I I think this is

108
00:02:27,070 --> 00:02:27,080
 

109
00:02:27,080 --> 00:02:30,010
old news what he got but occasionally

110
00:02:30,010 --> 00:02:30,020
 

111
00:02:30,020 --> 00:02:32,200
you get actually useful emails right so

112
00:02:32,200 --> 00:02:32,210
 

113
00:02:32,210 --> 00:02:33,790
this is actually somebody Erik darling

114
00:02:33,790 --> 00:02:33,800
 

115
00:02:33,800 --> 00:02:36,760
he's from a major sequel server debate

116
00:02:36,760 --> 00:02:36,770
 

117
00:02:36,770 --> 00:02:38,620
consultant company and he watched the

118
00:02:38,620 --> 00:02:38,630
 

119
00:02:38,630 --> 00:02:40,780
lecture from last class or enjoins and

120
00:02:40,780 --> 00:02:40,790
 

121
00:02:40,790 --> 00:02:42,460
he said they said that I said something

122
00:02:42,460 --> 00:02:42,470
 

123
00:02:42,470 --> 00:02:43,330
that was actually incorrect he's

124
00:02:43,330 --> 00:02:43,340
 

125
00:02:43,340 --> 00:02:44,920
absolutely right so when I was talking

126
00:02:44,920 --> 00:02:44,930
 

127
00:02:44,930 --> 00:02:47,140
about joins I was saying that oh well

128
00:02:47,140 --> 00:02:47,150
 

129
00:02:47,150 --> 00:02:49,360
building hash tables like building an X

130
00:02:49,360 --> 00:02:49,370
 

131
00:02:49,370 --> 00:02:52,450
on the fly and as far as they know no

132
00:02:52,450 --> 00:02:52,460
 

133
00:02:52,460 --> 00:02:54,220
database system actually would build a

134
00:02:54,220 --> 00:02:54,230
 

135
00:02:54,230 --> 00:02:56,620
B+ tree on the fly only they're only

136
00:02:56,620 --> 00:02:56,630
 

137
00:02:56,630 --> 00:02:58,090
gonna build hash tables to do hash joins

138
00:02:58,090 --> 00:02:58,100
 

139
00:02:58,100 --> 00:02:59,830
and he actually says actually this is

140
00:02:59,830 --> 00:02:59,840
 

141
00:02:59,840 --> 00:03:01,510
incorrect the sequel server has a

142
00:03:01,510 --> 00:03:01,520
 

143
00:03:01,520 --> 00:03:03,790
feature called index pooling where they

144
00:03:03,790 --> 00:03:03,800
 

145
00:03:03,800 --> 00:03:06,580
will build a B+ tree on the fly just for

146
00:03:06,580 --> 00:03:06,590
 

147
00:03:06,590 --> 00:03:08,260
the query that you're actually doing and

148
00:03:08,260 --> 00:03:08,270
 

149
00:03:08,270 --> 00:03:10,060
SIBO light does sort of something

150
00:03:10,060 --> 00:03:10,070
 

151
00:03:10,070 --> 00:03:13,690
something similar may say this is

152
00:03:13,690 --> 00:03:13,700
 

153
00:03:13,700 --> 00:03:16,060
actually a really cool website where you

154
00:03:16,060 --> 00:03:16,070
 

155
00:03:16,070 --> 00:03:18,430
can dump out the secret server.xml of a

156
00:03:18,430 --> 00:03:18,440
 

157
00:03:18,440 --> 00:03:20,410
query plan a quick sell of a query plan

158
00:03:20,410 --> 00:03:20,420

159
00:03:20,420 --> 00:03:22,270
from sequel server and you upload it to

160
00:03:22,270 --> 00:03:22,280
 

161
00:03:22,280 --> 00:03:23,320
the website and it gives you a nice

162
00:03:23,320 --> 00:03:23,330
 

163
00:03:23,330 --> 00:03:25,210
visualization of this alright so we

164
00:03:25,210 --> 00:03:25,220
 

165
00:03:25,220 --> 00:03:28,570
thank Eric for correcting us there's

166
00:03:28,570 --> 00:03:28,580
 

167
00:03:28,580 --> 00:03:29,979
much more comments in YouTube for other

168
00:03:29,979 --> 00:03:29,989
 

169
00:03:29,989 --> 00:03:31,240
things we've gotten correct and

170
00:03:31,240 --> 00:03:31,250
 

171
00:03:31,250 --> 00:03:32,470
incorrect but I'm not gonna read all of

172
00:03:32,470 --> 00:03:32,480
 

173
00:03:32,480 --> 00:03:36,640
them ok so again I take any feedback you

174
00:03:36,640 --> 00:03:36,650
 

175
00:03:36,650 --> 00:03:37,570
guys can provide because I wanna make

176
00:03:37,570 --> 00:03:37,580
 

177
00:03:37,580 --> 00:03:40,240
the course better year after year so

178
00:03:40,240 --> 00:03:40,250
 

179
00:03:40,250 --> 00:03:42,070
don't don't sum any bad email something

180
00:03:42,070 --> 00:03:42,080
 

181
00:03:42,080 --> 00:03:46,000
good ones okay alright so today's topic

182
00:03:46,000 --> 00:03:46,010
 

183
00:03:46,010 --> 00:03:48,490
is on query optimization so this is

184
00:03:48,490 --> 00:03:48,500
 

185
00:03:48,500 --> 00:03:50,470
actually one of my favorite lectures

186
00:03:50,470 --> 00:03:50,480
 

187
00:03:50,480 --> 00:03:52,390
we're only you know it's a my favorite

188
00:03:52,390 --> 00:03:52,400
 

189
00:03:52,400 --> 00:03:55,540
topics in in databases and part of the

190
00:03:55,540 --> 00:03:55,550
 

191
00:03:55,550 --> 00:03:56,800
reason why it's one my favorite topics

192
00:03:56,800 --> 00:03:56,810

193
00:03:56,810 --> 00:03:58,060
is because I'm actually really bad at it

194
00:03:58,060 --> 00:03:58,070
 

195
00:03:58,070 --> 00:03:59,860
or this is the one area I will fully

196
00:03:59,860 --> 00:03:59,870
 

197
00:03:59,870 --> 00:04:03,430
admit that I of all of database systems

198
00:04:03,430 --> 00:04:03,440
 

199
00:04:03,440 --> 00:04:05,560
that I don't fully understand and maybe

200
00:04:05,560 --> 00:04:05,570
 

201
00:04:05,570 --> 00:04:06,940
to the extent that I would want to and

202
00:04:06,940 --> 00:04:06,950
 

203
00:04:06,950 --> 00:04:08,710
for whatever reason that makes me like

204
00:04:08,710 --> 00:04:08,720
 

205
00:04:08,720 --> 00:04:13,390
it even more and so to understand what

206
00:04:13,390 --> 00:04:13,400
 

207
00:04:13,400 --> 00:04:15,630
we're gonna do in this in this lecture

208
00:04:15,630 --> 00:04:15,640
 

209
00:04:15,640 --> 00:04:17,789
we had to go back and understand what

210
00:04:17,789 --> 00:04:17,799
 

211
00:04:17,799 --> 00:04:21,509
sequel actually is right so so sequel is

212
00:04:21,509 --> 00:04:21,519
 

213
00:04:21,519 --> 00:04:25,470
a is a query that someone sends to the

214
00:04:25,470 --> 00:04:25,480
 

215
00:04:25,480 --> 00:04:28,530
database systems and that says here's

216
00:04:28,530 --> 00:04:28,540
 

217
00:04:28,540 --> 00:04:31,110
the answer I want you to compute right

218
00:04:31,110 --> 00:04:31,120
 

219
00:04:31,120 --> 00:04:33,270
it's done in a declarative way so

220
00:04:33,270 --> 00:04:33,280
 

221
00:04:33,280 --> 00:04:35,220
there's nothing about what it's in the

222
00:04:35,220 --> 00:04:35,230
 

223
00:04:35,230 --> 00:04:37,590
sequel that says you know run this joint

224
00:04:37,590 --> 00:04:37,600
 

225
00:04:37,600 --> 00:04:39,360
algorithm run you know run you're

226
00:04:39,360 --> 00:04:39,370
 

227
00:04:39,370 --> 00:04:41,100
sorting this way it just says give me

228
00:04:41,100 --> 00:04:41,110
 

229
00:04:41,110 --> 00:04:43,830
this answer and it's up for the database

230
00:04:43,830 --> 00:04:43,840
 

231
00:04:43,840 --> 00:04:46,530
system to figure out the the best way to

232
00:04:46,530 --> 00:04:46,540
 

233
00:04:46,540 --> 00:04:49,650
actually do it so we saw this right when

234
00:04:49,650 --> 00:04:49,660
 

235
00:04:49,660 --> 00:04:51,840
we talked about joins and sorting I said

236
00:04:51,840 --> 00:04:51,850
 

237
00:04:51,850 --> 00:04:52,830
there's a bunch of different algorithms

238
00:04:52,830 --> 00:04:52,840
 

239
00:04:52,840 --> 00:04:54,390
you could actually use right in case of

240
00:04:54,390 --> 00:04:54,400
 

241
00:04:54,400 --> 00:04:55,830
joins you can do nested loop you could

242
00:04:55,830 --> 00:04:55,840

243
00:04:55,840 --> 00:04:58,230
do hash joints you can do sort merge and

244
00:04:58,230 --> 00:04:58,240
 

245
00:04:58,240 --> 00:04:59,400
they have different algorithmic

246
00:04:59,400 --> 00:04:59,410
 

247
00:04:59,410 --> 00:05:01,350
properties and trade-offs and under

248
00:05:01,350 --> 00:05:01,360
 

249
00:05:01,360 --> 00:05:03,120
different scenarios you may actually

250
00:05:03,120 --> 00:05:03,130

251
00:05:03,130 --> 00:05:05,159
want to run one algorithm versus another

252
00:05:05,159 --> 00:05:05,169
 

253
00:05:05,169 --> 00:05:07,290
but when you write a sequel query to

254
00:05:07,290 --> 00:05:07,300
 

255
00:05:07,300 --> 00:05:09,720
join two tables you don't say join table

256
00:05:09,720 --> 00:05:09,730
 

257
00:05:09,730 --> 00:05:11,340
at you know take table a and do a hash

258
00:05:11,340 --> 00:05:11,350
 

259
00:05:11,350 --> 00:05:13,380
joint on it or table B you just say I

260
00:05:13,380 --> 00:05:13,390
 

261
00:05:13,390 --> 00:05:15,000
want to do a join are you just saying

262
00:05:15,000 --> 00:05:15,010
 

263
00:05:15,010 --> 00:05:16,380
what the answer you want to be and so

264
00:05:16,380 --> 00:05:16,390
 

265
00:05:16,390 --> 00:05:18,180
it's up for the database system in

266
00:05:18,180 --> 00:05:18,190
 

267
00:05:18,190 --> 00:05:20,250
particular the query optimizer was

268
00:05:20,250 --> 00:05:20,260
 

269
00:05:20,260 --> 00:05:22,260
referring to focused on today to figure

270
00:05:22,260 --> 00:05:22,270
 

271
00:05:22,270 --> 00:05:25,140
out what the best album to use for your

272
00:05:25,140 --> 00:05:25,150
 

273
00:05:25,150 --> 00:05:26,760
particular query based on what it knows

274
00:05:26,760 --> 00:05:26,770

275
00:05:26,770 --> 00:05:30,330
about the data and so we saw that there

276
00:05:30,330 --> 00:05:30,340
 

277
00:05:30,340 --> 00:05:31,469
was a big difference in performance when

278
00:05:31,469 --> 00:05:31,479
 

279
00:05:31,479 --> 00:05:33,480
we talked about joins right we said that

280
00:05:33,480 --> 00:05:33,490
 

281
00:05:33,490 --> 00:05:34,950
if you do this no stupidest thing with

282
00:05:34,950 --> 00:05:34,960
 

283
00:05:34,960 --> 00:05:36,840
the nested loop join then you can take

284
00:05:36,840 --> 00:05:36,850
 

285
00:05:36,850 --> 00:05:38,250
your query take one point three hours

286
00:05:38,250 --> 00:05:38,260
 

287
00:05:38,260 --> 00:05:40,590
but if you're do a hash join then you're

288
00:05:40,590 --> 00:05:40,600
 

289
00:05:40,600 --> 00:05:44,430
down to less than a second so as we go

290
00:05:44,430 --> 00:05:44,440
 

291
00:05:44,440 --> 00:05:46,710
along we'll see or I'll sort of mention

292
00:05:46,710 --> 00:05:46,720
 

293
00:05:46,720 --> 00:05:49,710
that in various cases that this is the

294
00:05:49,710 --> 00:05:49,720
 

295
00:05:49,720 --> 00:05:51,270
one thing that really separates the

296
00:05:51,270 --> 00:05:51,280
 

297
00:05:51,280 --> 00:05:52,950
commercial database systems from the

298
00:05:52,950 --> 00:05:52,960
 

299
00:05:52,960 --> 00:05:54,719
open source ones right this is what

300
00:05:54,719 --> 00:05:54,729
 

301
00:05:54,729 --> 00:05:56,670
makes commercial data part of the reason

302
00:05:56,670 --> 00:05:56,680
 

303
00:05:56,680 --> 00:05:58,170
what makes commercial databases so so

304
00:05:58,170 --> 00:05:58,180
 

305
00:05:58,180 --> 00:06:01,170
expensive right because it's gonna be

306
00:06:01,170 --> 00:06:01,180
 

307
00:06:01,180 --> 00:06:02,250
this query optimizer because they're

308
00:06:02,250 --> 00:06:02,260

309
00:06:02,260 --> 00:06:04,170
gonna have an entire floor at these

310
00:06:04,170 --> 00:06:04,180
 

311
00:06:04,180 --> 00:06:05,640
database companies with much you know

312
00:06:05,640 --> 00:06:05,650
 

313
00:06:05,650 --> 00:06:07,469
dudes with PhD he's trying to figure out

314
00:06:07,469 --> 00:06:07,479
 

315
00:06:07,479 --> 00:06:08,610
how to squeak the best performance you

316
00:06:08,610 --> 00:06:08,620
 

317
00:06:08,620 --> 00:06:11,040
can get out of a database system through

318
00:06:11,040 --> 00:06:11,050
 

319
00:06:11,050 --> 00:06:13,770
its query optimizer right and there's

320
00:06:13,770 --> 00:06:13,780
 

321
00:06:13,780 --> 00:06:15,630
been studies that show in that they

322
00:06:15,630 --> 00:06:15,640
 

323
00:06:15,640 --> 00:06:16,770
actually the Microsoft query optimizer

324
00:06:16,770 --> 00:06:16,780
 

325
00:06:16,780 --> 00:06:19,800
was actually the best one out there the

326
00:06:19,800 --> 00:06:19,810
 

327
00:06:19,810 --> 00:06:21,719
nuts say the open source ones are bad in

328
00:06:21,719 --> 00:06:21,729
 

329
00:06:21,729 --> 00:06:23,580
particular Postgres it just in terms of

330
00:06:23,580 --> 00:06:23,590
 

331
00:06:23,590 --> 00:06:25,409
level sophistication that the kind of

332
00:06:25,409 --> 00:06:25,419
 

333
00:06:25,419 --> 00:06:27,570
things that can support the commercial

334
00:06:27,570 --> 00:06:27,580
 

335
00:06:27,580 --> 00:06:29,070
ones are much better

336
00:06:29,070 --> 00:06:29,080
 

337
00:06:29,080 --> 00:06:32,249
so the original idea of a query

338
00:06:32,249 --> 00:06:32,259
 

339
00:06:32,259 --> 00:06:34,469
optimizer goes back you know as many

340
00:06:34,469 --> 00:06:34,479
 

341
00:06:34,479 --> 00:06:36,540
things do in databases goes back to IBM

342
00:06:36,540 --> 00:06:36,550

343
00:06:36,550 --> 00:06:38,999
system are so remember I said that in

344
00:06:38,999 --> 00:06:39,009
 

345
00:06:39,009 --> 00:06:41,010
the beginning of the semester system R

346
00:06:41,010 --> 00:06:41,020
 

347
00:06:41,020 --> 00:06:42,779
was this internal project by IBM

348
00:06:42,779 --> 00:06:42,789
 

349
00:06:42,789 --> 00:06:44,790
research down in San Jose where they

350
00:06:44,790 --> 00:06:44,800
 

351
00:06:44,800 --> 00:06:46,529
took Ted Cod's paper on the relational

352
00:06:46,529 --> 00:06:46,539
 

353
00:06:46,539 --> 00:06:48,510
model and said here let's actually try

354
00:06:48,510 --> 00:06:48,520
 

355
00:06:48,520 --> 00:06:49,439
to build a system that actually

356
00:06:49,439 --> 00:06:49,449
 

357
00:06:49,449 --> 00:06:52,140
implements this right and so Ted Cod

358
00:06:52,140 --> 00:06:52,150
 

359
00:06:52,150 --> 00:06:55,200
never actually proposed sequel he later

360
00:06:55,200 --> 00:06:55,210
 

361
00:06:55,210 --> 00:06:57,180
proposed his own declared language

362
00:06:57,180 --> 00:06:57,190
 

363
00:06:57,190 --> 00:06:58,800
called alpha but nobody ever actually

364
00:06:58,800 --> 00:06:58,810
 

365
00:06:58,810 --> 00:07:02,550
implemented so IBM came up with part of

366
00:07:02,550 --> 00:07:02,560
 

367
00:07:02,560 --> 00:07:03,659
the system our project they came out

368
00:07:03,659 --> 00:07:03,669

369
00:07:03,669 --> 00:07:05,839
with with the earliest version of sequel

370
00:07:05,839 --> 00:07:05,849
 

371
00:07:05,849 --> 00:07:09,480
so given again it's a sequel to the code

372
00:07:09,480 --> 00:07:09,490
 

373
00:07:09,490 --> 00:07:11,550
of language they then need to be be able

374
00:07:11,550 --> 00:07:11,560
 

375
00:07:11,560 --> 00:07:13,680
to take that query and actually generate

376
00:07:13,680 --> 00:07:13,690
 

377
00:07:13,690 --> 00:07:16,980
a execution plan that was that was that

378
00:07:16,980 --> 00:07:16,990
 

379
00:07:16,990 --> 00:07:20,129
was efficient so at the time in the

380
00:07:20,129 --> 00:07:20,139

381
00:07:20,139 --> 00:07:22,890
1970s people were arguing that a

382
00:07:22,890 --> 00:07:22,900
 

383
00:07:22,900 --> 00:07:25,379
database management system could never

384
00:07:25,379 --> 00:07:25,389
 

385
00:07:25,389 --> 00:07:27,659
produce a query plan as efficient and

386
00:07:27,659 --> 00:07:27,669
 

387
00:07:27,669 --> 00:07:29,790
what a human can write right so

388
00:07:29,790 --> 00:07:29,800
 

389
00:07:29,800 --> 00:07:31,290
therefore it was you know sequel is a

390
00:07:31,290 --> 00:07:31,300
 

391
00:07:31,300 --> 00:07:32,999
dumb idea or having quick knowledge was

392
00:07:32,999 --> 00:07:33,009
 

393
00:07:33,009 --> 00:07:34,050
a dumb idea because that's never gonna

394
00:07:34,050 --> 00:07:34,060

395
00:07:34,060 --> 00:07:36,629
be as good as what a human can do right

396
00:07:36,629 --> 00:07:36,639
 

397
00:07:36,639 --> 00:07:37,740
you can sort of think of this is the

398
00:07:37,740 --> 00:07:37,750
 

399
00:07:37,750 --> 00:07:38,909
same argument of having the time to

400
00:07:38,909 --> 00:07:38,919
 

401
00:07:38,919 --> 00:07:42,360
1970s about see the programming language

402
00:07:42,360 --> 00:07:42,370
 

403
00:07:42,370 --> 00:07:44,700
they argued that no human would ever be

404
00:07:44,700 --> 00:07:44,710
 

405
00:07:44,710 --> 00:07:46,050
able to write algorithms and write

406
00:07:46,050 --> 00:07:46,060
 

407
00:07:46,060 --> 00:07:49,920
applications in C and then have a query

408
00:07:49,920 --> 00:07:49,930
 

409
00:07:49,930 --> 00:07:51,890
optimizer sorry a compiler generate

410
00:07:51,890 --> 00:07:51,900
 

411
00:07:51,900 --> 00:07:55,950
execution machine code for your program

412
00:07:55,950 --> 00:07:55,960
 

413
00:07:55,960 --> 00:07:57,300
that would be as efficient what a human

414
00:07:57,300 --> 00:07:57,310
 

415
00:07:57,310 --> 00:07:59,100
could write and assembly of course

416
00:07:59,100 --> 00:07:59,110
 

417
00:07:59,110 --> 00:08:00,300
nobody writes assembling it anymore

418
00:08:00,300 --> 00:08:00,310

419
00:08:00,310 --> 00:08:02,760
right everyone relies on compilers so

420
00:08:02,760 --> 00:08:02,770
 

421
00:08:02,770 --> 00:08:04,080
it's the same argument but just in a

422
00:08:04,080 --> 00:08:04,090
 

423
00:08:04,090 --> 00:08:06,300
different context right for sequel

424
00:08:06,300 --> 00:08:06,310
 

425
00:08:06,310 --> 00:08:08,249
people argue that be better off people

426
00:08:08,249 --> 00:08:08,259
 

427
00:08:08,259 --> 00:08:10,019
writing codasyl or whatever they wanted

428
00:08:10,019 --> 00:08:10,029
 

429
00:08:10,029 --> 00:08:12,209
to do their joins themselves rather than

430
00:08:12,209 --> 00:08:12,219
 

431
00:08:12,219 --> 00:08:15,360
having a compiler figure things out so

432
00:08:15,360 --> 00:08:15,370
 

433
00:08:15,370 --> 00:08:16,980
as we go along through today we'll see

434
00:08:16,980 --> 00:08:16,990
 

435
00:08:16,990 --> 00:08:19,040
that there's been many cases where the

436
00:08:19,040 --> 00:08:19,050
 

437
00:08:19,050 --> 00:08:21,689
so the high-level concepts of what the

438
00:08:21,689 --> 00:08:21,699
 

439
00:08:21,699 --> 00:08:23,279
system our guys came up with back in the

440
00:08:23,279 --> 00:08:23,289
 

441
00:08:23,289 --> 00:08:25,769
1970s we're actually still used today

442
00:08:25,769 --> 00:08:25,779
 

443
00:08:25,779 --> 00:08:28,379
but this idea about cost based query

444
00:08:28,379 --> 00:08:28,389
 

445
00:08:28,389 --> 00:08:30,510
optimizer is sort of a key one the

446
00:08:30,510 --> 00:08:30,520
 

447
00:08:30,520 --> 00:08:31,950
algorithms may be slightly different and

448
00:08:31,950 --> 00:08:31,960
 

449
00:08:31,960 --> 00:08:33,689
some of the assumptions that IBM made in

450
00:08:33,689 --> 00:08:33,699
 

451
00:08:33,699 --> 00:08:36,569
the 1970s may not be so valid anymore

452
00:08:36,569 --> 00:08:36,579
 

453
00:08:36,579 --> 00:08:38,850
but again the core concept is exactly

454
00:08:38,850 --> 00:08:38,860
 

455
00:08:38,860 --> 00:08:41,339
the same and the woman that came up with

456
00:08:41,339 --> 00:08:41,349
 

457
00:08:41,349 --> 00:08:43,170
this at IBM Pat cell

458
00:08:43,170 --> 00:08:43,180
 

459
00:08:43,180 --> 00:08:45,300
I said system are they got like seven

460
00:08:45,300 --> 00:08:45,310
 

461
00:08:45,310 --> 00:08:47,220
people with PhDs in one room said and

462
00:08:47,220 --> 00:08:47,230
 

463
00:08:47,230 --> 00:08:48,660
they said go build a database system and

464
00:08:48,660 --> 00:08:48,670
 

465
00:08:48,670 --> 00:08:50,460
every person sort of carved off their

466
00:08:50,460 --> 00:08:50,470
 

467
00:08:50,470 --> 00:08:52,590
own piece so this one woman Pat Salinger

468
00:08:52,590 --> 00:08:52,600
 

469
00:08:52,600 --> 00:08:55,830
carved off the query optimizer part she

470
00:08:55,830 --> 00:08:55,840
 

471
00:08:55,840 --> 00:08:58,530
was at IBM for a long time she was that

472
00:08:58,530 --> 00:08:58,540
 

473
00:08:58,540 --> 00:08:59,970
sales horse and just retired and I had a

474
00:08:59,970 --> 00:08:59,980
 

475
00:08:59,980 --> 00:09:01,680
former student his class was working

476
00:09:01,680 --> 00:09:01,690
 

477
00:09:01,690 --> 00:09:03,810
with Pat Salinger took all my classes

478
00:09:03,810 --> 00:09:03,820
 

479
00:09:03,820 --> 00:09:05,580
knew about the seller generic query

480
00:09:05,580 --> 00:09:05,590
 

481
00:09:05,590 --> 00:09:07,290
optimizer and didn't put one didn't put

482
00:09:07,290 --> 00:09:07,300
 

483
00:09:07,300 --> 00:09:08,790
one one together that the woman she was

484
00:09:08,790 --> 00:09:08,800
 

485
00:09:08,800 --> 00:09:10,320
working with us the same woman we would

486
00:09:10,320 --> 00:09:10,330
 

487
00:09:10,330 --> 00:09:14,010
study in this class so she's still

488
00:09:14,010 --> 00:09:14,020
 

489
00:09:14,020 --> 00:09:15,390
around today and she has a lot done a

490
00:09:15,390 --> 00:09:15,400
 

491
00:09:15,400 --> 00:09:19,530
lot of great work in this area so for

492
00:09:19,530 --> 00:09:19,540
 

493
00:09:19,540 --> 00:09:21,510
query optimization we're basically going

494
00:09:21,510 --> 00:09:21,520

495
00:09:21,520 --> 00:09:24,210
to have two approaches the first it's

496
00:09:24,210 --> 00:09:24,220
 

497
00:09:24,220 --> 00:09:26,640
going to be using heuristics or rules

498
00:09:26,640 --> 00:09:26,650
 

499
00:09:26,650 --> 00:09:30,210
written by us as humans to do some

500
00:09:30,210 --> 00:09:30,220
 

501
00:09:30,220 --> 00:09:33,240
massaging of the query plan to apply

502
00:09:33,240 --> 00:09:33,250
 

503
00:09:33,250 --> 00:09:35,850
some some obvious options or fix some

504
00:09:35,850 --> 00:09:35,860
 

505
00:09:35,860 --> 00:09:37,590
obvious inefficiencies and apply some

506
00:09:37,590 --> 00:09:37,600
 

507
00:09:37,600 --> 00:09:40,620
some simple optimizations right so the

508
00:09:40,620 --> 00:09:40,630
 

509
00:09:40,630 --> 00:09:42,870
idea would be you have your query shows

510
00:09:42,870 --> 00:09:42,880
 

511
00:09:42,880 --> 00:09:44,340
up and you do some line a rewriting of

512
00:09:44,340 --> 00:09:44,350
 

513
00:09:44,350 --> 00:09:46,590
the syntax tree you never operate

514
00:09:46,590 --> 00:09:46,600
 

515
00:09:46,600 --> 00:09:48,840
directly on the sequel and the idea is

516
00:09:48,840 --> 00:09:48,850
 

517
00:09:48,850 --> 00:09:50,280
that we there are certain things we know

518
00:09:50,280 --> 00:09:50,290
 

519
00:09:50,290 --> 00:09:52,320
we're always going to want to do to make

520
00:09:52,320 --> 00:09:52,330
 

521
00:09:52,330 --> 00:09:54,000
the query run faster so we just have

522
00:09:54,000 --> 00:09:54,010
 

523
00:09:54,010 --> 00:09:55,380
rules to go ahead and just do them

524
00:09:55,380 --> 00:09:55,390
 

525
00:09:55,390 --> 00:09:58,110
before we go into the second phase we're

526
00:09:58,110 --> 00:09:58,120
 

527
00:09:58,120 --> 00:09:59,520
actually now we do a cost-based search

528
00:09:59,520 --> 00:09:59,530
 

529
00:09:59,530 --> 00:10:01,620
so the second phase is where we're gonna

530
00:10:01,620 --> 00:10:01,630
 

531
00:10:01,630 --> 00:10:03,540
say all right we know how to think need

532
00:10:03,540 --> 00:10:03,550
 

533
00:10:03,550 --> 00:10:04,650
to figure out other things about our

534
00:10:04,650 --> 00:10:04,660
 

535
00:10:04,660 --> 00:10:07,020
query plan and I don't have rules that I

536
00:10:07,020 --> 00:10:07,030
 

537
00:10:07,030 --> 00:10:08,760
can apply to say here's exactly what

538
00:10:08,760 --> 00:10:08,770
 

539
00:10:08,770 --> 00:10:09,720
you're always going to want to do

540
00:10:09,720 --> 00:10:09,730
 

541
00:10:09,730 --> 00:10:12,420
because it's the the choices you'll make

542
00:10:12,420 --> 00:10:12,430
 

543
00:10:12,430 --> 00:10:14,220
will depend on what your data looks like

544
00:10:14,220 --> 00:10:14,230
 

545
00:10:14,230 --> 00:10:15,870
and I'll explain what that means in a

546
00:10:15,870 --> 00:10:15,880
 

547
00:10:15,880 --> 00:10:19,230
second and so we do a search to find

548
00:10:19,230 --> 00:10:19,240
 

549
00:10:19,240 --> 00:10:21,600
what it would be what is an optimal

550
00:10:21,600 --> 00:10:21,610
 

551
00:10:21,610 --> 00:10:25,110
query plan for our query right the idea

552
00:10:25,110 --> 00:10:25,120
 

553
00:10:25,120 --> 00:10:26,190
here is that we're gonna have this cost

554
00:10:26,190 --> 00:10:26,200
 

555
00:10:26,200 --> 00:10:29,160
model say given to potential query plans

556
00:10:29,160 --> 00:10:29,170
 

557
00:10:29,170 --> 00:10:31,590
for a single sequel statement which one

558
00:10:31,590 --> 00:10:31,600
 

559
00:10:31,600 --> 00:10:32,820
is actually better in terms of

560
00:10:32,820 --> 00:10:32,830
 

561
00:10:32,830 --> 00:10:36,930
performance so just to understand the

562
00:10:36,930 --> 00:10:36,940
 

563
00:10:36,940 --> 00:10:39,780
sort of pipeline it is in a real system

564
00:10:39,780 --> 00:10:39,790
 

565
00:10:39,790 --> 00:10:41,700
at a high level it would look like this

566
00:10:41,700 --> 00:10:41,710
 

567
00:10:41,710 --> 00:10:44,070
so your application Smith so sequel

568
00:10:44,070 --> 00:10:44,080
 

569
00:10:44,080 --> 00:10:46,230
query and the first step is that it

570
00:10:46,230 --> 00:10:46,240
 

571
00:10:46,240 --> 00:10:48,290
always goes through a sequel parser

572
00:10:48,290 --> 00:10:48,300
 

573
00:10:48,300 --> 00:10:50,640
alright and the sequel parse is gonna

574
00:10:50,640 --> 00:10:50,650
 

575
00:10:50,650 --> 00:10:52,380
then convert it into an abstract syntax

576
00:10:52,380 --> 00:10:52,390
 

577
00:10:52,390 --> 00:10:55,200
tree alright it breaks up the tokens and

578
00:10:55,200 --> 00:10:55,210
 

579
00:10:55,210 --> 00:10:56,280
you know the Select statements of where

580
00:10:56,280 --> 00:10:56,290
 

581
00:10:56,290 --> 00:10:56,730
clauses

582
00:10:56,730 --> 00:10:56,740
 

583
00:10:56,740 --> 00:10:59,670
and getting gives you this tree but

584
00:10:59,670 --> 00:10:59,680
 

585
00:10:59,680 --> 00:11:01,920
inside this tree now all we have are

586
00:11:01,920 --> 00:11:01,930

587
00:11:01,930 --> 00:11:04,950
just the strings or the names of the

588
00:11:04,950 --> 00:11:04,960
 

589
00:11:04,960 --> 00:11:06,300
things that were in the sequel statement

590
00:11:06,300 --> 00:11:06,310

591
00:11:06,310 --> 00:11:09,180
like select star from table foo right in

592
00:11:09,180 --> 00:11:09,190
 

593
00:11:09,190 --> 00:11:10,650
our syntax tree at this point we just

594
00:11:10,650 --> 00:11:10,660
 

595
00:11:10,660 --> 00:11:12,420
have you know the string foo we don't

596
00:11:12,420 --> 00:11:12,430
 

597
00:11:12,430 --> 00:11:14,100
know anything about it we don't know

598
00:11:14,100 --> 00:11:14,110
 

599
00:11:14,110 --> 00:11:15,660
that it corresponds to a particular

600
00:11:15,660 --> 00:11:15,670
 

601
00:11:15,670 --> 00:11:20,070
table so in the binder phase we go do

602
00:11:20,070 --> 00:11:20,080
 

603
00:11:20,080 --> 00:11:22,200
lookups in our internal system catalog

604
00:11:22,200 --> 00:11:22,210
 

605
00:11:22,210 --> 00:11:24,360
about the database it's the metadata

606
00:11:24,360 --> 00:11:24,370
 

607
00:11:24,370 --> 00:11:26,430
about the data what tables do I have

608
00:11:26,430 --> 00:11:26,440
 

609
00:11:26,440 --> 00:11:28,260
what columns do I have what index do I

610
00:11:28,260 --> 00:11:28,270

611
00:11:28,270 --> 00:11:30,420
have things like that and it's gonna map

612
00:11:30,420 --> 00:11:30,430
 

613
00:11:30,430 --> 00:11:32,970
the the names that are in the strings

614
00:11:32,970 --> 00:11:32,980
 

615
00:11:32,980 --> 00:11:34,980
that are in an abstract syntax tree to

616
00:11:34,980 --> 00:11:34,990
 

617
00:11:34,990 --> 00:11:38,040
internal identifiers I just think of

618
00:11:38,040 --> 00:11:38,050
 

619
00:11:38,050 --> 00:11:40,470
like it's a you know internal ID number

620
00:11:40,470 --> 00:11:40,480
 

621
00:11:40,480 --> 00:11:44,310
for a particular table and then we feed

622
00:11:44,310 --> 00:11:44,320
 

623
00:11:44,320 --> 00:11:46,530
now this annotated abstracts index tree

624
00:11:46,530 --> 00:11:46,540
 

625
00:11:46,540 --> 00:11:50,550
to this query rewriter the thing I

626
00:11:50,550 --> 00:11:50,560
 

627
00:11:50,560 --> 00:11:52,140
showed in the first step in the previous

628
00:11:52,140 --> 00:11:52,150
 

629
00:11:52,150 --> 00:11:54,690
slide where we can apply some rules that

630
00:11:54,690 --> 00:11:54,700
 

631
00:11:54,700 --> 00:11:56,580
we that we know we're always gonna want

632
00:11:56,580 --> 00:11:56,590
 

633
00:11:56,590 --> 00:12:00,120
to apply to our query plan to to to make

634
00:12:00,120 --> 00:12:00,130
 

635
00:12:00,130 --> 00:12:01,710
it go faster make the query run faster

636
00:12:01,710 --> 00:12:01,720
 

637
00:12:01,720 --> 00:12:04,020
and I'll show examples of what that is

638
00:12:04,020 --> 00:12:04,030
 

639
00:12:04,030 --> 00:12:06,180
as we go along so not every single

640
00:12:06,180 --> 00:12:06,190
 

641
00:12:06,190 --> 00:12:07,710
database system has this right you can

642
00:12:07,710 --> 00:12:07,720
 

643
00:12:07,720 --> 00:12:09,360
still just have a query optimizer

644
00:12:09,360 --> 00:12:09,370
 

645
00:12:09,370 --> 00:12:12,420
without this initial step but this is

646
00:12:12,420 --> 00:12:12,430
 

647
00:12:12,430 --> 00:12:15,150
actually very common in most systems and

648
00:12:15,150 --> 00:12:15,160
 

649
00:12:15,160 --> 00:12:17,850
then in the last step when we take the

650
00:12:17,850 --> 00:12:17,860
 

651
00:12:17,860 --> 00:12:20,370
output of the the rewriter and feed this

652
00:12:20,370 --> 00:12:20,380
 

653
00:12:20,380 --> 00:12:22,680
into our cost based query optimizer I

654
00:12:22,680 --> 00:12:22,690
 

655
00:12:22,690 --> 00:12:24,570
can think of this is doing like an

656
00:12:24,570 --> 00:12:24,580
 

657
00:12:24,580 --> 00:12:26,730
optimization search looking at different

658
00:12:26,730 --> 00:12:26,740
 

659
00:12:26,740 --> 00:12:28,200
query plans getting information about

660
00:12:28,200 --> 00:12:28,210
 

661
00:12:28,210 --> 00:12:30,840
the what the tables look like from the

662
00:12:30,840 --> 00:12:30,850
 

663
00:12:30,850 --> 00:12:32,820
catalog and then using some kind of

664
00:12:32,820 --> 00:12:32,830
 

665
00:12:32,830 --> 00:12:34,950
internal cost model to say here's the

666
00:12:34,950 --> 00:12:34,960

667
00:12:34,960 --> 00:12:36,540
but here's the potential runtime cost of

668
00:12:36,540 --> 00:12:36,550

669
00:12:36,550 --> 00:12:38,940
exiting this query plan the idea is you

670
00:12:38,940 --> 00:12:38,950
 

671
00:12:38,950 --> 00:12:40,470
want you want to be able to examine as

672
00:12:40,470 --> 00:12:40,480
 

673
00:12:40,480 --> 00:12:42,510
many query plans as possible within

674
00:12:42,510 --> 00:12:42,520
 

675
00:12:42,520 --> 00:12:44,100
either you know sort of some kind of

676
00:12:44,100 --> 00:12:44,110
 

677
00:12:44,110 --> 00:12:45,780
budget like in terms of time or the

678
00:12:45,780 --> 00:12:45,790
 

679
00:12:45,790 --> 00:12:47,970
number thermal plans you investigate and

680
00:12:47,970 --> 00:12:47,980
 

681
00:12:47,980 --> 00:12:49,620
then whatever which one is the best one

682
00:12:49,620 --> 00:12:49,630
 

683
00:12:49,630 --> 00:12:51,600
you've ever seen that's the one you'll

684
00:12:51,600 --> 00:12:51,610

685
00:12:51,610 --> 00:12:53,430
spit out as the final query plan for

686
00:12:53,430 --> 00:12:53,440
 

687
00:12:53,440 --> 00:12:56,640
this query so as we see as we go along

688
00:12:56,640 --> 00:12:56,650
 

689
00:12:56,650 --> 00:13:00,510
the the the optimizer is actually not

690
00:13:00,510 --> 00:13:00,520
 

691
00:13:00,520 --> 00:13:02,790
always going to pick the globally

692
00:13:02,790 --> 00:13:02,800
 

693
00:13:02,800 --> 00:13:05,040
optimal plan right because that would

694
00:13:05,040 --> 00:13:05,050
 

695
00:13:05,050 --> 00:13:07,170
actually be really expensive so it's

696
00:13:07,170 --> 00:13:07,180
 

697
00:13:07,180 --> 00:13:09,930
going to try to use

698
00:13:09,930 --> 00:13:09,940
 

699
00:13:09,940 --> 00:13:12,390
methods to prune down the search base so

700
00:13:12,390 --> 00:13:12,400
 

701
00:13:12,400 --> 00:13:14,270
that can generate a good enough plan

702
00:13:14,270 --> 00:13:14,280
 

703
00:13:14,280 --> 00:13:18,000
within a regional amount of time so I

704
00:13:18,000 --> 00:13:18,010
 

705
00:13:18,010 --> 00:13:19,230
say this in the beginning I'll say it

706
00:13:19,230 --> 00:13:19,240
 

707
00:13:19,240 --> 00:13:21,480
again this is actually really hard to do

708
00:13:21,480 --> 00:13:21,490
 

709
00:13:21,490 --> 00:13:24,990
so the joke in in databases is that if

710
00:13:24,990 --> 00:13:25,000
 

711
00:13:25,000 --> 00:13:27,030
you try to do query optimization and you

712
00:13:27,030 --> 00:13:27,040
 

713
00:13:27,040 --> 00:13:29,640
fail the fallback plan is you go work on

714
00:13:29,640 --> 00:13:29,650
 

715
00:13:29,650 --> 00:13:31,500
rocket science right because query

716
00:13:31,500 --> 00:13:31,510
 

717
00:13:31,510 --> 00:13:32,670
optimization is harder than building

718
00:13:32,670 --> 00:13:32,680

719
00:13:32,680 --> 00:13:35,940
rockets this is again this is the

720
00:13:35,940 --> 00:13:35,950
 

721
00:13:35,950 --> 00:13:38,160
hardest part about building any database

722
00:13:38,160 --> 00:13:38,170
 

723
00:13:38,170 --> 00:13:40,350
minute system this is part of the reason

724
00:13:40,350 --> 00:13:40,360
 

725
00:13:40,360 --> 00:13:42,300
why a lot of the no sequel guys didn't

726
00:13:42,300 --> 00:13:42,310
 

727
00:13:42,310 --> 00:13:43,920
end up using sequel in the first place

728
00:13:43,920 --> 00:13:43,930
 

729
00:13:43,930 --> 00:13:46,590
because if you have sequel then you need

730
00:13:46,590 --> 00:13:46,600

731
00:13:46,600 --> 00:13:48,660
some kind of query optimizer this is

732
00:13:48,660 --> 00:13:48,670
 

733
00:13:48,670 --> 00:13:49,800
hard to do it's hard to get right

734
00:13:49,800 --> 00:13:49,810
 

735
00:13:49,810 --> 00:13:50,850
there's all these different corner cases

736
00:13:50,850 --> 00:13:50,860
 

737
00:13:50,860 --> 00:13:54,300
a seed will expand the do you have

738
00:13:54,300 --> 00:13:54,310
 

739
00:13:54,310 --> 00:13:56,280
nested queries and other things this is

740
00:13:56,280 --> 00:13:56,290
 

741
00:13:56,290 --> 00:14:01,740
really hard to get right the one thing I

742
00:14:01,740 --> 00:14:01,750
 

743
00:14:01,750 --> 00:14:03,570
will say also too is that if you're good

744
00:14:03,570 --> 00:14:03,580
 

745
00:14:03,580 --> 00:14:04,890
at this if you really like query

746
00:14:04,890 --> 00:14:04,900
 

747
00:14:04,900 --> 00:14:06,870
optimization you will have no problem

748
00:14:06,870 --> 00:14:06,880
 

749
00:14:06,880 --> 00:14:08,700
getting a job so I have friends and

750
00:14:08,700 --> 00:14:08,710
 

751
00:14:08,710 --> 00:14:09,870
various database companies and they

752
00:14:09,870 --> 00:14:09,880

753
00:14:09,880 --> 00:14:11,670
email me asking for you know what

754
00:14:11,670 --> 00:14:11,680
 

755
00:14:11,680 --> 00:14:12,900
students are looking to graduate looking

756
00:14:12,900 --> 00:14:12,910
 

757
00:14:12,910 --> 00:14:14,820
for jobs they have one thing I always

758
00:14:14,820 --> 00:14:14,830
 

759
00:14:14,830 --> 00:14:15,990
get is like yeah we want database

760
00:14:15,990 --> 00:14:16,000
 

761
00:14:16,000 --> 00:14:17,250
students but do we really want anybody

762
00:14:17,250 --> 00:14:17,260
 

763
00:14:17,260 --> 00:14:18,840
that knows query optimization so if

764
00:14:18,840 --> 00:14:18,850
 

765
00:14:18,850 --> 00:14:20,310
you're good at this you can have no

766
00:14:20,310 --> 00:14:20,320
 

767
00:14:20,320 --> 00:14:21,420
problem getting paid a lot of money

768
00:14:21,420 --> 00:14:21,430
 

769
00:14:21,430 --> 00:14:23,640
because when you think about it you know

770
00:14:23,640 --> 00:14:23,650
 

771
00:14:23,650 --> 00:14:25,500
what like 22 year old kid coming out of

772
00:14:25,500 --> 00:14:25,510

773
00:14:25,510 --> 00:14:27,030
grad school or undergraduate program has

774
00:14:27,030 --> 00:14:27,040
 

775
00:14:27,040 --> 00:14:29,400
experience in query optimizers right

776
00:14:29,400 --> 00:14:29,410
 

777
00:14:29,410 --> 00:14:31,380
it's like crusty old guys from the 1990s

778
00:14:31,380 --> 00:14:31,390
 

779
00:14:31,390 --> 00:14:33,390
and they don't really want to you know

780
00:14:33,390 --> 00:14:33,400
 

781
00:14:33,400 --> 00:14:34,710
move maybe to it like a startup and

782
00:14:34,710 --> 00:14:34,720
 

783
00:14:34,720 --> 00:14:36,330
things like that so this is the one

784
00:14:36,330 --> 00:14:36,340
 

785
00:14:36,340 --> 00:14:37,650
thing that that david's companies are

786
00:14:37,650 --> 00:14:37,660
 

787
00:14:37,660 --> 00:14:40,650
really really interested in so as we go

788
00:14:40,650 --> 00:14:40,660

789
00:14:40,660 --> 00:14:42,270
along i imagine and talked about various

790
00:14:42,270 --> 00:14:42,280
 

791
00:14:42,280 --> 00:14:43,710
problems we have to solve in our query

792
00:14:43,710 --> 00:14:43,720
 

793
00:14:43,720 --> 00:14:46,260
optimizer a lot even be saying in the

794
00:14:46,260 --> 00:14:46,270
 

795
00:14:46,270 --> 00:14:46,890
back of your mind

796
00:14:46,890 --> 00:14:46,900

797
00:14:46,900 --> 00:14:48,840
Oh can't machine learning solve this you

798
00:14:48,840 --> 00:14:48,850
 

799
00:14:48,850 --> 00:14:50,370
know can't can I use AI to make this all

800
00:14:50,370 --> 00:14:50,380
 

801
00:14:50,380 --> 00:14:53,870
go away make it much easier yes but no

802
00:14:53,870 --> 00:14:53,880
 

803
00:14:53,880 --> 00:14:56,790
there has been some early research in

804
00:14:56,790 --> 00:14:56,800
 

805
00:14:56,800 --> 00:14:58,440
the last one or two years of looking at

806
00:14:58,440 --> 00:14:58,450
 

807
00:14:58,450 --> 00:15:02,610
using machine learning to to improve the

808
00:15:02,610 --> 00:15:02,620

809
00:15:02,620 --> 00:15:05,580
accuracy or improve the the quality of

810
00:15:05,580 --> 00:15:05,590
 

811
00:15:05,590 --> 00:15:07,440
the query plans that the optimizer

812
00:15:07,440 --> 00:15:07,450
 

813
00:15:07,450 --> 00:15:10,170
generates but as far as they know no you

814
00:15:10,170 --> 00:15:10,180
 

815
00:15:10,180 --> 00:15:11,700
know this is still early work and no

816
00:15:11,700 --> 00:15:11,710
 

817
00:15:11,710 --> 00:15:13,050
major gated system actually supports

818
00:15:13,050 --> 00:15:13,060
 

819
00:15:13,060 --> 00:15:16,140
this persico's has a genetic algorithm

820
00:15:16,140 --> 00:15:16,150
 

821
00:15:16,150 --> 00:15:18,390
based query optimizer that if you try to

822
00:15:18,390 --> 00:15:18,400
 

823
00:15:18,400 --> 00:15:20,400
do joins with more than 13 queries then

824
00:15:20,400 --> 00:15:20,410
 

825
00:15:20,410 --> 00:15:22,350
it falls back to that to the genetic

826
00:15:22,350 --> 00:15:22,360
 

827
00:15:22,360 --> 00:15:23,370
algorithm but

828
00:15:23,370 --> 00:15:23,380
 

829
00:15:23,380 --> 00:15:24,660
what will describe today is basically

830
00:15:24,660 --> 00:15:24,670
 

831
00:15:24,670 --> 00:15:26,960
how most most systems actually do this

832
00:15:26,960 --> 00:15:26,970
 

833
00:15:26,970 --> 00:15:30,120
on a sale so two for the apply machine

834
00:15:30,120 --> 00:15:30,130
 

835
00:15:30,130 --> 00:15:31,980
learning to krauser is actually

836
00:15:31,980 --> 00:15:31,990
 

837
00:15:31,990 --> 00:15:33,300
something we're interested at here at

838
00:15:33,300 --> 00:15:33,310
 

839
00:15:33,310 --> 00:15:35,820
CMU we do have students looking looking

840
00:15:35,820 --> 00:15:35,830
 

841
00:15:35,830 --> 00:15:37,620
into this now but it's still very early

842
00:15:37,620 --> 00:15:37,630
 

843
00:15:37,630 --> 00:15:39,660
I love query optimization so much again

844
00:15:39,660 --> 00:15:39,670
 

845
00:15:39,670 --> 00:15:42,000
I'm really bad at it and it just makes

846
00:15:42,000 --> 00:15:42,010
 

847
00:15:42,010 --> 00:15:43,530
me want to do it even more so I get

848
00:15:43,530 --> 00:15:43,540
 

849
00:15:43,540 --> 00:15:45,510
better at it so in the advanced class

850
00:15:45,510 --> 00:15:45,520
 

851
00:15:45,520 --> 00:15:47,700
you know previous year to already spend

852
00:15:47,700 --> 00:15:47,710
 

853
00:15:47,710 --> 00:15:49,680
two weeks on query optimizers and cost

854
00:15:49,680 --> 00:15:49,690
 

855
00:15:49,690 --> 00:15:51,300
models but if you take the advanced

856
00:15:51,300 --> 00:15:51,310
 

857
00:15:51,310 --> 00:15:52,830
class this spring I probably add another

858
00:15:52,830 --> 00:15:52,840
 

859
00:15:52,840 --> 00:15:54,900
week to go over you know more complex

860
00:15:54,900 --> 00:15:54,910
 

861
00:15:54,910 --> 00:15:57,060
scenarios right we build our own query

862
00:15:57,060 --> 00:15:57,070
 

863
00:15:57,070 --> 00:15:58,920
optimizer from scratch here at CMU and

864
00:15:58,920 --> 00:15:58,930
 

865
00:15:58,930 --> 00:16:03,230
we just very used in making it better

866
00:16:03,230 --> 00:16:03,240
 

867
00:16:03,240 --> 00:16:06,120
okay so for today's class we're going to

868
00:16:06,120 --> 00:16:06,130
 

869
00:16:06,130 --> 00:16:08,730
talk about we're gonna have sort of four

870
00:16:08,730 --> 00:16:08,740
 

871
00:16:08,740 --> 00:16:10,050
parts talking about different query

872
00:16:10,050 --> 00:16:10,060
 

873
00:16:10,060 --> 00:16:11,910
optimization steps we have to do so

874
00:16:11,910 --> 00:16:11,920
 

875
00:16:11,920 --> 00:16:12,870
we'll talk about how to do relational

876
00:16:12,870 --> 00:16:12,880
 

877
00:16:12,880 --> 00:16:14,550
algebra Linc's to do the rewriting that

878
00:16:14,550 --> 00:16:14,560
 

879
00:16:14,560 --> 00:16:16,410
we talked about before then we'll do

880
00:16:16,410 --> 00:16:16,420
 

881
00:16:16,420 --> 00:16:18,150
plan cost estimation how do you actually

882
00:16:18,150 --> 00:16:18,160

883
00:16:18,160 --> 00:16:20,670
say for a potential query plan how many

884
00:16:20,670 --> 00:16:20,680
 

885
00:16:20,680 --> 00:16:22,620
tuples how much disk am I gonna have to

886
00:16:22,620 --> 00:16:22,630
 

887
00:16:22,630 --> 00:16:24,990
read to make it make it execute it then

888
00:16:24,990 --> 00:16:25,000

889
00:16:25,000 --> 00:16:26,250
we'll talk about how to do enumeration

890
00:16:26,250 --> 00:16:26,260
 

891
00:16:26,260 --> 00:16:27,900
or searching for different query plans

892
00:16:27,900 --> 00:16:27,910
 

893
00:16:27,910 --> 00:16:29,420
and sort of build up a query plan

894
00:16:29,420 --> 00:16:29,430
 

895
00:16:29,430 --> 00:16:31,770
holistically and look at the cost at

896
00:16:31,770 --> 00:16:31,780

897
00:16:31,780 --> 00:16:33,630
each step and then we'll talk about how

898
00:16:33,630 --> 00:16:33,640
 

899
00:16:33,640 --> 00:16:35,400
to do the two to two ways you can do

900
00:16:35,400 --> 00:16:35,410
 

901
00:16:35,410 --> 00:16:36,750
optimization with nested queries and

902
00:16:36,750 --> 00:16:36,760

903
00:16:36,760 --> 00:16:38,670
we'll finish up talking about again the

904
00:16:38,670 --> 00:16:38,680
 

905
00:16:38,680 --> 00:16:41,310
the remaining times going over the the

906
00:16:41,310 --> 00:16:41,320
 

907
00:16:41,320 --> 00:16:44,280
midterm at a high level okay okay

908
00:16:44,280 --> 00:16:44,290
 

909
00:16:44,290 --> 00:16:44,810
awesome

910
00:16:44,810 --> 00:16:44,820
 

911
00:16:44,820 --> 00:16:49,650
all right so we didn't really mention

912
00:16:49,650 --> 00:16:49,660
 

913
00:16:49,660 --> 00:16:51,450
this in the beginning of the semester

914
00:16:51,450 --> 00:16:51,460
 

915
00:16:51,460 --> 00:16:53,090
when we talk about relational algebra

916
00:16:53,090 --> 00:16:53,100
 

917
00:16:53,100 --> 00:16:58,350
but the the high-level idea is that what

918
00:16:58,350 --> 00:16:58,360
 

919
00:16:58,360 --> 00:16:59,280
we're gonna try to do this in this

920
00:16:59,280 --> 00:16:59,290
 

921
00:16:59,290 --> 00:17:01,980
rewriting step is a query is going to

922
00:17:01,980 --> 00:17:01,990
 

923
00:17:01,990 --> 00:17:04,080
show up will generate the relational

924
00:17:04,080 --> 00:17:04,090

925
00:17:04,090 --> 00:17:06,330
algebra from from from the abstract

926
00:17:06,330 --> 00:17:06,340
 

927
00:17:06,340 --> 00:17:08,970
syntax tree and then because of rules we

928
00:17:08,970 --> 00:17:08,980
 

929
00:17:08,980 --> 00:17:12,240
know about the relational algebra to

930
00:17:12,240 --> 00:17:12,250
 

931
00:17:12,250 --> 00:17:14,610
determine you know to permute the

932
00:17:14,610 --> 00:17:14,620
 

933
00:17:14,620 --> 00:17:16,290
expression and still have them be

934
00:17:16,290 --> 00:17:16,300

935
00:17:16,300 --> 00:17:18,750
equivalent with the with each other we

936
00:17:18,750 --> 00:17:18,760
 

937
00:17:18,760 --> 00:17:20,670
can apply certain rules to generate a

938
00:17:20,670 --> 00:17:20,680
 

939
00:17:20,680 --> 00:17:22,800
more optimal query plan that way and

940
00:17:22,800 --> 00:17:22,810

941
00:17:22,810 --> 00:17:25,200
this has nothing to do with what my data

942
00:17:25,200 --> 00:17:25,210
 

943
00:17:25,210 --> 00:17:26,880
looks like these are just general rules

944
00:17:26,880 --> 00:17:26,890
 

945
00:17:26,890 --> 00:17:28,380
that we can apply for every single query

946
00:17:28,380 --> 00:17:28,390
 

947
00:17:28,390 --> 00:17:29,940
because it's always going to be the the

948
00:17:29,940 --> 00:17:29,950
 

949
00:17:29,950 --> 00:17:31,320
almost always going to be the right

950
00:17:31,320 --> 00:17:31,330
 

951
00:17:31,330 --> 00:17:34,590
thing to do and so the idea here is that

952
00:17:34,590 --> 00:17:34,600
 

953
00:17:34,600 --> 00:17:36,060
this can be done efficiently we just

954
00:17:36,060 --> 00:17:36,070
 

955
00:17:36,070 --> 00:17:38,060
have some

956
00:17:38,060 --> 00:17:38,070

957
00:17:38,070 --> 00:17:40,500
some sort of a rule engine that can

958
00:17:40,500 --> 00:17:40,510
 

959
00:17:40,510 --> 00:17:42,570
check patterns in our in our index tree

960
00:17:42,570 --> 00:17:42,580
 

961
00:17:42,580 --> 00:17:44,910
to see whether we have matches and if we

962
00:17:44,910 --> 00:17:44,920
 

963
00:17:44,920 --> 00:17:46,380
have matches then we can easily apply

964
00:17:46,380 --> 00:17:46,390
 

965
00:17:46,390 --> 00:17:51,660
apply those rules and modify the tree so

966
00:17:51,660 --> 00:17:51,670
 

967
00:17:51,670 --> 00:17:53,010
give me example what I mean I'll go say

968
00:17:53,010 --> 00:17:53,020
 

969
00:17:53,020 --> 00:17:55,830
we have a simple join on the student

970
00:17:55,830 --> 00:17:55,840
 

971
00:17:55,840 --> 00:17:59,010
table in the enroll table right and the

972
00:17:59,010 --> 00:17:59,020
 

973
00:17:59,020 --> 00:18:00,720
so we have our join predicate on the

974
00:18:00,720 --> 00:18:00,730
 

975
00:18:00,730 --> 00:18:02,370
student ID in the student table in the

976
00:18:02,370 --> 00:18:02,380
 

977
00:18:02,380 --> 00:18:03,780
role table and then we have an

978
00:18:03,780 --> 00:18:03,790

979
00:18:03,790 --> 00:18:06,390
additional predicate on the on the on

980
00:18:06,390 --> 00:18:06,400
 

981
00:18:06,400 --> 00:18:09,330
the enrolled grade and so the if you

982
00:18:09,330 --> 00:18:09,340

983
00:18:09,340 --> 00:18:11,910
just take the the sequel and I must

984
00:18:11,910 --> 00:18:11,920
 

985
00:18:11,920 --> 00:18:14,430
generate exactly the the relational

986
00:18:14,430 --> 00:18:14,440

987
00:18:14,440 --> 00:18:16,110
algebra put this you would end up with a

988
00:18:16,110 --> 00:18:16,120
 

989
00:18:16,120 --> 00:18:19,020
query plan that looks like this right

990
00:18:19,020 --> 00:18:19,030
 

991
00:18:19,030 --> 00:18:21,330
but what's one obvious thing we can do

992
00:18:21,330 --> 00:18:21,340
 

993
00:18:21,340 --> 00:18:28,710
to optimize this query yes exactly check

994
00:18:28,710 --> 00:18:28,720
 

995
00:18:28,720 --> 00:18:29,760
the predicate except to check the

996
00:18:29,760 --> 00:18:29,770
 

997
00:18:29,770 --> 00:18:30,630
predicate before we join

998
00:18:30,630 --> 00:18:30,640

999
00:18:30,640 --> 00:18:32,790
so we have our filter on grade-a here

1000
00:18:32,790 --> 00:18:32,800
 

1001
00:18:32,800 --> 00:18:34,919
but we're doing that after we do the

1002
00:18:34,919 --> 00:18:34,929
 

1003
00:18:34,929 --> 00:18:37,830
join so again always try to think in

1004
00:18:37,830 --> 00:18:37,840
 

1005
00:18:37,840 --> 00:18:40,310
terms of extreme numbers to see you know

1006
00:18:40,310 --> 00:18:40,320
 

1007
00:18:40,320 --> 00:18:42,120
how something would actually affect

1008
00:18:42,120 --> 00:18:42,130
 

1009
00:18:42,130 --> 00:18:42,690
performance

1010
00:18:42,690 --> 00:18:42,700

1011
00:18:42,700 --> 00:18:45,960
so say we have a billion records in the

1012
00:18:45,960 --> 00:18:45,970
 

1013
00:18:45,970 --> 00:18:48,660
enroll table and only two people got an

1014
00:18:48,660 --> 00:18:48,670
 

1015
00:18:48,670 --> 00:18:51,600
A in the entire university right so that

1016
00:18:51,600 --> 00:18:51,610
 

1017
00:18:51,610 --> 00:18:53,760
means that when we feed this data into

1018
00:18:53,760 --> 00:18:53,770
 

1019
00:18:53,770 --> 00:18:56,040
this joint operator we would do a join

1020
00:18:56,040 --> 00:18:56,050
 

1021
00:18:56,050 --> 00:18:57,570
on one billion two books from the enroll

1022
00:18:57,570 --> 00:18:57,580
 

1023
00:18:57,580 --> 00:18:59,760
table then we have 1 billion two was

1024
00:18:59,760 --> 00:18:59,770
 

1025
00:18:59,770 --> 00:19:01,650
come as the output which is fed into now

1026
00:19:01,650 --> 00:19:01,660
 

1027
00:19:01,660 --> 00:19:04,350
the filter operator but then we're gonna

1028
00:19:04,350 --> 00:19:04,360
 

1029
00:19:04,360 --> 00:19:06,390
go now check we're you know grade equals

1030
00:19:06,390 --> 00:19:06,400
 

1031
00:19:06,400 --> 00:19:07,680
a but that's only gonna match to two

1032
00:19:07,680 --> 00:19:07,690
 

1033
00:19:07,690 --> 00:19:09,870
pools so we did a join on the billion

1034
00:19:09,870 --> 00:19:09,880
 

1035
00:19:09,880 --> 00:19:12,480
tuples where all but two of them is just

1036
00:19:12,480 --> 00:19:12,490
 

1037
00:19:12,490 --> 00:19:13,980
wasted work because it's not gonna get

1038
00:19:13,980 --> 00:19:13,990
 

1039
00:19:13,990 --> 00:19:17,760
produced as the output to to the user so

1040
00:19:17,760 --> 00:19:17,770
 

1041
00:19:17,770 --> 00:19:19,860
a simple optimization we can apply here

1042
00:19:19,860 --> 00:19:19,870
 

1043
00:19:19,870 --> 00:19:21,330
is called projection push sorry

1044
00:19:21,330 --> 00:19:21,340
 

1045
00:19:21,340 --> 00:19:23,790
predicate push down where we just moved

1046
00:19:23,790 --> 00:19:23,800

1047
00:19:23,800 --> 00:19:26,970
down the the filter operator to be below

1048
00:19:26,970 --> 00:19:26,980
 

1049
00:19:26,980 --> 00:19:30,240
the join all right this is sort of like

1050
00:19:30,240 --> 00:19:30,250
 

1051
00:19:30,250 --> 00:19:31,890
a no-brainer I'm always going to want to

1052
00:19:31,890 --> 00:19:31,900
 

1053
00:19:31,900 --> 00:19:34,320
do this so when you look at now the

1054
00:19:34,320 --> 00:19:34,330
 

1055
00:19:34,330 --> 00:19:35,730
relation out row for these two different

1056
00:19:35,730 --> 00:19:35,740
 

1057
00:19:35,740 --> 00:19:38,040
query plans week again we know that

1058
00:19:38,040 --> 00:19:38,050
 

1059
00:19:38,050 --> 00:19:40,530
they're equivalent right so in this case

1060
00:19:40,530 --> 00:19:40,540
 

1061
00:19:40,540 --> 00:19:42,480
here we do the join first then do the

1062
00:19:42,480 --> 00:19:42,490
 

1063
00:19:42,490 --> 00:19:44,100
filter in this case here we do the

1064
00:19:44,100 --> 00:19:44,110
 

1065
00:19:44,110 --> 00:19:46,710
filter first then do the join right

1066
00:19:46,710 --> 00:19:46,720
 

1067
00:19:46,720 --> 00:19:48,060
there's rules relational algebra that

1068
00:19:48,060 --> 00:19:48,070
 

1069
00:19:48,070 --> 00:19:50,760
would tell us that these two query plans

1070
00:19:50,760 --> 00:19:50,770
 

1071
00:19:50,770 --> 00:19:53,460
equivalent so the query optimizer can do

1072
00:19:53,460 --> 00:19:53,470
 

1073
00:19:53,470 --> 00:19:55,380
rewriting of this query plan and apply

1074
00:19:55,380 --> 00:19:55,390
 

1075
00:19:55,390 --> 00:19:58,260
this change without worrying about we

1076
00:19:58,260 --> 00:19:58,270
 

1077
00:19:58,270 --> 00:20:00,240
still guaranteeing that's could produce

1078
00:20:00,240 --> 00:20:00,250
 

1079
00:20:00,250 --> 00:20:01,140
the correct result

1080
00:20:01,140 --> 00:20:01,150
 

1081
00:20:01,150 --> 00:20:03,240
all these optimizations don't work if

1082
00:20:03,240 --> 00:20:03,250

1083
00:20:03,250 --> 00:20:04,860
you produce query plans that are you

1084
00:20:04,860 --> 00:20:04,870
 

1085
00:20:04,870 --> 00:20:06,270
know gonna give you the wrong result

1086
00:20:06,270 --> 00:20:06,280
 

1087
00:20:06,280 --> 00:20:09,780
that doesn't help us so there's some

1088
00:20:09,780 --> 00:20:09,790
 

1089
00:20:09,790 --> 00:20:11,310
sort of standard rules you can do for

1090
00:20:11,310 --> 00:20:11,320
 

1091
00:20:11,320 --> 00:20:13,860
selections right obviously perform the

1092
00:20:13,860 --> 00:20:13,870
 

1093
00:20:13,870 --> 00:20:17,010
filters as early as possible you can

1094
00:20:17,010 --> 00:20:17,020
 

1095
00:20:17,020 --> 00:20:20,370
reorder the predicates so that you apply

1096
00:20:20,370 --> 00:20:20,380
 

1097
00:20:20,380 --> 00:20:23,310
the more selective ones first right so

1098
00:20:23,310 --> 00:20:23,320
 

1099
00:20:23,320 --> 00:20:25,350
say I had something like we're you know

1100
00:20:25,350 --> 00:20:25,360
 

1101
00:20:25,360 --> 00:20:29,940
great equals a and you know age above 30

1102
00:20:29,940 --> 00:20:29,950
 

1103
00:20:29,950 --> 00:20:33,270
if there was fewer students that had the

1104
00:20:33,270 --> 00:20:33,280
 

1105
00:20:33,280 --> 00:20:36,180
age above 30 then students ahead with an

1106
00:20:36,180 --> 00:20:36,190
 

1107
00:20:36,190 --> 00:20:38,460
A then I want to apply that that age

1108
00:20:38,460 --> 00:20:38,470

1109
00:20:38,470 --> 00:20:41,130
filter first so even though the grade

1110
00:20:41,130 --> 00:20:41,140
 

1111
00:20:41,140 --> 00:20:43,200
may appear first in the sequel statement

1112
00:20:43,200 --> 00:20:43,210

1113
00:20:43,210 --> 00:20:45,330
I'm free to reorder the expression any

1114
00:20:45,330 --> 00:20:45,340
 

1115
00:20:45,340 --> 00:20:47,160
way that I want and maybe apply that

1116
00:20:47,160 --> 00:20:47,170
 

1117
00:20:47,170 --> 00:20:48,840
that the most selective predicate first

1118
00:20:48,840 --> 00:20:48,850
 

1119
00:20:48,850 --> 00:20:50,430
so I throw away as much more you know

1120
00:20:50,430 --> 00:20:50,440
 

1121
00:20:50,440 --> 00:20:52,350
much useless data as possible before I

1122
00:20:52,350 --> 00:20:52,360
 

1123
00:20:52,360 --> 00:20:56,130
go into the next stages and then you can

1124
00:20:56,130 --> 00:20:56,140
 

1125
00:20:56,140 --> 00:20:57,660
also do you know break up complex

1126
00:20:57,660 --> 00:20:57,670
 

1127
00:20:57,670 --> 00:20:59,640
predicate and you push down so you don't

1128
00:20:59,640 --> 00:20:59,650
 

1129
00:20:59,650 --> 00:21:04,200
always have to have the you know if they

1130
00:21:04,200 --> 00:21:04,210
 

1131
00:21:04,210 --> 00:21:05,130
have a where clause and bunch of

1132
00:21:05,130 --> 00:21:05,140
 

1133
00:21:05,140 --> 00:21:06,840
conjunctions put a bunch of predicates

1134
00:21:06,840 --> 00:21:06,850
 

1135
00:21:06,850 --> 00:21:08,340
you don't have to take all those

1136
00:21:08,340 --> 00:21:08,350
 

1137
00:21:08,350 --> 00:21:10,380
predicates and push them down in the

1138
00:21:10,380 --> 00:21:10,390
 

1139
00:21:10,390 --> 00:21:12,840
query plan right you may want to select

1140
00:21:12,840 --> 00:21:12,850
 

1141
00:21:12,850 --> 00:21:14,610
some of them right and this may be

1142
00:21:14,610 --> 00:21:14,620
 

1143
00:21:14,620 --> 00:21:15,990
because some predicates are more

1144
00:21:15,990 --> 00:21:16,000
 

1145
00:21:16,000 --> 00:21:17,880
expensive to compute than others right

1146
00:21:17,880 --> 00:21:17,890
 

1147
00:21:17,890 --> 00:21:20,520
say one predicate might be computing a

1148
00:21:20,520 --> 00:21:20,530
 

1149
00:21:20,530 --> 00:21:22,650
hash of some value so maybe you don't

1150
00:21:22,650 --> 00:21:22,660
 

1151
00:21:22,660 --> 00:21:24,810
want to do that down below for you

1152
00:21:24,810 --> 00:21:24,820
 

1153
00:21:24,820 --> 00:21:26,400
before join maybe you want to do it

1154
00:21:26,400 --> 00:21:26,410
 

1155
00:21:26,410 --> 00:21:27,900
after join so you're only you know

1156
00:21:27,900 --> 00:21:27,910
 

1157
00:21:27,910 --> 00:21:29,400
wasting the computational resources for

1158
00:21:29,400 --> 00:21:29,410

1159
00:21:29,410 --> 00:21:31,230
things you know are going to match or at

1160
00:21:31,230 --> 00:21:31,240
 

1161
00:21:31,240 --> 00:21:34,200
least at least get to the joint there's

1162
00:21:34,200 --> 00:21:34,210
 

1163
00:21:34,210 --> 00:21:35,550
other optimizations you can do as well

1164
00:21:35,550 --> 00:21:35,560
 

1165
00:21:35,560 --> 00:21:37,140
again relying on the transitive

1166
00:21:37,140 --> 00:21:37,150
 

1167
00:21:37,150 --> 00:21:40,710
properties of boolean logic so here we

1168
00:21:40,710 --> 00:21:40,720
 

1169
00:21:40,720 --> 00:21:43,800
have a complex predicate like x equals y

1170
00:21:43,800 --> 00:21:43,810
 

1171
00:21:43,810 --> 00:21:46,710
and y equals 3 right but we would know

1172
00:21:46,710 --> 00:21:46,720
 

1173
00:21:46,720 --> 00:21:49,440
that in this case here if y equals 3

1174
00:21:49,440 --> 00:21:49,450
 

1175
00:21:49,450 --> 00:21:52,500
then X always has to equal 3 so we can

1176
00:21:52,500 --> 00:21:52,510
 

1177
00:21:52,510 --> 00:21:54,230
rewrite this expression to be like this

1178
00:21:54,230 --> 00:21:54,240
 

1179
00:21:54,240 --> 00:21:57,000
so now maybe we could break up the

1180
00:21:57,000 --> 00:21:57,010
 

1181
00:21:57,010 --> 00:21:58,680
predicate and do the filters on the x

1182
00:21:58,680 --> 00:21:58,690
 

1183
00:21:58,690 --> 00:22:00,240
table or maybe filter on the on the y

1184
00:22:00,240 --> 00:22:00,250
 

1185
00:22:00,250 --> 00:22:03,660
tuples do them separately

1186
00:22:03,660 --> 00:22:03,670
 

1187
00:22:03,670 --> 00:22:23,670
yes so this question is if you're doing

1188
00:22:23,670 --> 00:22:23,680
 

1189
00:22:23,680 --> 00:22:26,400
squat choice can does it make it does it

1190
00:22:26,400 --> 00:22:26,410
 

1191
00:22:26,410 --> 00:22:29,550
make sense to always move all the

1192
00:22:29,550 --> 00:22:29,560

1193
00:22:29,560 --> 00:22:31,770
predicates down close to the skin as

1194
00:22:31,770 --> 00:22:31,780
 

1195
00:22:31,780 --> 00:22:35,610
possible and never break it up right so

1196
00:22:35,610 --> 00:22:35,620
 

1197
00:22:35,620 --> 00:22:39,990
in the end definitely the open source

1198
00:22:39,990 --> 00:22:40,000
 

1199
00:22:40,000 --> 00:22:41,250
guys I think they always push things

1200
00:22:41,250 --> 00:22:41,260
 

1201
00:22:41,260 --> 00:22:43,230
down right there could be an example

1202
00:22:43,230 --> 00:22:43,240
 

1203
00:22:43,240 --> 00:22:48,780
where it could be an example where a

1204
00:22:48,780 --> 00:22:48,790
 

1205
00:22:48,790 --> 00:22:50,610
predicate would be expensive to execute

1206
00:22:50,610 --> 00:22:50,620
 

1207
00:22:50,620 --> 00:22:52,470
I can say like predators can be anything

1208
00:22:52,470 --> 00:22:52,480
 

1209
00:22:52,480 --> 00:22:54,540
right you can actually you can write a

1210
00:22:54,540 --> 00:22:54,550
 

1211
00:22:54,550 --> 00:22:56,160
user-defined function that makes it an

1212
00:22:56,160 --> 00:22:56,170
 

1213
00:22:56,170 --> 00:22:58,260
invocation to an outside system to

1214
00:22:58,260 --> 00:22:58,270
 

1215
00:22:58,270 --> 00:23:00,450
compute whatever you want right and say

1216
00:23:00,450 --> 00:23:00,460
 

1217
00:23:00,460 --> 00:23:02,730
that call cost you money right I'm not

1218
00:23:02,730 --> 00:23:02,740
 

1219
00:23:02,740 --> 00:23:03,840
saying any system would actually do this

1220
00:23:03,840 --> 00:23:03,850
 

1221
00:23:03,850 --> 00:23:05,370
but like you could have you could

1222
00:23:05,370 --> 00:23:05,380
 

1223
00:23:05,380 --> 00:23:07,320
recognize that all right this is weak

1224
00:23:07,320 --> 00:23:07,330
 

1225
00:23:07,330 --> 00:23:09,810
expensive to do so I don't want to do it

1226
00:23:09,810 --> 00:23:09,820
 

1227
00:23:09,820 --> 00:23:11,310
before my join I'm gonna do it after my

1228
00:23:11,310 --> 00:23:11,320
 

1229
00:23:11,320 --> 00:23:12,840
join because it might be a join filter

1230
00:23:12,840 --> 00:23:12,850
 

1231
00:23:12,850 --> 00:23:15,690
that's gonna filter out even more right

1232
00:23:15,690 --> 00:23:15,700
 

1233
00:23:15,700 --> 00:23:17,670
so you may have a billion tuples going

1234
00:23:17,670 --> 00:23:17,680
 

1235
00:23:17,680 --> 00:23:19,320
to the join but the joint may only

1236
00:23:19,320 --> 00:23:19,330

1237
00:23:19,330 --> 00:23:21,390
produce two things rather then rather

1238
00:23:21,390 --> 00:23:21,400
 

1239
00:23:21,400 --> 00:23:23,400
than having for a billion tuples and

1240
00:23:23,400 --> 00:23:23,410

1241
00:23:23,410 --> 00:23:24,690
booked that offense of predicate you do

1242
00:23:24,690 --> 00:23:24,700
 

1243
00:23:24,700 --> 00:23:31,260
it after the join for that for that for

1244
00:23:31,260 --> 00:23:31,270
 

1245
00:23:31,270 --> 00:23:34,620
example you have to be yes but my UDF

1246
00:23:34,620 --> 00:23:34,630
 

1247
00:23:34,630 --> 00:23:36,600
exam owes my UDF ones a bad example

1248
00:23:36,600 --> 00:23:36,610
 

1249
00:23:36,610 --> 00:23:38,430
because UDF's are treated as black boxes

1250
00:23:38,430 --> 00:23:38,440
 

1251
00:23:38,440 --> 00:23:39,390
that the Davises and doesn't know

1252
00:23:39,390 --> 00:23:39,400
 

1253
00:23:39,400 --> 00:23:44,070
anything about that right but that would

1254
00:23:44,070 --> 00:23:44,080
 

1255
00:23:44,080 --> 00:23:45,630
be the guys maybe the difference I'm

1256
00:23:45,630 --> 00:23:45,640
 

1257
00:23:45,640 --> 00:23:46,980
trying to make here is that it's see

1258
00:23:46,980 --> 00:23:46,990
 

1259
00:23:46,990 --> 00:23:50,070
when I say cost I think in terms of how

1260
00:23:50,070 --> 00:23:50,080
 

1261
00:23:50,080 --> 00:23:51,330
it's related to the actual database

1262
00:23:51,330 --> 00:23:51,340
 

1263
00:23:51,340 --> 00:23:55,460
itself the computational cost would be

1264
00:23:55,460 --> 00:23:55,470
 

1265
00:23:55,470 --> 00:23:58,110
is sort of independent in some ways to

1266
00:23:58,110 --> 00:23:58,120
 

1267
00:23:58,120 --> 00:24:00,120
what how many tuples you have like the

1268
00:24:00,120 --> 00:24:00,130
 

1269
00:24:00,130 --> 00:24:01,440
computational cost and booking one

1270
00:24:01,440 --> 00:24:01,450
 

1271
00:24:01,450 --> 00:24:04,470
predicate it's the number of times he

1272
00:24:04,470 --> 00:24:04,480
 

1273
00:24:04,480 --> 00:24:06,990
would execute that predicate for the

1274
00:24:06,990 --> 00:24:07,000
 

1275
00:24:07,000 --> 00:24:08,580
neutral room or tuples that's something

1276
00:24:08,580 --> 00:24:08,590

1277
00:24:08,590 --> 00:24:11,510
will you on the cost model separately

1278
00:24:11,510 --> 00:24:11,520
 

1279
00:24:11,520 --> 00:24:15,350
all right for projections

1280
00:24:15,350 --> 00:24:15,360
 

1281
00:24:15,360 --> 00:24:17,780
this is mostly can be true for row

1282
00:24:17,780 --> 00:24:17,790
 

1283
00:24:17,790 --> 00:24:23,030
stores and for distributed databases but

1284
00:24:23,030 --> 00:24:23,040
 

1285
00:24:23,040 --> 00:24:24,950
the idea is that you want to maybe you

1286
00:24:24,950 --> 00:24:24,960
 

1287
00:24:24,960 --> 00:24:27,289
want to push projections down as early

1288
00:24:27,289 --> 00:24:27,299
 

1289
00:24:27,299 --> 00:24:29,840
as possible so that you reduce the size

1290
00:24:29,840 --> 00:24:29,850
 

1291
00:24:29,850 --> 00:24:32,120
of the tuples that you're copying from

1292
00:24:32,120 --> 00:24:32,130
 

1293
00:24:32,130 --> 00:24:34,340
one Operator to the next let me talk

1294
00:24:34,340 --> 00:24:34,350
 

1295
00:24:34,350 --> 00:24:36,500
about the materialization model the

1296
00:24:36,500 --> 00:24:36,510
 

1297
00:24:36,510 --> 00:24:38,000
iterator model and the vectorization

1298
00:24:38,000 --> 00:24:38,010

1299
00:24:38,010 --> 00:24:41,060
model you're copying data that the

1300
00:24:41,060 --> 00:24:41,070
 

1301
00:24:41,070 --> 00:24:43,130
operator generates from one Operator to

1302
00:24:43,130 --> 00:24:43,140
 

1303
00:24:43,140 --> 00:24:45,260
the next pushing it up the tree and so

1304
00:24:45,260 --> 00:24:45,270
 

1305
00:24:45,270 --> 00:24:46,700
if your tuples are really wide and

1306
00:24:46,700 --> 00:24:46,710
 

1307
00:24:46,710 --> 00:24:48,470
you're you're copying the entire thing

1308
00:24:48,470 --> 00:24:48,480
 

1309
00:24:48,480 --> 00:24:50,480
all the way up then you're wasting a lot

1310
00:24:50,480 --> 00:24:50,490
 

1311
00:24:50,490 --> 00:24:52,070
of space for four columns you know

1312
00:24:52,070 --> 00:24:52,080
 

1313
00:24:52,080 --> 00:24:53,299
you're never actually gonna need later

1314
00:24:53,299 --> 00:24:53,309
 

1315
00:24:53,309 --> 00:24:55,580
on all right so you go back to our

1316
00:24:55,580 --> 00:24:55,590
 

1317
00:24:55,590 --> 00:24:58,100
example here again at the top of the

1318
00:24:58,100 --> 00:24:58,110
 

1319
00:24:58,110 --> 00:25:00,470
query plan we're doing a projection on

1320
00:25:00,470 --> 00:25:00,480
 

1321
00:25:00,480 --> 00:25:02,390
the student name and the in the course

1322
00:25:02,390 --> 00:25:02,400
 

1323
00:25:02,400 --> 00:25:05,840
ID so say that the student enroll tables

1324
00:25:05,840 --> 00:25:05,850
 

1325
00:25:05,850 --> 00:25:07,760
were really wide we had a lot of columns

1326
00:25:07,760 --> 00:25:07,770
 

1327
00:25:07,770 --> 00:25:09,890
a lot of attributes so it might actually

1328
00:25:09,890 --> 00:25:09,900
 

1329
00:25:09,900 --> 00:25:12,140
be better for us to move down the

1330
00:25:12,140 --> 00:25:12,150
 

1331
00:25:12,150 --> 00:25:14,780
projection before the joins so we're

1332
00:25:14,780 --> 00:25:14,790
 

1333
00:25:14,790 --> 00:25:17,000
only passing in the student ID in the

1334
00:25:17,000 --> 00:25:17,010
 

1335
00:25:17,010 --> 00:25:18,980
name and this one only passes up the

1336
00:25:18,980 --> 00:25:18,990
 

1337
00:25:18,990 --> 00:25:20,210
student ID in the course ID because

1338
00:25:20,210 --> 00:25:20,220
 

1339
00:25:20,220 --> 00:25:22,310
that's the only thing you need to do for

1340
00:25:22,310 --> 00:25:22,320
 

1341
00:25:22,320 --> 00:25:24,799
the join here and the idea is that from

1342
00:25:24,799 --> 00:25:24,809
 

1343
00:25:24,809 --> 00:25:26,419
one operator to the next we're copying

1344
00:25:26,419 --> 00:25:26,429
 

1345
00:25:26,429 --> 00:25:29,330
less data again in distributed databases

1346
00:25:29,330 --> 00:25:29,340

1347
00:25:29,340 --> 00:25:31,820
this matters a lot because if you have

1348
00:25:31,820 --> 00:25:31,830
 

1349
00:25:31,830 --> 00:25:33,650
to then send data from one node to the

1350
00:25:33,650 --> 00:25:33,660
 

1351
00:25:33,660 --> 00:25:35,330
next then you're going over that network

1352
00:25:35,330 --> 00:25:35,340
 

1353
00:25:35,340 --> 00:25:36,590
and that becomes very expensive to do

1354
00:25:36,590 --> 00:25:36,600
 

1355
00:25:36,600 --> 00:25:38,390
again an ik column store we said this

1356
00:25:38,390 --> 00:25:38,400
 

1357
00:25:38,400 --> 00:25:39,710
wasn't gonna be an issue because the

1358
00:25:39,710 --> 00:25:39,720
 

1359
00:25:39,720 --> 00:25:41,120
column store can be smart and recognize

1360
00:25:41,120 --> 00:25:41,130
 

1361
00:25:41,130 --> 00:25:43,549
that oh I only need to read data from

1362
00:25:43,549 --> 00:25:43,559
 

1363
00:25:43,559 --> 00:25:45,440
this one column so I'm not gonna stitch

1364
00:25:45,440 --> 00:25:45,450
 

1365
00:25:45,450 --> 00:25:47,510
the entire tuple back together then pass

1366
00:25:47,510 --> 00:25:47,520
 

1367
00:25:47,520 --> 00:25:49,220
it up from one Operator the next it just

1368
00:25:49,220 --> 00:25:49,230
 

1369
00:25:49,230 --> 00:25:50,690
passes the bare minimum data you need

1370
00:25:50,690 --> 00:25:50,700
 

1371
00:25:50,700 --> 00:25:53,210
but if you're in a row store and as

1372
00:25:53,210 --> 00:25:53,220
 

1373
00:25:53,220 --> 00:25:54,320
you're scanning this you're basically

1374
00:25:54,320 --> 00:25:54,330

1375
00:25:54,330 --> 00:25:59,330
getting everything all right so let's

1376
00:25:59,330 --> 00:25:59,340
 

1377
00:25:59,340 --> 00:26:02,690
look some other examples how to do

1378
00:26:02,690 --> 00:26:02,700
 

1379
00:26:02,700 --> 00:26:05,659
optimization without without a cost

1380
00:26:05,659 --> 00:26:05,669

1381
00:26:05,669 --> 00:26:07,039
model so this actually comes from a

1382
00:26:07,039 --> 00:26:07,049
 

1383
00:26:07,049 --> 00:26:08,330
really great blog article that came out

1384
00:26:08,330 --> 00:26:08,340
 

1385
00:26:08,340 --> 00:26:12,890
last year from a DBA where he basically

1386
00:26:12,890 --> 00:26:12,900
 

1387
00:26:12,900 --> 00:26:14,330
mow a bunch of different types of

1388
00:26:14,330 --> 00:26:14,340
 

1389
00:26:14,340 --> 00:26:15,880
optimizations you can apply for queries

1390
00:26:15,880 --> 00:26:15,890
 

1391
00:26:15,890 --> 00:26:18,230
again without having a cost ball and he

1392
00:26:18,230 --> 00:26:18,240
 

1393
00:26:18,240 --> 00:26:20,390
looked at how the different database

1394
00:26:20,390 --> 00:26:20,400

1395
00:26:20,400 --> 00:26:21,620
systems actually would support them and

1396
00:26:21,620 --> 00:26:21,630
 

1397
00:26:21,630 --> 00:26:22,820
whether they can recognize the

1398
00:26:22,820 --> 00:26:22,830
 

1399
00:26:22,830 --> 00:26:25,190
inefficiencies in the string and what

1400
00:26:25,190 --> 00:26:25,200
 

1401
00:26:25,200 --> 00:26:27,260
what's in the sequel query and try to

1402
00:26:27,260 --> 00:26:27,270
 

1403
00:26:27,270 --> 00:26:28,880
rewrite them to be

1404
00:26:28,880 --> 00:26:28,890

1405
00:26:28,890 --> 00:26:32,240
more efficient or better right so the

1406
00:26:32,240 --> 00:26:32,250
 

1407
00:26:32,250 --> 00:26:33,830
first class class optimizations we can

1408
00:26:33,830 --> 00:26:33,840
 

1409
00:26:33,840 --> 00:26:36,700
apply or recognizing that when we have

1410
00:26:36,700 --> 00:26:36,710

1411
00:26:36,710 --> 00:26:39,110
impossible or unnecessary predicates

1412
00:26:39,110 --> 00:26:39,120

1413
00:26:39,120 --> 00:26:41,810
right so select star from table where

1414
00:26:41,810 --> 00:26:41,820
 

1415
00:26:41,820 --> 00:26:44,450
one equals zero right obviously one can

1416
00:26:44,450 --> 00:26:44,460
 

1417
00:26:44,460 --> 00:26:45,410
never equal zero

1418
00:26:45,410 --> 00:26:45,420
 

1419
00:26:45,420 --> 00:26:47,090
so it doesn't make sense for us to

1420
00:26:47,090 --> 00:26:47,100
 

1421
00:26:47,100 --> 00:26:48,950
actually scan through every single tuple

1422
00:26:48,950 --> 00:26:48,960
 

1423
00:26:48,960 --> 00:26:51,200
and apply this predicate because it's

1424
00:26:51,200 --> 00:26:51,210
 

1425
00:26:51,210 --> 00:26:52,700
always gonna be false and note people is

1426
00:26:52,700 --> 00:26:52,710
 

1427
00:26:52,710 --> 00:26:55,790
never gonna match right so some systems

1428
00:26:55,790 --> 00:26:55,800
 

1429
00:26:55,800 --> 00:26:57,410
can recognize in this case here that

1430
00:26:57,410 --> 00:26:57,420

1431
00:26:57,420 --> 00:26:59,090
this you know this will never value it

1432
00:26:59,090 --> 00:26:59,100
 

1433
00:26:59,100 --> 00:27:02,300
to true so it just skips the scan

1434
00:27:02,300 --> 00:27:02,310
 

1435
00:27:02,310 --> 00:27:05,030
entirely it'll give you back a result

1436
00:27:05,030 --> 00:27:05,040
 

1437
00:27:05,040 --> 00:27:07,280
set right because you because if I

1438
00:27:07,280 --> 00:27:07,290
 

1439
00:27:07,290 --> 00:27:08,810
execute a query I always want back I

1440
00:27:08,810 --> 00:27:08,820
 

1441
00:27:08,820 --> 00:27:10,460
always want a result set right this is

1442
00:27:10,460 --> 00:27:10,470
 

1443
00:27:10,470 --> 00:27:11,810
not an error right this is there's no

1444
00:27:11,810 --> 00:27:11,820
 

1445
00:27:11,820 --> 00:27:14,210
reason this is still valid sequel but it

1446
00:27:14,210 --> 00:27:14,220
 

1447
00:27:14,220 --> 00:27:15,500
can just be smart and say well I'm

1448
00:27:15,500 --> 00:27:15,510
 

1449
00:27:15,510 --> 00:27:16,850
actually I don't need to run anything

1450
00:27:16,850 --> 00:27:16,860
 

1451
00:27:16,860 --> 00:27:20,420
here's your empty result another example

1452
00:27:20,420 --> 00:27:20,430
 

1453
00:27:20,430 --> 00:27:21,770
would be like this right select star

1454
00:27:21,770 --> 00:27:21,780
 

1455
00:27:21,780 --> 00:27:24,110
from a where 1 equals 1 obviously in our

1456
00:27:24,110 --> 00:27:24,120
 

1457
00:27:24,120 --> 00:27:26,810
where Clause 1 will always equal 1 so

1458
00:27:26,810 --> 00:27:26,820
 

1459
00:27:26,820 --> 00:27:28,880
the optimization we can apply here is

1460
00:27:28,880 --> 00:27:28,890
 

1461
00:27:28,890 --> 00:27:30,980
just throw away this predicate entirely

1462
00:27:30,980 --> 00:27:30,990
 

1463
00:27:30,990 --> 00:27:33,020
rewrite the expression to not include

1464
00:27:33,020 --> 00:27:33,030
 

1465
00:27:33,030 --> 00:27:34,880
this and then now we're just gonna

1466
00:27:34,880 --> 00:27:34,890

1467
00:27:34,890 --> 00:27:36,710
basically take the this do you know a

1468
00:27:36,710 --> 00:27:36,720
 

1469
00:27:36,720 --> 00:27:38,420
complete spectral scan on the table and

1470
00:27:38,420 --> 00:27:38,430
 

1471
00:27:38,430 --> 00:27:40,610
just dump everything in our in our

1472
00:27:40,610 --> 00:27:40,620
 

1473
00:27:40,620 --> 00:27:43,520
output and the thing we're trying to

1474
00:27:43,520 --> 00:27:43,530
 

1475
00:27:43,530 --> 00:27:45,590
avoid is again not have to check whether

1476
00:27:45,590 --> 00:27:45,600
 

1477
00:27:45,600 --> 00:27:47,630
one equals one for every single tuple in

1478
00:27:47,630 --> 00:27:47,640
 

1479
00:27:47,640 --> 00:27:49,880
our table because that's that's useless

1480
00:27:49,880 --> 00:27:49,890
 

1481
00:27:49,890 --> 00:27:52,010
so it can just rewrite this like this

1482
00:27:52,010 --> 00:27:52,020
 

1483
00:27:52,020 --> 00:27:56,330
and these are equivalent another

1484
00:27:56,330 --> 00:27:56,340
 

1485
00:27:56,340 --> 00:27:57,740
optimization would apply is join

1486
00:27:57,740 --> 00:27:57,750
 

1487
00:27:57,750 --> 00:28:00,950
eliminations so say we have a query the

1488
00:28:00,950 --> 00:28:00,960
 

1489
00:28:00,960 --> 00:28:03,980
self join right from a as a 1 join on a

1490
00:28:03,980 --> 00:28:03,990
 

1491
00:28:03,990 --> 00:28:08,120
as a to where a data ID a 1 ID equals a

1492
00:28:08,120 --> 00:28:08,130
 

1493
00:28:08,130 --> 00:28:12,290
2 ID and up above I'm showing the schema

1494
00:28:12,290 --> 00:28:12,300
 

1495
00:28:12,300 --> 00:28:14,570
and ID is the primary key so this is a

1496
00:28:14,570 --> 00:28:14,580
 

1497
00:28:14,580 --> 00:28:17,000
unique column so there'll be a

1498
00:28:17,000 --> 00:28:17,010

1499
00:28:17,010 --> 00:28:21,470
one-to-one match between the ID in an a1

1500
00:28:21,470 --> 00:28:21,480
 

1501
00:28:21,480 --> 00:28:25,190
with a2 because the exact same table so

1502
00:28:25,190 --> 00:28:25,200
 

1503
00:28:25,200 --> 00:28:27,380
the the David Simmons can recognize that

1504
00:28:27,380 --> 00:28:27,390
 

1505
00:28:27,390 --> 00:28:30,080
this join is actually useless right and

1506
00:28:30,080 --> 00:28:30,090
 

1507
00:28:30,090 --> 00:28:31,910
just remove this entirely and rewrite it

1508
00:28:31,910 --> 00:28:31,920

1509
00:28:31,920 --> 00:28:34,510
like this right this is still equivalent

1510
00:28:34,510 --> 00:28:34,520
 

1511
00:28:34,520 --> 00:28:36,530
yet I don't need a cost model to figure

1512
00:28:36,530 --> 00:28:36,540
 

1513
00:28:36,540 --> 00:28:38,000
this out I can just look at my catalog

1514
00:28:38,000 --> 00:28:38,010
 

1515
00:28:38,010 --> 00:28:39,860
understand that the column ton join onto

1516
00:28:39,860 --> 00:28:39,870
 

1517
00:28:39,870 --> 00:28:42,409
this table is the primary key are you

1518
00:28:42,409 --> 00:28:42,419
 

1519
00:28:42,419 --> 00:28:44,629
we column so therefore I just throw away

1520
00:28:44,629 --> 00:28:44,639
 

1521
00:28:44,639 --> 00:28:46,220
throw away the join throw away the where

1522
00:28:46,220 --> 00:28:46,230
 

1523
00:28:46,230 --> 00:28:51,349
clause all right another one is to

1524
00:28:51,349 --> 00:28:51,359
 

1525
00:28:51,359 --> 00:28:55,580
remove useless projections so here we're

1526
00:28:55,580 --> 00:28:55,590
 

1527
00:28:55,590 --> 00:28:57,889
doing select star from a on as a one and

1528
00:28:57,889 --> 00:28:57,899
 

1529
00:28:57,899 --> 00:29:00,289
then we're going to have a in our where

1530
00:29:00,289 --> 00:29:00,299
 

1531
00:29:00,299 --> 00:29:01,580
clause we have an exist

1532
00:29:01,580 --> 00:29:01,590
 

1533
00:29:01,590 --> 00:29:04,070
function that says with the inside of

1534
00:29:04,070 --> 00:29:04,080
 

1535
00:29:04,080 --> 00:29:05,239
this we're now we're doing a join

1536
00:29:05,239 --> 00:29:05,249
 

1537
00:29:05,249 --> 00:29:08,479
between the outer a a and the inner a so

1538
00:29:08,479 --> 00:29:08,489
 

1539
00:29:08,489 --> 00:29:11,899
a1 is the outer a2 is the inner right

1540
00:29:11,899 --> 00:29:11,909
 

1541
00:29:11,909 --> 00:29:18,499
why is this useless what does the exists

1542
00:29:18,499 --> 00:29:18,509
 

1543
00:29:18,509 --> 00:29:25,940
exists to yes exactly

1544
00:29:25,940 --> 00:29:25,950
 

1545
00:29:25,950 --> 00:29:27,789
it checks whether at least one row

1546
00:29:27,789 --> 00:29:27,799
 

1547
00:29:27,799 --> 00:29:30,590
return is returned and then evaluates to

1548
00:29:30,590 --> 00:29:30,600
 

1549
00:29:30,600 --> 00:29:34,279
true so this is basically saying for for

1550
00:29:34,279 --> 00:29:34,289
 

1551
00:29:34,289 --> 00:29:37,039
my tuple do I exist in this enlighten my

1552
00:29:37,039 --> 00:29:37,049
 

1553
00:29:37,049 --> 00:29:40,310
own table it is always true so this is

1554
00:29:40,310 --> 00:29:40,320
 

1555
00:29:40,320 --> 00:29:42,320
so this is useless and we can further

1556
00:29:42,320 --> 00:29:42,330
 

1557
00:29:42,330 --> 00:29:48,499
rewrite this be like that all right the

1558
00:29:48,499 --> 00:29:48,509
 

1559
00:29:48,509 --> 00:29:51,409
last one is to do merging the predicates

1560
00:29:51,409 --> 00:29:51,419
 

1561
00:29:51,419 --> 00:29:53,419
so in this case here we're doing a

1562
00:29:53,419 --> 00:29:53,429
 

1563
00:29:53,429 --> 00:29:56,330
select star from a and then we have in

1564
00:29:56,330 --> 00:29:56,340
 

1565
00:29:56,340 --> 00:29:58,970
our where clause we have two between

1566
00:29:58,970 --> 00:29:58,980
 

1567
00:29:58,980 --> 00:30:01,159
between predicates so between just

1568
00:30:01,159 --> 00:30:01,169
 

1569
00:30:01,169 --> 00:30:02,479
there's a shorthand way to say like

1570
00:30:02,479 --> 00:30:02,489
 

1571
00:30:02,489 --> 00:30:04,669
greater than and less than or less than

1572
00:30:04,669 --> 00:30:04,679
 

1573
00:30:04,679 --> 00:30:07,220
and greater than right so this is saying

1574
00:30:07,220 --> 00:30:07,230
 

1575
00:30:07,230 --> 00:30:11,330
we're val is is between 1 and 100 or bow

1576
00:30:11,330 --> 00:30:11,340
 

1577
00:30:11,340 --> 00:30:14,359
between 50 and 150 right

1578
00:30:14,359 --> 00:30:14,369
 

1579
00:30:14,369 --> 00:30:16,340
what can we rewrite this to its a

1580
00:30:16,340 --> 00:30:16,350
 

1581
00:30:16,350 --> 00:30:20,629
disjunction 1 to 150 right because

1582
00:30:20,629 --> 00:30:20,639
 

1583
00:30:20,639 --> 00:30:22,180
because these two ranges are overlapping

1584
00:30:22,180 --> 00:30:22,190
 

1585
00:30:22,190 --> 00:30:24,680
so again instead of looking at every

1586
00:30:24,680 --> 00:30:24,690
 

1587
00:30:24,690 --> 00:30:26,479
single predicate every single to point

1588
00:30:26,479 --> 00:30:26,489
 

1589
00:30:26,489 --> 00:30:28,700
and evaluating this predicate I can just

1590
00:30:28,700 --> 00:30:28,710
 

1591
00:30:28,710 --> 00:30:31,129
rewrite it to be like this and that now

1592
00:30:31,129 --> 00:30:31,139
 

1593
00:30:31,139 --> 00:30:32,749
that's much more much more efficient to

1594
00:30:32,749 --> 00:30:32,759

1595
00:30:32,759 --> 00:30:36,619
to execute all right again so there's a

1596
00:30:36,619 --> 00:30:36,629
 

1597
00:30:36,629 --> 00:30:39,379
bunch of these different rules that the

1598
00:30:39,379 --> 00:30:39,389
 

1599
00:30:39,389 --> 00:30:40,909
very standard systems support and can

1600
00:30:40,909 --> 00:30:40,919
 

1601
00:30:40,919 --> 00:30:42,950
have some are better than others

1602
00:30:42,950 --> 00:30:42,960

1603
00:30:42,960 --> 00:30:44,570
and we can try this out real quickly to

1604
00:30:44,570 --> 00:30:44,580
 

1605
00:30:44,580 --> 00:30:49,779
see what kind of things they support

1606
00:30:49,779 --> 00:30:49,789


1607
00:30:49,789 --> 00:30:53,050
students

1608
00:30:53,050 --> 00:30:53,060


1609
00:30:53,060 --> 00:30:55,930
so this is gonna be a sample database

1610
00:30:55,930 --> 00:30:55,940
 

1611
00:30:55,940 --> 00:30:58,510
from the blog article I highly recommend

1612
00:30:58,510 --> 00:30:58,520
 

1613
00:30:58,520 --> 00:31:00,040
you guys check it out the link is in the

1614
00:31:00,040 --> 00:31:00,050
 

1615
00:31:00,050 --> 00:31:07,060
the slides and so he had a he provides a

1616
00:31:07,060 --> 00:31:07,070
 

1617
00:31:07,070 --> 00:31:11,860
sample table or sample database that's

1618
00:31:11,860 --> 00:31:11,870
 

1619
00:31:11,870 --> 00:31:16,090
based on that doesn't work that's based

1620
00:31:16,090 --> 00:31:16,100
 

1621
00:31:16,100 --> 00:31:18,280
on a like a video store

1622
00:31:18,280 --> 00:31:18,290
 

1623
00:31:18,290 --> 00:31:20,620
so there's films and people like rentals

1624
00:31:20,620 --> 00:31:20,630
 

1625
00:31:20,630 --> 00:31:22,450
right so it's sort of a sample schema

1626
00:31:22,450 --> 00:31:22,460

1627
00:31:22,460 --> 00:31:24,700
and it's awesome about is they provide

1628
00:31:24,700 --> 00:31:24,710
 

1629
00:31:24,710 --> 00:31:27,970
it in for my sequel Postgres sequel

1630
00:31:27,970 --> 00:31:27,980
 

1631
00:31:27,980 --> 00:31:29,410
server oracle sequel like they provide

1632
00:31:29,410 --> 00:31:29,420

1633
00:31:29,420 --> 00:31:30,310
it for a bunch of different data systems

1634
00:31:30,310 --> 00:31:30,320
 

1635
00:31:30,320 --> 00:31:34,750
so we can try it for all these systems

1636
00:31:34,750 --> 00:31:34,760
 

1637
00:31:34,760 --> 00:31:36,490
at the same same scheme in the same

1638
00:31:36,490 --> 00:31:36,500
 

1639
00:31:36,500 --> 00:31:40,240
query alright so this one we have

1640
00:31:40,240 --> 00:31:40,250
 

1641
00:31:40,250 --> 00:31:42,400
Postgres we have my sequel I got the

1642
00:31:42,400 --> 00:31:42,410
 

1643
00:31:42,410 --> 00:31:44,380
Linux version of sequel server 2017

1644
00:31:44,380 --> 00:31:44,390
 

1645
00:31:44,390 --> 00:31:46,480
running them on my machine and then we

1646
00:31:46,480 --> 00:31:46,490
 

1647
00:31:46,490 --> 00:31:48,460
also have sequel light so let's start

1648
00:31:48,460 --> 00:31:48,470
 

1649
00:31:48,470 --> 00:31:52,320
with the first one in Postgres right

1650
00:31:52,320 --> 00:31:52,330
 

1651
00:31:52,330 --> 00:31:55,390
select star from actor where 1 equals 0

1652
00:31:55,390 --> 00:31:55,400
 

1653
00:31:55,400 --> 00:31:57,220
and here I'm doing explain analyze

1654
00:31:57,220 --> 00:31:57,230
 

1655
00:31:57,230 --> 00:31:58,480
because I actually want to execute the

1656
00:31:58,480 --> 00:31:58,490
 

1657
00:31:58,490 --> 00:32:00,640
query and see what Postgres actually

1658
00:32:00,640 --> 00:32:00,650
 

1659
00:32:00,650 --> 00:32:04,000
does right and so again this is this is

1660
00:32:04,000 --> 00:32:04,010
 

1661
00:32:04,010 --> 00:32:06,670
an impossible where clause so we know

1662
00:32:06,670 --> 00:32:06,680
 

1663
00:32:06,680 --> 00:32:09,070
that it shouldn't actually look at any

1664
00:32:09,070 --> 00:32:09,080
 

1665
00:32:09,080 --> 00:32:11,140
data in this case here as far as I can

1666
00:32:11,140 --> 00:32:11,150
 

1667
00:32:11,150 --> 00:32:12,940
tell it actually it looks like it didn't

1668
00:32:12,940 --> 00:32:12,950
 

1669
00:32:12,950 --> 00:32:14,830
actually run at law right because it

1670
00:32:14,830 --> 00:32:14,840
 

1671
00:32:14,840 --> 00:32:18,190
says Rose equals 0 so it's a one-time

1672
00:32:18,190 --> 00:32:18,200
 

1673
00:32:18,200 --> 00:32:19,810
filter that's always valid to false so

1674
00:32:19,810 --> 00:32:19,820
 

1675
00:32:19,820 --> 00:32:21,640
it knows that there's this thing will

1676
00:32:21,640 --> 00:32:21,650
 

1677
00:32:21,650 --> 00:32:23,050
never value it to true so it just

1678
00:32:23,050 --> 00:32:23,060
 

1679
00:32:23,060 --> 00:32:25,210
doesn't execute anything and this gives

1680
00:32:25,210 --> 00:32:25,220
 

1681
00:32:25,220 --> 00:32:28,810
you back an empty result let's try this

1682
00:32:28,810 --> 00:32:28,820

1683
00:32:28,820 --> 00:32:34,090
in a my sequel so my sequel doesn't have

1684
00:32:34,090 --> 00:32:34,100
 

1685
00:32:34,100 --> 00:32:37,270
explain analyze like Postgres does and

1686
00:32:37,270 --> 00:32:37,280
 

1687
00:32:37,280 --> 00:32:39,640
they're explained is not as good as as

1688
00:32:39,640 --> 00:32:39,650
 

1689
00:32:39,650 --> 00:32:42,580
Postgres expressed great actually gives

1690
00:32:42,580 --> 00:32:42,590
 

1691
00:32:42,590 --> 00:32:43,750
you the the query plan tree which is

1692
00:32:43,750 --> 00:32:43,760

1693
00:32:43,760 --> 00:32:45,580
actually really nice so my sequel gives

1694
00:32:45,580 --> 00:32:45,590
 

1695
00:32:45,590 --> 00:32:47,170
you this is 5,7 it gives you some

1696
00:32:47,170 --> 00:32:47,180

1697
00:32:47,180 --> 00:32:49,120
metadata and you see here it says some

1698
00:32:49,120 --> 00:32:49,130
 

1699
00:32:49,130 --> 00:32:50,890
powerful where clause so it didn't

1700
00:32:50,890 --> 00:32:50,900
 

1701
00:32:50,900 --> 00:32:52,330
actually run anything it just recognized

1702
00:32:52,330 --> 00:32:52,340
 

1703
00:32:52,340 --> 00:32:54,760
that this thing I never bad wait to true

1704
00:32:54,760 --> 00:32:54,770
 

1705
00:32:54,770 --> 00:32:57,700
so it knows is doesn't actually need to

1706
00:32:57,700 --> 00:32:57,710
 

1707
00:32:57,710 --> 00:33:00,360
scan anything on the table

1708
00:33:00,360 --> 00:33:00,370
 

1709
00:33:00,370 --> 00:33:04,510
we'll try this in instakill light I

1710
00:33:04,510 --> 00:33:04,520
 

1711
00:33:04,520 --> 00:33:06,100
don't think see Colette gives you a good

1712
00:33:06,100 --> 00:33:06,110
 

1713
00:33:06,110 --> 00:33:09,100
explanation yeah it doesn't really tell

1714
00:33:09,100 --> 00:33:09,110
 

1715
00:33:09,110 --> 00:33:09,760
you anything

1716
00:33:09,760 --> 00:33:09,770
 

1717
00:33:09,770 --> 00:33:12,760
I just says idea scan on table if I

1718
00:33:12,760 --> 00:33:12,770
 

1719
00:33:12,770 --> 00:33:15,750
remove the query plan clause from that

1720
00:33:15,750 --> 00:33:15,760
 

1721
00:33:15,760 --> 00:33:18,760
it gives you a bunch of this I won't I

1722
00:33:18,760 --> 00:33:18,770
 

1723
00:33:18,770 --> 00:33:20,110
won't explain this now but basically the

1724
00:33:20,110 --> 00:33:20,120
 

1725
00:33:20,120 --> 00:33:21,549
way single light actually excuse queries

1726
00:33:21,549 --> 00:33:21,559
 

1727
00:33:21,559 --> 00:33:24,669
is that they convert the query planets

1728
00:33:24,669 --> 00:33:24,679
 

1729
00:33:24,679 --> 00:33:26,950
opcodes think of like the byte code in

1730
00:33:26,950 --> 00:33:26,960
 

1731
00:33:26,960 --> 00:33:28,120
the JVM and then they have an

1732
00:33:28,120 --> 00:33:28,130
 

1733
00:33:28,130 --> 00:33:29,919
interpreter for it right which is kind

1734
00:33:29,919 --> 00:33:29,929
 

1735
00:33:29,929 --> 00:33:32,289
of interesting so that's what all that's

1736
00:33:32,289 --> 00:33:32,299
 

1737
00:33:32,299 --> 00:33:33,549
what all these op codes are and then

1738
00:33:33,549 --> 00:33:33,559
 

1739
00:33:33,559 --> 00:33:34,720
this is sort of roughly showing and what

1740
00:33:34,720 --> 00:33:34,730
 

1741
00:33:34,730 --> 00:33:36,549
put they're actually doing so as far as

1742
00:33:36,549 --> 00:33:36,559
 

1743
00:33:36,559 --> 00:33:41,409
I can tell it doesn't doesn't look it

1744
00:33:41,409 --> 00:33:41,419
 

1745
00:33:41,419 --> 00:33:42,310
doesn't look like they're able to

1746
00:33:42,310 --> 00:33:42,320
 

1747
00:33:42,320 --> 00:33:45,299
recognize that it's an impossible query

1748
00:33:45,299 --> 00:33:45,309
 

1749
00:33:45,309 --> 00:33:49,210
alright the last one was a sequel server

1750
00:33:49,210 --> 00:33:49,220
 

1751
00:33:49,220 --> 00:33:51,250
so the sequel server as far as I know

1752
00:33:51,250 --> 00:33:51,260
 

1753
00:33:51,260 --> 00:33:54,760
does not have does not have explained

1754
00:33:54,760 --> 00:33:54,770
 

1755
00:33:54,770 --> 00:33:56,740
you have to do this like show show plan

1756
00:33:56,740 --> 00:33:56,750
 

1757
00:33:56,750 --> 00:33:58,659
thing right and tells you that it's

1758
00:33:58,659 --> 00:33:58,669
 

1759
00:33:58,669 --> 00:34:01,000
turned on and then we can now run a

1760
00:34:01,000 --> 00:34:01,010
 

1761
00:34:01,010 --> 00:34:02,440
query and doesn't actually run the query

1762
00:34:02,440 --> 00:34:02,450
 

1763
00:34:02,450 --> 00:34:07,060
it just tells you that I did it and here

1764
00:34:07,060 --> 00:34:07,070
 

1765
00:34:07,070 --> 00:34:08,470
again there's no there's no there's no

1766
00:34:08,470 --> 00:34:08,480
 

1767
00:34:08,480 --> 00:34:10,330
metadata to say whether it recognized

1768
00:34:10,330 --> 00:34:10,340

1769
00:34:10,340 --> 00:34:13,510
was impossible erases constant scan and

1770
00:34:13,510 --> 00:34:13,520
 

1771
00:34:13,520 --> 00:34:15,490
I suppose that would evaluate the false

1772
00:34:15,490 --> 00:34:15,500
 

1773
00:34:15,500 --> 00:34:16,540
and knows it doesn't actually do the

1774
00:34:16,540 --> 00:34:16,550
 

1775
00:34:16,550 --> 00:34:21,430
scan at all alright let's try the the

1776
00:34:21,430 --> 00:34:21,440
 

1777
00:34:21,440 --> 00:34:25,540
range query one say we go back to

1778
00:34:25,540 --> 00:34:25,550
 

1779
00:34:25,550 --> 00:34:32,109
Postgres so Postgres 2 is is not able to

1780
00:34:32,109 --> 00:34:32,119
 

1781
00:34:32,119 --> 00:34:33,430
recognize that these predicates we

1782
00:34:33,430 --> 00:34:33,440
 

1783
00:34:33,440 --> 00:34:35,409
merged and they rewrote the between

1784
00:34:35,409 --> 00:34:35,419
 

1785
00:34:35,419 --> 00:34:37,960
clause to be greater than equal to and

1786
00:34:37,960 --> 00:34:37,970
 

1787
00:34:37,970 --> 00:34:39,820
less than equal to but it still looks

1788
00:34:39,820 --> 00:34:39,830
 

1789
00:34:39,830 --> 00:34:41,560
like they're still going to perform the

1790
00:34:41,560 --> 00:34:41,570
 

1791
00:34:41,570 --> 00:34:45,159
the you know the scan for both of those

1792
00:34:45,159 --> 00:34:45,169
 

1793
00:34:45,169 --> 00:34:47,230
predicates right the book both of those

1794
00:34:47,230 --> 00:34:47,240
 

1795
00:34:47,240 --> 00:35:00,340
ranges we go to to my sequel no matching

1796
00:35:00,340 --> 00:35:00,350

1797
00:35:00,350 --> 00:35:04,230
row and cons table eyes alright sorry I

1798
00:35:04,230 --> 00:35:04,240
 

1799
00:35:04,240 --> 00:35:06,220
let me go back to this I'm you clean it

1800
00:35:06,220 --> 00:35:06,230
 

1801
00:35:06,230 --> 00:35:07,570
so actually I'm not doing the same range

1802
00:35:07,570 --> 00:35:07,580
 

1803
00:35:07,580 --> 00:35:09,220
gain I had before I'm actually doing an

1804
00:35:09,220 --> 00:35:09,230
 

1805
00:35:09,230 --> 00:35:10,030
impossible range

1806
00:35:10,030 --> 00:35:10,040

1807
00:35:10,040 --> 00:35:13,309
I've between 1 and 2 and between

1808
00:35:13,309 --> 00:35:13,319
 

1809
00:35:13,319 --> 00:35:15,829
199 and 200 right so these are disjoint

1810
00:35:15,829 --> 00:35:15,839
 

1811
00:35:15,839 --> 00:35:17,689
sets for doing a conjunction on them

1812
00:35:17,689 --> 00:35:17,699

1813
00:35:17,699 --> 00:35:19,670
disjoint ranges so it should never get

1814
00:35:19,670 --> 00:35:19,680
 

1815
00:35:19,680 --> 00:35:21,769
never actually match so my sequel

1816
00:35:21,769 --> 00:35:21,779
 

1817
00:35:21,779 --> 00:35:23,059
actually does the right thing and it's

1818
00:35:23,059 --> 00:35:23,069
 

1819
00:35:23,069 --> 00:35:26,989
able to recognize that this is actually

1820
00:35:26,989 --> 00:35:26,999
 

1821
00:35:26,999 --> 00:35:28,489
says here no matching brillouin

1822
00:35:28,489 --> 00:35:28,499
 

1823
00:35:28,499 --> 00:35:29,900
constable so maybe actually did apply it

1824
00:35:29,900 --> 00:35:29,910
 

1825
00:35:29,910 --> 00:35:34,160
but in case of in Postgres again it

1826
00:35:34,160 --> 00:35:34,170
 

1827
00:35:34,170 --> 00:35:35,120
didn't recognize that these are

1828
00:35:35,120 --> 00:35:35,130
 

1829
00:35:35,130 --> 00:35:36,709
impossible ranges and still did the scan

1830
00:35:36,709 --> 00:35:36,719
 

1831
00:35:36,719 --> 00:35:50,109
on it let's try this in sequel light

1832
00:35:50,109 --> 00:35:50,119


1833
00:35:50,119 --> 00:35:52,729
again as far as I can tell it's it's

1834
00:35:52,729 --> 00:35:52,739
 

1835
00:35:52,739 --> 00:35:55,489
still doing the it's still doing the

1836
00:35:55,489 --> 00:35:55,499
 

1837
00:35:55,499 --> 00:35:56,959
range scan on the on the query it

1838
00:35:56,959 --> 00:35:56,969
 

1839
00:35:56,969 --> 00:35:58,339
doesn't recognize that these things are

1840
00:35:58,339 --> 00:35:58,349
 

1841
00:35:58,349 --> 00:36:05,390
disjoint and the last one would be where

1842
00:36:05,390 --> 00:36:05,400

1843
00:36:05,400 --> 00:36:06,549
are we there we go

1844
00:36:06,549 --> 00:36:06,559

1845
00:36:06,559 --> 00:36:15,289
try this in in sequel server again

1846
00:36:15,289 --> 00:36:15,299
 

1847
00:36:15,299 --> 00:36:16,400
doesn't tell you anything tells you

1848
00:36:16,400 --> 00:36:16,410

1849
00:36:16,410 --> 00:36:18,049
constant there's a way to turn on the

1850
00:36:18,049 --> 00:36:18,059
 

1851
00:36:18,059 --> 00:36:21,410
more verbose like XML query query plan

1852
00:36:21,410 --> 00:36:21,420
 

1853
00:36:21,420 --> 00:36:24,349
of the sequel server but you need it you

1854
00:36:24,349 --> 00:36:24,359
 

1855
00:36:24,359 --> 00:36:25,640
need a viewer for that which I don't

1856
00:36:25,640 --> 00:36:25,650
 

1857
00:36:25,650 --> 00:36:26,989
have right it's just we just at the

1858
00:36:26,989 --> 00:36:26,999
 

1859
00:36:26,999 --> 00:36:28,969
terminal alright so the last one I want

1860
00:36:28,969 --> 00:36:28,979
 

1861
00:36:28,979 --> 00:36:35,059
to do is the projection pruning so this

1862
00:36:35,059 --> 00:36:35,069
 

1863
00:36:35,069 --> 00:36:37,819
is BEC this is Becker Postgres so here

1864
00:36:37,819 --> 00:36:37,829
 

1865
00:36:37,829 --> 00:36:39,709
we're going to do a select statement and

1866
00:36:39,709 --> 00:36:39,719
 

1867
00:36:39,719 --> 00:36:43,039
all we have is just exist where select

1868
00:36:43,039 --> 00:36:43,049
 

1869
00:36:43,049 --> 00:36:44,289
is 1/0

1870
00:36:44,289 --> 00:36:44,299
 

1871
00:36:44,299 --> 00:36:47,719
right so again exists returns true

1872
00:36:47,719 --> 00:36:47,729
 

1873
00:36:47,729 --> 00:36:49,430
whether there's at least one thing that

1874
00:36:49,430 --> 00:36:49,440

1875
00:36:49,440 --> 00:36:53,029
will match inside of inside of the

1876
00:36:53,029 --> 00:36:53,039
 

1877
00:36:53,039 --> 00:36:56,089
whatever you have inside of it right so

1878
00:36:56,089 --> 00:36:56,099
 

1879
00:36:56,099 --> 00:36:57,799
I could do something like this select

1880
00:36:57,799 --> 00:36:57,809
 

1881
00:36:57,809 --> 00:37:00,559
one right something will match because

1882
00:37:00,559 --> 00:37:00,569
 

1883
00:37:00,569 --> 00:37:02,839
there's a tuple with with one attribute

1884
00:37:02,839 --> 00:37:02,849

1885
00:37:02,849 --> 00:37:05,630
the values one and then the outer select

1886
00:37:05,630 --> 00:37:05,640
 

1887
00:37:05,640 --> 00:37:06,529
will say alright is there anything

1888
00:37:06,529 --> 00:37:06,539
 

1889
00:37:06,539 --> 00:37:08,390
inside that inner select if yes then

1890
00:37:08,390 --> 00:37:08,400
 

1891
00:37:08,400 --> 00:37:11,269
return true right so that's what we

1892
00:37:11,269 --> 00:37:11,279
 

1893
00:37:11,279 --> 00:37:13,579
expect like this so the question is

1894
00:37:13,579 --> 00:37:13,589
 

1895
00:37:13,589 --> 00:37:16,039
whether Postgres can recognize that no

1896
00:37:16,039 --> 00:37:16,049
 

1897
00:37:16,049 --> 00:37:17,959
matter what value I put in for the

1898
00:37:17,959 --> 00:37:17,969
 

1899
00:37:17,969 --> 00:37:21,380
inside this inner part here right no

1900
00:37:21,380 --> 00:37:21,390

1901
00:37:21,390 --> 00:37:23,420
matter what's in there there's it's

1902
00:37:23,420 --> 00:37:23,430
 

1903
00:37:23,430 --> 00:37:27,170
always going to be a tuple so therefore

1904
00:37:27,170 --> 00:37:27,180
 

1905
00:37:27,180 --> 00:37:29,960
always gonna evaluate to true so

1906
00:37:29,960 --> 00:37:29,970
 

1907
00:37:29,970 --> 00:37:31,190
therefore it doesn't need to even

1908
00:37:31,190 --> 00:37:31,200
 

1909
00:37:31,200 --> 00:37:32,599
execute whatever that projection is in

1910
00:37:32,599 --> 00:37:32,609
 

1911
00:37:32,609 --> 00:37:34,910
there so I can try to compute you know

1912
00:37:34,910 --> 00:37:34,920
 

1913
00:37:34,920 --> 00:37:37,910
the millionth digit of pi it's still

1914
00:37:37,910 --> 00:37:37,920
 

1915
00:37:37,920 --> 00:37:40,069
going to evaluate to true so you want to

1916
00:37:40,069 --> 00:37:40,079
 

1917
00:37:40,079 --> 00:37:41,630
see whether post cuts can recognize this

1918
00:37:41,630 --> 00:37:41,640
 

1919
00:37:41,640 --> 00:37:43,690
and not actually execute anything and

1920
00:37:43,690 --> 00:37:43,700
 

1921
00:37:43,700 --> 00:37:47,140
the way we can test this is by doing it

1922
00:37:47,140 --> 00:37:47,150
 

1923
00:37:47,150 --> 00:37:50,049
invalid division right 1 divided by 0 so

1924
00:37:50,049 --> 00:37:50,059
 

1925
00:37:50,059 --> 00:37:52,940
if it actually executes so that that

1926
00:37:52,940 --> 00:37:52,950
 

1927
00:37:52,950 --> 00:37:56,559
predicate then it'll throw an error if

1928
00:37:56,559 --> 00:37:56,569
 

1929
00:37:56,569 --> 00:38:01,490
it doesn't then I'll just say true raise

1930
00:38:01,490 --> 00:38:01,500
 

1931
00:38:01,500 --> 00:38:04,420
your hand if you think it'll execute it

1932
00:38:04,420 --> 00:38:04,430
 

1933
00:38:04,430 --> 00:38:08,870
1 2 yeah 5% he thinks it's smart enough

1934
00:38:08,870 --> 00:38:08,880
 

1935
00:38:08,880 --> 00:38:10,900
to know not to do it

1936
00:38:10,900 --> 00:38:10,910
 

1937
00:38:10,910 --> 00:38:13,069
no one's wanna think that bad few people

1938
00:38:13,069 --> 00:38:13,079
 

1939
00:38:13,079 --> 00:38:15,490
ok it can do it

1940
00:38:15,490 --> 00:38:15,500
 

1941
00:38:15,500 --> 00:38:22,040
alright so we can try this in in sequel

1942
00:38:22,040 --> 00:38:22,050
 

1943
00:38:22,050 --> 00:38:28,250
light alright comes back is true let's

1944
00:38:28,250 --> 00:38:28,260
 

1945
00:38:28,260 --> 00:38:33,170
try this in my sequel comes back goes

1946
00:38:33,170 --> 00:38:33,180
 

1947
00:38:33,180 --> 00:38:39,740
true question though is I'm actually not

1948
00:38:39,740 --> 00:38:39,750

1949
00:38:39,750 --> 00:38:41,120
sure if my seat will actually execute

1950
00:38:41,120 --> 00:38:41,130
 

1951
00:38:41,130 --> 00:38:44,690
this right so again if I do this and I

1952
00:38:44,690 --> 00:38:44,700
 

1953
00:38:44,700 --> 00:38:47,839
used like that it'll it gives you back

1954
00:38:47,839 --> 00:38:47,849
 

1955
00:38:47,849 --> 00:38:49,430
no but then it gives you a warning and

1956
00:38:49,430 --> 00:38:49,440
 

1957
00:38:49,440 --> 00:38:53,809
then for for my sequel you have to do

1958
00:38:53,809 --> 00:38:53,819

1959
00:38:53,819 --> 00:38:55,400
this command and then it says division

1960
00:38:55,400 --> 00:38:55,410
 

1961
00:38:55,410 --> 00:38:59,140
by 0 right if I try this in in Postgres

1962
00:38:59,140 --> 00:38:59,150
 

1963
00:38:59,150 --> 00:39:02,059
it should actually just throw an arrow

1964
00:39:02,059 --> 00:39:02,069
 

1965
00:39:02,069 --> 00:39:07,700
alright division by 0 so I'm not sure

1966
00:39:07,700 --> 00:39:07,710
 

1967
00:39:07,710 --> 00:39:09,740
whether my sequels actually executing

1968
00:39:09,740 --> 00:39:09,750
 

1969
00:39:09,750 --> 00:39:15,349
this or not but we tried another case

1970
00:39:15,349 --> 00:39:15,359
 

1971
00:39:15,359 --> 00:39:18,250
where we can try to give it an invalid

1972
00:39:18,250 --> 00:39:18,260
 

1973
00:39:18,260 --> 00:39:21,740
power and that that comes out to be true

1974
00:39:21,740 --> 00:39:21,750
 

1975
00:39:21,750 --> 00:39:24,079
too so that I think I think it's doing

1976
00:39:24,079 --> 00:39:24,089
 

1977
00:39:24,089 --> 00:39:26,960
the right thing right in that case it

1978
00:39:26,960 --> 00:39:26,970
 

1979
00:39:26,970 --> 00:39:27,950
throws an error I could try to do that

1980
00:39:27,950 --> 00:39:27,960
 

1981
00:39:27,960 --> 00:39:29,480
whereas like the divide by zero doesn't

1982
00:39:29,480 --> 00:39:29,490
 

1983
00:39:29,490 --> 00:39:31,760
throw an error again so the main

1984
00:39:31,760 --> 00:39:31,770
 

1985
00:39:31,770 --> 00:39:33,200
takeaway from these these are all rules

1986
00:39:33,200 --> 00:39:33,210
 

1987
00:39:33,210 --> 00:39:36,460
that are gonna that the system can use

1988
00:39:36,460 --> 00:39:36,470

1989
00:39:36,470 --> 00:39:38,539
before you even get to the call space

1990
00:39:38,539 --> 00:39:38,549
 

1991
00:39:38,549 --> 00:39:40,549
search because it knows

1992
00:39:40,549 --> 00:39:40,559
 

1993
00:39:40,559 --> 00:39:41,779
these are some optimizations that can

1994
00:39:41,779 --> 00:39:41,789
 

1995
00:39:41,789 --> 00:39:42,949
apply because they're always almost

1996
00:39:42,949 --> 00:39:42,959
 

1997
00:39:42,959 --> 00:39:44,469
always gonna be the right thing to do

1998
00:39:44,469 --> 00:39:44,479
 

1999
00:39:44,479 --> 00:39:55,039
okay okay so for for its single table

2000
00:39:55,039 --> 00:39:55,049
 

2001
00:39:55,049 --> 00:39:58,640
queries you know this crap addition is

2002
00:39:58,640 --> 00:39:58,650
 

2003
00:39:58,650 --> 00:40:02,390
pretty straightforward for joins as with

2004
00:40:02,390 --> 00:40:02,400
 

2005
00:40:02,400 --> 00:40:04,039
the tricky one this is this is the one

2006
00:40:04,039 --> 00:40:04,049
 

2007
00:40:04,049 --> 00:40:05,539
where we're having those problems

2008
00:40:05,539 --> 00:40:05,549
 

2009
00:40:05,549 --> 00:40:08,959
all right and the the part of the reason

2010
00:40:08,959 --> 00:40:08,969
 

2011
00:40:08,969 --> 00:40:10,880
we're gonna have problems is that we can

2012
00:40:10,880 --> 00:40:10,890
 

2013
00:40:10,890 --> 00:40:12,199
apply both commutativity and

2014
00:40:12,199 --> 00:40:12,209
 

2015
00:40:12,209 --> 00:40:14,299
associativity rules for for our joins

2016
00:40:14,299 --> 00:40:14,309

2017
00:40:14,309 --> 00:40:16,819
and reorder them in any any way that we

2018
00:40:16,819 --> 00:40:16,829
 

2019
00:40:16,829 --> 00:40:17,689
want and we're still always could

2020
00:40:17,689 --> 00:40:17,699
 

2021
00:40:17,699 --> 00:40:20,179
produce the correct result right if I

2022
00:40:20,179 --> 00:40:20,189
 

2023
00:40:20,189 --> 00:40:22,999
went to join R and s that's equivalent

2024
00:40:22,999 --> 00:40:23,009
 

2025
00:40:23,009 --> 00:40:25,249
to joining s with our right it's still

2026
00:40:25,249 --> 00:40:25,259
 

2027
00:40:25,259 --> 00:40:26,089
going to always computes the correct

2028
00:40:26,089 --> 00:40:26,099
 

2029
00:40:26,099 --> 00:40:28,459
result or if I want to join our SMT I

2030
00:40:28,459 --> 00:40:28,469
 

2031
00:40:28,469 --> 00:40:30,380
could join R and s first and then join

2032
00:40:30,380 --> 00:40:30,390
 

2033
00:40:30,390 --> 00:40:32,749
that output with it with T or I could

2034
00:40:32,749 --> 00:40:32,759
 

2035
00:40:32,759 --> 00:40:34,339
join SMT first and join that with our

2036
00:40:34,339 --> 00:40:34,349
 

2037
00:40:34,349 --> 00:40:36,319
all these are equivalent all these are

2038
00:40:36,319 --> 00:40:36,329
 

2039
00:40:36,329 --> 00:40:39,019
valid and so we hit but they're gonna

2040
00:40:39,019 --> 00:40:39,029
 

2041
00:40:39,029 --> 00:40:39,859
have different performance

2042
00:40:39,859 --> 00:40:39,869
 

2043
00:40:39,869 --> 00:40:41,390
characteristics but we solved this when

2044
00:40:41,390 --> 00:40:41,400
 

2045
00:40:41,400 --> 00:40:42,319
we talked about joint algorithms you

2046
00:40:42,319 --> 00:40:42,329
 

2047
00:40:42,329 --> 00:40:43,729
always want to put the smaller table as

2048
00:40:43,729 --> 00:40:43,739

2049
00:40:43,739 --> 00:40:46,249
the the outer table so now how are you

2050
00:40:46,249 --> 00:40:46,259
 

2051
00:40:46,259 --> 00:40:48,650
gonna pick which one to pick you know

2052
00:40:48,650 --> 00:40:48,660
 

2053
00:40:48,660 --> 00:40:51,019
which one which to join first and which

2054
00:40:51,019 --> 00:40:51,029
 

2055
00:40:51,029 --> 00:40:52,660
one should be the inverse of the outer

2056
00:40:52,660 --> 00:40:52,670
 

2057
00:40:52,670 --> 00:40:55,219
so what makes it so hard is that the

2058
00:40:55,219 --> 00:40:55,229
 

2059
00:40:55,229 --> 00:40:56,689
total number different combinations we

2060
00:40:56,689 --> 00:40:56,699

2061
00:40:56,699 --> 00:40:59,870
could have is 4 to the n right you know

2062
00:40:59,870 --> 00:40:59,880
 

2063
00:40:59,880 --> 00:41:01,339
it's a big number when it has a special

2064
00:41:01,339 --> 00:41:01,349
 

2065
00:41:01,349 --> 00:41:02,989
name right so it's called a Catalan

2066
00:41:02,989 --> 00:41:02,999
 

2067
00:41:02,999 --> 00:41:06,739
number all right and so then because

2068
00:41:06,739 --> 00:41:06,749
 

2069
00:41:06,749 --> 00:41:08,209
there's so many different choices we

2070
00:41:08,209 --> 00:41:08,219
 

2071
00:41:08,219 --> 00:41:10,939
could have for our join orders and that

2072
00:41:10,939 --> 00:41:10,949
 

2073
00:41:10,949 --> 00:41:14,209
we're not gonna be able to to compare

2074
00:41:14,209 --> 00:41:14,219
 

2075
00:41:14,219 --> 00:41:17,029
every single one we need a way to prune

2076
00:41:17,029 --> 00:41:17,039

2077
00:41:17,039 --> 00:41:19,160
the search space right cuz they're doing

2078
00:41:19,160 --> 00:41:19,170
 

2079
00:41:19,170 --> 00:41:20,390
the results a search is just gonna be

2080
00:41:20,390 --> 00:41:20,400
 

2081
00:41:20,400 --> 00:41:23,929
way too slow so we're gonna hold off on

2082
00:41:23,929 --> 00:41:23,939
 

2083
00:41:23,939 --> 00:41:25,819
this for now we'll talk about how you're

2084
00:41:25,819 --> 00:41:25,829
 

2085
00:41:25,829 --> 00:41:27,739
going to estimate whether one joint is

2086
00:41:27,739 --> 00:41:27,749
 

2087
00:41:27,749 --> 00:41:29,419
better than another and then we'll see

2088
00:41:29,419 --> 00:41:29,429

2089
00:41:29,429 --> 00:41:31,099
how we can then figure out what the

2090
00:41:31,099 --> 00:41:31,109
 

2091
00:41:31,109 --> 00:41:36,829
joint ordering should be so the in the

2092
00:41:36,829 --> 00:41:36,839
 

2093
00:41:36,839 --> 00:41:38,569
the the call space search search

2094
00:41:38,569 --> 00:41:38,579
 

2095
00:41:38,579 --> 00:41:41,239
optimization the idea is that for a

2096
00:41:41,239 --> 00:41:41,249
 

2097
00:41:41,249 --> 00:41:43,400
particular query plan so the ideas can

2098
00:41:43,400 --> 00:41:43,410
 

2099
00:41:43,410 --> 00:41:45,799
take a query you generate the syntax

2100
00:41:45,799 --> 00:41:45,809
 

2101
00:41:45,809 --> 00:41:47,900
tree and then now say there's joint you

2102
00:41:47,900 --> 00:41:47,910
 

2103
00:41:47,910 --> 00:41:48,949
want to figure out what order you should

2104
00:41:48,949 --> 00:41:48,959
 

2105
00:41:48,959 --> 00:41:50,929
actually join your tables and so you're

2106
00:41:50,929 --> 00:41:50,939
 

2107
00:41:50,939 --> 00:41:52,459
gonna try a bunch of accommodations of

2108
00:41:52,459 --> 00:41:52,469
 

2109
00:41:52,469 --> 00:41:53,930
those different joint orderings and

2110
00:41:53,930 --> 00:41:53,940
 

2111
00:41:53,940 --> 00:41:55,010
way to figure out which one is better

2112
00:41:55,010 --> 00:41:55,020
 

2113
00:41:55,020 --> 00:41:56,780
than another so you're gonna use the

2114
00:41:56,780 --> 00:41:56,790
 

2115
00:41:56,790 --> 00:41:58,609
cost model to be able to do this

2116
00:41:58,609 --> 00:41:58,619
 

2117
00:41:58,619 --> 00:42:02,690
estimation all right and so it's the

2118
00:42:02,690 --> 00:42:02,700
 

2119
00:42:02,700 --> 00:42:04,250
cost model is going to generate a number

2120
00:42:04,250 --> 00:42:04,260
 

2121
00:42:04,260 --> 00:42:06,200
that's internal to the database system

2122
00:42:06,200 --> 00:42:06,210
 

2123
00:42:06,210 --> 00:42:10,490
meaning it's not really gonna be a you

2124
00:42:10,490 --> 00:42:10,500
 

2125
00:42:10,500 --> 00:42:12,319
know tied to wall clock times I can say

2126
00:42:12,319 --> 00:42:12,329
 

2127
00:42:12,329 --> 00:42:13,430
you know miss Cory's gonna say ten

2128
00:42:13,430 --> 00:42:13,440
 

2129
00:42:13,440 --> 00:42:15,319
milliseconds that squares gonna take 100

2130
00:42:15,319 --> 00:42:15,329
 

2131
00:42:15,329 --> 00:42:17,510
milliseconds but is this internal metric

2132
00:42:17,510 --> 00:42:17,520
 

2133
00:42:17,520 --> 00:42:19,940
that it uses just to compare whether one

2134
00:42:19,940 --> 00:42:19,950
 

2135
00:42:19,950 --> 00:42:22,520
query plan is better than another but

2136
00:42:22,520 --> 00:42:22,530

2137
00:42:22,530 --> 00:42:24,349
it's gonna be derived from a bunch of

2138
00:42:24,349 --> 00:42:24,359
 

2139
00:42:24,359 --> 00:42:25,970
different information that it can

2140
00:42:25,970 --> 00:42:25,980
 

2141
00:42:25,980 --> 00:42:27,950
collect about your data and about your

2142
00:42:27,950 --> 00:42:27,960
 

2143
00:42:27,960 --> 00:42:30,559
hardware right so try to think think

2144
00:42:30,559 --> 00:42:30,569
 

2145
00:42:30,569 --> 00:42:32,300
about like all right well this joint

2146
00:42:32,300 --> 00:42:32,310
 

2147
00:42:32,310 --> 00:42:34,220
algorithms can take this many CPU cycles

2148
00:42:34,220 --> 00:42:34,230

2149
00:42:34,230 --> 00:42:36,740
and I'm gonna have this many cache

2150
00:42:36,740 --> 00:42:36,750
 

2151
00:42:36,750 --> 00:42:39,170
misses so you know I'll wait that'd be

2152
00:42:39,170 --> 00:42:39,180
 

2153
00:42:39,180 --> 00:42:41,569
more than the other one I know how many

2154
00:42:41,569 --> 00:42:41,579
 

2155
00:42:41,579 --> 00:42:42,980
blocks me have to read from disk or how

2156
00:42:42,980 --> 00:42:42,990
 

2157
00:42:42,990 --> 00:42:44,120
much data at the center of the network

2158
00:42:44,120 --> 00:42:44,130
 

2159
00:42:44,130 --> 00:42:46,609
how much memory I'm gonna use so this

2160
00:42:46,609 --> 00:42:46,619
 

2161
00:42:46,619 --> 00:42:48,410
cost must be a combination of all these

2162
00:42:48,410 --> 00:42:48,420
 

2163
00:42:48,420 --> 00:42:50,089
things and again the commercial guys are

2164
00:42:50,089 --> 00:42:50,099
 

2165
00:42:50,099 --> 00:42:51,200
way more sophisticated than the

2166
00:42:51,200 --> 00:42:51,210
 

2167
00:42:51,210 --> 00:42:54,319
open-source guys and then it's gonna use

2168
00:42:54,319 --> 00:42:54,329
 

2169
00:42:54,329 --> 00:42:56,000
that again to determine whether one is

2170
00:42:56,000 --> 00:42:56,010
 

2171
00:42:56,010 --> 00:42:58,849
better than another so the way you need

2172
00:42:58,849 --> 00:42:58,859
 

2173
00:42:58,859 --> 00:43:01,250
to figure out how much resources the

2174
00:43:01,250 --> 00:43:01,260
 

2175
00:43:01,260 --> 00:43:03,200
query is gonna use is based on the

2176
00:43:03,200 --> 00:43:03,210

2177
00:43:03,210 --> 00:43:05,180
statistics and information you're gonna

2178
00:43:05,180 --> 00:43:05,190
 

2179
00:43:05,190 --> 00:43:08,260
drive about the underlying database

2180
00:43:08,260 --> 00:43:08,270
 

2181
00:43:08,270 --> 00:43:11,150
right you want to know how many tuples I

2182
00:43:11,150 --> 00:43:11,160
 

2183
00:43:11,160 --> 00:43:12,890
have for the table from table a and on

2184
00:43:12,890 --> 00:43:12,900
 

2185
00:43:12,900 --> 00:43:14,750
joining with table B how why do those

2186
00:43:14,750 --> 00:43:14,760
 

2187
00:43:14,760 --> 00:43:18,079
there's those tuples how fast the disk

2188
00:43:18,079 --> 00:43:18,089
 

2189
00:43:18,089 --> 00:43:19,579
that they're stored on all this

2190
00:43:19,579 --> 00:43:19,589
 

2191
00:43:19,589 --> 00:43:21,470
information you need to maintain then in

2192
00:43:21,470 --> 00:43:21,480
 

2193
00:43:21,480 --> 00:43:23,599
order to figure out what the estimate

2194
00:43:23,599 --> 00:43:23,609
 

2195
00:43:23,609 --> 00:43:26,170
how much things gonna cost to execute it

2196
00:43:26,170 --> 00:43:26,180
 

2197
00:43:26,180 --> 00:43:28,430
so every single database system that has

2198
00:43:28,430 --> 00:43:28,440
 

2199
00:43:28,440 --> 00:43:30,829
a query optimizer has to have you know

2200
00:43:30,829 --> 00:43:30,839
 

2201
00:43:30,839 --> 00:43:32,210
it's gonna have a cost based query

2202
00:43:32,210 --> 00:43:32,220
 

2203
00:43:32,220 --> 00:43:34,280
optimizer has to maintain these internal

2204
00:43:34,280 --> 00:43:34,290
 

2205
00:43:34,290 --> 00:43:35,599
statistics that it's gonna collect about

2206
00:43:35,599 --> 00:43:35,609
 

2207
00:43:35,609 --> 00:43:38,540
the data so if your data is read-only

2208
00:43:38,540 --> 00:43:38,550
 

2209
00:43:38,550 --> 00:43:40,010
then this is not a big deal because you

2210
00:43:40,010 --> 00:43:40,020
 

2211
00:43:40,020 --> 00:43:41,359
just sort of scan over at once and then

2212
00:43:41,359 --> 00:43:41,369
 

2213
00:43:41,369 --> 00:43:43,099
we try to collect what much data as you

2214
00:43:43,099 --> 00:43:43,109
 

2215
00:43:43,109 --> 00:43:43,520
can

2216
00:43:43,520 --> 00:43:43,530

2217
00:43:43,530 --> 00:43:44,780
shouldn't say it's not a big deal but

2218
00:43:44,780 --> 00:43:44,790
 

2219
00:43:44,790 --> 00:43:48,980
it's it's it's less challenging than if

2220
00:43:48,980 --> 00:43:48,990
 

2221
00:43:48,990 --> 00:43:50,180
you're in a dynamic environment where

2222
00:43:50,180 --> 00:43:50,190
 

2223
00:43:50,190 --> 00:43:52,670
your data is always getting updated so

2224
00:43:52,670 --> 00:43:52,680
 

2225
00:43:52,680 --> 00:43:54,319
the way database systems manage this is

2226
00:43:54,319 --> 00:43:54,329

2227
00:43:54,329 --> 00:43:56,530
that they typically have a background

2228
00:43:56,530 --> 00:43:56,540
 

2229
00:43:56,540 --> 00:43:59,270
sort of stats collector I think that's

2230
00:43:59,270 --> 00:43:59,280
 

2231
00:43:59,280 --> 00:44:02,180
what Postgres calls it that's going to

2232
00:44:02,180 --> 00:44:02,190
 

2233
00:44:02,190 --> 00:44:04,790
scan through your data every so often or

2234
00:44:04,790 --> 00:44:04,800
 

2235
00:44:04,800 --> 00:44:06,990
whenever you invoke it

2236
00:44:06,990 --> 00:44:07,000
 

2237
00:44:07,000 --> 00:44:08,880
and derive some information about what

2238
00:44:08,880 --> 00:44:08,890
 

2239
00:44:08,890 --> 00:44:10,530
the distribution and when the values

2240
00:44:10,530 --> 00:44:10,540
 

2241
00:44:10,540 --> 00:44:12,900
look like and then maintain that in the

2242
00:44:12,900 --> 00:44:12,910
 

2243
00:44:12,910 --> 00:44:14,340
internal system catalog that it can then

2244
00:44:14,340 --> 00:44:14,350
 

2245
00:44:14,350 --> 00:44:17,730
be used by the optimizers cost model to

2246
00:44:17,730 --> 00:44:17,740
 

2247
00:44:17,740 --> 00:44:21,300
make estimations so again the different

2248
00:44:21,300 --> 00:44:21,310
 

2249
00:44:21,310 --> 00:44:22,560
data systems have different rules about

2250
00:44:22,560 --> 00:44:22,570
 

2251
00:44:22,570 --> 00:44:24,630
when you actually collect this data or

2252
00:44:24,630 --> 00:44:24,640
 

2253
00:44:24,640 --> 00:44:27,180
it can be like if my if I update 10% of

2254
00:44:27,180 --> 00:44:27,190
 

2255
00:44:27,190 --> 00:44:28,650
the tuples in my table then I'll fire

2256
00:44:28,650 --> 00:44:28,660
 

2257
00:44:28,660 --> 00:44:30,950
off the the background stats collector

2258
00:44:30,950 --> 00:44:30,960
 

2259
00:44:30,960 --> 00:44:33,390
if I delete all of it and load it back

2260
00:44:33,390 --> 00:44:33,400
 

2261
00:44:33,400 --> 00:44:36,330
in I'll run it run run them again you

2262
00:44:36,330 --> 00:44:36,340
 

2263
00:44:36,340 --> 00:44:37,710
can also mainly invoke these things

2264
00:44:37,710 --> 00:44:37,720
 

2265
00:44:37,720 --> 00:44:40,500
right the Postgres in sequel light and a

2266
00:44:40,500 --> 00:44:40,510
 

2267
00:44:40,510 --> 00:44:41,820
lot of other systems have the analyze

2268
00:44:41,820 --> 00:44:41,830
 

2269
00:44:41,830 --> 00:44:44,730
keyword that just tells you to again

2270
00:44:44,730 --> 00:44:44,740
 

2271
00:44:44,740 --> 00:44:46,560
scan through a table and and collect

2272
00:44:46,560 --> 00:44:46,570
 

2273
00:44:46,570 --> 00:44:49,020
this information single server it's

2274
00:44:49,020 --> 00:44:49,030
 

2275
00:44:49,030 --> 00:44:50,550
updates of physics and then db2 is

2276
00:44:50,550 --> 00:44:50,560
 

2277
00:44:50,560 --> 00:44:52,050
runstats so there's nothing in the

2278
00:44:52,050 --> 00:44:52,060
 

2279
00:44:52,060 --> 00:44:54,270
sequel standard to say do this most of

2280
00:44:54,270 --> 00:44:54,280
 

2281
00:44:54,280 --> 00:44:56,280
the times you see analyze right but it

2282
00:44:56,280 --> 00:44:56,290
 

2283
00:44:56,290 --> 00:44:57,450
Oracle my sequel have to be different

2284
00:44:57,450 --> 00:44:57,460
 

2285
00:44:57,460 --> 00:45:01,200
when analyze table so what are these

2286
00:45:01,200 --> 00:45:01,210
 

2287
00:45:01,210 --> 00:45:04,080
tags what do these look like well the

2288
00:45:04,080 --> 00:45:04,090
 

2289
00:45:04,090 --> 00:45:06,240
highest level the most easiest thing is

2290
00:45:06,240 --> 00:45:06,250
 

2291
00:45:06,250 --> 00:45:07,860
obviously the the number of tuples I

2292
00:45:07,860 --> 00:45:07,870
 

2293
00:45:07,870 --> 00:45:10,170
have my table right if I want to know

2294
00:45:10,170 --> 00:45:10,180
 

2295
00:45:10,180 --> 00:45:11,460
how many tuples I'm gonna feed into my

2296
00:45:11,460 --> 00:45:11,470
 

2297
00:45:11,470 --> 00:45:13,290
joint algorithm after after do my scan

2298
00:45:13,290 --> 00:45:13,300
 

2299
00:45:13,300 --> 00:45:15,870
you need to know that and you can simply

2300
00:45:15,870 --> 00:45:15,880
 

2301
00:45:15,880 --> 00:45:17,130
derive that based on the number of

2302
00:45:17,130 --> 00:45:17,140
 

2303
00:45:17,140 --> 00:45:19,560
tuples but then we need to know

2304
00:45:19,560 --> 00:45:19,570
 

2305
00:45:19,570 --> 00:45:21,210
something about the values inside those

2306
00:45:21,210 --> 00:45:21,220
 

2307
00:45:21,220 --> 00:45:23,730
tuples for all the different columns so

2308
00:45:23,730 --> 00:45:23,740
 

2309
00:45:23,740 --> 00:45:25,380
the most basic thing we can maintain is

2310
00:45:25,380 --> 00:45:25,390
 

2311
00:45:25,390 --> 00:45:28,080
the the number of distinct values for a

2312
00:45:28,080 --> 00:45:28,090
 

2313
00:45:28,090 --> 00:45:30,390
given attribute in our table so we'll

2314
00:45:30,390 --> 00:45:30,400
 

2315
00:45:30,400 --> 00:45:33,000
define this as a function VAR whether

2316
00:45:33,000 --> 00:45:33,010
 

2317
00:45:33,010 --> 00:45:34,350
this just says again the number distinct

2318
00:45:34,350 --> 00:45:34,360
 

2319
00:45:34,360 --> 00:45:36,660
values I have for actually a in table R

2320
00:45:36,660 --> 00:45:36,670
 

2321
00:45:36,670 --> 00:45:40,070
and then for this we can now derive

2322
00:45:40,070 --> 00:45:40,080
 

2323
00:45:40,080 --> 00:45:42,720
things we actually can use to estimate

2324
00:45:42,720 --> 00:45:42,730
 

2325
00:45:42,730 --> 00:45:44,520
the cost of executing query plans so I

2326
00:45:44,520 --> 00:45:44,530
 

2327
00:45:44,530 --> 00:45:46,050
and this is me the first thing we're

2328
00:45:46,050 --> 00:45:46,060
 

2329
00:45:46,060 --> 00:45:47,400
going to derive is called a select it

2330
00:45:47,400 --> 00:45:47,410
 

2331
00:45:47,410 --> 00:45:50,160
little selection cardinality and this is

2332
00:45:50,160 --> 00:45:50,170

2333
00:45:50,170 --> 00:45:53,670
just gonna be the the average number of

2334
00:45:53,670 --> 00:45:53,680
 

2335
00:45:53,680 --> 00:45:56,340
records that have a particular value in

2336
00:45:56,340 --> 00:45:56,350
 

2337
00:45:56,350 --> 00:45:57,920
an attribute for that for the table

2338
00:45:57,920 --> 00:45:57,930
 

2339
00:45:57,930 --> 00:45:59,790
all right so you think of something

2340
00:45:59,790 --> 00:45:59,800
 

2341
00:45:59,800 --> 00:46:02,670
really simple like you know if I have 10

2342
00:46:02,670 --> 00:46:02,680
 

2343
00:46:02,680 --> 00:46:04,920
to 'pls and I have a single attribute

2344
00:46:04,920 --> 00:46:04,930
 

2345
00:46:04,930 --> 00:46:07,320
and there's 10 unique values for that

2346
00:46:07,320 --> 00:46:07,330
 

2347
00:46:07,330 --> 00:46:09,750
attribute then the selection cardinality

2348
00:46:09,750 --> 00:46:09,760
 

2349
00:46:09,760 --> 00:46:12,870
is is 1 because before I became in

2350
00:46:12,870 --> 00:46:12,880
 

2351
00:46:12,880 --> 00:46:14,520
predicate you know if I'm gonna say does

2352
00:46:14,520 --> 00:46:14,530
 

2353
00:46:14,530 --> 00:46:16,260
something Eagle something I'm gonna get

2354
00:46:16,260 --> 00:46:16,270
 

2355
00:46:16,270 --> 00:46:18,750
back one tuple

2356
00:46:18,750 --> 00:46:18,760

2357
00:46:18,760 --> 00:46:20,860
and so this is just taking the number to

2358
00:46:20,860 --> 00:46:20,870
 

2359
00:46:20,870 --> 00:46:22,150
lose I have and dividing it by the

2360
00:46:22,150 --> 00:46:22,160
 

2361
00:46:22,160 --> 00:46:23,860
number of distinct values for it for a

2362
00:46:23,860 --> 00:46:23,870
 

2363
00:46:23,870 --> 00:46:26,680
particular attribute so what's one

2364
00:46:26,680 --> 00:46:26,690
 

2365
00:46:26,690 --> 00:46:30,700
obvious limitation about this we're

2366
00:46:30,700 --> 00:46:30,710

2367
00:46:30,710 --> 00:46:31,810
taking the number tools they have and

2368
00:46:31,810 --> 00:46:31,820
 

2369
00:46:31,820 --> 00:46:33,190
dividing it by the number of distinct

2370
00:46:33,190 --> 00:46:33,200
 

2371
00:46:33,200 --> 00:46:42,210
values it assumes yes are go ahead yes

2372
00:46:42,210 --> 00:46:42,220


2373
00:46:42,220 --> 00:46:45,490
so he says you need to maintain a set

2374
00:46:45,490 --> 00:46:45,500
 

2375
00:46:45,500 --> 00:46:48,610
for the distinct values I thinking more

2376
00:46:48,610 --> 00:46:48,620
 

2377
00:46:48,620 --> 00:46:53,800
high-level than that exactly yes so a

2378
00:46:53,800 --> 00:46:53,810
 

2379
00:46:53,810 --> 00:46:55,390
big assumption we're gonna make here and

2380
00:46:55,390 --> 00:46:55,400

2381
00:46:55,400 --> 00:46:57,400
this is goes back to the system art is

2382
00:46:57,400 --> 00:46:57,410
 

2383
00:46:57,410 --> 00:47:00,160
is that we're assuming we have uniform

2384
00:47:00,160 --> 00:47:00,170
 

2385
00:47:00,170 --> 00:47:01,900
distribution of values to make this work

2386
00:47:01,900 --> 00:47:01,910
 

2387
00:47:01,910 --> 00:47:05,290
right but we know in reality it's not

2388
00:47:05,290 --> 00:47:05,300
 

2389
00:47:05,300 --> 00:47:07,540
the case at all but I just think of like

2390
00:47:07,540 --> 00:47:07,550
 

2391
00:47:07,550 --> 00:47:10,510
just in CMU right seeing you has ten

2392
00:47:10,510 --> 00:47:10,520
 

2393
00:47:10,520 --> 00:47:12,640
colleges right the school computer

2394
00:47:12,640 --> 00:47:12,650
 

2395
00:47:12,650 --> 00:47:15,880
science is one of them there's way more

2396
00:47:15,880 --> 00:47:15,890
 

2397
00:47:15,890 --> 00:47:18,670
students in SES than what the other

2398
00:47:18,670 --> 00:47:18,680
 

2399
00:47:18,680 --> 00:47:21,100
schools are right music or something

2400
00:47:21,100 --> 00:47:21,110
 

2401
00:47:21,110 --> 00:47:25,690
like that right so if we assume our data

2402
00:47:25,690 --> 00:47:25,700
 

2403
00:47:25,700 --> 00:47:27,880
is uniform then every college if seem

2404
00:47:27,880 --> 00:47:27,890
 

2405
00:47:27,890 --> 00:47:28,660
you will have the same number of

2406
00:47:28,660 --> 00:47:28,670
 

2407
00:47:28,670 --> 00:47:30,310
students but that's not the case at all

2408
00:47:30,310 --> 00:47:30,320
 

2409
00:47:30,320 --> 00:47:32,440
I think of like zip codes there's way

2410
00:47:32,440 --> 00:47:32,450
 

2411
00:47:32,450 --> 00:47:34,540
more people that live in York City and

2412
00:47:34,540 --> 00:47:34,550
 

2413
00:47:34,550 --> 00:47:37,060
those zip codes then live in Wyoming and

2414
00:47:37,060 --> 00:47:37,070
 

2415
00:47:37,070 --> 00:47:40,990
Montana so real data does not fit this

2416
00:47:40,990 --> 00:47:41,000
 

2417
00:47:41,000 --> 00:47:43,420
pattern at all but to simplify our

2418
00:47:43,420 --> 00:47:43,430
 

2419
00:47:43,430 --> 00:47:44,980
explanation of what our cost cost

2420
00:47:44,980 --> 00:47:44,990
 

2421
00:47:44,990 --> 00:47:46,780
estimations are doing we're just going

2422
00:47:46,780 --> 00:47:46,790
 

2423
00:47:46,790 --> 00:47:49,570
to make that assumption right again we

2424
00:47:49,570 --> 00:47:49,580
 

2425
00:47:49,580 --> 00:47:50,920
go through examples of how it doesn't

2426
00:47:50,920 --> 00:47:50,930
 

2427
00:47:50,930 --> 00:47:54,760
work out all right so if we assume our

2428
00:47:54,760 --> 00:47:54,770
 

2429
00:47:54,770 --> 00:47:58,240
data is uniform then it's really easy

2430
00:47:58,240 --> 00:47:58,250
 

2431
00:47:58,250 --> 00:48:00,340
for us to estimate the number of tuples

2432
00:48:00,340 --> 00:48:00,350
 

2433
00:48:00,350 --> 00:48:03,640
we'd have for own unique keys when we do

2434
00:48:03,640 --> 00:48:03,650

2435
00:48:03,650 --> 00:48:06,400
a quality predacons right so say i've

2436
00:48:06,400 --> 00:48:06,410
 

2437
00:48:06,410 --> 00:48:07,930
select star from people where ID equals

2438
00:48:07,930 --> 00:48:07,940

2439
00:48:07,940 --> 00:48:10,300
one two three ID is the primary key so

2440
00:48:10,300 --> 00:48:10,310
 

2441
00:48:10,310 --> 00:48:12,640
the selection cardinality for this is

2442
00:48:12,640 --> 00:48:12,650
 

2443
00:48:12,650 --> 00:48:15,490
obviously one right because only one two

2444
00:48:15,490 --> 00:48:15,500
 

2445
00:48:15,500 --> 00:48:17,110
book could ever have a particular value

2446
00:48:17,110 --> 00:48:17,120
 

2447
00:48:17,120 --> 00:48:18,430
for that for the ID field

2448
00:48:18,430 --> 00:48:18,440
 

2449
00:48:18,440 --> 00:48:20,410
so therefore this predicate does

2450
00:48:20,410 --> 00:48:20,420
 

2451
00:48:20,420 --> 00:48:22,270
something equal something has to always

2452
00:48:22,270 --> 00:48:22,280
 

2453
00:48:22,280 --> 00:48:26,200
return one things get tricky though is

2454
00:48:26,200 --> 00:48:26,210
 

2455
00:48:26,210 --> 00:48:28,410
when you start having other predicates

2456
00:48:28,410 --> 00:48:28,420
 

2457
00:48:28,420 --> 00:48:31,480
range queries inequalities an inequality

2458
00:48:31,480 --> 00:48:31,490
 

2459
00:48:31,490 --> 00:48:32,470
easy

2460
00:48:32,470 --> 00:48:32,480
 

2461
00:48:32,480 --> 00:48:36,130
range queries and other things like that

2462
00:48:36,130 --> 00:48:36,140
 

2463
00:48:36,140 --> 00:48:38,800
and now complex are conjunctions and

2464
00:48:38,800 --> 00:48:38,810
 

2465
00:48:38,810 --> 00:48:41,560
disjunctions as well right so now how do

2466
00:48:41,560 --> 00:48:41,570
 

2467
00:48:41,570 --> 00:48:42,820
I estimate things like value greater

2468
00:48:42,820 --> 00:48:42,830
 

2469
00:48:42,830 --> 00:48:45,280
than 100 or age equals 30 n status

2470
00:48:45,280 --> 00:48:45,290
 

2471
00:48:45,290 --> 00:48:48,970
equals something all right so now we're

2472
00:48:48,970 --> 00:48:48,980
 

2473
00:48:48,980 --> 00:48:50,710
gonna introduce to you know handle these

2474
00:48:50,710 --> 00:48:50,720
 

2475
00:48:50,720 --> 00:48:52,210
we can use a new concept called the

2476
00:48:52,210 --> 00:48:52,220
 

2477
00:48:52,220 --> 00:48:54,520
selectivity by predicate and it's just

2478
00:48:54,520 --> 00:48:54,530
 

2479
00:48:54,530 --> 00:48:56,170
think of this is like the fraction of

2480
00:48:56,170 --> 00:48:56,180
 

2481
00:48:56,180 --> 00:48:58,990
the two pools that will qualify forgiven

2482
00:48:58,990 --> 00:48:59,000
 

2483
00:48:59,000 --> 00:49:00,970
forgiven predicate for like one one

2484
00:49:00,970 --> 00:49:00,980
 

2485
00:49:00,980 --> 00:49:02,740
component of a where clause

2486
00:49:02,740 --> 00:49:02,750
 

2487
00:49:02,750 --> 00:49:05,320
and so the we'll have a bunch of

2488
00:49:05,320 --> 00:49:05,330
 

2489
00:49:05,330 --> 00:49:07,660
formulas we can use based on the

2490
00:49:07,660 --> 00:49:07,670
 

2491
00:49:07,670 --> 00:49:11,230
statistics we'll collect to estimate the

2492
00:49:11,230 --> 00:49:11,240
 

2493
00:49:11,240 --> 00:49:13,780
selectivity but and they're based on

2494
00:49:13,780 --> 00:49:13,790
 

2495
00:49:13,790 --> 00:49:15,250
what kind of operation you're doing a

2496
00:49:15,250 --> 00:49:15,260

2497
00:49:15,260 --> 00:49:17,800
quality range predicate and then

2498
00:49:17,800 --> 00:49:17,810
 

2499
00:49:17,810 --> 00:49:19,000
conjunction disjunction

2500
00:49:19,000 --> 00:49:19,010

2501
00:49:19,010 --> 00:49:20,560
so we'll go through a bunch of these

2502
00:49:20,560 --> 00:49:20,570
 

2503
00:49:20,570 --> 00:49:22,450
examples again we're gonna assume that

2504
00:49:22,450 --> 00:49:22,460
 

2505
00:49:22,460 --> 00:49:25,390
our data's uniform so that the math

2506
00:49:25,390 --> 00:49:25,400
 

2507
00:49:25,400 --> 00:49:27,730
works out in most cases but in reality

2508
00:49:27,730 --> 00:49:27,740
 

2509
00:49:27,740 --> 00:49:31,300
again this is not always the case and in

2510
00:49:31,300 --> 00:49:31,310
 

2511
00:49:31,310 --> 00:49:32,650
commercial systems don't always make

2512
00:49:32,650 --> 00:49:32,660
 

2513
00:49:32,660 --> 00:49:36,250
this assumption all right so we already

2514
00:49:36,250 --> 00:49:36,260
 

2515
00:49:36,260 --> 00:49:38,680
showed how to do predicates where it's

2516
00:49:38,680 --> 00:49:38,690
 

2517
00:49:38,690 --> 00:49:39,400
you know something

2518
00:49:39,400 --> 00:49:39,410
 

2519
00:49:39,410 --> 00:49:40,810
eatle something at a quality predicate

2520
00:49:40,810 --> 00:49:40,820

2521
00:49:40,820 --> 00:49:43,180
on a unique key let's look an example

2522
00:49:43,180 --> 00:49:43,190
 

2523
00:49:43,190 --> 00:49:46,380
when a key may not actually be unique so

2524
00:49:46,380 --> 00:49:46,390
 

2525
00:49:46,390 --> 00:49:49,450
for assuming this we're gonna have the

2526
00:49:49,450 --> 00:49:49,460
 

2527
00:49:49,460 --> 00:49:51,820
table people and they'll be an attribute

2528
00:49:51,820 --> 00:49:51,830
 

2529
00:49:51,830 --> 00:49:55,030
age and the number distinct values for

2530
00:49:55,030 --> 00:49:55,040
 

2531
00:49:55,040 --> 00:49:58,000
this this age attribute will be 5 0

2532
00:49:58,000 --> 00:49:58,010
 

2533
00:49:58,010 --> 00:50:00,160
through 4 and then the number two boys

2534
00:50:00,160 --> 00:50:00,170
 

2535
00:50:00,170 --> 00:50:03,220
we have in this table are just me 5 so

2536
00:50:03,220 --> 00:50:03,230
 

2537
00:50:03,230 --> 00:50:04,900
if you want to determine whether

2538
00:50:04,900 --> 00:50:04,910
 

2539
00:50:04,910 --> 00:50:07,870
something equals something you know does

2540
00:50:07,870 --> 00:50:07,880
 

2541
00:50:07,880 --> 00:50:10,120
at radik all constant again assuming

2542
00:50:10,120 --> 00:50:10,130
 

2543
00:50:10,130 --> 00:50:13,710
that this is this is non unique then our

2544
00:50:13,710 --> 00:50:13,720
 

2545
00:50:13,720 --> 00:50:16,270
our the math works out to produce the

2546
00:50:16,270 --> 00:50:16,280
 

2547
00:50:16,280 --> 00:50:17,380
selectivity it's just to take the

2548
00:50:17,380 --> 00:50:17,390

2549
00:50:17,390 --> 00:50:18,460
selection cardinality with this

2550
00:50:18,460 --> 00:50:18,470

2551
00:50:18,470 --> 00:50:20,470
predicate and divided by the number of

2552
00:50:20,470 --> 00:50:20,480
 

2553
00:50:20,480 --> 00:50:24,310
unique values right so say we're in this

2554
00:50:24,310 --> 00:50:24,320
 

2555
00:50:24,320 --> 00:50:26,440
example here we're age equals two we can

2556
00:50:26,440 --> 00:50:26,450
 

2557
00:50:26,450 --> 00:50:29,950
represent our data as a histogram right

2558
00:50:29,950 --> 00:50:29,960
 

2559
00:50:29,960 --> 00:50:32,170
so for each age the number of tuples we

2560
00:50:32,170 --> 00:50:32,180
 

2561
00:50:32,180 --> 00:50:35,109
have that people at that age and again

2562
00:50:35,109 --> 00:50:35,119
 

2563
00:50:35,119 --> 00:50:36,460
assuming in this case we're only have

2564
00:50:36,460 --> 00:50:36,470
 

2565
00:50:36,470 --> 00:50:38,290
five two pools so each of these bars

2566
00:50:38,290 --> 00:50:38,300
 

2567
00:50:38,300 --> 00:50:42,099
equal one so the first thing we would

2568
00:50:42,099 --> 00:50:42,109
 

2569
00:50:42,109 --> 00:50:44,140
get the number of distinct values along

2570
00:50:44,140 --> 00:50:44,150
 

2571
00:50:44,150 --> 00:50:46,420
the the bottom the x-axis is just

2572
00:50:46,420 --> 00:50:46,430
 

2573
00:50:46,430 --> 00:50:49,029
and then the selection a cardinality of

2574
00:50:49,029 --> 00:50:49,039
 

2575
00:50:49,039 --> 00:50:51,880
age equals 2 which is 1 therefore the

2576
00:50:51,880 --> 00:50:51,890
 

2577
00:50:51,890 --> 00:50:54,309
selectivity of this predicate is just 1

2578
00:50:54,309 --> 00:50:54,319
 

2579
00:50:54,319 --> 00:50:58,930
over v 1 v right simple example and this

2580
00:50:58,930 --> 00:50:58,940
 

2581
00:50:58,940 --> 00:51:02,920
works out if we look at range queries

2582
00:51:02,920 --> 00:51:02,930

2583
00:51:02,930 --> 00:51:05,319
like where age is greater than equal to

2584
00:51:05,319 --> 00:51:05,329
 

2585
00:51:05,329 --> 00:51:07,569
2 right you can use this formula where

2586
00:51:07,569 --> 00:51:07,579
 

2587
00:51:07,579 --> 00:51:10,660
you you take the max value subtracted by

2588
00:51:10,660 --> 00:51:10,670

2589
00:51:10,670 --> 00:51:12,910
the the value trying to do a look-up on

2590
00:51:12,910 --> 00:51:12,920
 

2591
00:51:12,920 --> 00:51:15,760
the constant and divide that by the the

2592
00:51:15,760 --> 00:51:15,770
 

2593
00:51:15,770 --> 00:51:18,160
max value minus the min value and then

2594
00:51:18,160 --> 00:51:18,170
 

2595
00:51:18,170 --> 00:51:20,769
that produces roughly the right roughly

2596
00:51:20,769 --> 00:51:20,779
 

2597
00:51:20,779 --> 00:51:22,329
the estimate but it's not not exactly

2598
00:51:22,329 --> 00:51:22,339
 

2599
00:51:22,339 --> 00:51:23,980
accurate so what I think about is we

2600
00:51:23,980 --> 00:51:23,990
 

2601
00:51:23,990 --> 00:51:25,569
want to know what what the selectivity

2602
00:51:25,569 --> 00:51:25,579
 

2603
00:51:25,579 --> 00:51:27,099
is for this range here we're greater

2604
00:51:27,099 --> 00:51:27,109
 

2605
00:51:27,109 --> 00:51:29,799
than equals to 2 so we had the min and

2606
00:51:29,799 --> 00:51:29,809
 

2607
00:51:29,809 --> 00:51:32,680
the max and we can we can do that

2608
00:51:32,680 --> 00:51:32,690
 

2609
00:51:32,690 --> 00:51:35,609
particular that and then we produce a

2610
00:51:35,609 --> 00:51:35,619
 

2611
00:51:35,619 --> 00:51:39,819
1/2 because we're taking the the ceiling

2612
00:51:39,819 --> 00:51:39,829
 

2613
00:51:39,829 --> 00:51:42,099
of this again it's not entirely accurate

2614
00:51:42,099 --> 00:51:42,109
 

2615
00:51:42,109 --> 00:51:44,410
because in this case here it's actually

2616
00:51:44,410 --> 00:51:44,420
 

2617
00:51:44,420 --> 00:51:46,900
the correct the correct selectivity

2618
00:51:46,900 --> 00:51:46,910
 

2619
00:51:46,910 --> 00:51:50,740
would be 3/5 the formula comes out to be

2620
00:51:50,740 --> 00:51:50,750

2621
00:51:50,750 --> 00:51:53,260
1/2 so this is a good example where the

2622
00:51:53,260 --> 00:51:53,270
 

2623
00:51:53,270 --> 00:51:55,029
math is not exactly right there's some

2624
00:51:55,029 --> 00:51:55,039
 

2625
00:51:55,039 --> 00:51:56,170
corner cases like this where you don't

2626
00:51:56,170 --> 00:51:56,180
 

2627
00:51:56,180 --> 00:51:59,289
get it perfect if it was instead of

2628
00:51:59,289 --> 00:51:59,299
 

2629
00:51:59,299 --> 00:52:01,120
greater than equals equals it was just

2630
00:52:01,120 --> 00:52:01,130
 

2631
00:52:01,130 --> 00:52:02,920
greater than then it would just be from

2632
00:52:02,920 --> 00:52:02,930
 

2633
00:52:02,930 --> 00:52:08,319
this over and then it would be 2/5 right

2634
00:52:08,319 --> 00:52:08,329
 

2635
00:52:08,329 --> 00:52:10,089
and again but if we use that simple

2636
00:52:10,089 --> 00:52:10,099
 

2637
00:52:10,099 --> 00:52:12,150
formula then it doesn't work out for

2638
00:52:12,150 --> 00:52:12,160
 

2639
00:52:12,160 --> 00:52:14,349
negation queries this is actually really

2640
00:52:14,349 --> 00:52:14,359
 

2641
00:52:14,359 --> 00:52:17,260
easy to do right age doesn't equal to 2

2642
00:52:17,260 --> 00:52:17,270
 

2643
00:52:17,270 --> 00:52:19,359
well we already know how to compute the

2644
00:52:19,359 --> 00:52:19,369
 

2645
00:52:19,369 --> 00:52:24,250
selectivity of h equals 2 so we just

2646
00:52:24,250 --> 00:52:24,260
 

2647
00:52:24,260 --> 00:52:27,849
take the selection cardinality of H

2648
00:52:27,849 --> 00:52:27,859
 

2649
00:52:27,859 --> 00:52:30,970
equals 2 and just negate it so that we

2650
00:52:30,970 --> 00:52:30,980
 

2651
00:52:30,980 --> 00:52:33,819
get these other bounds here and then now

2652
00:52:33,819 --> 00:52:33,829
 

2653
00:52:33,829 --> 00:52:36,670
our selectivity is just 1 minus 1/5 so

2654
00:52:36,670 --> 00:52:36,680
 

2655
00:52:36,680 --> 00:52:40,240
we get 4/5 there so it should be kind of

2656
00:52:40,240 --> 00:52:40,250
 

2657
00:52:40,250 --> 00:52:43,000
clear at this point that these the

2658
00:52:43,000 --> 00:52:43,010
 

2659
00:52:43,010 --> 00:52:45,809
selectivity looks a lot like

2660
00:52:45,809 --> 00:52:45,819

2661
00:52:45,819 --> 00:52:48,789
probabilities right it's like what's the

2662
00:52:48,789 --> 00:52:48,799
 

2663
00:52:48,799 --> 00:52:50,500
probability that my predicate is gonna

2664
00:52:50,500 --> 00:52:50,510
 

2665
00:52:50,510 --> 00:52:53,829
match a particular tuple in in in my

2666
00:52:53,829 --> 00:52:53,839
 

2667
00:52:53,839 --> 00:52:57,130
input and so if we assume that they're

2668
00:52:57,130 --> 00:52:57,140
 

2669
00:52:57,140 --> 00:52:58,809
probabilities which is not again it's

2670
00:52:58,809 --> 00:52:58,819

2671
00:52:58,819 --> 00:53:00,100
not always exactly

2672
00:53:00,100 --> 00:53:00,110
 

2673
00:53:00,110 --> 00:53:02,860
not entirely accurate but if we assume

2674
00:53:02,860 --> 00:53:02,870
 

2675
00:53:02,870 --> 00:53:04,660
that they're actually probabilities then

2676
00:53:04,660 --> 00:53:04,670
 

2677
00:53:04,670 --> 00:53:05,830
we can take all the rules that we

2678
00:53:05,830 --> 00:53:05,840
 

2679
00:53:05,840 --> 00:53:07,990
learned from you know probability 101 in

2680
00:53:07,990 --> 00:53:08,000
 

2681
00:53:08,000 --> 00:53:10,090
our intro math courses and apply them to

2682
00:53:10,090 --> 00:53:10,100

2683
00:53:10,100 --> 00:53:14,860
our to our predicates here so say again

2684
00:53:14,860 --> 00:53:14,870

2685
00:53:14,870 --> 00:53:17,320
you have if you have a conjunction right

2686
00:53:17,320 --> 00:53:17,330
 

2687
00:53:17,330 --> 00:53:19,150
you're even an Clause in this case here

2688
00:53:19,150 --> 00:53:19,160
 

2689
00:53:19,160 --> 00:53:21,520
I or H equals two and name like some

2690
00:53:21,520 --> 00:53:21,530
 

2691
00:53:21,530 --> 00:53:22,570
some wildcard

2692
00:53:22,570 --> 00:53:22,580
 

2693
00:53:22,580 --> 00:53:26,740
then I can just take the the predicate

2694
00:53:26,740 --> 00:53:26,750
 

2695
00:53:26,750 --> 00:53:30,010
take the the selectivity of age equals

2696
00:53:30,010 --> 00:53:30,020
 

2697
00:53:30,020 --> 00:53:33,400
two and multiply that by the predicate

2698
00:53:33,400 --> 00:53:33,410
 

2699
00:53:33,410 --> 00:53:35,290
or the selectivity of the predicate name

2700
00:53:35,290 --> 00:53:35,300
 

2701
00:53:35,300 --> 00:53:37,720
equals wildcard and then that produces

2702
00:53:37,720 --> 00:53:37,730
 

2703
00:53:37,730 --> 00:53:40,840
my my my total selectivity for the

2704
00:53:40,840 --> 00:53:40,850
 

2705
00:53:40,850 --> 00:53:42,550
entire predicate right so think of this

2706
00:53:42,550 --> 00:53:42,560
 

2707
00:53:42,560 --> 00:53:45,160
p1 is this range here are the tuples

2708
00:53:45,160 --> 00:53:45,170
 

2709
00:53:45,170 --> 00:53:47,530
level match the first predicate p2 is

2710
00:53:47,530 --> 00:53:47,540
 

2711
00:53:47,540 --> 00:53:48,760
the range of the tuples that match the

2712
00:53:48,760 --> 00:53:48,770
 

2713
00:53:48,770 --> 00:53:52,180
second predicate so the area in which

2714
00:53:52,180 --> 00:53:52,190
 

2715
00:53:52,190 --> 00:53:54,070
the both credits will evaluate to true

2716
00:53:54,070 --> 00:53:54,080
 

2717
00:53:54,080 --> 00:53:55,930
is just the intersection of this part

2718
00:53:55,930 --> 00:53:55,940
 

2719
00:53:55,940 --> 00:53:58,000
here and we get that by multiplying the

2720
00:53:58,000 --> 00:53:58,010
 

2721
00:53:58,010 --> 00:54:01,090
two probabilities together so the big

2722
00:54:01,090 --> 00:54:01,100
 

2723
00:54:01,100 --> 00:54:02,620
assumption now another big assumption

2724
00:54:02,620 --> 00:54:02,630

2725
00:54:02,630 --> 00:54:04,780
we're making here is that the predicates

2726
00:54:04,780 --> 00:54:04,790
 

2727
00:54:04,790 --> 00:54:05,860
are independent of each other and

2728
00:54:05,860 --> 00:54:05,870
 

2729
00:54:05,870 --> 00:54:07,920
therefore you can multiply them together

2730
00:54:07,920 --> 00:54:07,930
 

2731
00:54:07,930 --> 00:54:12,220
that's not always the case either right

2732
00:54:12,220 --> 00:54:12,230
 

2733
00:54:12,230 --> 00:54:14,890
think again think of real real datasets

2734
00:54:14,890 --> 00:54:14,900
 

2735
00:54:14,900 --> 00:54:19,120
I could have a I could have a table

2736
00:54:19,120 --> 00:54:19,130
 

2737
00:54:19,130 --> 00:54:22,060
people their dresses and I have zip code

2738
00:54:22,060 --> 00:54:22,070
 

2739
00:54:22,070 --> 00:54:25,150
and city alright and for a particular

2740
00:54:25,150 --> 00:54:25,160
 

2741
00:54:25,160 --> 00:54:27,880
zip code so our particular city it's

2742
00:54:27,880 --> 00:54:27,890
 

2743
00:54:27,890 --> 00:54:31,450
always gonna be in in one and only one

2744
00:54:31,450 --> 00:54:31,460
 

2745
00:54:31,460 --> 00:54:34,180
zip code so if I assume they're

2746
00:54:34,180 --> 00:54:34,190
 

2747
00:54:34,190 --> 00:54:36,340
independent then if I say you know we're

2748
00:54:36,340 --> 00:54:36,350
 

2749
00:54:36,350 --> 00:54:37,870
zip code equals one five two one seven

2750
00:54:37,870 --> 00:54:37,880

2751
00:54:37,880 --> 00:54:40,570
and City Eagles Pittsburgh if I take

2752
00:54:40,570 --> 00:54:40,580
 

2753
00:54:40,580 --> 00:54:41,800
those two predicates and multiply them

2754
00:54:41,800 --> 00:54:41,810
 

2755
00:54:41,810 --> 00:54:44,680
together I'm gonna be sort of under

2756
00:54:44,680 --> 00:54:44,690
 

2757
00:54:44,690 --> 00:54:45,880
estimating the number of triples that

2758
00:54:45,880 --> 00:54:45,890

2759
00:54:45,890 --> 00:54:47,800
will match me because it's really if I'm

2760
00:54:47,800 --> 00:54:47,810
 

2761
00:54:47,810 --> 00:54:49,750
in if I'm in zip code one five two one

2762
00:54:49,750 --> 00:54:49,760
 

2763
00:54:49,760 --> 00:54:52,240
seven I'm sorry if I'm in City

2764
00:54:52,240 --> 00:54:52,250
 

2765
00:54:52,250 --> 00:54:54,250
Pittsburgh that I have to be in one five

2766
00:54:54,250 --> 00:54:54,260
 

2767
00:54:54,260 --> 00:54:55,960
two one seven so therefore they're not

2768
00:54:55,960 --> 00:54:55,970
 

2769
00:54:55,970 --> 00:54:57,250
independent cuz they're correlated with

2770
00:54:57,250 --> 00:54:57,260
 

2771
00:54:57,260 --> 00:55:00,160
each other so this math doesn't actually

2772
00:55:00,160 --> 00:55:00,170
 

2773
00:55:00,170 --> 00:55:02,830
work out in real data sets there's a

2774
00:55:02,830 --> 00:55:02,840
 

2775
00:55:02,840 --> 00:55:03,940
bunch of rent ways the commercial guys

2776
00:55:03,940 --> 00:55:03,950
 

2777
00:55:03,950 --> 00:55:05,470
can handle this but this is again

2778
00:55:05,470 --> 00:55:05,480
 

2779
00:55:05,480 --> 00:55:06,880
another big fallacy or another big

2780
00:55:06,880 --> 00:55:06,890
 

2781
00:55:06,890 --> 00:55:09,550
assumption that was made in the 1970s

2782
00:55:09,550 --> 00:55:09,560
 

2783
00:55:09,560 --> 00:55:10,690
that still carries through to gay

2784
00:55:10,690 --> 00:55:10,700
 

2785
00:55:10,700 --> 00:55:12,160
because this makes things easier to

2786
00:55:12,160 --> 00:55:12,170
 

2787
00:55:12,170 --> 00:55:14,250
reason about

2788
00:55:14,250 --> 00:55:14,260
 

2789
00:55:14,260 --> 00:55:17,440
disjunctions it's it's the opposite of

2790
00:55:17,440 --> 00:55:17,450
 

2791
00:55:17,450 --> 00:55:19,930
conjunction right again we want to take

2792
00:55:19,930 --> 00:55:19,940
 

2793
00:55:19,940 --> 00:55:21,970
all the predicates that either match

2794
00:55:21,970 --> 00:55:21,980
 

2795
00:55:21,980 --> 00:55:24,400
this part or this part and it's just the

2796
00:55:24,400 --> 00:55:24,410
 

2797
00:55:24,410 --> 00:55:26,680
entire area and then this is the math up

2798
00:55:26,680 --> 00:55:26,690
 

2799
00:55:26,690 --> 00:55:29,170
here that takes fix the that makes that

2800
00:55:29,170 --> 00:55:29,180

2801
00:55:29,180 --> 00:55:30,400
assumption that they're independent and

2802
00:55:30,400 --> 00:55:30,410
 

2803
00:55:30,410 --> 00:55:41,230
adds them together in the back yes the

2804
00:55:41,230 --> 00:55:41,240
 

2805
00:55:41,240 --> 00:55:49,930
typo we're sorry on this yes yes I'll

2806
00:55:49,930 --> 00:55:49,940
 

2807
00:55:49,940 --> 00:55:53,440
fix that thank you that's a good

2808
00:55:53,440 --> 00:55:53,450
 

2809
00:55:53,450 --> 00:55:54,579
correction thank you and you didn't

2810
00:55:54,579 --> 00:55:54,589
 

2811
00:55:54,589 --> 00:55:58,329
curse okay all right so where's this all

2812
00:55:58,329 --> 00:55:58,339
 

2813
00:55:58,339 --> 00:56:03,819
leading to so we want to now estimate

2814
00:56:03,819 --> 00:56:03,829

2815
00:56:03,829 --> 00:56:06,130
the result set size of joins this is the

2816
00:56:06,130 --> 00:56:06,140
 

2817
00:56:06,140 --> 00:56:07,930
thing that all the the optimizers are

2818
00:56:07,930 --> 00:56:07,940
 

2819
00:56:07,940 --> 00:56:09,490
gonna get wrong and this matters the

2820
00:56:09,490 --> 00:56:09,500
 

2821
00:56:09,500 --> 00:56:13,120
most right the idea is getting given two

2822
00:56:13,120 --> 00:56:13,130
 

2823
00:56:13,130 --> 00:56:15,630
tuples I'm sorry two tables are ns and

2824
00:56:15,630 --> 00:56:15,640
 

2825
00:56:15,640 --> 00:56:19,270
some some some where clause of how

2826
00:56:19,270 --> 00:56:19,280
 

2827
00:56:19,280 --> 00:56:21,160
you're going to join them we want to

2828
00:56:21,160 --> 00:56:21,170
 

2829
00:56:21,170 --> 00:56:22,359
estimate the number of tuples we're

2830
00:56:22,359 --> 00:56:22,369
 

2831
00:56:22,369 --> 00:56:26,770
gonna produce as output right if we're

2832
00:56:26,770 --> 00:56:26,780
 

2833
00:56:26,780 --> 00:56:29,470
just joining two tables this doesn't

2834
00:56:29,470 --> 00:56:29,480
 

2835
00:56:29,480 --> 00:56:31,390
matter that much because we really care

2836
00:56:31,390 --> 00:56:31,400
 

2837
00:56:31,400 --> 00:56:32,410
about the number two was getting fed

2838
00:56:32,410 --> 00:56:32,420
 

2839
00:56:32,420 --> 00:56:33,579
into the query plan because we can

2840
00:56:33,579 --> 00:56:33,589

2841
00:56:33,589 --> 00:56:34,690
decide which ones the universe of the

2842
00:56:34,690 --> 00:56:34,700
 

2843
00:56:34,700 --> 00:56:36,609
outer but now if you're doing multi way

2844
00:56:36,609 --> 00:56:36,619
 

2845
00:56:36,619 --> 00:56:38,470
joins or multiple joins in your inner

2846
00:56:38,470 --> 00:56:38,480
 

2847
00:56:38,480 --> 00:56:40,870
query then it matters a lot to know how

2848
00:56:40,870 --> 00:56:40,880
 

2849
00:56:40,880 --> 00:56:42,130
much tuple how many tuples are getting

2850
00:56:42,130 --> 00:56:42,140
 

2851
00:56:42,140 --> 00:56:43,990
output about you join because you would

2852
00:56:43,990 --> 00:56:44,000
 

2853
00:56:44,000 --> 00:56:45,670
then you want to figure out who should

2854
00:56:45,670 --> 00:56:45,680
 

2855
00:56:45,680 --> 00:56:47,200
be at the bottom and who should you know

2856
00:56:47,200 --> 00:56:47,210
 

2857
00:56:47,210 --> 00:56:48,190
who should be the universe at the outer

2858
00:56:48,190 --> 00:56:48,200
 

2859
00:56:48,200 --> 00:56:49,450
that way because now you're joining on

2860
00:56:49,450 --> 00:56:49,460
 

2861
00:56:49,460 --> 00:56:51,520
derive tables or joined tables rather

2862
00:56:51,520 --> 00:56:51,530
 

2863
00:56:51,530 --> 00:56:55,000
than the base tables themselves so in

2864
00:56:55,000 --> 00:56:55,010
 

2865
00:56:55,010 --> 00:56:57,390
the sake of time I'm gonna skip the the

2866
00:56:57,390 --> 00:56:57,400
 

2867
00:56:57,400 --> 00:57:00,160
math here but the basic idea is again

2868
00:57:00,160 --> 00:57:00,170
 

2869
00:57:00,170 --> 00:57:01,420
it's just we're estimating the number

2870
00:57:01,420 --> 00:57:01,430
 

2871
00:57:01,430 --> 00:57:03,130
two was getting fed in from from from

2872
00:57:03,130 --> 00:57:03,140
 

2873
00:57:03,140 --> 00:57:05,260
one table and the other table and then

2874
00:57:05,260 --> 00:57:05,270
 

2875
00:57:05,270 --> 00:57:06,490
we have some simple formula to estimate

2876
00:57:06,490 --> 00:57:06,500
 

2877
00:57:06,500 --> 00:57:07,960
the number two plus that will match on

2878
00:57:07,960 --> 00:57:07,970
 

2879
00:57:07,970 --> 00:57:11,770
this but as I said in in the in most

2880
00:57:11,770 --> 00:57:11,780

2881
00:57:11,780 --> 00:57:13,059
systems they get this horribly wrong

2882
00:57:13,059 --> 00:57:13,069
 

2883
00:57:13,069 --> 00:57:14,650
actually in all systems they get this

2884
00:57:14,650 --> 00:57:14,660
 

2885
00:57:14,660 --> 00:57:17,380
horribly wrong because the problem is

2886
00:57:17,380 --> 00:57:17,390
 

2887
00:57:17,390 --> 00:57:19,569
that if you get the if you get the

2888
00:57:19,569 --> 00:57:19,579
 

2889
00:57:19,579 --> 00:57:21,550
selectivity slightly incorrect for the

2890
00:57:21,550 --> 00:57:21,560
 

2891
00:57:21,560 --> 00:57:23,920
joins at the bottom the query plan then

2892
00:57:23,920 --> 00:57:23,930
 

2893
00:57:23,930 --> 00:57:26,430
as you go up big that

2894
00:57:26,430 --> 00:57:26,440
 

2895
00:57:26,440 --> 00:57:30,120
that error increases right because now

2896
00:57:30,120 --> 00:57:30,130
 

2897
00:57:30,130 --> 00:57:31,380
you're throwing errors on errors on

2898
00:57:31,380 --> 00:57:31,390
 

2899
00:57:31,390 --> 00:57:32,579
errors and it gets worse and worse and

2900
00:57:32,579 --> 00:57:32,589
 

2901
00:57:32,589 --> 00:57:34,740
worse so again we'll cover this in the

2902
00:57:34,740 --> 00:57:34,750
 

2903
00:57:34,750 --> 00:57:35,970
advanced class when I'm time to do it

2904
00:57:35,970 --> 00:57:35,980
 

2905
00:57:35,980 --> 00:57:40,380
here but sequel server actually does the

2906
00:57:40,380 --> 00:57:40,390
 

2907
00:57:40,390 --> 00:57:42,599
best job of figuring this thing out and

2908
00:57:42,599 --> 00:57:42,609
 

2909
00:57:42,609 --> 00:57:44,730
most systems underestimate it and you

2910
00:57:44,730 --> 00:57:44,740
 

2911
00:57:44,740 --> 00:57:46,200
would get under estimations if you make

2912
00:57:46,200 --> 00:57:46,210
 

2913
00:57:46,210 --> 00:57:47,819
the assumptions like uniform data

2914
00:57:47,819 --> 00:57:47,829

2915
00:57:47,829 --> 00:57:51,420
distribution or or independent

2916
00:57:51,420 --> 00:57:51,430
 

2917
00:57:51,430 --> 00:57:57,780
probabilities all right so this is fine

2918
00:57:57,780 --> 00:57:57,790
 

2919
00:57:57,790 --> 00:57:59,339
so now we have some basic formulas you

2920
00:57:59,339 --> 00:57:59,349
 

2921
00:57:59,349 --> 00:58:00,839
can use to estimate the selectivity of

2922
00:58:00,839 --> 00:58:00,849
 

2923
00:58:00,849 --> 00:58:02,849
predicates right and we can use that to

2924
00:58:02,849 --> 00:58:02,859
 

2925
00:58:02,859 --> 00:58:04,530
figure out how many two boys are getting

2926
00:58:04,530 --> 00:58:04,540
 

2927
00:58:04,540 --> 00:58:05,790
fed into an operator and how many tuples

2928
00:58:05,790 --> 00:58:05,800
 

2929
00:58:05,800 --> 00:58:07,500
are gonna it's gonna output but how are

2930
00:58:07,500 --> 00:58:07,510
 

2931
00:58:07,510 --> 00:58:10,530
we actually deriving those that's

2932
00:58:10,530 --> 00:58:10,540
 

2933
00:58:10,540 --> 00:58:11,550
selectivity you're like what is the

2934
00:58:11,550 --> 00:58:11,560
 

2935
00:58:11,560 --> 00:58:13,339
underlying information we have we have

2936
00:58:13,339 --> 00:58:13,349
 

2937
00:58:13,349 --> 00:58:17,130
so the the way the David Simmons going

2938
00:58:17,130 --> 00:58:17,140
 

2939
00:58:17,140 --> 00:58:20,069
to maintain information about what your

2940
00:58:20,069 --> 00:58:20,079
 

2941
00:58:20,079 --> 00:58:21,870
data actually looks like is through

2942
00:58:21,870 --> 00:58:21,880
 

2943
00:58:21,880 --> 00:58:26,849
histograms right the the basic idea is

2944
00:58:26,849 --> 00:58:26,859
 

2945
00:58:26,859 --> 00:58:28,620
that for every you know every unique

2946
00:58:28,620 --> 00:58:28,630
 

2947
00:58:28,630 --> 00:58:30,650
value or a range of values

2948
00:58:30,650 --> 00:58:30,660
 

2949
00:58:30,660 --> 00:58:34,079
how many tuples actually have had that

2950
00:58:34,079 --> 00:58:34,089
 

2951
00:58:34,089 --> 00:58:36,690
particular value right so in the case

2952
00:58:36,690 --> 00:58:36,700
 

2953
00:58:36,700 --> 00:58:38,880
here along the x-axis we have the number

2954
00:58:38,880 --> 00:58:38,890
 

2955
00:58:38,890 --> 00:58:40,260
distinct values for an attribute and

2956
00:58:40,260 --> 00:58:40,270
 

2957
00:58:40,270 --> 00:58:41,609
then the y-axis is the number of

2958
00:58:41,609 --> 00:58:41,619
 

2959
00:58:41,619 --> 00:58:43,319
occurrences again for this particular

2960
00:58:43,319 --> 00:58:43,329
 

2961
00:58:43,329 --> 00:58:45,569
example I'm assuming our data is uniform

2962
00:58:45,569 --> 00:58:45,579
 

2963
00:58:45,579 --> 00:58:47,550
so there's actually nothing I really

2964
00:58:47,550 --> 00:58:47,560
 

2965
00:58:47,560 --> 00:58:49,079
really need to store here I disagree to

2966
00:58:49,079 --> 00:58:49,089
 

2967
00:58:49,089 --> 00:58:50,910
store one value say all tuples have you

2968
00:58:50,910 --> 00:58:50,920
 

2969
00:58:50,920 --> 00:58:54,270
know all values for every value in my

2970
00:58:54,270 --> 00:58:54,280
 

2971
00:58:54,280 --> 00:58:55,740
table for this pickle attribute there

2972
00:58:55,740 --> 00:58:55,750
 

2973
00:58:55,750 --> 00:58:58,470
will be five tuples that match it the

2974
00:58:58,470 --> 00:58:58,480
 

2975
00:58:58,480 --> 00:58:59,579
problem is real data looks something

2976
00:58:59,579 --> 00:58:59,589

2977
00:58:59,589 --> 00:59:01,290
like this right it's the the

2978
00:59:01,290 --> 00:59:01,300
 

2979
00:59:01,300 --> 00:59:03,150
distribution is all over the map

2980
00:59:03,150 --> 00:59:03,160
 

2981
00:59:03,160 --> 00:59:04,859
it's oftentimes it's as if theand

2982
00:59:04,859 --> 00:59:04,869
 

2983
00:59:04,869 --> 00:59:07,170
distribution right so let up our law

2984
00:59:07,170 --> 00:59:07,180

2985
00:59:07,180 --> 00:59:08,970
curve but for our purposes here this is

2986
00:59:08,970 --> 00:59:08,980
 

2987
00:59:08,980 --> 00:59:12,990
fine and so now the problem is for a

2988
00:59:12,990 --> 00:59:13,000
 

2989
00:59:13,000 --> 00:59:15,150
particular attribute particular value in

2990
00:59:15,150 --> 00:59:15,160

2991
00:59:15,160 --> 00:59:17,790
that attribute we would have to maintain

2992
00:59:17,790 --> 00:59:17,800

2993
00:59:17,800 --> 00:59:20,460
a giant map that says for this value

2994
00:59:20,460 --> 00:59:20,470
 

2995
00:59:20,470 --> 00:59:22,950
here's the count for right and this you

2996
00:59:22,950 --> 00:59:22,960
 

2997
00:59:22,960 --> 00:59:23,940
think about how you actually would

2998
00:59:23,940 --> 00:59:23,950
 

2999
00:59:23,950 --> 00:59:25,440
implement this if you just for every

3000
00:59:25,440 --> 00:59:25,450
 

3001
00:59:25,450 --> 00:59:27,180
single distinct value to maintain this

3002
00:59:27,180 --> 00:59:27,190
 

3003
00:59:27,190 --> 00:59:29,910
mapping it would be huge right for a

3004
00:59:29,910 --> 00:59:29,920
 

3005
00:59:29,920 --> 00:59:32,990
column where you have say unique numbers

3006
00:59:32,990 --> 00:59:33,000
 

3007
00:59:33,000 --> 00:59:36,390
if you have a 32-bit number and that's

3008
00:59:36,390 --> 00:59:36,400
 

3009
00:59:36,400 --> 00:59:37,890
unique throughout the entire column in

3010
00:59:37,890 --> 00:59:37,900
 

3011
00:59:37,900 --> 00:59:39,870
your histogram map

3012
00:59:39,870 --> 00:59:39,880
 

3013
00:59:39,880 --> 00:59:42,029
you would have another 32-bit integer

3014
00:59:42,029 --> 00:59:42,039
 

3015
00:59:42,039 --> 00:59:43,829
just keep track of the number of tuples

3016
00:59:43,829 --> 00:59:43,839
 

3017
00:59:43,839 --> 00:59:44,999
I have that value and it's always gonna

3018
00:59:44,999 --> 00:59:45,009
 

3019
00:59:45,009 --> 00:59:47,730
be one right always or some small urban

3020
00:59:47,730 --> 00:59:47,740
 

3021
00:59:47,740 --> 00:59:49,079
so you base actually doubling the size

3022
00:59:49,079 --> 00:59:49,089
 

3023
00:59:49,089 --> 00:59:51,420
of every single column because you have

3024
00:59:51,420 --> 00:59:51,430
 

3025
00:59:51,430 --> 00:59:54,120
to store this additional information so

3026
00:59:54,120 --> 00:59:54,130
 

3027
00:59:54,130 --> 01:00:00,150
way to to fix this is to use buckets all

3028
01:00:00,150 --> 01:00:00,160
 

3029
01:00:00,160 --> 01:00:02,549
right so the idea here is that for every

3030
01:00:02,549 --> 01:00:02,559
 

3031
01:00:02,559 --> 01:00:05,579
for every three values in our in our in

3032
01:00:05,579 --> 01:00:05,589
 

3033
01:00:05,589 --> 01:00:08,279
our histogram we're just gonna bucket

3034
01:00:08,279 --> 01:00:08,289
 

3035
01:00:08,289 --> 01:00:09,779
them together count the number of tuples

3036
01:00:09,779 --> 01:00:09,789
 

3037
01:00:09,789 --> 01:00:11,670
that they have are the number of values

3038
01:00:11,670 --> 01:00:11,680
 

3039
01:00:11,680 --> 01:00:12,839
that there are number of currencies that

3040
01:00:12,839 --> 01:00:12,849
 

3041
01:00:12,849 --> 01:00:14,670
they have and then for every single

3042
01:00:14,670 --> 01:00:14,680
 

3043
01:00:14,680 --> 01:00:17,430
bucket we just have keep track of that

3044
01:00:17,430 --> 01:00:17,440
 

3045
01:00:17,440 --> 01:00:19,019
the min and Max and then the count for

3046
01:00:19,019 --> 01:00:19,029
 

3047
01:00:19,029 --> 01:00:22,859
that I say we're condensing down the the

3048
01:00:22,859 --> 01:00:22,869
 

3049
01:00:22,869 --> 01:00:25,440
the the information so that it's more

3050
01:00:25,440 --> 01:00:25,450
 

3051
01:00:25,450 --> 01:00:28,230
manageable size of course what's the

3052
01:00:28,230 --> 01:00:28,240
 

3053
01:00:28,240 --> 01:00:32,579
obvious problem with this right

3054
01:00:32,579 --> 01:00:32,589
 

3055
01:00:32,589 --> 01:00:37,019
say it again sorry he says the problem

3056
01:00:37,019 --> 01:00:37,029
 

3057
01:00:37,029 --> 01:00:38,279
is get the maintain these numbers so

3058
01:00:38,279 --> 01:00:38,289
 

3059
01:00:38,289 --> 01:00:40,230
we're not so much yes you have to

3060
01:00:40,230 --> 01:00:40,240
 

3061
01:00:40,240 --> 01:00:41,279
maintain the numbers we talked about

3062
01:00:41,279 --> 01:00:41,289
 

3063
01:00:41,289 --> 01:00:44,099
that before the you run analyze or you

3064
01:00:44,099 --> 01:00:44,109
 

3065
01:00:44,109 --> 01:00:45,870
think you have this background process

3066
01:00:45,870 --> 01:00:45,880
 

3067
01:00:45,880 --> 01:00:47,549
actually does this I'm thinking more in

3068
01:00:47,549 --> 01:00:47,559
 

3069
01:00:47,559 --> 01:00:48,569
terms of the accuracy of this

3070
01:00:48,569 --> 01:00:48,579
 

3071
01:00:48,579 --> 01:00:53,099
information right he says they could be

3072
01:00:53,099 --> 01:00:53,109
 

3073
01:00:53,109 --> 01:00:54,779
largely different numbers right so we're

3074
01:00:54,779 --> 01:00:54,789
 

3075
01:00:54,789 --> 01:00:56,930
sort of blindly bucketing together

3076
01:00:56,930 --> 01:00:56,940
 

3077
01:00:56,940 --> 01:01:00,240
contiguous values in our range list and

3078
01:01:00,240 --> 01:01:00,250
 

3079
01:01:00,250 --> 01:01:02,460
that may actually not be the right thing

3080
01:01:02,460 --> 01:01:02,470
 

3081
01:01:02,470 --> 01:01:04,680
to do because there may be because since

3082
01:01:04,680 --> 01:01:04,690
 

3083
01:01:04,690 --> 01:01:06,450
we're taking essentially just computing

3084
01:01:06,450 --> 01:01:06,460
 

3085
01:01:06,460 --> 01:01:08,730
the average now you could be some of the

3086
01:01:08,730 --> 01:01:08,740
 

3087
01:01:08,740 --> 01:01:10,499
really low value a really high value and

3088
01:01:10,499 --> 01:01:10,509
 

3089
01:01:10,509 --> 01:01:13,859
we're missing those outliers so way to

3090
01:01:13,859 --> 01:01:13,869
 

3091
01:01:13,869 --> 01:01:16,019
fix this is use what are called equity

3092
01:01:16,019 --> 01:01:16,029
 

3093
01:01:16,029 --> 01:01:17,819
with histograms and for this one I'll

3094
01:01:17,819 --> 01:01:17,829
 

3095
01:01:17,829 --> 01:01:21,029
use quantiles and the idea is that for

3096
01:01:21,029 --> 01:01:21,039
 

3097
01:01:21,039 --> 01:01:23,490
every as we go along for every single

3098
01:01:23,490 --> 01:01:23,500
 

3099
01:01:23,500 --> 01:01:23,999
bucket

3100
01:01:23,999 --> 01:01:24,009
 

3101
01:01:24,009 --> 01:01:26,789
the counts always gonna be the same it's

3102
01:01:26,789 --> 01:01:26,799
 

3103
01:01:26,799 --> 01:01:28,140
just we're gonna have a variable number

3104
01:01:28,140 --> 01:01:28,150
 

3105
01:01:28,150 --> 01:01:32,160
of elements or values in that bucket so

3106
01:01:32,160 --> 01:01:32,170
 

3107
01:01:32,170 --> 01:01:34,710
in the fruit and the these three buckets

3108
01:01:34,710 --> 01:01:34,720
 

3109
01:01:34,720 --> 01:01:36,630
here bucket one bucket - bucket for the

3110
01:01:36,630 --> 01:01:36,640
 

3111
01:01:36,640 --> 01:01:39,480
count will be 12 so we try to add as

3112
01:01:39,480 --> 01:01:39,490
 

3113
01:01:39,490 --> 01:01:42,720
many values as we can to get that you

3114
01:01:42,720 --> 01:01:42,730
 

3115
01:01:42,730 --> 01:01:45,180
know they get that count be 12 this this

3116
01:01:45,180 --> 01:01:45,190
 

3117
01:01:45,190 --> 01:01:47,460
middle guy here is sort of an outlier he

3118
01:01:47,460 --> 01:01:47,470
 

3119
01:01:47,470 --> 01:01:49,380
has a larger bucket size or bucket width

3120
01:01:49,380 --> 01:01:49,390
 

3121
01:01:49,390 --> 01:01:52,230
and the counts only 9 all right so then

3122
01:01:52,230 --> 01:01:52,240
 

3123
01:01:52,240 --> 01:01:53,489
we end up something like

3124
01:01:53,489 --> 01:01:53,499
 

3125
01:01:53,499 --> 01:01:56,650
so the number elements or the count per

3126
01:01:56,650 --> 01:01:56,660
 

3127
01:01:56,660 --> 01:02:00,069
bucket will be the same roughly but the

3128
01:02:00,069 --> 01:02:00,079
 

3129
01:02:00,079 --> 01:02:02,259
number of values distinct values in a

3130
01:02:02,259 --> 01:02:02,269
 

3131
01:02:02,269 --> 01:02:05,890
bucket can can vary another option also

3132
01:02:05,890 --> 01:02:05,900

3133
01:02:05,900 --> 01:02:08,349
to do is to maintain a separate data

3134
01:02:08,349 --> 01:02:08,359
 

3135
01:02:08,359 --> 01:02:09,700
structure for heavy hitters like if I

3136
01:02:09,700 --> 01:02:09,710
 

3137
01:02:09,710 --> 01:02:12,549
know I have one value that has way way

3138
01:02:12,549 --> 01:02:12,559
 

3139
01:02:12,559 --> 01:02:16,150
different number of occurrences in our

3140
01:02:16,150 --> 01:02:16,160
 

3141
01:02:16,160 --> 01:02:17,680
column than all other values I'll

3142
01:02:17,680 --> 01:02:17,690
 

3143
01:02:17,690 --> 01:02:19,420
maintain that as a separate data

3144
01:02:19,420 --> 01:02:19,430
 

3145
01:02:19,430 --> 01:02:21,729
structure because I wouldn't have really

3146
01:02:21,729 --> 01:02:21,739
 

3147
01:02:21,739 --> 01:02:24,099
accurate predictions for that one so

3148
01:02:24,099 --> 01:02:24,109
 

3149
01:02:24,109 --> 01:02:25,839
sort of combination of these things to

3150
01:02:25,839 --> 01:02:25,849
 

3151
01:02:25,849 --> 01:02:30,579
make this all work so again these

3152
01:02:30,579 --> 01:02:30,589
 

3153
01:02:30,589 --> 01:02:31,900
histograms are essentially you're

3154
01:02:31,900 --> 01:02:31,910
 

3155
01:02:31,910 --> 01:02:34,660
compressing the data about the metadata

3156
01:02:34,660 --> 01:02:34,670
 

3157
01:02:34,670 --> 01:02:36,460
about about your data and we have to do

3158
01:02:36,460 --> 01:02:36,470
 

3159
01:02:36,470 --> 01:02:37,870
this to make it more manageable but

3160
01:02:37,870 --> 01:02:37,880
 

3161
01:02:37,880 --> 01:02:41,499
again we sacrifice accuracy well it's

3162
01:02:41,499 --> 01:02:41,509
 

3163
01:02:41,509 --> 01:02:42,970
another approach we can you and use a

3164
01:02:42,970 --> 01:02:42,980
 

3165
01:02:42,980 --> 01:02:46,410
set of maintaining histograms

3166
01:02:46,410 --> 01:02:46,420


3167
01:02:46,420 --> 01:02:48,460
to estimate you know the number of

3168
01:02:48,460 --> 01:02:48,470
 

3169
01:02:48,470 --> 01:02:53,289
tuples for particular value I try this

3170
01:02:53,289 --> 01:02:53,299
 

3171
01:02:53,299 --> 01:02:54,700
every year and no one actually can guess

3172
01:02:54,700 --> 01:02:54,710
 

3173
01:02:54,710 --> 01:02:54,999
it

3174
01:02:54,999 --> 01:02:55,009

3175
01:02:55,009 --> 01:03:01,029
sampling right so the the idea is that

3176
01:03:01,029 --> 01:03:01,039
 

3177
01:03:01,039 --> 01:03:04,029
rather than checking histogram to say

3178
01:03:04,029 --> 01:03:04,039
 

3179
01:03:04,039 --> 01:03:05,859
you know how many what's my selectivity

3180
01:03:05,859 --> 01:03:05,869

3181
01:03:05,869 --> 01:03:07,839
for a predicate for this particular

3182
01:03:07,839 --> 01:03:07,849
 

3183
01:03:07,849 --> 01:03:10,539
value I'll just collect some sample data

3184
01:03:10,539 --> 01:03:10,549
 

3185
01:03:10,549 --> 01:03:13,479
from the underlying table and then this

3186
01:03:13,479 --> 01:03:13,489
 

3187
01:03:13,489 --> 01:03:15,069
run a complete scrunch will scan on that

3188
01:03:15,069 --> 01:03:15,079
 

3189
01:03:15,079 --> 01:03:17,349
sample and that helps me I can use that

3190
01:03:17,349 --> 01:03:17,359
 

3191
01:03:17,359 --> 01:03:19,329
to figure out my selectivity of my

3192
01:03:19,329 --> 01:03:19,339
 

3193
01:03:19,339 --> 01:03:22,089
predicates right so let's say I have a

3194
01:03:22,089 --> 01:03:22,099
 

3195
01:03:22,099 --> 01:03:24,249
query here almost like all the people

3196
01:03:24,249 --> 01:03:24,259
 

3197
01:03:24,259 --> 01:03:26,470
with age greater than 50 say I have a

3198
01:03:26,470 --> 01:03:26,480
 

3199
01:03:26,480 --> 01:03:29,620
billion tuples all right so what I'll do

3200
01:03:29,620 --> 01:03:29,630
 

3201
01:03:29,630 --> 01:03:31,779
is for that query I'll just sample every

3202
01:03:31,779 --> 01:03:31,789
 

3203
01:03:31,789 --> 01:03:33,099
other or something like that it's

3204
01:03:33,099 --> 01:03:33,109
 

3205
01:03:33,109 --> 01:03:35,529
usually much smaller small amount store

3206
01:03:35,529 --> 01:03:35,539
 

3207
01:03:35,539 --> 01:03:38,410
this in a sort of temporary table that's

3208
01:03:38,410 --> 01:03:38,420
 

3209
01:03:38,420 --> 01:03:39,940
only accessible to the query optimizer

3210
01:03:39,940 --> 01:03:39,950
 

3211
01:03:39,950 --> 01:03:41,440
so you're treating this like a regular

3212
01:03:41,440 --> 01:03:41,450
 

3213
01:03:41,450 --> 01:03:43,269
table but it says you can't run queries

3214
01:03:43,269 --> 01:03:43,279
 

3215
01:03:43,279 --> 01:03:44,680
against it right so using all the same

3216
01:03:44,680 --> 01:03:44,690
 

3217
01:03:44,690 --> 01:03:47,170
you know table storage and heap storage

3218
01:03:47,170 --> 01:03:47,180
 

3219
01:03:47,180 --> 01:03:50,049
stuff we talked about before and then

3220
01:03:50,049 --> 01:03:50,059
 

3221
01:03:50,059 --> 01:03:51,579
when my query shows up and I say all

3222
01:03:51,579 --> 01:03:51,589
 

3223
01:03:51,589 --> 01:03:52,839
right what's the selectivity of age

3224
01:03:52,839 --> 01:03:52,849
 

3225
01:03:52,849 --> 01:03:55,479
greater than hippie I just do a

3226
01:03:55,479 --> 01:03:55,489
 

3227
01:03:55,489 --> 01:03:58,390
sequential scan on my on my sample to

3228
01:03:58,390 --> 01:03:58,400
 

3229
01:03:58,400 --> 01:04:00,640
figure out what it is all right I don't

3230
01:04:00,640 --> 01:04:00,650
 

3231
01:04:00,650 --> 01:04:02,200
look at any histograms and the idea is

3232
01:04:02,200 --> 01:04:02,210
 

3233
01:04:02,210 --> 01:04:04,650
that if I have obviously a a

3234
01:04:04,650 --> 01:04:04,660
 

3235
01:04:04,660 --> 01:04:06,750
reasonably large enough sample size then

3236
01:04:06,750 --> 01:04:06,760
 

3237
01:04:06,760 --> 01:04:08,370
that would be an accurate reflection of

3238
01:04:08,370 --> 01:04:08,380
 

3239
01:04:08,380 --> 01:04:13,099
what the underlying table looks like yes

3240
01:04:13,099 --> 01:04:13,109
 

3241
01:04:13,109 --> 01:04:15,349
one's fine

3242
01:04:15,349 --> 01:04:15,359
 

3243
01:04:15,359 --> 01:04:24,839
yes question is why is called equal to F

3244
01:04:24,839 --> 01:04:24,849
 

3245
01:04:24,849 --> 01:04:25,950
where's the bucket or not call it I

3246
01:04:25,950 --> 01:04:25,960
 

3247
01:04:25,960 --> 01:04:31,829
could with um good question so this

3248
01:04:31,829 --> 01:04:31,839
 

3249
01:04:31,839 --> 01:04:33,329
would be echoed with records you always

3250
01:04:33,329 --> 01:04:33,339
 

3251
01:04:33,339 --> 01:04:36,089
take two three elements let me

3252
01:04:36,089 --> 01:04:36,099
 

3253
01:04:36,099 --> 01:04:40,049
double-check that what's that wait

3254
01:04:40,049 --> 01:04:40,059
 

3255
01:04:40,059 --> 01:04:42,270
echoed what echo death all right is that

3256
01:04:42,270 --> 01:04:42,280
 

3257
01:04:42,280 --> 01:04:42,829
what it's called

3258
01:04:42,829 --> 01:04:42,839
 

3259
01:04:42,839 --> 01:04:46,170
all right we'll do it but double check

3260
01:04:46,170 --> 01:04:46,180
 

3261
01:04:46,180 --> 01:04:51,569
this okay all right so we have like

3262
01:04:51,569 --> 01:04:51,579
 

3263
01:04:51,579 --> 01:04:57,599
eight minutes left I'm gonna I'm gonna

3264
01:04:57,599 --> 01:04:57,609
 

3265
01:04:57,609 --> 01:05:00,210
pause this now we'll come back to this

3266
01:05:00,210 --> 01:05:00,220
 

3267
01:05:00,220 --> 01:05:02,579
after the midterm because I want to get

3268
01:05:02,579 --> 01:05:02,589
 

3269
01:05:02,589 --> 01:05:05,099
to the review but just to understand

3270
01:05:05,099 --> 01:05:05,109
 

3271
01:05:05,109 --> 01:05:09,180
we're at we've able to we have as we

3272
01:05:09,180 --> 01:05:09,190

3273
01:05:09,190 --> 01:05:12,660
have a way to derive information about

3274
01:05:12,660 --> 01:05:12,670
 

3275
01:05:12,670 --> 01:05:14,579
the tables we go around queries on we

3276
01:05:14,579 --> 01:05:14,589
 

3277
01:05:14,589 --> 01:05:17,010
have some formulas we can use to to

3278
01:05:17,010 --> 01:05:17,020

3279
01:05:17,020 --> 01:05:18,420
estimate the selectivity of predicates

3280
01:05:18,420 --> 01:05:18,430
 

3281
01:05:18,430 --> 01:05:20,160
and then the next phase we want to

3282
01:05:20,160 --> 01:05:20,170
 

3283
01:05:20,170 --> 01:05:22,230
figure out how we actually can use that

3284
01:05:22,230 --> 01:05:22,240
 

3285
01:05:22,240 --> 01:05:23,730
information to help us guide our search

3286
01:05:23,730 --> 01:05:23,740
 

3287
01:05:23,740 --> 01:05:25,799
to find a better query plan so let's

3288
01:05:25,799 --> 01:05:25,809
 

3289
01:05:25,809 --> 01:05:27,930
pause on this from now because we only

3290
01:05:27,930 --> 01:05:27,940
 

3291
01:05:27,940 --> 01:05:30,150
have ten minutes left and we'll go to

3292
01:05:30,150 --> 01:05:30,160
 

3293
01:05:30,160 --> 01:05:41,789
the midterm review okay

3294
01:05:41,789 --> 01:05:41,799
 

3295
01:05:41,799 --> 01:05:44,370
so again the midterm is this Wednesday

3296
01:05:44,370 --> 01:05:44,380
 

3297
01:05:44,380 --> 01:05:48,289
in this class at the same time right

3298
01:05:48,289 --> 01:05:48,299
 

3299
01:05:48,299 --> 01:05:50,250
everyone needs to take the midterm no

3300
01:05:50,250 --> 01:05:50,260
 

3301
01:05:50,260 --> 01:05:54,750
one no one is excluded right you should

3302
01:05:54,750 --> 01:05:54,760
 

3303
01:05:54,760 --> 01:05:56,970
bring your CMU ID because I need to use

3304
01:05:56,970 --> 01:05:56,980
 

3305
01:05:56,980 --> 01:05:58,049
class of hundred people so I need to be

3306
01:05:58,049 --> 01:05:58,059
 

3307
01:05:58,059 --> 01:06:00,720
able check who's who you need to bring a

3308
01:06:00,720 --> 01:06:00,730
 

3309
01:06:00,730 --> 01:06:03,240
calculator to help you dude you know the

3310
01:06:03,240 --> 01:06:03,250
 

3311
01:06:03,250 --> 01:06:05,010
basic formulas that we've talked about

3312
01:06:05,010 --> 01:06:05,020
 

3313
01:06:05,020 --> 01:06:07,160
and then you're allowed to bring a

3314
01:06:07,160 --> 01:06:07,170
 

3315
01:06:07,170 --> 01:06:09,539
one-page double-sided of handwritten

3316
01:06:09,539 --> 01:06:09,549
 

3317
01:06:09,549 --> 01:06:11,370
notes with anything anything you want

3318
01:06:11,370 --> 01:06:11,380
 

3319
01:06:11,380 --> 01:06:12,599
any format things like that so that

3320
01:06:12,599 --> 01:06:12,609
 

3321
01:06:12,609 --> 01:06:14,430
means you can't take the slide and sort

3322
01:06:14,430 --> 01:06:14,440
 

3323
01:06:14,440 --> 01:06:16,260
of compress them down and try to fit

3324
01:06:16,260 --> 01:06:16,270
 

3325
01:06:16,270 --> 01:06:17,190
them onto a page everything that's

3326
01:06:17,190 --> 01:06:17,200
 

3327
01:06:17,200 --> 01:06:17,940
behind written

3328
01:06:17,940 --> 01:06:17,950
 

3329
01:06:17,950 --> 01:06:19,589
and I do that because I think you get

3330
01:06:19,589 --> 01:06:19,599
 

3331
01:06:19,599 --> 01:06:21,030
more out of it that way and so just copy

3332
01:06:21,030 --> 01:06:21,040
 

3333
01:06:21,040 --> 01:06:24,900
and pasting alright so this is my list

3334
01:06:24,900 --> 01:06:24,910
 

3335
01:06:24,910 --> 01:06:26,430
of what not to bring and it gets longer

3336
01:06:26,430 --> 01:06:26,440
 

3337
01:06:26,440 --> 01:06:29,280
every single year so a few years ago

3338
01:06:29,280 --> 01:06:29,290
 

3339
01:06:29,290 --> 01:06:31,260
someone brought a live animal don't do

3340
01:06:31,260 --> 01:06:31,270
 

3341
01:06:31,270 --> 01:06:33,420
that right and then last year somebody

3342
01:06:33,420 --> 01:06:33,430
 

3343
01:06:33,430 --> 01:06:35,039
brought their wet mangy from their dorm

3344
01:06:35,039 --> 01:06:35,049
 

3345
01:06:35,049 --> 01:06:36,510
right and I was like what the hell's

3346
01:06:36,510 --> 01:06:36,520
 

3347
01:06:36,520 --> 01:06:38,910
going on right so they brought it and

3348
01:06:38,910 --> 01:06:38,920
 

3349
01:06:38,920 --> 01:06:40,020
wasn't this room but it's another room

3350
01:06:40,020 --> 01:06:40,030
 

3351
01:06:40,030 --> 01:06:41,700
they brought it to dry while they were

3352
01:06:41,700 --> 01:06:41,710
 

3353
01:06:41,710 --> 01:06:43,380
taking the exam and it smelled kind of

3354
01:06:43,380 --> 01:06:43,390
 

3355
01:06:43,390 --> 01:06:45,120
funky because it was like sitting in the

3356
01:06:45,120 --> 01:06:45,130
 

3357
01:06:45,130 --> 01:06:45,599
washing machine

3358
01:06:45,599 --> 01:06:45,609
 

3359
01:06:45,609 --> 01:06:47,039
overnight so you do not bring your wet

3360
01:06:47,039 --> 01:06:47,049
 

3361
01:06:47,049 --> 01:06:50,160
laundry all right if you have something

3362
01:06:50,160 --> 01:06:50,170
 

3363
01:06:50,170 --> 01:06:52,220
crazy you want to bring email me

3364
01:06:52,220 --> 01:06:52,230
 

3365
01:06:52,230 --> 01:06:54,480
beforehand and let me know and just

3366
01:06:54,480 --> 01:06:54,490
 

3367
01:06:54,490 --> 01:06:55,349
figure out whether it's okay because

3368
01:06:55,349 --> 01:06:55,359
 

3369
01:06:55,359 --> 01:06:56,789
otherwise I gotta you know add you to

3370
01:06:56,789 --> 01:06:56,799
 

3371
01:06:56,799 --> 01:07:00,030
the list here right so no snakes no dogs

3372
01:07:00,030 --> 01:07:00,040
 

3373
01:07:00,040 --> 01:07:03,809
no what laundry okay so the midterm will

3374
01:07:03,809 --> 01:07:03,819
 

3375
01:07:03,819 --> 01:07:06,150
cover everything up and tune up to and

3376
01:07:06,150 --> 01:07:06,160
 

3377
01:07:06,160 --> 01:07:07,920
including the the joint lecture lecture

3378
01:07:07,920 --> 01:07:07,930
 

3379
01:07:07,930 --> 01:07:10,920
twelve you're gonna be closed book you

3380
01:07:10,920 --> 01:07:10,930
 

3381
01:07:10,930 --> 01:07:13,890
get get one one sheet of handwritten

3382
01:07:13,890 --> 01:07:13,900
 

3383
01:07:13,900 --> 01:07:16,049
notes double-sided and then if you need

3384
01:07:16,049 --> 01:07:16,059
 

3385
01:07:16,059 --> 01:07:18,480
any special accommodations please email

3386
01:07:18,480 --> 01:07:18,490
 

3387
01:07:18,490 --> 01:07:20,370
me now so we can make sure those things

3388
01:07:20,370 --> 01:07:20,380
 

3389
01:07:20,380 --> 01:07:22,770
happen and then this is the link to what

3390
01:07:22,770 --> 01:07:22,780
 

3391
01:07:22,780 --> 01:07:24,569
I post on Piazza for the midterm study

3392
01:07:24,569 --> 01:07:24,579
 

3393
01:07:24,579 --> 01:07:26,670
guide it has the list of chapters that

3394
01:07:26,670 --> 01:07:26,680
 

3395
01:07:26,680 --> 01:07:29,520
are covered in the textbook that are

3396
01:07:29,520 --> 01:07:29,530
 

3397
01:07:29,530 --> 01:07:32,039
relevant to the exam and then a link to

3398
01:07:32,039 --> 01:07:32,049
 

3399
01:07:32,049 --> 01:07:34,319
go find the solutions to any I think the

3400
01:07:34,319 --> 01:07:34,329
 

3401
01:07:34,329 --> 01:07:37,020
odd problems if you want to expand the

3402
01:07:37,020 --> 01:07:37,030

3403
01:07:37,030 --> 01:07:38,069
things that you're looking at and a link

3404
01:07:38,069 --> 01:07:38,079
 

3405
01:07:38,079 --> 01:07:40,170
also to the the practice exam that we

3406
01:07:40,170 --> 01:07:40,180
 

3407
01:07:40,180 --> 01:07:43,829
gave out from a few years ago okay all

3408
01:07:43,829 --> 01:07:43,839
 

3409
01:07:43,839 --> 01:07:46,109
right so what's gonna be on the exam so

3410
01:07:46,109 --> 01:07:46,119
 

3411
01:07:46,119 --> 01:07:49,170
obviously the relational model the you

3412
01:07:49,170 --> 01:07:49,180
 

3413
01:07:49,180 --> 01:07:50,579
know the focus on integrity constraints

3414
01:07:50,579 --> 01:07:50,589
 

3415
01:07:50,589 --> 01:07:52,770
what does that mean in relational

3416
01:07:52,770 --> 01:07:52,780
 

3417
01:07:52,780 --> 01:07:54,480
algebra we didn't cover any relational

3418
01:07:54,480 --> 01:07:54,490
 

3419
01:07:54,490 --> 01:07:56,010
calculus so don't worry about that if

3420
01:07:56,010 --> 01:07:56,020
 

3421
01:07:56,020 --> 01:07:58,230
it's in the textbook right again I'm not

3422
01:07:58,230 --> 01:07:58,240
 

3423
01:07:58,240 --> 01:07:59,400
gonna ask you to write more complex

3424
01:07:59,400 --> 01:07:59,410
 

3425
01:07:59,410 --> 01:08:01,500
things just understand what these basic

3426
01:08:01,500 --> 01:08:01,510
 

3427
01:08:01,510 --> 01:08:06,120
operators actually do for sequel again

3428
01:08:06,120 --> 01:08:06,130
 

3429
01:08:06,130 --> 01:08:08,250
everyone should already know Siegel from

3430
01:08:08,250 --> 01:08:08,260
 

3431
01:08:08,260 --> 01:08:10,349
the first homework assignment and so

3432
01:08:10,349 --> 01:08:10,359
 

3433
01:08:10,359 --> 01:08:11,730
I'll ask sort of high-level questions

3434
01:08:11,730 --> 01:08:11,740
 

3435
01:08:11,740 --> 01:08:13,530
about the more complex things that we

3436
01:08:13,530 --> 01:08:13,540
 

3437
01:08:13,540 --> 01:08:15,930
covered I join zagraz to common table

3438
01:08:15,930 --> 01:08:15,940
 

3439
01:08:15,940 --> 01:08:17,490
expressions these are the things that

3440
01:08:17,490 --> 01:08:17,500
 

3441
01:08:17,500 --> 01:08:18,479
you guys did in the first homework

3442
01:08:18,479 --> 01:08:18,489
 

3443
01:08:18,489 --> 01:08:20,249
assignment I won't cover window

3444
01:08:20,249 --> 01:08:20,259
 

3445
01:08:20,259 --> 01:08:21,689
functions because you guys weren't

3446
01:08:21,689 --> 01:08:21,699

3447
01:08:21,699 --> 01:08:23,450
actually able to do that in sequel Lite

3448
01:08:23,450 --> 01:08:23,460
 

3449
01:08:23,460 --> 01:08:25,559
but again think about it we're not gonna

3450
01:08:25,559 --> 01:08:25,569
 

3451
01:08:25,569 --> 01:08:26,970
ask you to write really complex queries

3452
01:08:26,970 --> 01:08:26,980
 

3453
01:08:26,980 --> 01:08:28,800
because you have to write it you know on

3454
01:08:28,800 --> 01:08:28,810
 

3455
01:08:28,810 --> 01:08:30,590
paper we're not gonna

3456
01:08:30,590 --> 01:08:30,600
 

3457
01:08:30,600 --> 01:08:32,510
in testan see whether that key works so

3458
01:08:32,510 --> 01:08:32,520
 

3459
01:08:32,520 --> 01:08:34,580
we're more we're more interested in the

3460
01:08:34,580 --> 01:08:34,590
 

3461
01:08:34,590 --> 01:08:36,710
high-level concepts about what these

3462
01:08:36,710 --> 01:08:36,720
 

3463
01:08:36,720 --> 01:08:39,800
queries are actually doing and then this

3464
01:08:39,800 --> 01:08:39,810
 

3465
01:08:39,810 --> 01:08:41,450
comes up every year and then for a

3466
01:08:41,450 --> 01:08:41,460
 

3467
01:08:41,460 --> 01:08:42,380
common table expressions they would

3468
01:08:42,380 --> 01:08:42,390
 

3469
01:08:42,390 --> 01:08:46,040
include recursive expressions so then we

3470
01:08:46,040 --> 01:08:46,050

3471
01:08:46,050 --> 01:08:47,630
get into the actual implementation of

3472
01:08:47,630 --> 01:08:47,640
 

3473
01:08:47,640 --> 01:08:49,580
the database system so we covered things

3474
01:08:49,580 --> 01:08:49,590
 

3475
01:08:49,590 --> 01:08:53,150
like buffer management policies so you

3476
01:08:53,150 --> 01:08:53,160
 

3477
01:08:53,160 --> 01:08:56,900
know LRU mru clock how to handle ntral

3478
01:08:56,900 --> 01:08:56,910
 

3479
01:08:56,910 --> 01:08:58,670
flooding we talked about how to actually

3480
01:08:58,670 --> 01:08:58,680
 

3481
01:08:58,680 --> 01:09:00,680
represent the database on disk or heap

3482
01:09:00,680 --> 01:09:00,690
 

3483
01:09:00,690 --> 01:09:02,990
files or link lists page directories

3484
01:09:02,990 --> 01:09:03,000

3485
01:09:03,000 --> 01:09:04,640
things like that then we talked about

3486
01:09:04,640 --> 01:09:04,650
 

3487
01:09:04,650 --> 01:09:06,349
when you bring her at what section side

3488
01:09:06,349 --> 01:09:06,359
 

3489
01:09:06,359 --> 01:09:08,450
the page right we talked about slotted

3490
01:09:08,450 --> 01:09:08,460
 

3491
01:09:08,460 --> 01:09:09,920
page layout we talked a log structured

3492
01:09:09,920 --> 01:09:09,930
 

3493
01:09:09,930 --> 01:09:11,870
layout we talked about what the tuple

3494
01:09:11,870 --> 01:09:11,880
 

3495
01:09:11,880 --> 01:09:14,240
how to represent data and tuples all

3496
01:09:14,240 --> 01:09:14,250
 

3497
01:09:14,250 --> 01:09:15,500
right what's in the header things like

3498
01:09:15,500 --> 01:09:15,510
 

3499
01:09:15,510 --> 01:09:19,370
that then we talked about hash hash

3500
01:09:19,370 --> 01:09:19,380
 

3501
01:09:19,380 --> 01:09:21,860
tables so again there's two high level

3502
01:09:21,860 --> 01:09:21,870
 

3503
01:09:21,870 --> 01:09:23,450
approaches to hashing there's the static

3504
01:09:23,450 --> 01:09:23,460

3505
01:09:23,460 --> 01:09:26,270
hash tables like linear probing the

3506
01:09:26,270 --> 01:09:26,280

3507
01:09:26,280 --> 01:09:28,280
robin hood cuckoo hashing then there was

3508
01:09:28,280 --> 01:09:28,290
 

3509
01:09:28,290 --> 01:09:30,200
it dynamic hash tables extendable

3510
01:09:30,200 --> 01:09:30,210
 

3511
01:09:30,210 --> 01:09:32,599
hashing chain hashing and linear hashing

3512
01:09:32,599 --> 01:09:32,609
 

3513
01:09:32,609 --> 01:09:35,090
and again we're not going to ask you to

3514
01:09:35,090 --> 01:09:35,100
 

3515
01:09:35,100 --> 01:09:36,920
you know write code it's more about the

3516
01:09:36,920 --> 01:09:36,930
 

3517
01:09:36,930 --> 01:09:38,210
high-level concepts of what these

3518
01:09:38,210 --> 01:09:38,220
 

3519
01:09:38,220 --> 01:09:41,510
different hashing schemes actually do I

3520
01:09:41,510 --> 01:09:41,520
 

3521
01:09:41,520 --> 01:09:43,220
don't care about hash functions it's

3522
01:09:43,220 --> 01:09:43,230
 

3523
01:09:43,230 --> 01:09:45,740
more about the hash table itself and

3524
01:09:45,740 --> 01:09:45,750
 

3525
01:09:45,750 --> 01:09:48,950
then we also want to care about how

3526
01:09:48,950 --> 01:09:48,960
 

3527
01:09:48,960 --> 01:09:51,050
these data structures relate to or

3528
01:09:51,050 --> 01:09:51,060
 

3529
01:09:51,060 --> 01:09:53,750
compare with B plus trees right when

3530
01:09:53,750 --> 01:09:53,760
 

3531
01:09:53,760 --> 01:09:54,650
would you want to use the hash table

3532
01:09:54,650 --> 01:09:54,660
 

3533
01:09:54,660 --> 01:09:57,890
versus a B plus tree then we talked

3534
01:09:57,890 --> 01:09:57,900
 

3535
01:09:57,900 --> 01:09:59,990
about order preserving tree indexes then

3536
01:09:59,990 --> 01:10:00,000
 

3537
01:10:00,000 --> 01:10:01,550
we spent a lot of time talking about B

3538
01:10:01,550 --> 01:10:01,560
 

3539
01:10:01,560 --> 01:10:03,350
plus trees you guys are building this

3540
01:10:03,350 --> 01:10:03,360
 

3541
01:10:03,360 --> 01:10:05,360
for your first second assignment so

3542
01:10:05,360 --> 01:10:05,370
 

3543
01:10:05,370 --> 01:10:08,180
insertions deletions splits merges how

3544
01:10:08,180 --> 01:10:08,190

3545
01:10:08,190 --> 01:10:10,310
they differ with a b-tree or B link tree

3546
01:10:10,310 --> 01:10:10,320
 

3547
01:10:10,320 --> 01:10:13,430
at a high level and how it actually do

3548
01:10:13,430 --> 01:10:13,440
 

3549
01:10:13,440 --> 01:10:15,050
latch grabbing Blackledge coupling

3550
01:10:15,050 --> 01:10:15,060

3551
01:10:15,060 --> 01:10:18,800
including doing leaf node scans and any

3552
01:10:18,800 --> 01:10:18,810
 

3553
01:10:18,810 --> 01:10:20,510
basic optimization is like you know

3554
01:10:20,510 --> 01:10:20,520
 

3555
01:10:20,520 --> 01:10:24,410
delayed or delayed parent splitting and

3556
01:10:24,410 --> 01:10:24,420

3557
01:10:24,420 --> 01:10:25,430
then we talked about a little bit about

3558
01:10:25,430 --> 01:10:25,440
 

3559
01:10:25,440 --> 01:10:27,650
radix trees and skip lists I realized

3560
01:10:27,650 --> 01:10:27,660

3561
01:10:27,660 --> 01:10:28,880
this is not in the textbooks we're not

3562
01:10:28,880 --> 01:10:28,890
 

3563
01:10:28,890 --> 01:10:30,710
going to complicated things it's more

3564
01:10:30,710 --> 01:10:30,720
 

3565
01:10:30,720 --> 01:10:33,140
about a high-level what are the what are

3566
01:10:33,140 --> 01:10:33,150
 

3567
01:10:33,150 --> 01:10:35,810
the high-level design differences

3568
01:10:35,810 --> 01:10:35,820
 

3569
01:10:35,820 --> 01:10:37,480
between these different data structures

3570
01:10:37,480 --> 01:10:37,490
 

3571
01:10:37,490 --> 01:10:42,540
versus versus B plus trees

3572
01:10:42,540 --> 01:10:42,550


3573
01:10:42,550 --> 01:10:44,310
then we talked about sorting and

3574
01:10:44,310 --> 01:10:44,320
 

3575
01:10:44,320 --> 01:10:45,600
particularly focused on the external

3576
01:10:45,600 --> 01:10:45,610
 

3577
01:10:45,610 --> 01:10:47,430
merge sort which I've got two variants

3578
01:10:47,430 --> 01:10:47,440
 

3579
01:10:47,440 --> 01:10:49,169
of it right there was the two way merge

3580
01:10:49,169 --> 01:10:49,179
 

3581
01:10:49,179 --> 01:10:51,629
sort and then there was the the the K

3582
01:10:51,629 --> 01:10:51,639
 

3583
01:10:51,639 --> 01:10:53,640
way or the general-purpose external

3584
01:10:53,640 --> 01:10:53,650
 

3585
01:10:53,650 --> 01:10:55,770
merge sort and the basic questions are

3586
01:10:55,770 --> 01:10:55,780

3587
01:10:55,780 --> 01:10:57,089
going to be things like as you're seeing

3588
01:10:57,089 --> 01:10:57,099
 

3589
01:10:57,099 --> 01:10:58,830
in the the current homework assignment

3590
01:10:58,830 --> 01:10:58,840
 

3591
01:10:58,840 --> 01:11:00,600
right if I have a data file that looks

3592
01:11:00,600 --> 01:11:00,610
 

3593
01:11:00,610 --> 01:11:02,160
like this and I had this new many

3594
01:11:02,160 --> 01:11:02,170
 

3595
01:11:02,170 --> 01:11:04,740
buffers how many passes a trauma need to

3596
01:11:04,740 --> 01:11:04,750
 

3597
01:11:04,750 --> 01:11:06,689
do or how quickly can I sort it all

3598
01:11:06,689 --> 01:11:06,699
 

3599
01:11:06,699 --> 01:11:11,459
right query processing we talked about

3600
01:11:11,459 --> 01:11:11,469
 

3601
01:11:11,469 --> 01:11:13,649
different processing models iterator or

3602
01:11:13,649 --> 01:11:13,659

3603
01:11:13,659 --> 01:11:15,390
volcano versus vectorize Arce

3604
01:11:15,390 --> 01:11:15,400
 

3605
01:11:15,400 --> 01:11:18,600
materialized again what are the design

3606
01:11:18,600 --> 01:11:18,610
 

3607
01:11:18,610 --> 01:11:19,649
trade-offs and performance

3608
01:11:19,649 --> 01:11:19,659

3609
01:11:19,659 --> 01:11:21,600
characteristics of these different

3610
01:11:21,600 --> 01:11:21,610
 

3611
01:11:21,610 --> 01:11:23,549
approaches what kind of workloads would

3612
01:11:23,549 --> 01:11:23,559

3613
01:11:23,559 --> 01:11:26,609
you want to use one versus another right

3614
01:11:26,609 --> 01:11:26,619
 

3615
01:11:26,619 --> 01:11:27,780
and then we talked about joint

3616
01:11:27,780 --> 01:11:27,790

3617
01:11:27,790 --> 01:11:30,030
algorithms nested loop joins hash joins

3618
01:11:30,030 --> 01:11:30,040
 

3619
01:11:30,040 --> 01:11:32,250
and sort merge joins again what are the

3620
01:11:32,250 --> 01:11:32,260
 

3621
01:11:32,260 --> 01:11:34,410
performance implications of them if I

3622
01:11:34,410 --> 01:11:34,420
 

3623
01:11:34,420 --> 01:11:35,970
give you a data set with this how many

3624
01:11:35,970 --> 01:11:35,980
 

3625
01:11:35,980 --> 01:11:37,919
this many tuples in many pages you have

3626
01:11:37,919 --> 01:11:37,929
 

3627
01:11:37,929 --> 01:11:40,530
this many blocks how many you know how

3628
01:11:40,530 --> 01:11:40,540
 

3629
01:11:40,540 --> 01:11:42,899
many disk i/o is it gonna take you to do

3630
01:11:42,899 --> 01:11:42,909
 

3631
01:11:42,909 --> 01:11:48,600
the join all right so this is it so any

3632
01:11:48,600 --> 01:11:48,610
 

3633
01:11:48,610 --> 01:11:54,479
any questions everyone feels very fairly

3634
01:11:54,479 --> 01:11:54,489
 

3635
01:11:54,489 --> 01:11:58,709
confident Stata basis where I should be

3636
01:11:58,709 --> 01:11:58,719
 

3637
01:11:58,719 --> 01:12:02,600
fun awesome ok that's it then we're done

3638
01:12:02,600 --> 01:12:02,610
 

3639
01:12:02,610 --> 01:12:06,209
so next class after the exam will cover

3640
01:12:06,209 --> 01:12:06,219
 

3641
01:12:06,219 --> 01:12:08,220
parallel query extent will finish off in

3642
01:12:08,220 --> 01:12:08,230
 

3643
01:12:08,230 --> 01:12:10,020
the query opposition stuff then let's

3644
01:12:10,020 --> 01:12:10,030
 

3645
01:12:10,030 --> 01:12:10,890
talk about doing parallel query

3646
01:12:10,890 --> 01:12:10,900
 

3647
01:12:10,900 --> 01:12:13,080
execution again the idea here is that

3648
01:12:13,080 --> 01:12:13,090
 

3649
01:12:13,090 --> 01:12:15,720
everything we've focused on so far has

3650
01:12:15,720 --> 01:12:15,730
 

3651
01:12:15,730 --> 01:12:17,700
been sort of running single thread to do

3652
01:12:17,700 --> 01:12:17,710
 

3653
01:12:17,710 --> 01:12:18,780
your joining or whatever you want to do

3654
01:12:18,780 --> 01:12:18,790
 

3655
01:12:18,790 --> 01:12:21,180
now you want to say in a modern database

3656
01:12:21,180 --> 01:12:21,190
 

3657
01:12:21,190 --> 01:12:24,990
system that has multiple cores how does

3658
01:12:24,990 --> 01:12:25,000
 

3659
01:12:25,000 --> 01:12:26,399
the execution change if yeah if you can

3660
01:12:26,399 --> 01:12:26,409
 

3661
01:12:26,409 --> 01:12:28,439
run parallel threads and be just to say

3662
01:12:28,439 --> 01:12:28,449
 

3663
01:12:28,449 --> 01:12:29,669
this is not the same thing as

3664
01:12:29,669 --> 01:12:29,679
 

3665
01:12:29,679 --> 01:12:30,810
distributing execution that'll be

3666
01:12:30,810 --> 01:12:30,820
 

3667
01:12:30,820 --> 01:12:32,129
covered later on this is like a single

3668
01:12:32,129 --> 01:12:32,139
 

3669
01:12:32,139 --> 01:12:33,899
box how can I run things in parallel

3670
01:12:33,899 --> 01:12:33,909
 

3671
01:12:33,909 --> 01:12:37,770
okay all right all of us ours now you

3672
01:12:37,770 --> 01:12:37,780
 

3673
01:12:37,780 --> 01:12:39,120
know if you have any questions and those

3674
01:12:39,120 --> 01:12:39,130

3675
01:12:39,130 --> 01:12:41,010
questions about the practice exam on

3676
01:12:41,010 --> 01:12:41,020
 

3677
01:12:41,020 --> 01:12:42,510
Piazza will take care of that later

3678
01:12:42,510 --> 01:12:42,520
 

3679
01:12:42,520 --> 01:12:50,330
today alright guys see ya

3680
01:12:50,330 --> 01:12:50,340


3681
01:12:50,340 --> 01:12:55,589
yes it's the SD cricket IDE mess I make

3682
01:12:55,589 --> 01:12:55,599
 

3683
01:12:55,599 --> 01:12:58,439
a mess unless I can do it like a gia are

3684
01:12:58,439 --> 01:12:58,449
 

3685
01:12:58,449 --> 01:13:01,890
you with the G to the e to the T comes

3686
01:13:01,890 --> 01:13:01,900
 

3687
01:13:01,900 --> 01:13:03,930
dope I play the game with no rules

3688
01:13:03,930 --> 01:13:03,940
 

3689
01:13:03,940 --> 01:13:05,879
homies on the trucks are y'all looking

3690
01:13:05,879 --> 01:13:05,889
 

3691
01:13:05,889 --> 01:13:08,399
for my room with the bus a cap on the

3692
01:13:08,399 --> 01:13:08,409
 

3693
01:13:08,409 --> 01:13:19,560
road with a blow and faint eyes when I

3694
01:13:19,560 --> 01:13:19,570
 

3695
01:13:19,570 --> 01:13:22,589
party by the 12-pack case of a bar

3696
01:13:22,589 --> 01:13:22,599
 

3697
01:13:22,599 --> 01:13:25,470
six-pack for the egg gets the real I

3698
01:13:25,470 --> 01:13:25,480
 

3699
01:13:25,480 --> 01:13:28,410
treat put your drinking proper 12 ow

3700
01:13:28,410 --> 01:13:28,420
 

3701
01:13:28,420 --> 01:13:31,260
they say build nation but what's a nice

3702
01:13:31,260 --> 01:13:31,270
 

3703
01:13:31,270 --> 01:13:35,040
is straight so it really don't matter

