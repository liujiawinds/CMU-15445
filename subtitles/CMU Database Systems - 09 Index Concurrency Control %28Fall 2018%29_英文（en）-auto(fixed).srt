1
00:00:00,730 --> 00:00:10,700
[Music]

2
00:00:10,700 --> 00:00:10,710


3
00:00:10,710 --> 00:00:18,120
maybe on the Jill's neck to do today is

4
00:00:18,120 --> 00:00:18,130
 

5
00:00:18,130 --> 00:00:19,650
anyway gonna be bowl until they haven't

6
00:00:19,650 --> 00:00:19,660
 

7
00:00:19,660 --> 00:00:23,839
started yet

8
00:00:23,839 --> 00:00:23,849


9
00:00:23,849 --> 00:00:29,400
so who here is done I got 1% fifteen

10
00:00:29,400 --> 00:00:29,410
 

11
00:00:29,410 --> 00:00:32,280
twenty percent okay is there any one

12
00:00:32,280 --> 00:00:32,290
 

13
00:00:32,290 --> 00:00:33,810
thing that everyone's stuck on it's just

14
00:00:33,810 --> 00:00:33,820
 

15
00:00:33,820 --> 00:00:34,680
matter sitting through and getting

16
00:00:34,680 --> 00:00:34,690
 

17
00:00:34,690 --> 00:00:35,730
through the test I notice we would have

18
00:00:35,730 --> 00:00:35,740
 

19
00:00:35,740 --> 00:00:39,060
trouble with memory leaks right that's

20
00:00:39,060 --> 00:00:39,070
 

21
00:00:39,070 --> 00:00:42,479
that's real you got to fix those any any

22
00:00:42,479 --> 00:00:42,489
 

23
00:00:42,489 --> 00:00:43,590
other high-level things you guys are

24
00:00:43,590 --> 00:00:43,600
 

25
00:00:43,600 --> 00:00:52,709
stuck on definition of what sorry in

26
00:00:52,709 --> 00:00:52,719
 

27
00:00:52,719 --> 00:01:22,200
terms of what we need are confusion okay

28
00:01:22,200 --> 00:01:22,210
 

29
00:01:22,210 --> 00:01:25,319
um and you persist on Piazza right all

30
00:01:25,319 --> 00:01:25,329
 

31
00:01:25,329 --> 00:01:29,219
right so there's a lot of person Piazza

32
00:01:29,219 --> 00:01:29,229
 

33
00:01:29,229 --> 00:01:31,620
it would be helpful you can send me an

34
00:01:31,620 --> 00:01:31,630
 

35
00:01:31,630 --> 00:01:33,690
email exactly what the issue is and that

36
00:01:33,690 --> 00:01:33,700
 

37
00:01:33,700 --> 00:01:35,160
way we can fix it up for next year okay

38
00:01:35,160 --> 00:01:35,170
 

39
00:01:35,170 --> 00:01:36,870
if it's a combination of like the slides

40
00:01:36,870 --> 00:01:36,880
 

41
00:01:36,880 --> 00:01:38,130
don't match with what the assignment is

42
00:01:38,130 --> 00:01:38,140
 

43
00:01:38,140 --> 00:01:39,600
or the textbook doesn't match or that

44
00:01:39,600 --> 00:01:39,610
 

45
00:01:39,610 --> 00:01:41,219
the reddit doesn't match let me know

46
00:01:41,219 --> 00:01:41,229
 

47
00:01:41,229 --> 00:01:42,240
what it is when you fix it make it

48
00:01:42,240 --> 00:01:42,250
 

49
00:01:42,250 --> 00:01:44,160
better but we try to improve it this

50
00:01:44,160 --> 00:01:44,170
 

51
00:01:44,170 --> 00:01:46,980
year from the issues we had last year so

52
00:01:46,980 --> 00:01:46,990
 

53
00:01:46,990 --> 00:01:49,980
we always want to get better okay that's

54
00:01:49,980 --> 00:01:49,990
 

55
00:01:49,990 --> 00:01:51,920
right so homework two is due this Friday

56
00:01:51,920 --> 00:01:51,930
 

57
00:01:51,930 --> 00:01:55,530
at midnight and then project two will be

58
00:01:55,530 --> 00:01:55,540

59
00:01:55,540 --> 00:01:58,080
going out today and what we're gonna do

60
00:01:58,080 --> 00:01:58,090
 

61
00:01:58,090 --> 00:01:59,340
this time as I'll say at the end of the

62
00:01:59,340 --> 00:01:59,350
 

63
00:01:59,350 --> 00:02:01,980
class this is gonna be broken up to two

64
00:02:01,980 --> 00:02:01,990
 

65
00:02:01,990 --> 00:02:03,929
checkpoints it does in this game we this

66
00:02:03,929 --> 00:02:03,939
 

67
00:02:03,939 --> 00:02:04,950
is what we learned from last year last

68
00:02:04,950 --> 00:02:04,960
 

69
00:02:04,960 --> 00:02:06,270
year I was like oh the buffer pool is

70
00:02:06,270 --> 00:02:06,280
 

71
00:02:06,280 --> 00:02:07,950
easy the B plus tree is gonna be easy to

72
00:02:07,950 --> 00:02:07,960
 

73
00:02:07,960 --> 00:02:09,510
so people waited to the last minute try

74
00:02:09,510 --> 00:02:09,520
 

75
00:02:09,520 --> 00:02:11,250
to do it and they're like oh what

76
00:02:11,250 --> 00:02:11,260
 

77
00:02:11,260 --> 00:02:13,530
the pool or the B plus trees hard as

78
00:02:13,530 --> 00:02:13,540
 

79
00:02:13,540 --> 00:02:16,590
we'll see today and so what we're doing

80
00:02:16,590 --> 00:02:16,600
 

81
00:02:16,600 --> 00:02:17,670
is we're having

82
00:02:17,670 --> 00:02:17,680
 

83
00:02:17,680 --> 00:02:20,309
a check point that's due halfway through

84
00:02:20,309 --> 00:02:20,319
 

85
00:02:20,319 --> 00:02:21,899
so right again just make sure that you

86
00:02:21,899 --> 00:02:21,909
 

87
00:02:21,909 --> 00:02:24,330
guys are we start about it started

88
00:02:24,330 --> 00:02:24,340
 

89
00:02:24,340 --> 00:02:25,380
thinking about it and worked on it and

90
00:02:25,380 --> 00:02:25,390
 

91
00:02:25,390 --> 00:02:27,539
then there'll be a final you know final

92
00:02:27,539 --> 00:02:27,549
 

93
00:02:27,549 --> 00:02:28,709
submission where you get the full grid

94
00:02:28,709 --> 00:02:28,719

95
00:02:28,719 --> 00:02:29,789
and everything okay

96
00:02:29,789 --> 00:02:29,799
 

97
00:02:29,799 --> 00:02:32,339
I said what covered that bien all right

98
00:02:32,339 --> 00:02:32,349
 

99
00:02:32,349 --> 00:02:33,890
so let's jump in today's material so

100
00:02:33,890 --> 00:02:33,900

101
00:02:33,900 --> 00:02:37,080
today's lecture is entitled index

102
00:02:37,080 --> 00:02:37,090
 

103
00:02:37,090 --> 00:02:42,209
concurrency control and so this lecture

104
00:02:42,209 --> 00:02:42,219
 

105
00:02:42,219 --> 00:02:44,849
I actually gave last year near the end

106
00:02:44,849 --> 00:02:44,859
 

107
00:02:44,859 --> 00:02:47,369
of the semester when we after we talked

108
00:02:47,369 --> 00:02:47,379
 

109
00:02:47,379 --> 00:02:48,959
about concurrent retour protocols for

110
00:02:48,959 --> 00:02:48,969
 

111
00:02:48,969 --> 00:02:52,319
for transactions and I decided to move

112
00:02:52,319 --> 00:02:52,329
 

113
00:02:52,329 --> 00:02:55,860
it up front this year because in the

114
00:02:55,860 --> 00:02:55,870
 

115
00:02:55,870 --> 00:02:57,179
same way that you guys don't had

116
00:02:57,179 --> 00:02:57,189
 

117
00:02:57,189 --> 00:02:58,770
questions about oh how do you you know

118
00:02:58,770 --> 00:02:58,780

119
00:02:58,780 --> 00:03:00,360
handle updates when you're doing reads

120
00:03:00,360 --> 00:03:00,370
 

121
00:03:00,370 --> 00:03:02,369
in your B+ tree I decided to move it

122
00:03:02,369 --> 00:03:02,379
 

123
00:03:02,379 --> 00:03:03,839
forward now that way we can to talk

124
00:03:03,839 --> 00:03:03,849
 

125
00:03:03,849 --> 00:03:06,690
about it in the context of what in the

126
00:03:06,690 --> 00:03:06,700
 

127
00:03:06,700 --> 00:03:08,190
B+ tree is fresh in your mind and you're

128
00:03:08,190 --> 00:03:08,200
 

129
00:03:08,200 --> 00:03:09,770
gonna need this for the second project

130
00:03:09,770 --> 00:03:09,780
 

131
00:03:09,780 --> 00:03:13,619
so everything up until till now at least

132
00:03:13,619 --> 00:03:13,629
 

133
00:03:13,629 --> 00:03:14,819
the last three lectures and we talked

134
00:03:14,819 --> 00:03:14,829
 

135
00:03:14,829 --> 00:03:16,110
about data structures the B plus trees

136
00:03:16,110 --> 00:03:16,120
 

137
00:03:16,120 --> 00:03:17,699
the hash tables skip less and all that

138
00:03:17,699 --> 00:03:17,709
 

139
00:03:17,709 --> 00:03:19,470
for the most part we've been assuming

140
00:03:19,470 --> 00:03:19,480
 

141
00:03:19,480 --> 00:03:22,710
that we were we were building data

142
00:03:22,710 --> 00:03:22,720

143
00:03:22,720 --> 00:03:24,089
structures that were gonna operate

144
00:03:24,089 --> 00:03:24,099
 

145
00:03:24,099 --> 00:03:25,830
within a single threaded environment

146
00:03:25,830 --> 00:03:25,840
 

147
00:03:25,840 --> 00:03:27,899
meaning only one thread was gonna be

148
00:03:27,899 --> 00:03:27,909
 

149
00:03:27,909 --> 00:03:29,460
reading or writing to the data structure

150
00:03:29,460 --> 00:03:29,470
 

151
00:03:29,470 --> 00:03:31,770
at a time and we sort of talked a little

152
00:03:31,770 --> 00:03:31,780
 

153
00:03:31,780 --> 00:03:33,210
bit about how you could do this in a

154
00:03:33,210 --> 00:03:33,220
 

155
00:03:33,220 --> 00:03:34,379
multi-threaded environment with lock

156
00:03:34,379 --> 00:03:34,389

157
00:03:34,389 --> 00:03:36,479
freed skipped lists but I sort of you

158
00:03:36,479 --> 00:03:36,489
 

159
00:03:36,489 --> 00:03:37,800
know I was sort of being very hand with

160
00:03:37,800 --> 00:03:37,810
 

161
00:03:37,810 --> 00:03:38,819
you about it I didn't wanted to sort of

162
00:03:38,819 --> 00:03:38,829
 

163
00:03:38,829 --> 00:03:40,710
dwell on it because I want to talk about

164
00:03:40,710 --> 00:03:40,720
 

165
00:03:40,720 --> 00:03:42,210
how we're gonna do things correctly

166
00:03:42,210 --> 00:03:42,220
 

167
00:03:42,220 --> 00:03:46,499
today so obviously in a modern you know

168
00:03:46,499 --> 00:03:46,509
 

169
00:03:46,509 --> 00:03:48,089
a modern operating environment on modern

170
00:03:48,089 --> 00:03:48,099
 

171
00:03:48,099 --> 00:03:51,569
computers yeah you have now CPUs with a

172
00:03:51,569 --> 00:03:51,579
 

173
00:03:51,579 --> 00:03:53,520
lot of cores and you want to be able to

174
00:03:53,520 --> 00:03:53,530
 

175
00:03:53,530 --> 00:03:55,080
use all those cores means you want to

176
00:03:55,080 --> 00:03:55,090
 

177
00:03:55,090 --> 00:03:57,199
have as many threads as possible

178
00:03:57,199 --> 00:03:57,209

179
00:03:57,209 --> 00:03:59,009
potentially reading and writing to your

180
00:03:59,009 --> 00:03:59,019
 

181
00:03:59,019 --> 00:04:00,360
data structure at the same time and need

182
00:04:00,360 --> 00:04:00,370

183
00:04:00,370 --> 00:04:02,280
to protect themselves from each other so

184
00:04:02,280 --> 00:04:02,290
 

185
00:04:02,290 --> 00:04:03,719
this is what we're gonna be focusing on

186
00:04:03,719 --> 00:04:03,729
 

187
00:04:03,729 --> 00:04:05,490
today and that we say else to do it's

188
00:04:05,490 --> 00:04:05,500
 

189
00:04:05,500 --> 00:04:07,469
not just in the context of having you

190
00:04:07,469 --> 00:04:07,479
 

191
00:04:07,479 --> 00:04:08,219
know take advantage of all the

192
00:04:08,219 --> 00:04:08,229
 

193
00:04:08,229 --> 00:04:10,439
additional cores we'll see this later on

194
00:04:10,439 --> 00:04:10,449
 

195
00:04:10,449 --> 00:04:12,030
but these these concepts are talking

196
00:04:12,030 --> 00:04:12,040
 

197
00:04:12,040 --> 00:04:13,949
about today or old but from the 1970s

198
00:04:13,949 --> 00:04:13,959
 

199
00:04:13,959 --> 00:04:16,740
and back then you had sort of once one

200
00:04:16,740 --> 00:04:16,750
 

201
00:04:16,750 --> 00:04:18,599
CPU socket with one core you don't have

202
00:04:18,599 --> 00:04:18,609
 

203
00:04:18,609 --> 00:04:20,310
one sort of thread could run at any

204
00:04:20,310 --> 00:04:20,320
 

205
00:04:20,320 --> 00:04:22,499
given time but because we're a disc

206
00:04:22,499 --> 00:04:22,509
 

207
00:04:22,509 --> 00:04:24,300
Ordnung database and we said that any

208
00:04:24,300 --> 00:04:24,310
 

209
00:04:24,310 --> 00:04:25,409
time a thread could touch something

210
00:04:25,409 --> 00:04:25,419
 

211
00:04:25,419 --> 00:04:26,640
that's not in memory and therefore has

212
00:04:26,640 --> 00:04:26,650
 

213
00:04:26,650 --> 00:04:28,200
to stall because that's about the system

214
00:04:28,200 --> 00:04:28,210
 

215
00:04:28,210 --> 00:04:30,180
has to go out to disk and get it we want

216
00:04:30,180 --> 00:04:30,190
 

217
00:04:30,190 --> 00:04:31,530
to let other threads run

218
00:04:31,530 --> 00:04:31,540

219
00:04:31,540 --> 00:04:33,660
time right so this is why we want to

220
00:04:33,660 --> 00:04:33,670
 

221
00:04:33,670 --> 00:04:36,180
have we want to have our data show just

222
00:04:36,180 --> 00:04:36,190
 

223
00:04:36,190 --> 00:04:37,770
be protected from some of these threats

224
00:04:37,770 --> 00:04:37,780
 

225
00:04:37,780 --> 00:04:39,930
updating it and things reading and

226
00:04:39,930 --> 00:04:39,940
 

227
00:04:39,940 --> 00:04:41,940
writing at the same time the one thing

228
00:04:41,940 --> 00:04:41,950
 

229
00:04:41,950 --> 00:04:43,680
also say too is a sort of a spoiler is

230
00:04:43,680 --> 00:04:43,690
 

231
00:04:43,690 --> 00:04:46,590
that everything we're talk about today

232
00:04:46,590 --> 00:04:46,600

233
00:04:46,600 --> 00:04:48,600
is pretty much used in almost every

234
00:04:48,600 --> 00:04:48,610
 

235
00:04:48,610 --> 00:04:50,760
single database system one notable

236
00:04:50,760 --> 00:04:50,770
 

237
00:04:50,770 --> 00:04:52,950
extension is actually both DB doesn't do

238
00:04:52,950 --> 00:04:52,960
 

239
00:04:52,960 --> 00:04:54,060
any of the things that we're talking

240
00:04:54,060 --> 00:04:54,070
 

241
00:04:54,070 --> 00:04:56,700
about today right they actually only run

242
00:04:56,700 --> 00:04:56,710
 

243
00:04:56,710 --> 00:04:59,880
single threaded on a core and now

244
00:04:59,880 --> 00:04:59,890
 

245
00:04:59,890 --> 00:05:00,810
they're gonna have multiple cores

246
00:05:00,810 --> 00:05:00,820
 

247
00:05:00,820 --> 00:05:02,970
running each in single threaded mode but

248
00:05:02,970 --> 00:05:02,980
 

249
00:05:02,980 --> 00:05:04,380
this is gonna allow them to avoid all

250
00:05:04,380 --> 00:05:04,390
 

251
00:05:04,390 --> 00:05:06,600
the overhead of the index concurrent

252
00:05:06,600 --> 00:05:06,610
 

253
00:05:06,610 --> 00:05:07,470
role and latching stuff we're talking

254
00:05:07,470 --> 00:05:07,480
 

255
00:05:07,480 --> 00:05:09,240
about today so I like to say how they're

256
00:05:09,240 --> 00:05:09,250
 

257
00:05:09,250 --> 00:05:10,230
gonna do it but again they're coming at

258
00:05:10,230 --> 00:05:10,240
 

259
00:05:10,240 --> 00:05:12,450
the end of the semester and also explain

260
00:05:12,450 --> 00:05:12,460
 

261
00:05:12,460 --> 00:05:14,340
why they do this approach so this would

262
00:05:14,340 --> 00:05:14,350
 

263
00:05:14,350 --> 00:05:15,870
work really well for transactions and

264
00:05:15,870 --> 00:05:15,880
 

265
00:05:15,880 --> 00:05:18,510
OTD workloads not so great for OLAP and

266
00:05:18,510 --> 00:05:18,520
 

267
00:05:18,520 --> 00:05:21,600
we'll see why later all right so the way

268
00:05:21,600 --> 00:05:21,610
 

269
00:05:21,610 --> 00:05:23,070
we're going to protect our data

270
00:05:23,070 --> 00:05:23,080
 

271
00:05:23,080 --> 00:05:25,140
structures is through a concurrent

272
00:05:25,140 --> 00:05:25,150
 

273
00:05:25,150 --> 00:05:27,210
tutorial protocol so concur trio

274
00:05:27,210 --> 00:05:27,220

275
00:05:27,220 --> 00:05:28,790
protocols is this broad class of

276
00:05:28,790 --> 00:05:28,800

277
00:05:28,800 --> 00:05:32,670
algorithms or methods that software

278
00:05:32,670 --> 00:05:32,680
 

279
00:05:32,680 --> 00:05:34,590
systems can use to allow simultaneous

280
00:05:34,590 --> 00:05:34,600

281
00:05:34,600 --> 00:05:37,260
threads to do things they do operate on

282
00:05:37,260 --> 00:05:37,270
 

283
00:05:37,270 --> 00:05:39,540
the same object or thing at the same

284
00:05:39,540 --> 00:05:39,550
 

285
00:05:39,550 --> 00:05:41,340
time being bei what I want to when I say

286
00:05:41,340 --> 00:05:41,350
 

287
00:05:41,350 --> 00:05:44,430
anything and to ensure that they're

288
00:05:44,430 --> 00:05:44,440
 

289
00:05:44,440 --> 00:05:46,950
concurrent operations still produce a

290
00:05:46,950 --> 00:05:46,960
 

291
00:05:46,960 --> 00:05:49,410
correct result so I was too too vague a

292
00:05:49,410 --> 00:05:49,420
 

293
00:05:49,420 --> 00:05:50,730
mean bank or two parts here

294
00:05:50,730 --> 00:05:50,740
 

295
00:05:50,740 --> 00:05:52,410
the term correct and the therm the term

296
00:05:52,410 --> 00:05:52,420

297
00:05:52,420 --> 00:05:56,580
thing so by database thing it could be a

298
00:05:56,580 --> 00:05:56,590
 

299
00:05:56,590 --> 00:05:58,500
tuple could be a data structure it could

300
00:05:58,500 --> 00:05:58,510
 

301
00:05:58,510 --> 00:06:00,600
be a page could be a table right it

302
00:06:00,600 --> 00:06:00,610
 

303
00:06:00,610 --> 00:06:01,080
doesn't matter

304
00:06:01,080 --> 00:06:01,090
 

305
00:06:01,090 --> 00:06:04,650
and by correctness I had this one quote

306
00:06:04,650 --> 00:06:04,660
 

307
00:06:04,660 --> 00:06:07,050
because what correctness means from one

308
00:06:07,050 --> 00:06:07,060

309
00:06:07,060 --> 00:06:09,150
protocol to the next can depend on what

310
00:06:09,150 --> 00:06:09,160
 

311
00:06:09,160 --> 00:06:12,330
their criteria is so sort of two broad

312
00:06:12,330 --> 00:06:12,340
 

313
00:06:12,340 --> 00:06:13,710
categories of correctness could be a

314
00:06:13,710 --> 00:06:13,720
 

315
00:06:13,720 --> 00:06:16,320
logical correctness meaning can I see

316
00:06:16,320 --> 00:06:16,330
 

317
00:06:16,330 --> 00:06:18,000
the data that I'm supposed to see mean

318
00:06:18,000 --> 00:06:18,010
 

319
00:06:18,010 --> 00:06:20,220
if I if I write something into the the

320
00:06:20,220 --> 00:06:20,230
 

321
00:06:20,230 --> 00:06:22,920
index or the table if I go back and try

322
00:06:22,920 --> 00:06:22,930
 

323
00:06:22,930 --> 00:06:24,330
to read it right away and I actually

324
00:06:24,330 --> 00:06:24,340
 

325
00:06:24,340 --> 00:06:26,340
gonna see it or am I going to see the

326
00:06:26,340 --> 00:06:26,350

327
00:06:26,350 --> 00:06:28,500
things that transactions are threads

328
00:06:28,500 --> 00:06:28,510
 

329
00:06:28,510 --> 00:06:30,000
came behind me actually updated while

330
00:06:30,000 --> 00:06:30,010
 

331
00:06:30,010 --> 00:06:32,940
you'll see those and then the other term

332
00:06:32,940 --> 00:06:32,950
 

333
00:06:32,950 --> 00:06:34,080
of correctness is physical correctness

334
00:06:34,080 --> 00:06:34,090

335
00:06:34,090 --> 00:06:36,630
meaning is the internal representation

336
00:06:36,630 --> 00:06:36,640
 

337
00:06:36,640 --> 00:06:40,050
of how the the object is being stored in

338
00:06:40,050 --> 00:06:40,060
 

339
00:06:40,060 --> 00:06:42,180
memory your own disk is that considered

340
00:06:42,180 --> 00:06:42,190
 

341
00:06:42,190 --> 00:06:45,390
valid or sound and then I've at I mean

342
00:06:45,390 --> 00:06:45,400
 

343
00:06:45,400 --> 00:06:46,860
there's not gonna be a pointer to some

344
00:06:46,860 --> 00:06:46,870
 

345
00:06:46,870 --> 00:06:49,140
you know some random location in memory

346
00:06:49,140 --> 00:06:49,150
 

347
00:06:49,150 --> 00:06:50,010
that we're not supposed to be reading

348
00:06:50,010 --> 00:06:50,020
 

349
00:06:50,020 --> 00:06:52,140
right if I follow the data structure I

350
00:06:52,140 --> 00:06:52,150
 

351
00:06:52,150 --> 00:06:53,340
follow my treating pointers

352
00:06:53,340 --> 00:06:53,350

353
00:06:53,350 --> 00:06:55,969
I see the nodes that I should be seeing

354
00:06:55,969 --> 00:06:55,979
 

355
00:06:55,979 --> 00:06:59,400
so for this we're gonna focus on the

356
00:06:59,400 --> 00:06:59,410
 

357
00:06:59,410 --> 00:07:01,230
second one physical correctness right

358
00:07:01,230 --> 00:07:01,240
 

359
00:07:01,240 --> 00:07:03,750
how do we make sure our B+ tree is the

360
00:07:03,750 --> 00:07:03,760
 

361
00:07:03,760 --> 00:07:06,210
integrity is sound we're gonna focus

362
00:07:06,210 --> 00:07:06,220
 

363
00:07:06,220 --> 00:07:07,920
later on about logic correctness later

364
00:07:07,920 --> 00:07:07,930
 

365
00:07:07,930 --> 00:07:09,540
when we talk about transactions or

366
00:07:09,540 --> 00:07:09,550
 

367
00:07:09,550 --> 00:07:11,700
high-level transactions after the

368
00:07:11,700 --> 00:07:11,710
 

369
00:07:11,710 --> 00:07:13,530
midterm and I find this really really

370
00:07:13,530 --> 00:07:13,540

371
00:07:13,540 --> 00:07:15,000
fascinating my whole you know I spend a

372
00:07:15,000 --> 00:07:15,010
 

373
00:07:15,010 --> 00:07:16,770
large portion of my a grad student

374
00:07:16,770 --> 00:07:16,780
 

375
00:07:16,780 --> 00:07:18,420
career at my early time here at CMU

376
00:07:18,420 --> 00:07:18,430
 

377
00:07:18,430 --> 00:07:20,310
worried about this problem think about

378
00:07:20,310 --> 00:07:20,320
 

379
00:07:20,320 --> 00:07:21,659
this problem right this is really kind

380
00:07:21,659 --> 00:07:21,669
 

381
00:07:21,669 --> 00:07:22,830
of cool thing to say like all right I

382
00:07:22,830 --> 00:07:22,840
 

383
00:07:22,840 --> 00:07:24,689
can have they're gonna interleave

384
00:07:24,689 --> 00:07:24,699
 

385
00:07:24,699 --> 00:07:26,760
operations and anyway I want long as it

386
00:07:26,760 --> 00:07:26,770
 

387
00:07:26,770 --> 00:07:28,200
sort of comes out logically correct I

388
00:07:28,200 --> 00:07:28,210
 

389
00:07:28,210 --> 00:07:29,340
don't care how to you add you in or

390
00:07:29,340 --> 00:07:29,350
 

391
00:07:29,350 --> 00:07:31,350
leave them whereas in the physical

392
00:07:31,350 --> 00:07:31,360
 

393
00:07:31,360 --> 00:07:32,370
correctness there are certain cases

394
00:07:32,370 --> 00:07:32,380
 

395
00:07:32,380 --> 00:07:33,570
where you have to do things in a certain

396
00:07:33,570 --> 00:07:33,580
 

397
00:07:33,580 --> 00:07:35,490
order so again we'll focus on the second

398
00:07:35,490 --> 00:07:35,500
 

399
00:07:35,500 --> 00:07:37,290
one the first one will come up later on

400
00:07:37,290 --> 00:07:37,300
 

401
00:07:37,300 --> 00:07:38,939
when we talk about transactions and

402
00:07:38,939 --> 00:07:38,949
 

403
00:07:38,949 --> 00:07:40,590
control for you know higher-level

404
00:07:40,590 --> 00:07:40,600
 

405
00:07:40,600 --> 00:07:43,320
semantics alright so today's agenda

406
00:07:43,320 --> 00:07:43,330

407
00:07:43,330 --> 00:07:45,450
we're going to focus on different level

408
00:07:45,450 --> 00:07:45,460
 

409
00:07:45,460 --> 00:07:47,520
a ODEs and then we're primary to spend

410
00:07:47,520 --> 00:07:47,530
 

411
00:07:47,530 --> 00:07:48,990
our time talking about doing index

412
00:07:48,990 --> 00:07:49,000
 

413
00:07:49,000 --> 00:07:50,670
crabbing or lat crabbing your latch

414
00:07:50,670 --> 00:07:50,680
 

415
00:07:50,680 --> 00:07:52,230
coupling and this is what you have to

416
00:07:52,230 --> 00:07:52,240
 

417
00:07:52,240 --> 00:07:54,000
implement in in the second project and

418
00:07:54,000 --> 00:07:54,010
 

419
00:07:54,010 --> 00:07:56,010
then we'll talk about how to do leaf

420
00:07:56,010 --> 00:07:56,020
 

421
00:07:56,020 --> 00:07:58,440
scans safely and then we'll talk about a

422
00:07:58,440 --> 00:07:58,450
 

423
00:07:58,450 --> 00:07:59,850
simple optimization that was invented

424
00:07:59,850 --> 00:07:59,860
 

425
00:07:59,860 --> 00:08:01,920
here at CMU called delayed parent update

426
00:08:01,920 --> 00:08:01,930
 

427
00:08:01,930 --> 00:08:03,930
and sort of an obvious optimization but

428
00:08:03,930 --> 00:08:03,940
 

429
00:08:03,940 --> 00:08:05,310
we sort of talked about the semantics of

430
00:08:05,310 --> 00:08:05,320
 

431
00:08:05,320 --> 00:08:12,210
it okay all right so I showed this slide

432
00:08:12,210 --> 00:08:12,220
 

433
00:08:12,220 --> 00:08:14,969
earlier in the semester and to

434
00:08:14,969 --> 00:08:14,979
 

435
00:08:14,979 --> 00:08:17,760
distinguish between latches and locks in

436
00:08:17,760 --> 00:08:17,770
 

437
00:08:17,770 --> 00:08:19,890
the context of databases and I got the

438
00:08:19,890 --> 00:08:19,900
 

439
00:08:19,900 --> 00:08:20,969
impression that everyone's sort of eyes

440
00:08:20,969 --> 00:08:20,979
 

441
00:08:20,979 --> 00:08:22,740
were glazed over and what it wasn't

442
00:08:22,740 --> 00:08:22,750
 

443
00:08:22,750 --> 00:08:24,540
quite sure what I was trying to say so

444
00:08:24,540 --> 00:08:24,550
 

445
00:08:24,550 --> 00:08:25,740
I'm gonna go over this again because

446
00:08:25,740 --> 00:08:25,750
 

447
00:08:25,750 --> 00:08:27,360
we're need to understand this for what

448
00:08:27,360 --> 00:08:27,370
 

449
00:08:27,370 --> 00:08:29,670
we're talking about today so in

450
00:08:29,670 --> 00:08:29,680
 

451
00:08:29,680 --> 00:08:32,190
databases and database systems there is

452
00:08:32,190 --> 00:08:32,200
 

453
00:08:32,200 --> 00:08:34,170
a distinguished there's a dichotomy

454
00:08:34,170 --> 00:08:34,180
 

455
00:08:34,180 --> 00:08:38,610
between locks and latches so locks are

456
00:08:38,610 --> 00:08:38,620
 

457
00:08:38,620 --> 00:08:40,199
things that are going to use to protect

458
00:08:40,199 --> 00:08:40,209
 

459
00:08:40,209 --> 00:08:43,320
logical contents of the database as you

460
00:08:43,320 --> 00:08:43,330
 

461
00:08:43,330 --> 00:08:46,260
can protect the you can protect to poles

462
00:08:46,260 --> 00:08:46,270
 

463
00:08:46,270 --> 00:08:47,850
you can protect tables you can protect

464
00:08:47,850 --> 00:08:47,860
 

465
00:08:47,860 --> 00:08:50,160
entire database we're not talking an

466
00:08:50,160 --> 00:08:50,170
 

467
00:08:50,170 --> 00:08:51,960
underlying low-level things like here's

468
00:08:51,960 --> 00:08:51,970
 

469
00:08:51,970 --> 00:08:53,550
some here's some region of memory I want

470
00:08:53,550 --> 00:08:53,560
 

471
00:08:53,560 --> 00:08:55,230
to protect that's not what locks are for

472
00:08:55,230 --> 00:08:55,240
 

473
00:08:55,240 --> 00:08:59,129
and so the the locks are protect

474
00:08:59,129 --> 00:08:59,139
 

475
00:08:59,139 --> 00:09:01,169
the logical contents of our database in

476
00:09:01,169 --> 00:09:01,179
 

477
00:09:01,179 --> 00:09:02,549
this case here that were technological

478
00:09:02,549 --> 00:09:02,559
 

479
00:09:02,559 --> 00:09:06,569
contests of index and the these locks

480
00:09:06,569 --> 00:09:06,579
 

481
00:09:06,579 --> 00:09:07,799
are gonna be held for the entire

482
00:09:07,799 --> 00:09:07,809
 

483
00:09:07,809 --> 00:09:09,660
duration of a transaction I'm having to

484
00:09:09,660 --> 00:09:09,670
 

485
00:09:09,670 --> 00:09:11,489
find what a transaction is yet just

486
00:09:11,489 --> 00:09:11,499
 

487
00:09:11,499 --> 00:09:12,989
think of it as a sequence of operations

488
00:09:12,989 --> 00:09:12,999
 

489
00:09:12,999 --> 00:09:15,150
we want to do in our database I want to

490
00:09:15,150 --> 00:09:15,160
 

491
00:09:15,160 --> 00:09:16,379
update five tuple and I'm going to do

492
00:09:16,379 --> 00:09:16,389
 

493
00:09:16,389 --> 00:09:18,179
them atomically right that's essentially

494
00:09:18,179 --> 00:09:18,189
 

495
00:09:18,189 --> 00:09:20,340
what a transaction is so any lock that

496
00:09:20,340 --> 00:09:20,350

497
00:09:20,350 --> 00:09:23,970
I'm gonna take on an object in in in the

498
00:09:23,970 --> 00:09:23,980
 

499
00:09:23,980 --> 00:09:25,829
database I'm gonna hold that for the

500
00:09:25,829 --> 00:09:25,839
 

501
00:09:25,839 --> 00:09:27,210
entire duration of the transaction

502
00:09:27,210 --> 00:09:27,220
 

503
00:09:27,220 --> 00:09:29,609
that's not entirely true but for now we

504
00:09:29,609 --> 00:09:29,619
 

505
00:09:29,619 --> 00:09:32,609
just assume that and then the key thing

506
00:09:32,609 --> 00:09:32,619
 

507
00:09:32,619 --> 00:09:35,299
about locks is also to is that the

508
00:09:35,299 --> 00:09:35,309
 

509
00:09:35,309 --> 00:09:37,349
there's going to be this sort of

510
00:09:37,349 --> 00:09:37,359
 

511
00:09:37,359 --> 00:09:39,210
additional process or validation

512
00:09:39,210 --> 00:09:39,220
 

513
00:09:39,220 --> 00:09:41,549
mechanism that's gonna let us that's

514
00:09:41,549 --> 00:09:41,559
 

515
00:09:41,559 --> 00:09:43,289
going to decide whether we're our

516
00:09:43,289 --> 00:09:43,299
 

517
00:09:43,299 --> 00:09:44,639
transactions allowed to proceed or not

518
00:09:44,639 --> 00:09:44,649
 

519
00:09:44,649 --> 00:09:47,789
and if not write this because of some

520
00:09:47,789 --> 00:09:47,799
 

521
00:09:47,799 --> 00:09:50,729
violation of lock ordering then we have

522
00:09:50,729 --> 00:09:50,739

523
00:09:50,739 --> 00:09:52,199
to abort our transaction and rollback

524
00:09:52,199 --> 00:09:52,209
 

525
00:09:52,209 --> 00:09:55,139
any changes so again a really simple

526
00:09:55,139 --> 00:09:55,149
 

527
00:09:55,149 --> 00:09:56,759
example I need to update two tuples I

528
00:09:56,759 --> 00:09:56,769
 

529
00:09:56,769 --> 00:09:58,619
get the lock on the first one I update

530
00:09:58,619 --> 00:09:58,629
 

531
00:09:58,629 --> 00:10:00,659
it I get the lock on the second one but

532
00:10:00,659 --> 00:10:00,669
 

533
00:10:00,669 --> 00:10:02,340
then that fails I can't get the lock and

534
00:10:02,340 --> 00:10:02,350
 

535
00:10:02,350 --> 00:10:04,139
I have to abort my transaction so I need

536
00:10:04,139 --> 00:10:04,149
 

537
00:10:04,149 --> 00:10:05,579
to roll back the change or the first one

538
00:10:05,579 --> 00:10:05,589
 

539
00:10:05,589 --> 00:10:07,350
and there's some additional mechanisms

540
00:10:07,350 --> 00:10:07,360
 

541
00:10:07,360 --> 00:10:10,039
we have to implement to do that rollback

542
00:10:10,039 --> 00:10:10,049
 

543
00:10:10,049 --> 00:10:12,299
now the sting richness with between

544
00:10:12,299 --> 00:10:12,309
 

545
00:10:12,309 --> 00:10:14,039
latches and again if you're coming from

546
00:10:14,039 --> 00:10:14,049
 

547
00:10:14,049 --> 00:10:16,049
an operating system background this is

548
00:10:16,049 --> 00:10:16,059
 

549
00:10:16,059 --> 00:10:19,559
what they would call a lock right like

550
00:10:19,559 --> 00:10:19,569
 

551
00:10:19,569 --> 00:10:20,519
you're protecting like the underlying

552
00:10:20,519 --> 00:10:20,529

553
00:10:20,529 --> 00:10:22,229
physical data structure of something so

554
00:10:22,229 --> 00:10:22,239
 

555
00:10:22,239 --> 00:10:23,460
this is the latches are going to help us

556
00:10:23,460 --> 00:10:23,470
 

557
00:10:23,470 --> 00:10:25,470
protect the critical sections of our

558
00:10:25,470 --> 00:10:25,480
 

559
00:10:25,480 --> 00:10:27,749
indexes internal data structure remember

560
00:10:27,749 --> 00:10:27,759
 

561
00:10:27,759 --> 00:10:29,159
I said the distinction between logical

562
00:10:29,159 --> 00:10:29,169
 

563
00:10:29,169 --> 00:10:30,539
correctness and physical correctness the

564
00:10:30,539 --> 00:10:30,549
 

565
00:10:30,549 --> 00:10:32,220
lock is to protect the logical

566
00:10:32,220 --> 00:10:32,230
 

567
00:10:32,230 --> 00:10:33,929
correctness the latches could protect

568
00:10:33,929 --> 00:10:33,939
 

569
00:10:33,939 --> 00:10:35,579
the physical correctness this is like

570
00:10:35,579 --> 00:10:35,589
 

571
00:10:35,589 --> 00:10:37,199
the critical section you know we want to

572
00:10:37,199 --> 00:10:37,209
 

573
00:10:37,209 --> 00:10:38,970
update a pointer to another node and we

574
00:10:38,970 --> 00:10:38,980
 

575
00:10:38,980 --> 00:10:40,499
don't anyone even wait on anybody to

576
00:10:40,499 --> 00:10:40,509
 

577
00:10:40,509 --> 00:10:43,259
read that until we're actually done so

578
00:10:43,259 --> 00:10:43,269
 

579
00:10:43,269 --> 00:10:44,970
for these latches they're gonna be

580
00:10:44,970 --> 00:10:44,980
 

581
00:10:44,980 --> 00:10:46,169
they're not gonna hold them for a long

582
00:10:46,169 --> 00:10:46,179
 

583
00:10:46,179 --> 00:10:48,509
time your thread is gonna acquire latch

584
00:10:48,509 --> 00:10:48,519
 

585
00:10:48,519 --> 00:10:49,769
do whatever needs to do and then

586
00:10:49,769 --> 00:10:49,779
 

587
00:10:49,779 --> 00:10:51,809
immediately give it up right and means

588
00:10:51,809 --> 00:10:51,819
 

589
00:10:51,819 --> 00:10:54,389
you can you can even acquire and release

590
00:10:54,389 --> 00:10:54,399
 

591
00:10:54,399 --> 00:10:55,650
in choir at least the same latch

592
00:10:55,650 --> 00:10:55,660
 

593
00:10:55,660 --> 00:10:57,900
multiple times during your your

594
00:10:57,900 --> 00:10:57,910
 

595
00:10:57,910 --> 00:11:00,840
transaction the key difference also to

596
00:11:00,840 --> 00:11:00,850
 

597
00:11:00,850 --> 00:11:02,609
in the latch and lock is that we don't

598
00:11:02,609 --> 00:11:02,619

599
00:11:02,619 --> 00:11:04,279
need to actually roll back any changes

600
00:11:04,279 --> 00:11:04,289
 

601
00:11:04,289 --> 00:11:06,659
meaning it's sort of thing it's an

602
00:11:06,659 --> 00:11:06,669
 

603
00:11:06,669 --> 00:11:09,029
atomic operation either it happens or it

604
00:11:09,029 --> 00:11:09,039
 

605
00:11:09,039 --> 00:11:11,609
doesn't happen and we'll see it later on

606
00:11:11,609 --> 00:11:11,619
 

607
00:11:11,619 --> 00:11:13,010
but like if it doesn't happen

608
00:11:13,010 --> 00:11:13,020
 

609
00:11:13,020 --> 00:11:14,690
if I can't get the latch when I want I

610
00:11:14,690 --> 00:11:14,700
 

611
00:11:14,700 --> 00:11:16,820
can just loop back and try again right

612
00:11:16,820 --> 00:11:16,830
 

613
00:11:16,830 --> 00:11:20,269
maybe to spin on it okay so there's this

614
00:11:20,269 --> 00:11:20,279
 

615
00:11:20,279 --> 00:11:23,360
great table from the the book I

616
00:11:23,360 --> 00:11:23,370
 

617
00:11:23,370 --> 00:11:25,360
recommended you guys from Gertz graffiti

618
00:11:25,360 --> 00:11:25,370
 

619
00:11:25,370 --> 00:11:29,210
on the the B+ tree stuff where he's had

620
00:11:29,210 --> 00:11:29,220
 

621
00:11:29,220 --> 00:11:31,400
to lay it out exactly where locks and

622
00:11:31,400 --> 00:11:31,410
 

623
00:11:31,410 --> 00:11:34,190
latches are how they're using in a

624
00:11:34,190 --> 00:11:34,200
 

625
00:11:34,200 --> 00:11:36,980
database system so he says four locks

626
00:11:36,980 --> 00:11:36,990
 

627
00:11:36,990 --> 00:11:38,570
they're gonna use to be separate user

628
00:11:38,570 --> 00:11:38,580
 

629
00:11:38,580 --> 00:11:40,670
transactions right updating tuples

630
00:11:40,670 --> 00:11:40,680
 

631
00:11:40,680 --> 00:11:43,670
things like that and and there were in

632
00:11:43,670 --> 00:11:43,680
 

633
00:11:43,680 --> 00:11:45,199
there protecting the database contents

634
00:11:45,199 --> 00:11:45,209
 

635
00:11:45,209 --> 00:11:48,740
like tuples pay tuples tables databases

636
00:11:48,740 --> 00:11:48,750
 

637
00:11:48,750 --> 00:11:50,360
and we're gonna hold them for the entire

638
00:11:50,360 --> 00:11:50,370
 

639
00:11:50,370 --> 00:11:52,430
duration of the transaction and we're

640
00:11:52,430 --> 00:11:52,440
 

641
00:11:52,440 --> 00:11:54,050
have different modes for what kind of

642
00:11:54,050 --> 00:11:54,060
 

643
00:11:54,060 --> 00:11:55,910
locks we can take for now we can ignore

644
00:11:55,910 --> 00:11:55,920
 

645
00:11:55,920 --> 00:11:58,850
all this just just you just know that

646
00:11:58,850 --> 00:11:58,860
 

647
00:11:58,860 --> 00:12:00,260
there's more nodes that there's more

648
00:12:00,260 --> 00:12:00,270
 

649
00:12:00,270 --> 00:12:02,329
modes than we'll see four latches and

650
00:12:02,329 --> 00:12:02,339
 

651
00:12:02,339 --> 00:12:03,500
the way we're gonna protect against

652
00:12:03,500 --> 00:12:03,510

653
00:12:03,510 --> 00:12:05,960
deadlocks is to have separate detection

654
00:12:05,960 --> 00:12:05,970
 

655
00:12:05,970 --> 00:12:08,180
mechanism or resolution process using

656
00:12:08,180 --> 00:12:08,190

657
00:12:08,190 --> 00:12:09,710
various mechanisms like a wait for graph

658
00:12:09,710 --> 00:12:09,720
 

659
00:12:09,720 --> 00:12:11,570
or timeouts and aborts and the

660
00:12:11,570 --> 00:12:11,580
 

661
00:12:11,580 --> 00:12:13,220
information about what transaction holds

662
00:12:13,220 --> 00:12:13,230
 

663
00:12:13,230 --> 00:12:15,170
what lock we stored in a centralized

664
00:12:15,170 --> 00:12:15,180

665
00:12:15,180 --> 00:12:17,030
lock manager all doesn't make sense

666
00:12:17,030 --> 00:12:17,040
 

667
00:12:17,040 --> 00:12:18,949
later on but for now just again just

668
00:12:18,949 --> 00:12:18,959
 

669
00:12:18,959 --> 00:12:25,069
distinguishing each of them yes these

670
00:12:25,069 --> 00:12:25,079

671
00:12:25,079 --> 00:12:26,569
question is why do latches only have a

672
00:12:26,569 --> 00:12:26,579

673
00:12:26,579 --> 00:12:29,019
reading right mode as opposed to what

674
00:12:29,019 --> 00:12:29,029
 

675
00:12:29,029 --> 00:12:34,490
intention mode that's a real that's a

676
00:12:34,490 --> 00:12:34,500
 

677
00:12:34,500 --> 00:12:40,460
real ass ending yeah all right so again

678
00:12:40,460 --> 00:12:40,470
 

679
00:12:40,470 --> 00:12:42,980
in the database literature can

680
00:12:42,980 --> 00:12:42,990

681
00:12:42,990 --> 00:12:44,240
distinguishing locks and latches there's

682
00:12:44,240 --> 00:12:44,250

683
00:12:44,250 --> 00:12:46,550
a shared lock you can get a shared lock

684
00:12:46,550 --> 00:12:46,560
 

685
00:12:46,560 --> 00:12:50,449
on a on on a tuple you get a read latch

686
00:12:50,449 --> 00:12:50,459
 

687
00:12:50,459 --> 00:12:52,850
on the memory of that tuple

688
00:12:52,850 --> 00:12:52,860
 

689
00:12:52,860 --> 00:12:55,130
it's a way to think about all right so

690
00:12:55,130 --> 00:12:55,140
 

691
00:12:55,140 --> 00:12:56,360
the latches are gonna be use to protect

692
00:12:56,360 --> 00:12:56,370
 

693
00:12:56,370 --> 00:12:58,160
threads from each other and they're

694
00:12:58,160 --> 00:12:58,170
 

695
00:12:58,170 --> 00:12:59,810
gonna be only used to protect the in

696
00:12:59,810 --> 00:12:59,820
 

697
00:12:59,820 --> 00:13:01,100
memory data structures like the P plus

698
00:13:01,100 --> 00:13:01,110
 

699
00:13:01,110 --> 00:13:03,650
tree will be building here so that means

700
00:13:03,650 --> 00:13:03,660
 

701
00:13:03,660 --> 00:13:05,269
that we don't ever you know write in the

702
00:13:05,269 --> 00:13:05,279
 

703
00:13:05,279 --> 00:13:06,829
information out the disk about what

704
00:13:06,829 --> 00:13:06,839

705
00:13:06,839 --> 00:13:08,449
latches are being held because does it

706
00:13:08,449 --> 00:13:08,459
 

707
00:13:08,459 --> 00:13:10,010
make sense we come back we boot the

708
00:13:10,010 --> 00:13:10,020
 

709
00:13:10,020 --> 00:13:11,990
system back up these latches aren't

710
00:13:11,990 --> 00:13:12,000
 

711
00:13:12,000 --> 00:13:13,910
around anymore so we protect the

712
00:13:13,910 --> 00:13:13,920
 

713
00:13:13,920 --> 00:13:15,319
critical sections of our data structures

714
00:13:15,319 --> 00:13:15,329
 

715
00:13:15,329 --> 00:13:17,060
when we have two modes read and write

716
00:13:17,060 --> 00:13:17,070

717
00:13:17,070 --> 00:13:18,860
which we over the next slide and then

718
00:13:18,860 --> 00:13:18,870
 

719
00:13:18,870 --> 00:13:20,389
the way we're going to avoid deadlocks

720
00:13:20,389 --> 00:13:20,399
 

721
00:13:20,399 --> 00:13:23,210
or handle deadlocks is through us being

722
00:13:23,210 --> 00:13:23,220
 

723
00:13:23,220 --> 00:13:24,650
good programmers good database

724
00:13:24,650 --> 00:13:24,660

725
00:13:24,660 --> 00:13:26,180
developers and software engineers

726
00:13:26,180 --> 00:13:26,190
 

727
00:13:26,190 --> 00:13:28,519
there's through coding discipline so we

728
00:13:28,519 --> 00:13:28,529
 

729
00:13:28,529 --> 00:13:29,990
need to be careful out write our code to

730
00:13:29,990 --> 00:13:30,000
 

731
00:13:30,000 --> 00:13:31,610
make sure that we can't have dead locks

732
00:13:31,610 --> 00:13:31,620
 

733
00:13:31,620 --> 00:13:33,590
in a way we can avoid deadlocks is

734
00:13:33,590 --> 00:13:33,600
 

735
00:13:33,600 --> 00:13:35,300
basically if I can't get the latch that

736
00:13:35,300 --> 00:13:35,310
 

737
00:13:35,310 --> 00:13:38,389
I want I have to know it in what context

738
00:13:38,389 --> 00:13:38,399
 

739
00:13:38,399 --> 00:13:39,800
I'm trying to acquire that latch and

740
00:13:39,800 --> 00:13:39,810
 

741
00:13:39,810 --> 00:13:41,629
should I wait to acquire or should I

742
00:13:41,629 --> 00:13:41,639

743
00:13:41,639 --> 00:13:44,840
kill myself right away all right in the

744
00:13:44,840 --> 00:13:44,850
 

745
00:13:44,850 --> 00:13:47,329
context of a chance action with a lock

746
00:13:47,329 --> 00:13:47,339
 

747
00:13:47,339 --> 00:13:50,300
that logic is is managed by both there's

748
00:13:50,300 --> 00:13:50,310
 

749
00:13:50,310 --> 00:13:51,350
some kind of centralized coordinator

750
00:13:51,350 --> 00:13:51,360
 

751
00:13:51,360 --> 00:13:55,400
like a lock manager okay all right so

752
00:13:55,400 --> 00:13:55,410
 

753
00:13:55,410 --> 00:13:57,829
again this lecture is focused on the

754
00:13:57,829 --> 00:13:57,839
 

755
00:13:57,839 --> 00:14:00,110
latches because we're protecting the the

756
00:14:00,110 --> 00:14:00,120
 

757
00:14:00,120 --> 00:14:03,379
internal data structure of our of our b

758
00:14:03,379 --> 00:14:03,389
 

759
00:14:03,389 --> 00:14:05,660
plus treating all the locks self will

760
00:14:05,660 --> 00:14:05,670
 

761
00:14:05,670 --> 00:14:07,639
cover after the midterm in lecture 17

762
00:14:07,639 --> 00:14:07,649
 

763
00:14:07,649 --> 00:14:09,619
again I find this all of this stuff

764
00:14:09,619 --> 00:14:09,629
 

765
00:14:09,629 --> 00:14:13,850
really fascinating so sort of what his

766
00:14:13,850 --> 00:14:13,860
 

767
00:14:13,860 --> 00:14:17,090
question was about you know can you have

768
00:14:17,090 --> 00:14:17,100
 

769
00:14:17,100 --> 00:14:19,340
a read latch look I share mutex the

770
00:14:19,340 --> 00:14:19,350
 

771
00:14:19,350 --> 00:14:20,389
answer is yes we're just calling this a

772
00:14:20,389 --> 00:14:20,399
 

773
00:14:20,399 --> 00:14:24,559
read mode so a read mode latch can you

774
00:14:24,559 --> 00:14:24,569
 

775
00:14:24,569 --> 00:14:26,059
can have multiple threads acquired this

776
00:14:26,059 --> 00:14:26,069
 

777
00:14:26,069 --> 00:14:28,040
the same latch in the same mode multiple

778
00:14:28,040 --> 00:14:28,050
 

779
00:14:28,050 --> 00:14:30,019
times so if I come along and I want

780
00:14:30,019 --> 00:14:30,029
 

781
00:14:30,029 --> 00:14:31,850
acquire this latch and you hold it and

782
00:14:31,850 --> 00:14:31,860
 

783
00:14:31,860 --> 00:14:33,650
you have it in read mode and I want in

784
00:14:33,650 --> 00:14:33,660
 

785
00:14:33,660 --> 00:14:35,420
the read mode then I can also piggyback

786
00:14:35,420 --> 00:14:35,430

787
00:14:35,430 --> 00:14:36,970
off you and also acquire it and

788
00:14:36,970 --> 00:14:36,980
 

789
00:14:36,980 --> 00:14:39,319
internally the lack maintains a metadata

790
00:14:39,319 --> 00:14:39,329
 

791
00:14:39,329 --> 00:14:41,179
to say alright this thread has met has

792
00:14:41,179 --> 00:14:41,189
 

793
00:14:41,189 --> 00:14:42,860
me in read mode and this thread has me

794
00:14:42,860 --> 00:14:42,870
 

795
00:14:42,870 --> 00:14:44,480
in read mode and I know that one guy

796
00:14:44,480 --> 00:14:44,490
 

797
00:14:44,490 --> 00:14:46,160
releases it it's still being held by

798
00:14:46,160 --> 00:14:46,170

799
00:14:46,170 --> 00:14:47,210
another thread so it's not like I

800
00:14:47,210 --> 00:14:47,220
 

801
00:14:47,220 --> 00:14:50,689
released the latch entirely for the

802
00:14:50,689 --> 00:14:50,699

803
00:14:50,699 --> 00:14:52,819
write mode only one thread is allowed to

804
00:14:52,819 --> 00:14:52,829
 

805
00:14:52,829 --> 00:14:56,660
hold the latch in that mode at a time so

806
00:14:56,660 --> 00:14:56,670
 

807
00:14:56,670 --> 00:14:58,009
if you cut if you already had the latch

808
00:14:58,009 --> 00:14:58,019
 

809
00:14:58,019 --> 00:14:59,329
in read mode and I want to get in write

810
00:14:59,329 --> 00:14:59,339
 

811
00:14:59,339 --> 00:15:01,100
mode I can't I have to get either

812
00:15:01,100 --> 00:15:01,110
 

813
00:15:01,110 --> 00:15:05,569
blocked or wait or abort myself and if

814
00:15:05,569 --> 00:15:05,579
 

815
00:15:05,579 --> 00:15:07,040
I'm holding a reit latch and then nobody

816
00:15:07,040 --> 00:15:07,050
 

817
00:15:07,050 --> 00:15:08,240
else can acquire it at the same time

818
00:15:08,240 --> 00:15:08,250
 

819
00:15:08,250 --> 00:15:10,730
that I am right so there's a sort of

820
00:15:10,730 --> 00:15:10,740
 

821
00:15:10,740 --> 00:15:12,309
obvious compatibility matrix like this

822
00:15:12,309 --> 00:15:12,319
 

823
00:15:12,319 --> 00:15:14,960
the way to think about this is say one

824
00:15:14,960 --> 00:15:14,970
 

825
00:15:14,970 --> 00:15:17,809
side is what the latch mode currently is

826
00:15:17,809 --> 00:15:17,819
 

827
00:15:17,819 --> 00:15:22,249
in and the top the top sort of set of

828
00:15:22,249 --> 00:15:22,259
 

829
00:15:22,259 --> 00:15:24,110
columns is what latch mode somebody was

830
00:15:24,110 --> 00:15:24,120
 

831
00:15:24,120 --> 00:15:26,420
acquired in so if somebody holds it in

832
00:15:26,420 --> 00:15:26,430
 

833
00:15:26,430 --> 00:15:27,860
read mode I can acquire it in read mode

834
00:15:27,860 --> 00:15:27,870
 

835
00:15:27,870 --> 00:15:29,900
and no other mode and everything else

836
00:15:29,900 --> 00:15:29,910

837
00:15:29,910 --> 00:15:32,840
gets is is denied and what happens when

838
00:15:32,840 --> 00:15:32,850
 

839
00:15:32,850 --> 00:15:34,370
you denied depends on the implementation

840
00:15:34,370 --> 00:15:34,380
 

841
00:15:34,380 --> 00:15:36,199
and in what context are actually trying

842
00:15:36,199 --> 00:15:36,209
 

843
00:15:36,209 --> 00:15:37,590
to acquire that latch

844
00:15:37,590 --> 00:15:37,600
 

845
00:15:37,600 --> 00:15:40,690
all right so now using these latches we

846
00:15:40,690 --> 00:15:40,700
 

847
00:15:40,700 --> 00:15:42,670
can talk about how to do we want to do B

848
00:15:42,670 --> 00:15:42,680
 

849
00:15:42,680 --> 00:15:44,260
plus the purchased or how to build a

850
00:15:44,260 --> 00:15:44,270
 

851
00:15:44,270 --> 00:15:47,310
multi-threaded B plus tree so there's

852
00:15:47,310 --> 00:15:47,320
 

853
00:15:47,320 --> 00:15:49,870
two types of problems we need to deal

854
00:15:49,870 --> 00:15:49,880
 

855
00:15:49,880 --> 00:15:52,390
with the first problem is when we have

856
00:15:52,390 --> 00:15:52,400
 

857
00:15:52,400 --> 00:15:54,640
two threads trying to update the same

858
00:15:54,640 --> 00:15:54,650
 

859
00:15:54,650 --> 00:15:56,950
page at the same time to maybe to try to

860
00:15:56,950 --> 00:15:56,960
 

861
00:15:56,960 --> 00:15:59,710
insert or update the the key value pair

862
00:15:59,710 --> 00:15:59,720

863
00:15:59,720 --> 00:16:01,870
arrays inside of it right and this is

864
00:16:01,870 --> 00:16:01,880
 

865
00:16:01,880 --> 00:16:03,100
sort of obvious way to fix this right

866
00:16:03,100 --> 00:16:03,110
 

867
00:16:03,110 --> 00:16:04,780
you just take a read latch on that node

868
00:16:04,780 --> 00:16:04,790
 

869
00:16:04,790 --> 00:16:06,280
sorry you take a write latch on that

870
00:16:06,280 --> 00:16:06,290

871
00:16:06,290 --> 00:16:09,100
node and only one thread is allowed to

872
00:16:09,100 --> 00:16:09,110
 

873
00:16:09,110 --> 00:16:10,120
update at a time and then when you're

874
00:16:10,120 --> 00:16:10,130
 

875
00:16:10,130 --> 00:16:11,440
done updating it you release the write

876
00:16:11,440 --> 00:16:11,450
 

877
00:16:11,450 --> 00:16:13,060
latch and then somebody else can go

878
00:16:13,060 --> 00:16:13,070
 

879
00:16:13,070 --> 00:16:14,980
ahead and update it right that's that's

880
00:16:14,980 --> 00:16:14,990
 

881
00:16:14,990 --> 00:16:16,420
a no-brainer right that's we all know

882
00:16:16,420 --> 00:16:16,430
 

883
00:16:16,430 --> 00:16:17,980
that from your basic systems programming

884
00:16:17,980 --> 00:16:17,990
 

885
00:16:17,990 --> 00:16:20,260
the one that's more complicated though

886
00:16:20,260 --> 00:16:20,270
 

887
00:16:20,270 --> 00:16:24,220
is dealing with traversals because now

888
00:16:24,220 --> 00:16:24,230
 

889
00:16:24,230 --> 00:16:25,930
you could have one thread traversing

890
00:16:25,930 --> 00:16:25,940
 

891
00:16:25,940 --> 00:16:27,280
down to the tree try to get to a leaf

892
00:16:27,280 --> 00:16:27,290

893
00:16:27,290 --> 00:16:29,740
node and while another thread is doing

894
00:16:29,740 --> 00:16:29,750
 

895
00:16:29,750 --> 00:16:32,079
an insert or a delete that's gonna cause

896
00:16:32,079 --> 00:16:32,089
 

897
00:16:32,089 --> 00:16:35,019
me to either split or merge or remove a

898
00:16:35,019 --> 00:16:35,029
 

899
00:16:35,029 --> 00:16:37,690
sibling around and that could foul up

900
00:16:37,690 --> 00:16:37,700
 

901
00:16:37,700 --> 00:16:39,880
the other thread because now I'm moving

902
00:16:39,880 --> 00:16:39,890
 

903
00:16:39,890 --> 00:16:41,769
moving memory around I'm changing

904
00:16:41,769 --> 00:16:41,779
 

905
00:16:41,779 --> 00:16:43,090
pointers so now point to new locations

906
00:16:43,090 --> 00:16:43,100
 

907
00:16:43,100 --> 00:16:45,250
right and that becomes problematic cuz

908
00:16:45,250 --> 00:16:45,260
 

909
00:16:45,260 --> 00:16:47,500
now we could have if we have a race

910
00:16:47,500 --> 00:16:47,510
 

911
00:16:47,510 --> 00:16:50,470
condition where I copy the data to it to

912
00:16:50,470 --> 00:16:50,480
 

913
00:16:50,480 --> 00:16:52,600
a new location in memory but before

914
00:16:52,600 --> 00:16:52,610
 

915
00:16:52,610 --> 00:16:54,010
update the pointer someone follows the

916
00:16:54,010 --> 00:16:54,020

917
00:16:54,020 --> 00:16:55,870
pointer to the old location but maybe

918
00:16:55,870 --> 00:16:55,880
 

919
00:16:55,880 --> 00:16:57,340
I've already you reused that memory for

920
00:16:57,340 --> 00:16:57,350
 

921
00:16:57,350 --> 00:16:59,440
something else alright we're talking

922
00:16:59,440 --> 00:16:59,450
 

923
00:16:59,450 --> 00:17:01,600
microseconds here or nanoseconds but

924
00:17:01,600 --> 00:17:01,610
 

925
00:17:01,610 --> 00:17:05,319
this you know with enough you know bad

926
00:17:05,319 --> 00:17:05,329

927
00:17:05,329 --> 00:17:06,640
things can happen bad things can happen

928
00:17:06,640 --> 00:17:06,650
 

929
00:17:06,650 --> 00:17:08,350
bad things will happen so we have to

930
00:17:08,350 --> 00:17:08,360
 

931
00:17:08,360 --> 00:17:10,630
protect ourselves so it's like a really

932
00:17:10,630 --> 00:17:10,640
 

933
00:17:10,640 --> 00:17:12,520
simple example of what this looks like

934
00:17:12,520 --> 00:17:12,530
 

935
00:17:12,530 --> 00:17:14,740
so we set we have a simple B+ tree like

936
00:17:14,740 --> 00:17:14,750
 

937
00:17:14,750 --> 00:17:17,049
this and then what I'm doing is I'm

938
00:17:17,049 --> 00:17:17,059
 

939
00:17:17,059 --> 00:17:19,419
labeling the nodes on this side cuz I

940
00:17:19,419 --> 00:17:19,429
 

941
00:17:19,429 --> 00:17:20,770
gotta focus on the other side just one

942
00:17:20,770 --> 00:17:20,780
 

943
00:17:20,780 --> 00:17:21,880
letter so that we know what we're

944
00:17:21,880 --> 00:17:21,890
 

945
00:17:21,890 --> 00:17:24,040
talking about as we go down so say I

946
00:17:24,040 --> 00:17:24,050
 

947
00:17:24,050 --> 00:17:25,750
have one thread and they want to delete

948
00:17:25,750 --> 00:17:25,760
 

949
00:17:25,760 --> 00:17:28,780
44 it's down here at the bottom so it

950
00:17:28,780 --> 00:17:28,790
 

951
00:17:28,790 --> 00:17:31,090
just goes down one after another until

952
00:17:31,090 --> 00:17:31,100
 

953
00:17:31,100 --> 00:17:32,440
reach the bottom falling the separate

954
00:17:32,440 --> 00:17:32,450
 

955
00:17:32,450 --> 00:17:34,870
keys decide which way it wants to go but

956
00:17:34,870 --> 00:17:34,880
 

957
00:17:34,880 --> 00:17:37,060
then and then it goes has hasn't delete

958
00:17:37,060 --> 00:17:37,070

959
00:17:37,070 --> 00:17:41,080
this but now our node I here at the

960
00:17:41,080 --> 00:17:41,090
 

961
00:17:41,090 --> 00:17:43,960
bottom is is not less than half full

962
00:17:43,960 --> 00:17:43,970
 

963
00:17:43,970 --> 00:17:46,240
it's empty so we need to rebalance and

964
00:17:46,240 --> 00:17:46,250
 

965
00:17:46,250 --> 00:17:48,760
we'll do this by stealing 41 and and

966
00:17:48,760 --> 00:17:48,770

967
00:17:48,770 --> 00:17:50,320
from out from our neighbor and copying

968
00:17:50,320 --> 00:17:50,330
 

969
00:17:50,330 --> 00:17:51,090
it over

970
00:17:51,090 --> 00:17:51,100
 

971
00:17:51,100 --> 00:17:53,770
but now at the same time thread to comes

972
00:17:53,770 --> 00:17:53,780
 

973
00:17:53,780 --> 00:17:56,650
along and they want to find 41 so they

974
00:17:56,650 --> 00:17:56,660
 

975
00:17:56,660 --> 00:17:58,150
do the same thing they coming down and

976
00:17:58,150 --> 00:17:58,160
 

977
00:17:58,160 --> 00:17:59,050
they're coming along down here and they

978
00:17:59,050 --> 00:17:59,060
 

979
00:17:59,060 --> 00:18:01,690
get down to D and at this point when

980
00:18:01,690 --> 00:18:01,700
 

981
00:18:01,700 --> 00:18:03,430
they're they look at D they see the

982
00:18:03,430 --> 00:18:03,440
 

983
00:18:03,440 --> 00:18:05,410
separated key says oh well anything

984
00:18:05,410 --> 00:18:05,420
 

985
00:18:05,420 --> 00:18:08,620
between 38 and 44 is that node H so I

986
00:18:08,620 --> 00:18:08,630
 

987
00:18:08,630 --> 00:18:10,960
know I need to go there but in between

988
00:18:10,960 --> 00:18:10,970
 

989
00:18:10,970 --> 00:18:14,410
this time sorry I'm gonna fall at this

990
00:18:14,410 --> 00:18:14,420
 

991
00:18:14,420 --> 00:18:16,000
point in between this time the other

992
00:18:16,000 --> 00:18:16,010
 

993
00:18:16,010 --> 00:18:18,910
thread moves 41 over so now I go down

994
00:18:18,910 --> 00:18:18,920
 

995
00:18:18,920 --> 00:18:20,680
here and the thing that I thought should

996
00:18:20,680 --> 00:18:20,690
 

997
00:18:20,690 --> 00:18:23,980
be there is not there right so this

998
00:18:23,980 --> 00:18:23,990
 

999
00:18:23,990 --> 00:18:26,250
seems like this is sort of a logical

1000
00:18:26,250 --> 00:18:26,260
 

1001
00:18:26,260 --> 00:18:28,300
problem right because with like I

1002
00:18:28,300 --> 00:18:28,310
 

1003
00:18:28,310 --> 00:18:29,770
thought 44 was there but it's not there

1004
00:18:29,770 --> 00:18:29,780
 

1005
00:18:29,780 --> 00:18:31,180
it's actually a physical thing because

1006
00:18:31,180 --> 00:18:31,190
 

1007
00:18:31,190 --> 00:18:32,620
the data structure is telling you I'm

1008
00:18:32,620 --> 00:18:32,630

1009
00:18:32,630 --> 00:18:34,000
should go to this node age you'll find

1010
00:18:34,000 --> 00:18:34,010
 

1011
00:18:34,010 --> 00:18:35,890
what you want but it's no longer there

1012
00:18:35,890 --> 00:18:35,900
 

1013
00:18:35,900 --> 00:18:38,760
right because then after the fact the

1014
00:18:38,760 --> 00:18:38,770
 

1015
00:18:38,770 --> 00:18:41,530
right the D got updated with the correct

1016
00:18:41,530 --> 00:18:41,540
 

1017
00:18:41,540 --> 00:18:43,840
separator key and so any thread coming

1018
00:18:43,840 --> 00:18:43,850
 

1019
00:18:43,850 --> 00:18:46,240
behind this shirt on to I right so this

1020
00:18:46,240 --> 00:18:46,250
 

1021
00:18:46,250 --> 00:18:47,380
is essentially what what we need to

1022
00:18:47,380 --> 00:18:47,390
 

1023
00:18:47,390 --> 00:18:50,230
protect ourselves from so the way we're

1024
00:18:50,230 --> 00:18:50,240

1025
00:18:50,240 --> 00:18:51,460
gonna do this the sort of standard

1026
00:18:51,460 --> 00:18:51,470
 

1027
00:18:51,470 --> 00:18:52,990
technique is called lat crabbing or

1028
00:18:52,990 --> 00:18:53,000
 

1029
00:18:53,000 --> 00:18:55,810
latch coupling so I when I you know when

1030
00:18:55,810 --> 00:18:55,820

1031
00:18:55,820 --> 00:18:57,070
I learned databases when I was younger

1032
00:18:57,070 --> 00:18:57,080
 

1033
00:18:57,080 --> 00:18:59,260
they taught us the term latch crabbing

1034
00:18:59,260 --> 00:18:59,270
 

1035
00:18:59,270 --> 00:19:01,090
sometimes it's called latch coupling I

1036
00:19:01,090 --> 00:19:01,100

1037
00:19:01,100 --> 00:19:03,100
forget what the the textbook says but

1038
00:19:03,100 --> 00:19:03,110
 

1039
00:19:03,110 --> 00:19:04,510
they mean basically it's they mean

1040
00:19:04,510 --> 00:19:04,520
 

1041
00:19:04,520 --> 00:19:06,730
exactly the same thing so Wikipedia

1042
00:19:06,730 --> 00:19:06,740
 

1043
00:19:06,740 --> 00:19:08,250
might call it one versus the other

1044
00:19:08,250 --> 00:19:08,260
 

1045
00:19:08,260 --> 00:19:11,110
so latch crabbing is going to be a

1046
00:19:11,110 --> 00:19:11,120
 

1047
00:19:11,120 --> 00:19:13,480
protocol that is gonna allow multiple

1048
00:19:13,480 --> 00:19:13,490
 

1049
00:19:13,490 --> 00:19:15,430
threads to access and modify our B plus

1050
00:19:15,430 --> 00:19:15,440
 

1051
00:19:15,440 --> 00:19:18,220
tree at the same time and not have any

1052
00:19:18,220 --> 00:19:18,230
 

1053
00:19:18,230 --> 00:19:21,190
of these these problems and so the the

1054
00:19:21,190 --> 00:19:21,200
 

1055
00:19:21,200 --> 00:19:23,250
idea is pretty pretty straightforward

1056
00:19:23,250 --> 00:19:23,260
 

1057
00:19:23,260 --> 00:19:26,710
anytime we we want to reenter the tree

1058
00:19:26,710 --> 00:19:26,720
 

1059
00:19:26,720 --> 00:19:29,080
we always have to get a latch on a

1060
00:19:29,080 --> 00:19:29,090
 

1061
00:19:29,090 --> 00:19:31,570
parent node and then we try to get the

1062
00:19:31,570 --> 00:19:31,580
 

1063
00:19:31,580 --> 00:19:33,100
latch on the child node the direction we

1064
00:19:33,100 --> 00:19:33,110
 

1065
00:19:33,110 --> 00:19:35,230
want to go and then if we're able to get

1066
00:19:35,230 --> 00:19:35,240
 

1067
00:19:35,240 --> 00:19:36,910
that latch we move our thread down to

1068
00:19:36,910 --> 00:19:36,920
 

1069
00:19:36,920 --> 00:19:38,950
the next node and then we go ahead and

1070
00:19:38,950 --> 00:19:38,960
 

1071
00:19:38,960 --> 00:19:42,160
and release the parent node latch if

1072
00:19:42,160 --> 00:19:42,170
 

1073
00:19:42,170 --> 00:19:46,000
that node is considered safe and so if I

1074
00:19:46,000 --> 00:19:46,010
 

1075
00:19:46,010 --> 00:19:48,850
safe I mean that we know that based on

1076
00:19:48,850 --> 00:19:48,860
 

1077
00:19:48,860 --> 00:19:50,110
whatever operation we're trying to do

1078
00:19:50,110 --> 00:19:50,120
 

1079
00:19:50,120 --> 00:19:52,630
whether it's an insert or delete that

1080
00:19:52,630 --> 00:19:52,640
 

1081
00:19:52,640 --> 00:19:55,780
the node that we just moved to would not

1082
00:19:55,780 --> 00:19:55,790
 

1083
00:19:55,790 --> 00:19:58,300
need to be split or merged meaning it

1084
00:19:58,300 --> 00:19:58,310
 

1085
00:19:58,310 --> 00:19:59,770
can accommodate whatever the change is

1086
00:19:59,770 --> 00:19:59,780
 

1087
00:19:59,780 --> 00:20:04,000
that may be below it right so if if my

1088
00:20:04,000 --> 00:20:04,010
 

1089
00:20:04,010 --> 00:20:05,499
node is full

1090
00:20:05,499 --> 00:20:05,509

1091
00:20:05,509 --> 00:20:08,680
and I'm doing an insertion then I may

1092
00:20:08,680 --> 00:20:08,690
 

1093
00:20:08,690 --> 00:20:10,389
have to split that node my parent node

1094
00:20:10,389 --> 00:20:10,399
 

1095
00:20:10,399 --> 00:20:12,039
so therefore I could split the node I'm

1096
00:20:12,039 --> 00:20:12,049
 

1097
00:20:12,049 --> 00:20:13,539
at and therefore had to update my parent

1098
00:20:13,539 --> 00:20:13,549
 

1099
00:20:13,549 --> 00:20:14,860
node so therefore I don't want to

1100
00:20:14,860 --> 00:20:14,870
 

1101
00:20:14,870 --> 00:20:16,899
release the latch my parent node same

1102
00:20:16,899 --> 00:20:16,909
 

1103
00:20:16,909 --> 00:20:18,399
thing for delete if it's if it's less

1104
00:20:18,399 --> 00:20:18,409
 

1105
00:20:18,409 --> 00:20:20,200
than half full then I may have to do a

1106
00:20:20,200 --> 00:20:20,210
 

1107
00:20:20,210 --> 00:20:22,720
merge and therefore I type my parents

1108
00:20:22,720 --> 00:20:22,730
 

1109
00:20:22,730 --> 00:20:25,870
not safe either all right so let's see

1110
00:20:25,870 --> 00:20:25,880
 

1111
00:20:25,880 --> 00:20:27,129
basic how this work right first search

1112
00:20:27,129 --> 00:20:27,139
 

1113
00:20:27,139 --> 00:20:28,600
it's pretty straightforward right you

1114
00:20:28,600 --> 00:20:28,610
 

1115
00:20:28,610 --> 00:20:29,830
take real a choose all the way down

1116
00:20:29,830 --> 00:20:29,840
 

1117
00:20:29,840 --> 00:20:32,139
right you cry the latch on your child

1118
00:20:32,139 --> 00:20:32,149
 

1119
00:20:32,149 --> 00:20:34,180
the one the one that's below you if you

1120
00:20:34,180 --> 00:20:34,190
 

1121
00:20:34,190 --> 00:20:35,590
acquire you move down there and then you

1122
00:20:35,590 --> 00:20:35,600
 

1123
00:20:35,600 --> 00:20:37,269
always unreleased your parent right

1124
00:20:37,269 --> 00:20:37,279
 

1125
00:20:37,279 --> 00:20:38,919
because you know searches are obviously

1126
00:20:38,919 --> 00:20:38,929
 

1127
00:20:38,929 --> 00:20:39,940
read-only so you're never going to

1128
00:20:39,940 --> 00:20:39,950
 

1129
00:20:39,950 --> 00:20:42,279
modify the structure of the tree doing

1130
00:20:42,279 --> 00:20:42,289
 

1131
00:20:42,289 --> 00:20:43,539
is sort of delete you start the route

1132
00:20:43,539 --> 00:20:43,549

1133
00:20:43,549 --> 00:20:45,100
and go down inquire write latches all

1134
00:20:45,100 --> 00:20:45,110
 

1135
00:20:45,110 --> 00:20:48,159
the way down and then as you go down if

1136
00:20:48,159 --> 00:20:48,169
 

1137
00:20:48,169 --> 00:20:50,649
you know that the the child node you

1138
00:20:50,649 --> 00:20:50,659

1139
00:20:50,659 --> 00:20:52,840
just jump to is safe then it's you can

1140
00:20:52,840 --> 00:20:52,850
 

1141
00:20:52,850 --> 00:20:54,399
go ahead and release the latch for your

1142
00:20:54,399 --> 00:20:54,409
 

1143
00:20:54,409 --> 00:20:57,850
parent or anything above it okay let's

1144
00:20:57,850 --> 00:20:57,860
 

1145
00:20:57,860 --> 00:21:00,129
look an example so say that our thread

1146
00:21:00,129 --> 00:21:00,139
 

1147
00:21:00,139 --> 00:21:03,639
here wants to search for 38 so we

1148
00:21:03,639 --> 00:21:03,649
 

1149
00:21:03,649 --> 00:21:05,019
started off at the very beginning we get

1150
00:21:05,019 --> 00:21:05,029
 

1151
00:21:05,029 --> 00:21:07,180
the read latch on the root a then we

1152
00:21:07,180 --> 00:21:07,190
 

1153
00:21:07,190 --> 00:21:09,129
jump down get the real a and B and then

1154
00:21:09,129 --> 00:21:09,139
 

1155
00:21:09,139 --> 00:21:11,200
move down there again right and this

1156
00:21:11,200 --> 00:21:11,210
 

1157
00:21:11,210 --> 00:21:13,389
point here since it's read-only it's

1158
00:21:13,389 --> 00:21:13,399
 

1159
00:21:13,399 --> 00:21:15,340
safe for us to release the latch on a so

1160
00:21:15,340 --> 00:21:15,350
 

1161
00:21:15,350 --> 00:21:17,259
we go ahead and do that then move down

1162
00:21:17,259 --> 00:21:17,269
 

1163
00:21:17,269 --> 00:21:20,049
further the latch on D go down there get

1164
00:21:20,049 --> 00:21:20,059
 

1165
00:21:20,059 --> 00:21:21,850
to latch on H go down there and then

1166
00:21:21,850 --> 00:21:21,860
 

1167
00:21:21,860 --> 00:21:23,139
we're done I mean we can read the item

1168
00:21:23,139 --> 00:21:23,149
 

1169
00:21:23,149 --> 00:21:25,509
that we wanted right pretty shape word

1170
00:21:25,509 --> 00:21:25,519
 

1171
00:21:25,519 --> 00:21:26,409
and that's so the coupling or the

1172
00:21:26,409 --> 00:21:26,419
 

1173
00:21:26,419 --> 00:21:27,820
grabbing part the crowding part says be

1174
00:21:27,820 --> 00:21:27,830
 

1175
00:21:27,830 --> 00:21:30,249
like the way a crab walks so you're

1176
00:21:30,249 --> 00:21:30,259

1177
00:21:30,259 --> 00:21:33,180
releasing these these latches behind you

1178
00:21:33,180 --> 00:21:33,190

1179
00:21:33,190 --> 00:21:35,259
all right let's see about we want to do

1180
00:21:35,259 --> 00:21:35,269
 

1181
00:21:35,269 --> 00:21:37,600
a delete so we started ready to get any

1182
00:21:37,600 --> 00:21:37,610
 

1183
00:21:37,610 --> 00:21:41,649
one leap key 38 here at the bottom so we

1184
00:21:41,649 --> 00:21:41,659
 

1185
00:21:41,659 --> 00:21:43,779
start off the right latch on a and then

1186
00:21:43,779 --> 00:21:43,789
 

1187
00:21:43,789 --> 00:21:46,119
we get the right latch on B and then

1188
00:21:46,119 --> 00:21:46,129
 

1189
00:21:46,129 --> 00:21:50,649
move down now at at this point since B

1190
00:21:50,649 --> 00:21:50,659
 

1191
00:21:50,659 --> 00:21:53,139
is really two keys in here but this B is

1192
00:21:53,139 --> 00:21:53,149
 

1193
00:21:53,149 --> 00:21:56,320
half for less we don't know what's gonna

1194
00:21:56,320 --> 00:21:56,330
 

1195
00:21:56,330 --> 00:21:58,810
happen below us at this point right we

1196
00:21:58,810 --> 00:21:58,820
 

1197
00:21:58,820 --> 00:22:00,519
only know with that our current node and

1198
00:22:00,519 --> 00:22:00,529
 

1199
00:22:00,529 --> 00:22:02,169
the one that came behind us so at this

1200
00:22:02,169 --> 00:22:02,179
 

1201
00:22:02,179 --> 00:22:04,419
point here we don't know whether the if

1202
00:22:04,419 --> 00:22:04,429
 

1203
00:22:04,429 --> 00:22:06,909
we go down to D whether it's going to

1204
00:22:06,909 --> 00:22:06,919
 

1205
00:22:06,919 --> 00:22:09,519
have to do a merge because it looks less

1206
00:22:09,519 --> 00:22:09,529
 

1207
00:22:09,529 --> 00:22:12,430
than half full so at this point here we

1208
00:22:12,430 --> 00:22:12,440
 

1209
00:22:12,440 --> 00:22:14,950
can't release the latch on on a because

1210
00:22:14,950 --> 00:22:14,960

1211
00:22:14,960 --> 00:22:18,400
we may have to merge or B right

1212
00:22:18,400 --> 00:22:18,410
 

1213
00:22:18,410 --> 00:22:20,740
so then we get down to D and then now we

1214
00:22:20,740 --> 00:22:20,750
 

1215
00:22:20,750 --> 00:22:24,340
recognize that D is completely full and

1216
00:22:24,340 --> 00:22:24,350
 

1217
00:22:24,350 --> 00:22:26,050
we're doing a delete here so no matter

1218
00:22:26,050 --> 00:22:26,060
 

1219
00:22:26,060 --> 00:22:28,870
what happens below us D can absorb if

1220
00:22:28,870 --> 00:22:28,880
 

1221
00:22:28,880 --> 00:22:31,090
you will any change without having to

1222
00:22:31,090 --> 00:22:31,100
 

1223
00:22:31,100 --> 00:22:33,220
propagate it back up into the tree so at

1224
00:22:33,220 --> 00:22:33,230
 

1225
00:22:33,230 --> 00:22:35,050
this point here we can release the latch

1226
00:22:35,050 --> 00:22:35,060
 

1227
00:22:35,060 --> 00:22:37,120
on a and B our entire lineage back up to

1228
00:22:37,120 --> 00:22:37,130
 

1229
00:22:37,130 --> 00:22:39,760
the root so one key thing to point out

1230
00:22:39,760 --> 00:22:39,770
 

1231
00:22:39,770 --> 00:22:41,500
here is that we're gonna release the

1232
00:22:41,500 --> 00:22:41,510
 

1233
00:22:41,510 --> 00:22:44,560
latch the latches in first in first out

1234
00:22:44,560 --> 00:22:44,570
 

1235
00:22:44,570 --> 00:22:46,810
order that we acquired them so I'm gonna

1236
00:22:46,810 --> 00:22:46,820

1237
00:22:46,820 --> 00:22:49,150
release the latch on a first followed by

1238
00:22:49,150 --> 00:22:49,160
 

1239
00:22:49,160 --> 00:23:01,300
B and we take a guess why exactly yeah

1240
00:23:01,300 --> 00:23:01,310
 

1241
00:23:01,310 --> 00:23:02,890
so she said you want somebody to access

1242
00:23:02,890 --> 00:23:02,900
 

1243
00:23:02,900 --> 00:23:05,620
a as soon as possible right so there's

1244
00:23:05,620 --> 00:23:05,630
 

1245
00:23:05,630 --> 00:23:08,170
no correctness issue right because if I

1246
00:23:08,170 --> 00:23:08,180
 

1247
00:23:08,180 --> 00:23:11,140
release be here you know it's not an

1248
00:23:11,140 --> 00:23:11,150
 

1249
00:23:11,150 --> 00:23:12,190
issue because no one can get to it

1250
00:23:12,190 --> 00:23:12,200
 

1251
00:23:12,200 --> 00:23:13,600
anyway because I had the right latch on

1252
00:23:13,600 --> 00:23:13,610

1253
00:23:13,610 --> 00:23:16,570
on a on the roof so if I release the

1254
00:23:16,570 --> 00:23:16,580
 

1255
00:23:16,580 --> 00:23:18,670
latch on a first when we're talking

1256
00:23:18,670 --> 00:23:18,680
 

1257
00:23:18,680 --> 00:23:20,380
again nanoseconds or microseconds here

1258
00:23:20,380 --> 00:23:20,390
 

1259
00:23:20,390 --> 00:23:22,840
but it opens up a window now where

1260
00:23:22,840 --> 00:23:22,850

1261
00:23:22,850 --> 00:23:25,090
someone can come in and and and possibly

1262
00:23:25,090 --> 00:23:25,100
 

1263
00:23:25,100 --> 00:23:27,010
get into our tree and they may name may

1264
00:23:27,010 --> 00:23:27,020
 

1265
00:23:27,020 --> 00:23:28,690
not even going down the same same path

1266
00:23:28,690 --> 00:23:28,700
 

1267
00:23:28,700 --> 00:23:29,980
that we are then they may be going down

1268
00:23:29,980 --> 00:23:29,990
 

1269
00:23:29,990 --> 00:23:31,240
another path on the other side of the

1270
00:23:31,240 --> 00:23:31,250
 

1271
00:23:31,250 --> 00:23:33,340
tree but again everyone's always stymied

1272
00:23:33,340 --> 00:23:33,350
 

1273
00:23:33,350 --> 00:23:35,800
on on the root I'm blocked on that so as

1274
00:23:35,800 --> 00:23:35,810
 

1275
00:23:35,810 --> 00:23:37,180
soon as I can release that the better it

1276
00:23:37,180 --> 00:23:37,190
 

1277
00:23:37,190 --> 00:23:40,810
is alright so then I get my right latch

1278
00:23:40,810 --> 00:23:40,820
 

1279
00:23:40,820 --> 00:23:44,770
on on H I move down and I go ahead and I

1280
00:23:44,770 --> 00:23:44,780
 

1281
00:23:44,780 --> 00:23:48,640
can delete 38 and again there's no we're

1282
00:23:48,640 --> 00:23:48,650
 

1283
00:23:48,650 --> 00:23:50,230
out more than half full so there's no

1284
00:23:50,230 --> 00:23:50,240
 

1285
00:23:50,240 --> 00:23:51,820
change I need to make to anybody above

1286
00:23:51,820 --> 00:23:51,830
 

1287
00:23:51,830 --> 00:23:53,050
it so I didn't have to hold the latch

1288
00:23:53,050 --> 00:23:53,060
 

1289
00:23:53,060 --> 00:23:58,000
for that okay all right let's see now an

1290
00:23:58,000 --> 00:23:58,010
 

1291
00:23:58,010 --> 00:24:00,640
insertion so on insert 45 same thing I

1292
00:24:00,640 --> 00:24:00,650
 

1293
00:24:00,650 --> 00:24:02,950
started off I get my right latch on a ok

1294
00:24:02,950 --> 00:24:02,960
 

1295
00:24:02,960 --> 00:24:04,210
the right outlook speed and move down

1296
00:24:04,210 --> 00:24:04,220
 

1297
00:24:04,220 --> 00:24:09,190
and again at this point I can release a

1298
00:24:09,190 --> 00:24:09,200
 

1299
00:24:09,200 --> 00:24:11,680
because I know I have a free slot or

1300
00:24:11,680 --> 00:24:11,690
 

1301
00:24:11,690 --> 00:24:15,520
freaky space in B so no matter what if I

1302
00:24:15,520 --> 00:24:15,530
 

1303
00:24:15,530 --> 00:24:18,310
have and I have to split below I can

1304
00:24:18,310 --> 00:24:18,320
 

1305
00:24:18,320 --> 00:24:21,790
absorb a new a separated key at B so we

1306
00:24:21,790 --> 00:24:21,800
 

1307
00:24:21,800 --> 00:24:23,470
can release the latch on a then we get

1308
00:24:23,470 --> 00:24:23,480
 

1309
00:24:23,480 --> 00:24:27,610
down to to get the latch on I and this

1310
00:24:27,610 --> 00:24:27,620
 

1311
00:24:27,620 --> 00:24:29,890
point here I has room so we can release

1312
00:24:29,890 --> 00:24:29,900
 

1313
00:24:29,900 --> 00:24:32,050
the latch on B and D all the way

1314
00:24:32,050 --> 00:24:32,060
 

1315
00:24:32,060 --> 00:24:33,670
right actually in this case here 4d

1316
00:24:33,670 --> 00:24:33,680
 

1317
00:24:33,680 --> 00:24:36,220
going back and here I couldn't release

1318
00:24:36,220 --> 00:24:36,230
 

1319
00:24:36,230 --> 00:24:38,020
latch on B because I don't know what's

1320
00:24:38,020 --> 00:24:38,030
 

1321
00:24:38,030 --> 00:24:40,690
below me at D so I and I don't have any

1322
00:24:40,690 --> 00:24:40,700
 

1323
00:24:40,700 --> 00:24:42,310
more space and take another key so I

1324
00:24:42,310 --> 00:24:42,320
 

1325
00:24:42,320 --> 00:24:43,990
have to maintain the latch on B because

1326
00:24:43,990 --> 00:24:44,000
 

1327
00:24:44,000 --> 00:24:45,580
I may have to go all the way up and and

1328
00:24:45,580 --> 00:24:45,590
 

1329
00:24:45,590 --> 00:24:47,650
do splitting but when I get down to I I

1330
00:24:47,650 --> 00:24:47,660
 

1331
00:24:47,660 --> 00:24:49,660
say oh I have a free space I'm not gonna

1332
00:24:49,660 --> 00:24:49,670
 

1333
00:24:49,670 --> 00:24:51,250
have to do a split so therefore I can

1334
00:24:51,250 --> 00:24:51,260
 

1335
00:24:51,260 --> 00:24:52,750
release the bat flip the latch on B and

1336
00:24:52,750 --> 00:24:52,760
 

1337
00:24:52,760 --> 00:24:57,970
D okay alright so let's look one more

1338
00:24:57,970 --> 00:24:57,980
 

1339
00:24:57,980 --> 00:24:59,710
example inserts what you do have to do a

1340
00:24:59,710 --> 00:24:59,720
 

1341
00:24:59,720 --> 00:25:03,460
split so we wanna start key 25 same

1342
00:25:03,460 --> 00:25:03,470
 

1343
00:25:03,470 --> 00:25:06,010
thing start off one on a get delete we

1344
00:25:06,010 --> 00:25:06,020
 

1345
00:25:06,020 --> 00:25:07,060
get the right latch get the right latch

1346
00:25:07,060 --> 00:25:07,070
 

1347
00:25:07,070 --> 00:25:10,750
on B move down at this point here B's

1348
00:25:10,750 --> 00:25:10,760
 

1349
00:25:10,760 --> 00:25:12,310
not gonna have to a split so we release

1350
00:25:12,310 --> 00:25:12,320
 

1351
00:25:12,320 --> 00:25:14,500
the roulette right latch on a move down

1352
00:25:14,500 --> 00:25:14,510

1353
00:25:14,510 --> 00:25:18,760
to C same thing we have a free space so

1354
00:25:18,760 --> 00:25:18,770
 

1355
00:25:18,770 --> 00:25:21,550
we're not gonna have to do a split at C

1356
00:25:21,550 --> 00:25:21,560

1357
00:25:21,560 --> 00:25:23,880
so we release over like right latch on B

1358
00:25:23,880 --> 00:25:23,890
 

1359
00:25:23,890 --> 00:25:27,580
then we get down to F and now we see

1360
00:25:27,580 --> 00:25:27,590
 

1361
00:25:27,590 --> 00:25:29,590
we're gonna have to do a split so for

1362
00:25:29,590 --> 00:25:29,600
 

1363
00:25:29,600 --> 00:25:31,180
this we can't release the right latch on

1364
00:25:31,180 --> 00:25:31,190
 

1365
00:25:31,190 --> 00:25:33,670
C because we're gonna have to put

1366
00:25:33,670 --> 00:25:33,680
 

1367
00:25:33,680 --> 00:25:34,690
something in there alright cuz we're

1368
00:25:34,690 --> 00:25:34,700
 

1369
00:25:34,700 --> 00:25:38,530
doing a split on on F right so we keep

1370
00:25:38,530 --> 00:25:38,540
 

1371
00:25:38,540 --> 00:25:40,540
the latch on a parent node and then we

1372
00:25:40,540 --> 00:25:40,550

1373
00:25:40,550 --> 00:25:43,630
do our insertion update the separator

1374
00:25:43,630 --> 00:25:43,640
 

1375
00:25:43,640 --> 00:25:46,510
key and add at our new page right and

1376
00:25:46,510 --> 00:25:46,520
 

1377
00:25:46,520 --> 00:25:48,190
then once that all that's done we

1378
00:25:48,190 --> 00:25:48,200
 

1379
00:25:48,200 --> 00:25:50,500
release all the latches and now our new

1380
00:25:50,500 --> 00:25:50,510
 

1381
00:25:50,510 --> 00:25:52,990
key of 25 is is visible to other threads

1382
00:25:52,990 --> 00:25:53,000
 

1383
00:25:53,000 --> 00:25:55,480
and we're the integrity of the data

1384
00:25:55,480 --> 00:25:55,490
 

1385
00:25:55,490 --> 00:25:58,750
structure is still sound right so if

1386
00:25:58,750 --> 00:25:58,760
 

1387
00:25:58,760 --> 00:26:00,070
anybody coming behind us is doing a

1388
00:26:00,070 --> 00:26:00,080
 

1389
00:26:00,080 --> 00:26:02,470
lookup right they want to look in these

1390
00:26:02,470 --> 00:26:02,480
 

1391
00:26:02,480 --> 00:26:04,210
pages they would get blocked at this

1392
00:26:04,210 --> 00:26:04,220
 

1393
00:26:04,220 --> 00:26:05,110
point because they're not gonna be able

1394
00:26:05,110 --> 00:26:05,120
 

1395
00:26:05,120 --> 00:26:14,860
to get any latch on C yes his question

1396
00:26:14,860 --> 00:26:14,870
 

1397
00:26:14,870 --> 00:26:17,290
is the the criteria for judging whether

1398
00:26:17,290 --> 00:26:17,300
 

1399
00:26:17,300 --> 00:26:21,790
a node is safe or not I'll just say what

1400
00:26:21,790 --> 00:26:21,800
 

1401
00:26:21,800 --> 00:26:24,400
it is so it's it's if you're gonna if

1402
00:26:24,400 --> 00:26:24,410
 

1403
00:26:24,410 --> 00:26:27,340
you're doing the insert if the if the

1404
00:26:27,340 --> 00:26:27,350
 

1405
00:26:27,350 --> 00:26:31,570
node is not full that means that no

1406
00:26:31,570 --> 00:26:31,580
 

1407
00:26:31,580 --> 00:26:33,490
matter what happens below you if you do

1408
00:26:33,490 --> 00:26:33,500
 

1409
00:26:33,500 --> 00:26:36,340
a split that you can you gonna you could

1410
00:26:36,340 --> 00:26:36,350
 

1411
00:26:36,350 --> 00:26:38,200
have room to take a new separator key at

1412
00:26:38,200 --> 00:26:38,210
 

1413
00:26:38,210 --> 00:26:40,270
that node at your parent node so

1414
00:26:40,270 --> 00:26:40,280
 

1415
00:26:40,280 --> 00:26:41,500
therefore you're not going to split that

1416
00:26:41,500 --> 00:26:41,510
 

1417
00:26:41,510 --> 00:26:44,440
node so you don't need to to hold a

1418
00:26:44,440 --> 00:26:44,450
 

1419
00:26:44,450 --> 00:26:45,430
right latch on that because you're never

1420
00:26:45,430 --> 00:26:45,440
 

1421
00:26:45,440 --> 00:26:45,940
going to

1422
00:26:45,940 --> 00:26:45,950
 

1423
00:26:45,950 --> 00:26:48,009
changes propagated beyond the one you're

1424
00:26:48,009 --> 00:26:48,019

1425
00:26:48,019 --> 00:26:50,230
at right so at this point here going

1426
00:26:50,230 --> 00:26:50,240
 

1427
00:26:50,240 --> 00:26:53,379
back so we're here we get our right

1428
00:26:53,379 --> 00:26:53,389
 

1429
00:26:53,389 --> 00:26:55,509
latch on C and then we jump down and now

1430
00:26:55,509 --> 00:26:55,519
 

1431
00:26:55,519 --> 00:26:57,340
at this point we know we're doing an

1432
00:26:57,340 --> 00:26:57,350
 

1433
00:26:57,350 --> 00:27:00,430
insert so no matter what happens below

1434
00:27:00,430 --> 00:27:00,440
 

1435
00:27:00,440 --> 00:27:03,789
here whether we split or not or even if

1436
00:27:03,789 --> 00:27:03,799
 

1437
00:27:03,799 --> 00:27:06,669
we do split that we can put it in we

1438
00:27:06,669 --> 00:27:06,679
 

1439
00:27:06,679 --> 00:27:09,009
have room to put a space in here so that

1440
00:27:09,009 --> 00:27:09,019
 

1441
00:27:09,019 --> 00:27:10,360
means that we're never gonna have to

1442
00:27:10,360 --> 00:27:10,370
 

1443
00:27:10,370 --> 00:27:12,340
split this and therefore update B so

1444
00:27:12,340 --> 00:27:12,350

1445
00:27:12,350 --> 00:27:14,560
it's safe for us to release the latch on

1446
00:27:14,560 --> 00:27:14,570
 

1447
00:27:14,570 --> 00:27:17,019
on D and then when we get down here we

1448
00:27:17,019 --> 00:27:17,029
 

1449
00:27:17,029 --> 00:27:18,490
say oh well now we actually do a

1450
00:27:18,490 --> 00:27:18,500
 

1451
00:27:18,500 --> 00:27:20,139
split so now we can't release our latch

1452
00:27:20,139 --> 00:27:20,149
 

1453
00:27:20,149 --> 00:27:21,580
on C because we're have to update it and

1454
00:27:21,580 --> 00:27:21,590
 

1455
00:27:21,590 --> 00:27:30,220
we do we do our split that way yes his

1456
00:27:30,220 --> 00:27:30,230
 

1457
00:27:30,230 --> 00:27:31,600
question is would you need thousand of

1458
00:27:31,600 --> 00:27:31,610
 

1459
00:27:31,610 --> 00:27:35,740
new Texas free Street yes right buddy so

1460
00:27:35,740 --> 00:27:35,750
 

1461
00:27:35,750 --> 00:27:37,840
I don't wanna get into the

1462
00:27:37,840 --> 00:27:37,850
 

1463
00:27:37,850 --> 00:27:40,690
implementation side of things for these

1464
00:27:40,690 --> 00:27:40,700
 

1465
00:27:40,700 --> 00:27:43,440
you'd you do wouldn't want to use like a

1466
00:27:43,440 --> 00:27:43,450
 

1467
00:27:43,450 --> 00:27:46,120
like the standard standard template

1468
00:27:46,120 --> 00:27:46,130
 

1469
00:27:46,130 --> 00:27:48,340
library mutex which is just a linux

1470
00:27:48,340 --> 00:27:48,350
 

1471
00:27:48,350 --> 00:27:50,919
futex right used when he's a spin latch

1472
00:27:50,919 --> 00:27:50,929
 

1473
00:27:50,929 --> 00:27:53,409
I mean just you have a single atomic

1474
00:27:53,409 --> 00:27:53,419
 

1475
00:27:53,419 --> 00:27:55,690
like integer and you do compare-and-swap

1476
00:27:55,690 --> 00:27:55,700
 

1477
00:27:55,700 --> 00:27:57,730
to acquire if you can't acquire you spin

1478
00:27:57,730 --> 00:27:57,740
 

1479
00:27:57,740 --> 00:27:59,860
on it that's that's the fastest way to

1480
00:27:59,860 --> 00:27:59,870
 

1481
00:27:59,870 --> 00:28:02,230
implement a latch so now we're talking

1482
00:28:02,230 --> 00:28:02,240
 

1483
00:28:02,240 --> 00:28:06,340
like in each page you can do a I think

1484
00:28:06,340 --> 00:28:06,350
 

1485
00:28:06,350 --> 00:28:09,610
you can do 8-bit atomic latches because

1486
00:28:09,610 --> 00:28:09,620

1487
00:28:09,620 --> 00:28:12,759
we don't care about the value and that's

1488
00:28:12,759 --> 00:28:12,769
 

1489
00:28:12,769 --> 00:28:14,590
not true because if you if you need to

1490
00:28:14,590 --> 00:28:14,600
 

1491
00:28:14,600 --> 00:28:17,139
keep that are writers leaders or writers

1492
00:28:17,139 --> 00:28:17,149
 

1493
00:28:17,149 --> 00:28:18,730
you do have a it has to be a little

1494
00:28:18,730 --> 00:28:18,740
 

1495
00:28:18,740 --> 00:28:20,889
better and then way you implement that

1496
00:28:20,889 --> 00:28:20,899
 

1497
00:28:20,899 --> 00:28:22,779
is you could have a single counter for

1498
00:28:22,779 --> 00:28:22,789

1499
00:28:22,789 --> 00:28:25,509
the right latch and then a counter for

1500
00:28:25,509 --> 00:28:25,519
 

1501
00:28:25,519 --> 00:28:27,310
the the read latch at any time you

1502
00:28:27,310 --> 00:28:27,320

1503
00:28:27,320 --> 00:28:28,509
acquire you add one to the read latch

1504
00:28:28,509 --> 00:28:28,519
 

1505
00:28:28,519 --> 00:28:30,399
and you know the new subtract one when

1506
00:28:30,399 --> 00:28:30,409

1507
00:28:30,409 --> 00:28:31,210
you release it you can do that

1508
00:28:31,210 --> 00:28:31,220
 

1509
00:28:31,220 --> 00:28:33,850
atomically so we're maybe talking 64

1510
00:28:33,850 --> 00:28:33,860
 

1511
00:28:33,860 --> 00:28:40,720
bits per latch it's nothing all right so

1512
00:28:40,720 --> 00:28:40,730
 

1513
00:28:40,730 --> 00:28:42,759
I started said those are already and

1514
00:28:42,759 --> 00:28:42,769
 

1515
00:28:42,769 --> 00:28:45,279
when I asked I asked before what was the

1516
00:28:45,279 --> 00:28:45,289
 

1517
00:28:45,289 --> 00:28:47,529
first step that we did in in every

1518
00:28:47,529 --> 00:28:47,539
 

1519
00:28:47,539 --> 00:28:49,149
single case we were updating the the

1520
00:28:49,149 --> 00:28:49,159
 

1521
00:28:49,159 --> 00:28:55,000
tree what's the very first step block

1522
00:28:55,000 --> 00:28:55,010
 

1523
00:28:55,010 --> 00:28:56,919
the root exactly yes right and if you're

1524
00:28:56,919 --> 00:28:56,929
 

1525
00:28:56,929 --> 00:28:59,210
doing all these updates you're locking

1526
00:28:59,210 --> 00:28:59,220
 

1527
00:28:59,220 --> 00:29:01,730
and within a right latch mode so nobody

1528
00:29:01,730 --> 00:29:01,740
 

1529
00:29:01,740 --> 00:29:04,039
can even read it all right so this

1530
00:29:04,039 --> 00:29:04,049
 

1531
00:29:04,049 --> 00:29:05,720
becomes a major bottleneck because every

1532
00:29:05,720 --> 00:29:05,730
 

1533
00:29:05,730 --> 00:29:07,990
single time you want to do anything

1534
00:29:07,990 --> 00:29:08,000
 

1535
00:29:08,000 --> 00:29:10,070
you're you're locking the route and

1536
00:29:10,070 --> 00:29:10,080
 

1537
00:29:10,080 --> 00:29:11,750
essentially making this be a serial

1538
00:29:11,750 --> 00:29:11,760
 

1539
00:29:11,760 --> 00:29:15,830
single threaded data structure so this

1540
00:29:15,830 --> 00:29:15,840

1541
00:29:15,840 --> 00:29:17,840
will become a major bottleneck in a

1542
00:29:17,840 --> 00:29:17,850
 

1543
00:29:17,850 --> 00:29:19,190
highly parallel environment because

1544
00:29:19,190 --> 00:29:19,200

1545
00:29:19,200 --> 00:29:21,020
everybody has to go through this sort of

1546
00:29:21,020 --> 00:29:21,030
 

1547
00:29:21,030 --> 00:29:23,659
one contention point even if they go

1548
00:29:23,659 --> 00:29:23,669
 

1549
00:29:23,669 --> 00:29:24,590
down to different parts of the trees

1550
00:29:24,590 --> 00:29:24,600
 

1551
00:29:24,600 --> 00:29:26,149
they're always sort of starting at the

1552
00:29:26,149 --> 00:29:26,159
 

1553
00:29:26,159 --> 00:29:28,310
same spot so we need to we need

1554
00:29:28,310 --> 00:29:28,320
 

1555
00:29:28,320 --> 00:29:32,270
something better and so the this album

1556
00:29:32,270 --> 00:29:32,280
 

1557
00:29:32,280 --> 00:29:34,539
knows when I have a name it's sort of

1558
00:29:34,539 --> 00:29:34,549
 

1559
00:29:34,549 --> 00:29:37,340
it's it's to be customized named after

1560
00:29:37,340 --> 00:29:37,350
 

1561
00:29:37,350 --> 00:29:38,990
the people these two Germans Bayer

1562
00:29:38,990 --> 00:29:39,000
 

1563
00:29:39,000 --> 00:29:40,850
slotnick sometimes it's called alpha

1564
00:29:40,850 --> 00:29:40,860
 

1565
00:29:40,860 --> 00:29:43,159
mystical a latching algorithm right it's

1566
00:29:43,159 --> 00:29:43,169

1567
00:29:43,169 --> 00:29:45,680
an old thing as from like 1977 right but

1568
00:29:45,680 --> 00:29:45,690
 

1569
00:29:45,690 --> 00:29:47,029
the idea is pretty straightforward and

1570
00:29:47,029 --> 00:29:47,039
 

1571
00:29:47,039 --> 00:29:48,740
this is pretty much what everyone all

1572
00:29:48,740 --> 00:29:48,750
 

1573
00:29:48,750 --> 00:29:51,350
the this is that the very least would

1574
00:29:51,350 --> 00:29:51,360
 

1575
00:29:51,360 --> 00:29:53,390
every system that uses a B+ tree that

1576
00:29:53,390 --> 00:29:53,400
 

1577
00:29:53,400 --> 00:29:54,289
must be mostly threaded will do

1578
00:29:54,289 --> 00:29:54,299
 

1579
00:29:54,299 --> 00:29:55,220
something like this there's a bunch of

1580
00:29:55,220 --> 00:29:55,230
 

1581
00:29:55,230 --> 00:29:56,480
other optimization if we can do we're

1582
00:29:56,480 --> 00:29:56,490

1583
00:29:56,490 --> 00:29:58,100
not gonna cover but this is what every

1584
00:29:58,100 --> 00:29:58,110
 

1585
00:29:58,110 --> 00:30:00,890
what everyone does so this better

1586
00:30:00,890 --> 00:30:00,900
 

1587
00:30:00,900 --> 00:30:02,480
latching algorithm is considered an

1588
00:30:02,480 --> 00:30:02,490

1589
00:30:02,490 --> 00:30:05,090
optimistic algorithm meaning it's going

1590
00:30:05,090 --> 00:30:05,100
 

1591
00:30:05,100 --> 00:30:07,940
to assume that if you're doing an insert

1592
00:30:07,940 --> 00:30:07,950
 

1593
00:30:07,950 --> 00:30:11,120
or delete that the leaf node that you're

1594
00:30:11,120 --> 00:30:11,130
 

1595
00:30:11,130 --> 00:30:13,070
going to be modifying will be safe I

1596
00:30:13,070 --> 00:30:13,080
 

1597
00:30:13,080 --> 00:30:15,529
mean you're not gonna have to do a split

1598
00:30:15,529 --> 00:30:15,539

1599
00:30:15,539 --> 00:30:17,360
or a merge right and this sort of makes

1600
00:30:17,360 --> 00:30:17,370
 

1601
00:30:17,370 --> 00:30:19,070
sense right by my simple example I'm not

1602
00:30:19,070 --> 00:30:19,080
 

1603
00:30:19,080 --> 00:30:21,529
showing nodes with two keys but as we

1604
00:30:21,529 --> 00:30:21,539
 

1605
00:30:21,539 --> 00:30:23,840
said before in a real P plus tree your

1606
00:30:23,840 --> 00:30:23,850
 

1607
00:30:23,850 --> 00:30:25,610
your node size is going to be at least

1608
00:30:25,610 --> 00:30:25,620
 

1609
00:30:25,620 --> 00:30:27,289
your page size or larger so like four

1610
00:30:27,289 --> 00:30:27,299
 

1611
00:30:27,299 --> 00:30:29,480
kilobytes or even or potentially larger

1612
00:30:29,480 --> 00:30:29,490
 

1613
00:30:29,490 --> 00:30:31,220
than that at least in a disk coordinate

1614
00:30:31,220 --> 00:30:31,230
 

1615
00:30:31,230 --> 00:30:33,529
system so the likelihood that you're

1616
00:30:33,529 --> 00:30:33,539
 

1617
00:30:33,539 --> 00:30:35,299
gonna have to do a split or merge for

1618
00:30:35,299 --> 00:30:35,309
 

1619
00:30:35,309 --> 00:30:38,360
every single insert or delete is it's

1620
00:30:38,360 --> 00:30:38,370
 

1621
00:30:38,370 --> 00:30:41,419
pretty low so instead we're gonna assume

1622
00:30:41,419 --> 00:30:41,429
 

1623
00:30:41,429 --> 00:30:43,880
that we're not gonna have to do a split

1624
00:30:43,880 --> 00:30:43,890
 

1625
00:30:43,890 --> 00:30:46,250
or merge and therefore we're gonna take

1626
00:30:46,250 --> 00:30:46,260
 

1627
00:30:46,260 --> 00:30:48,409
real latches all the way down and and

1628
00:30:48,409 --> 00:30:48,419
 

1629
00:30:48,419 --> 00:30:50,000
then right before we get to the leaf

1630
00:30:50,000 --> 00:30:50,010
 

1631
00:30:50,010 --> 00:30:51,860
node then we take out we take the right

1632
00:30:51,860 --> 00:30:51,870
 

1633
00:30:51,870 --> 00:30:53,810
latch on that leaf node and then if we

1634
00:30:53,810 --> 00:30:53,820

1635
00:30:53,820 --> 00:30:55,669
find out that we are gonna have to split

1636
00:30:55,669 --> 00:30:55,679
 

1637
00:30:55,679 --> 00:30:58,909
or merge then we just we abort our

1638
00:30:58,909 --> 00:30:58,919
 

1639
00:30:58,919 --> 00:31:01,310
operation go back and retry it then take

1640
00:31:01,310 --> 00:31:01,320
 

1641
00:31:01,320 --> 00:31:03,830
the right latches as the normal protocol

1642
00:31:03,830 --> 00:31:03,840
 

1643
00:31:03,840 --> 00:31:06,169
is by the idea here is that you're in

1644
00:31:06,169 --> 00:31:06,179
 

1645
00:31:06,179 --> 00:31:07,340
again you're assuming your splits are

1646
00:31:07,340 --> 00:31:07,350
 

1647
00:31:07,350 --> 00:31:09,200
plus a rare your merges are rare so

1648
00:31:09,200 --> 00:31:09,210

1649
00:31:09,210 --> 00:31:10,909
don't take right latches give that limbs

1650
00:31:10,909 --> 00:31:10,919
 

1651
00:31:10,919 --> 00:31:12,950
concurrency and if your

1652
00:31:12,950 --> 00:31:12,960
 

1653
00:31:12,960 --> 00:31:16,760
you just go back and restart it right so

1654
00:31:16,760 --> 00:31:16,770
 

1655
00:31:16,770 --> 00:31:17,840
let's see how this works so we go back

1656
00:31:17,840 --> 00:31:17,850
 

1657
00:31:17,850 --> 00:31:20,269
and do a delete of 38 damn we start here

1658
00:31:20,269 --> 00:31:20,279
 

1659
00:31:20,279 --> 00:31:21,980
at the root again instead of requiring

1660
00:31:21,980 --> 00:31:21,990
 

1661
00:31:21,990 --> 00:31:24,049
the read latch so you said of acquiring

1662
00:31:24,049 --> 00:31:24,059
 

1663
00:31:24,059 --> 00:31:26,480
the latch in right mode will card in

1664
00:31:26,480 --> 00:31:26,490
 

1665
00:31:26,490 --> 00:31:29,240
read mode and then we just go down and

1666
00:31:29,240 --> 00:31:29,250
 

1667
00:31:29,250 --> 00:31:30,769
do our standard crabbing and coupling

1668
00:31:30,769 --> 00:31:30,779
 

1669
00:31:30,779 --> 00:31:32,960
all the way down and then here when we

1670
00:31:32,960 --> 00:31:32,970

1671
00:31:32,970 --> 00:31:36,710
get down to D we take the right latch on

1672
00:31:36,710 --> 00:31:36,720
 

1673
00:31:36,720 --> 00:31:40,100
H jump down here we recognize that we're

1674
00:31:40,100 --> 00:31:40,110
 

1675
00:31:40,110 --> 00:31:41,570
safe we can do our delete without ever

1676
00:31:41,570 --> 00:31:41,580
 

1677
00:31:41,580 --> 00:31:45,019
have to split we release the latch on D

1678
00:31:45,019 --> 00:31:45,029
 

1679
00:31:45,029 --> 00:31:47,480
the read latch go ahead it and then do

1680
00:31:47,480 --> 00:31:47,490
 

1681
00:31:47,490 --> 00:31:53,960
our delete right it's pretty obvious all

1682
00:31:53,960 --> 00:31:53,970
 

1683
00:31:53,970 --> 00:31:56,000
right so let's see now that insert on 25

1684
00:31:56,000 --> 00:31:56,010
 

1685
00:31:56,010 --> 00:31:58,880
so I start again the read latch on a

1686
00:31:58,880 --> 00:31:58,890
 

1687
00:31:58,890 --> 00:32:01,460
real Achin b traverse down release that

1688
00:32:01,460 --> 00:32:01,470
 

1689
00:32:01,470 --> 00:32:03,620
go to C Traverse down the lease on B

1690
00:32:03,620 --> 00:32:03,630
 

1691
00:32:03,630 --> 00:32:07,340
then I get down to 2f I recognize here

1692
00:32:07,340 --> 00:32:07,350
 

1693
00:32:07,350 --> 00:32:09,799
that I'm gonna now have to do a split so

1694
00:32:09,799 --> 00:32:09,809
 

1695
00:32:09,809 --> 00:32:13,399
therefore I I needed that right latch on

1696
00:32:13,399 --> 00:32:13,409
 

1697
00:32:13,409 --> 00:32:16,430
C but I didn't get that as I went down

1698
00:32:16,430 --> 00:32:16,440
 

1699
00:32:16,440 --> 00:32:17,600
because I was assuming I wasn't gonna

1700
00:32:17,600 --> 00:32:17,610
 

1701
00:32:17,610 --> 00:32:19,789
have to split so in this case here I'd

1702
00:32:19,789 --> 00:32:19,799

1703
00:32:19,799 --> 00:32:21,799
recognize that my leaf node is not safe

1704
00:32:21,799 --> 00:32:21,809
 

1705
00:32:21,809 --> 00:32:24,289
so therefore I restart everything and

1706
00:32:24,289 --> 00:32:24,299
 

1707
00:32:24,299 --> 00:32:30,230
take right latches all the way down so

1708
00:32:30,230 --> 00:32:30,240

1709
00:32:30,240 --> 00:32:32,240
again this is an optimistic algorithm

1710
00:32:32,240 --> 00:32:32,250
 

1711
00:32:32,250 --> 00:32:34,190
the surgery the surgeons are just the

1712
00:32:34,190 --> 00:32:34,200
 

1713
00:32:34,200 --> 00:32:36,440
same you take just do reach read read

1714
00:32:36,440 --> 00:32:36,450
 

1715
00:32:36,450 --> 00:32:37,880
latch coupling re-latch crowding on the

1716
00:32:37,880 --> 00:32:37,890
 

1717
00:32:37,890 --> 00:32:39,830
way down and then again for inserts and

1718
00:32:39,830 --> 00:32:39,840
 

1719
00:32:39,840 --> 00:32:42,710
deletes you set latches as as all the

1720
00:32:42,710 --> 00:32:42,720
 

1721
00:32:42,720 --> 00:32:44,419
way down as if you were searching with

1722
00:32:44,419 --> 00:32:44,429

1723
00:32:44,429 --> 00:32:46,490
you know in read mode and then you get

1724
00:32:46,490 --> 00:32:46,500
 

1725
00:32:46,500 --> 00:32:48,139
the right latch on the mote on the leaf

1726
00:32:48,139 --> 00:32:48,149
 

1727
00:32:48,149 --> 00:32:50,389
node you want if it's not safe you

1728
00:32:50,389 --> 00:32:50,399
 

1729
00:32:50,399 --> 00:32:52,250
restart and get right latches that way

1730
00:32:52,250 --> 00:32:52,260
 

1731
00:32:52,260 --> 00:32:53,510
you get the you get the right latches

1732
00:32:53,510 --> 00:32:53,520
 

1733
00:32:53,520 --> 00:32:56,539
that you need and in the tower hierarchy

1734
00:32:56,539 --> 00:32:56,549
 

1735
00:32:56,549 --> 00:32:57,710
with the tree going down to your leaf

1736
00:32:57,710 --> 00:32:57,720
 

1737
00:32:57,720 --> 00:33:02,779
node otherwise you just do it so again

1738
00:33:02,779 --> 00:33:02,789
 

1739
00:33:02,789 --> 00:33:04,460
this is an optimistic algorithm because

1740
00:33:04,460 --> 00:33:04,470

1741
00:33:04,470 --> 00:33:09,260
it's assuming that the be the likelihood

1742
00:33:09,260 --> 00:33:09,270
 

1743
00:33:09,270 --> 00:33:10,610
that you're gonna do a split or merge is

1744
00:33:10,610 --> 00:33:10,620
 

1745
00:33:10,620 --> 00:33:13,159
rare and therefore you're you you end up

1746
00:33:13,159 --> 00:33:13,169
 

1747
00:33:13,169 --> 00:33:17,060
saving they're saving work and improve

1748
00:33:17,060 --> 00:33:17,070
 

1749
00:33:17,070 --> 00:33:18,440
your parallelism because you make this

1750
00:33:18,440 --> 00:33:18,450
 

1751
00:33:18,450 --> 00:33:20,570
assumption but obviously if you're wrong

1752
00:33:20,570 --> 00:33:20,580
 

1753
00:33:20,580 --> 00:33:23,090
then you're actually getting being worse

1754
00:33:23,090 --> 00:33:23,100
 

1755
00:33:23,100 --> 00:33:24,289
off and you would have been if you

1756
00:33:24,289 --> 00:33:24,299
 

1757
00:33:24,299 --> 00:33:26,150
didn't actually take this optimization

1758
00:33:26,150 --> 00:33:26,160
 

1759
00:33:26,160 --> 00:33:28,040
because now you're actually doing sort

1760
00:33:28,040 --> 00:33:28,050
 

1761
00:33:28,050 --> 00:33:30,230
of almost double the work so I do my

1762
00:33:30,230 --> 00:33:30,240
 

1763
00:33:30,240 --> 00:33:31,580
traversal with real ashes get to the

1764
00:33:31,580 --> 00:33:31,590
 

1765
00:33:31,590 --> 00:33:33,140
bottom recognize that my leaf node is

1766
00:33:33,140 --> 00:33:33,150

1767
00:33:33,150 --> 00:33:35,210
not safe now I have to abort and come

1768
00:33:35,210 --> 00:33:35,220
 

1769
00:33:35,220 --> 00:33:36,800
back and do it all over again so that

1770
00:33:36,800 --> 00:33:36,810
 

1771
00:33:36,810 --> 00:33:38,420
work I did to figure out that I wasn't

1772
00:33:38,420 --> 00:33:38,430
 

1773
00:33:38,430 --> 00:33:42,080
safe is wasted and so there are some

1774
00:33:42,080 --> 00:33:42,090
 

1775
00:33:42,090 --> 00:33:43,700
optimizations you can do to provide

1776
00:33:43,700 --> 00:33:43,710
 

1777
00:33:43,710 --> 00:33:47,210
hints about what's below you in in the

1778
00:33:47,210 --> 00:33:47,220
 

1779
00:33:47,220 --> 00:33:50,750
in the in the tree you know they don't

1780
00:33:50,750 --> 00:33:50,760
 

1781
00:33:50,760 --> 00:33:51,800
have to be entirely accurate all the

1782
00:33:51,800 --> 00:33:51,810
 

1783
00:33:51,810 --> 00:33:54,980
time but you know the worst you that the

1784
00:33:54,980 --> 00:33:54,990
 

1785
00:33:54,990 --> 00:33:57,620
less accurate is the wrong ger the more

1786
00:33:57,620 --> 00:33:57,630
 

1787
00:33:57,630 --> 00:34:00,110
the more incorrect your your assumptions

1788
00:34:00,110 --> 00:34:00,120

1789
00:34:00,120 --> 00:34:02,090
or approximations are going to be and

1790
00:34:02,090 --> 00:34:02,100
 

1791
00:34:02,100 --> 00:34:03,110
your Android actually doing much worse

1792
00:34:03,110 --> 00:34:03,120
 

1793
00:34:03,120 --> 00:34:04,820
but you're wasting your wasting cycles

1794
00:34:04,820 --> 00:34:04,830
 

1795
00:34:04,830 --> 00:34:06,740
or wasting instructions doing work that

1796
00:34:06,740 --> 00:34:06,750
 

1797
00:34:06,750 --> 00:34:11,889
get the ends up getting thrown away yes

1798
00:34:11,889 --> 00:34:11,899


1799
00:34:11,899 --> 00:34:13,970
this question is do you always need to

1800
00:34:13,970 --> 00:34:13,980
 

1801
00:34:13,980 --> 00:34:20,889
start at the root node so yeah there are

1802
00:34:20,889 --> 00:34:20,899
 

1803
00:34:20,899 --> 00:34:24,379
there are some optimizations where you

1804
00:34:24,379 --> 00:34:24,389
 

1805
00:34:24,389 --> 00:34:26,149
can have like a hash table on the side

1806
00:34:26,149 --> 00:34:26,159

1807
00:34:26,159 --> 00:34:28,430
to say hey if you really want this key

1808
00:34:28,430 --> 00:34:28,440
 

1809
00:34:28,440 --> 00:34:34,460
here's the node to jump to in general

1810
00:34:34,460 --> 00:34:34,470
 

1811
00:34:34,470 --> 00:34:39,110
yes mates you don't have to the that's

1812
00:34:39,110 --> 00:34:39,120

1813
00:34:39,120 --> 00:34:40,280
like an extent that's like at an

1814
00:34:40,280 --> 00:34:40,290
 

1815
00:34:40,290 --> 00:34:41,810
advanced optimization that like people

1816
00:34:41,810 --> 00:34:41,820

1817
00:34:41,820 --> 00:34:43,490
have tried there's a literature from

1818
00:34:43,490 --> 00:34:43,500
 

1819
00:34:43,500 --> 00:34:46,970
like early 1980s that discuss this of

1820
00:34:46,970 --> 00:34:46,980
 

1821
00:34:46,980 --> 00:34:48,230
course now yeah this is what I was

1822
00:34:48,230 --> 00:34:48,240
 

1823
00:34:48,240 --> 00:34:51,320
trying to say also - is like you either

1824
00:34:51,320 --> 00:34:51,330
 

1825
00:34:51,330 --> 00:34:52,850
have to make that hash table that jump

1826
00:34:52,850 --> 00:34:52,860
 

1827
00:34:52,860 --> 00:34:54,919
allows to jump to a node always be in

1828
00:34:54,919 --> 00:34:54,929
 

1829
00:34:54,929 --> 00:34:58,220
sync or you can start update it lazily

1830
00:34:58,220 --> 00:34:58,230
 

1831
00:34:58,230 --> 00:35:00,830
but now you may end up guessing wrong

1832
00:35:00,830 --> 00:35:00,840
 

1833
00:35:00,840 --> 00:35:03,230
based on it and have to restart and

1834
00:35:03,230 --> 00:35:03,240
 

1835
00:35:03,240 --> 00:35:05,030
retry always going through the root

1836
00:35:05,030 --> 00:35:05,040
 

1837
00:35:05,040 --> 00:35:07,610
right so there's sort of this trade-off

1838
00:35:07,610 --> 00:35:07,620
 

1839
00:35:07,620 --> 00:35:09,530
between like alright I most the time is

1840
00:35:09,530 --> 00:35:09,540
 

1841
00:35:09,540 --> 00:35:11,390
gonna be right and when I'm wrong it's

1842
00:35:11,390 --> 00:35:11,400
 

1843
00:35:11,400 --> 00:35:13,100
not a big deal for me to go ahead and

1844
00:35:13,100 --> 00:35:13,110
 

1845
00:35:13,110 --> 00:35:19,980
just undo what I did

1846
00:35:19,980 --> 00:35:19,990


1847
00:35:19,990 --> 00:35:23,200
so he's quite a statement is in this

1848
00:35:23,200 --> 00:35:23,210
 

1849
00:35:23,210 --> 00:35:26,020
example here I can like in this case

1850
00:35:26,020 --> 00:35:26,030
 

1851
00:35:26,030 --> 00:35:28,630
here I I went when I went down I could

1852
00:35:28,630 --> 00:35:28,640
 

1853
00:35:28,640 --> 00:35:30,370
cheap track of the path I went to and

1854
00:35:30,370 --> 00:35:30,380

1855
00:35:30,380 --> 00:35:33,400
then maybe when are we starting from the

1856
00:35:33,400 --> 00:35:33,410
 

1857
00:35:33,410 --> 00:35:37,089
route jump to another location but again

1858
00:35:37,089 --> 00:35:37,099
 

1859
00:35:37,099 --> 00:35:39,849
like I need to protect that right

1860
00:35:39,849 --> 00:35:39,859
 

1861
00:35:39,859 --> 00:35:41,410
because by the time I come back and

1862
00:35:41,410 --> 00:35:41,420
 

1863
00:35:41,420 --> 00:35:43,240
restart another thread could have like

1864
00:35:43,240 --> 00:35:43,250
 

1865
00:35:43,250 --> 00:35:45,040
trashed this C or delete a bunch of

1866
00:35:45,040 --> 00:35:45,050
 

1867
00:35:45,050 --> 00:35:47,170
stuff and now I'm jumping to a bad

1868
00:35:47,170 --> 00:35:47,180
 

1869
00:35:47,180 --> 00:35:51,910
location and regarded so again this is

1870
00:35:51,910 --> 00:35:51,920
 

1871
00:35:51,920 --> 00:35:54,099
like I always say that bad approximation

1872
00:35:54,099 --> 00:35:54,109
 

1873
00:35:54,109 --> 00:36:01,120
is is a bad one we do this in our BW

1874
00:36:01,120 --> 00:36:01,130
 

1875
00:36:01,130 --> 00:36:02,680
tree which I don't talk about here that

1876
00:36:02,680 --> 00:36:02,690
 

1877
00:36:02,690 --> 00:36:06,069
we implemented where we if you want to

1878
00:36:06,069 --> 00:36:06,079
 

1879
00:36:06,079 --> 00:36:07,390
do range scans in reverse direction

1880
00:36:07,390 --> 00:36:07,400

1881
00:36:07,400 --> 00:36:09,040
because it only has sibling pointers in

1882
00:36:09,040 --> 00:36:09,050
 

1883
00:36:09,050 --> 00:36:11,109
one direction you could keep the stack

1884
00:36:11,109 --> 00:36:11,119
 

1885
00:36:11,119 --> 00:36:12,790
of how you got down there how you got to

1886
00:36:12,790 --> 00:36:12,800
 

1887
00:36:12,800 --> 00:36:14,920
it the reason why we do is in the beat

1888
00:36:14,920 --> 00:36:14,930
 

1889
00:36:14,930 --> 00:36:16,180
of a tree and it's hard to do it in this

1890
00:36:16,180 --> 00:36:16,190
 

1891
00:36:16,190 --> 00:36:17,920
is like to be in retreat there's a

1892
00:36:17,920 --> 00:36:17,930
 

1893
00:36:17,930 --> 00:36:19,420
separate mapping table says if you want

1894
00:36:19,420 --> 00:36:19,430
 

1895
00:36:19,430 --> 00:36:21,490
this note ID here's the memory address

1896
00:36:21,490 --> 00:36:21,500
 

1897
00:36:21,500 --> 00:36:24,849
in this they're like page IDs and then

1898
00:36:24,849 --> 00:36:24,859
 

1899
00:36:24,859 --> 00:36:26,500
the page ID mint might not be there

1900
00:36:26,500 --> 00:36:26,510
 

1901
00:36:26,510 --> 00:36:26,980
anymore

1902
00:36:26,980 --> 00:36:26,990

1903
00:36:26,990 --> 00:36:30,849
right because I might've got swapped out

1904
00:36:30,849 --> 00:36:30,859
 

1905
00:36:30,859 --> 00:36:41,380
the disk okay cool alright so the one

1906
00:36:41,380 --> 00:36:41,390
 

1907
00:36:41,390 --> 00:36:42,849
observation I want to make now is that

1908
00:36:42,849 --> 00:36:42,859
 

1909
00:36:42,859 --> 00:36:45,450
in all the examples I've shown so far

1910
00:36:45,450 --> 00:36:45,460
 

1911
00:36:45,460 --> 00:36:48,720
we've had our threads acquire latches in

1912
00:36:48,720 --> 00:36:48,730
 

1913
00:36:48,730 --> 00:36:52,359
what I call a top-down manner meaning we

1914
00:36:52,359 --> 00:36:52,369
 

1915
00:36:52,369 --> 00:36:54,760
start the root we get we get to left on

1916
00:36:54,760 --> 00:36:54,770
 

1917
00:36:54,770 --> 00:36:56,800
that root and then we the next latch

1918
00:36:56,800 --> 00:36:56,810
 

1919
00:36:56,810 --> 00:36:58,150
what you want to get always has to be

1920
00:36:58,150 --> 00:36:58,160
 

1921
00:36:58,160 --> 00:36:59,680
something that's below us that the node

1922
00:36:59,680 --> 00:36:59,690
 

1923
00:36:59,690 --> 00:37:02,680
that's below us we never go in the

1924
00:37:02,680 --> 00:37:02,690
 

1925
00:37:02,690 --> 00:37:05,980
opposite direction in our tree remember

1926
00:37:05,980 --> 00:37:05,990
 

1927
00:37:05,990 --> 00:37:08,349
I said earlier that although there's no

1928
00:37:08,349 --> 00:37:08,359
 

1929
00:37:08,359 --> 00:37:10,420
reason you couldn't have pointers from

1930
00:37:10,420 --> 00:37:10,430
 

1931
00:37:10,430 --> 00:37:12,700
the from a child to a parent almost

1932
00:37:12,700 --> 00:37:12,710
 

1933
00:37:12,710 --> 00:37:13,960
nobody actually implements it that way

1934
00:37:13,960 --> 00:37:13,970
 

1935
00:37:13,970 --> 00:37:15,760
so no one no one's gonna be going in

1936
00:37:15,760 --> 00:37:15,770
 

1937
00:37:15,770 --> 00:37:16,720
reverse direction everyone's always

1938
00:37:16,720 --> 00:37:16,730
 

1939
00:37:16,730 --> 00:37:21,010
going to the top down so the benefit of

1940
00:37:21,010 --> 00:37:21,020
 

1941
00:37:21,020 --> 00:37:23,740
this and it's sort of obvious but is

1942
00:37:23,740 --> 00:37:23,750
 

1943
00:37:23,750 --> 00:37:25,770
that you can never have deadlocks

1944
00:37:25,770 --> 00:37:25,780
 

1945
00:37:25,780 --> 00:37:28,839
because the the order in which threads

1946
00:37:28,839 --> 00:37:28,849
 

1947
00:37:28,849 --> 00:37:31,839
try to acquire latches are always in the

1948
00:37:31,839 --> 00:37:31,849

1949
00:37:31,849 --> 00:37:32,349
same direction

1950
00:37:32,349 --> 00:37:32,359
 

1951
00:37:32,359 --> 00:37:34,359
like I can't get my latch on this this

1952
00:37:34,359 --> 00:37:34,369
 

1953
00:37:34,369 --> 00:37:36,130
child know that I want unless I had to

1954
00:37:36,130 --> 00:37:36,140
 

1955
00:37:36,140 --> 00:37:37,749
latch on the parent so nobody else is

1956
00:37:37,749 --> 00:37:37,759
 

1957
00:37:37,759 --> 00:37:38,920
coming in the other direction trying to

1958
00:37:38,920 --> 00:37:38,930
 

1959
00:37:38,930 --> 00:37:41,759
get the latch on the node that I have so

1960
00:37:41,759 --> 00:37:41,769
 

1961
00:37:41,769 --> 00:37:44,680
this so in this case here as as we're

1962
00:37:44,680 --> 00:37:44,690
 

1963
00:37:44,690 --> 00:37:48,370
going down if we try to get a latch and

1964
00:37:48,370 --> 00:37:48,380
 

1965
00:37:48,380 --> 00:37:50,970
we can't on a node then we can just wait

1966
00:37:50,970 --> 00:37:50,980
 

1967
00:37:50,980 --> 00:37:52,809
because we know there could ever be a

1968
00:37:52,809 --> 00:37:52,819
 

1969
00:37:52,819 --> 00:37:55,089
deadlock and at some point whatever the

1970
00:37:55,089 --> 00:37:55,099
 

1971
00:37:55,099 --> 00:37:56,680
threat is is that how was the latch is

1972
00:37:56,680 --> 00:37:56,690
 

1973
00:37:56,690 --> 00:37:57,999
doing something they'll be able to

1974
00:37:57,999 --> 00:37:58,009
 

1975
00:37:58,009 --> 00:37:59,769
release it and then we can go ahead and

1976
00:37:59,769 --> 00:37:59,779
 

1977
00:37:59,779 --> 00:38:02,499
acquire it all right so again if you're

1978
00:38:02,499 --> 00:38:02,509
 

1979
00:38:02,509 --> 00:38:04,059
implementing implementing this as a spin

1980
00:38:04,059 --> 00:38:04,069

1981
00:38:04,069 --> 00:38:06,970
lock we just sort of spin on on the the

1982
00:38:06,970 --> 00:38:06,980
 

1983
00:38:06,980 --> 00:38:09,130
variable that maintains the latch and at

1984
00:38:09,130 --> 00:38:09,140
 

1985
00:38:09,140 --> 00:38:11,170
some point it'll change then we can we

1986
00:38:11,170 --> 00:38:11,180

1987
00:38:11,180 --> 00:38:13,960
can we can acquire it and in the week we

1988
00:38:13,960 --> 00:38:13,970
 

1989
00:38:13,970 --> 00:38:15,640
can continue with whatever operation we

1990
00:38:15,640 --> 00:38:15,650
 

1991
00:38:15,650 --> 00:38:17,499
wanted to do and does it make sense

1992
00:38:17,499 --> 00:38:17,509
 

1993
00:38:17,509 --> 00:38:20,039
I'll save you think about it like if I

1994
00:38:20,039 --> 00:38:20,049
 

1995
00:38:20,049 --> 00:38:22,599
traverse the tree and I can't get the

1996
00:38:22,599 --> 00:38:22,609
 

1997
00:38:22,609 --> 00:38:24,720
latch on the node that I want to go to

1998
00:38:24,720 --> 00:38:24,730
 

1999
00:38:24,730 --> 00:38:28,329
if I abort and restart then the

2000
00:38:28,329 --> 00:38:28,339
 

2001
00:38:28,339 --> 00:38:30,039
likelihood I'm just gonna come back to

2002
00:38:30,039 --> 00:38:30,049
 

2003
00:38:30,049 --> 00:38:32,079
the very beginning the root and come

2004
00:38:32,079 --> 00:38:32,089
 

2005
00:38:32,089 --> 00:38:33,549
down to the exact same location again

2006
00:38:33,549 --> 00:38:33,559
 

2007
00:38:33,559 --> 00:38:36,039
and just get stymied or blocked on the

2008
00:38:36,039 --> 00:38:36,049
 

2009
00:38:36,049 --> 00:38:38,109
latch I couldn't get before so you just

2010
00:38:38,109 --> 00:38:38,119
 

2011
00:38:38,119 --> 00:38:41,499
sort of spin and wait but as we people

2012
00:38:41,499 --> 00:38:41,509
 

2013
00:38:41,509 --> 00:38:43,420
are asking earlier I think I was last

2014
00:38:43,420 --> 00:38:43,430
 

2015
00:38:43,430 --> 00:38:47,499
week about these sibling pointers but

2016
00:38:47,499 --> 00:38:47,509
 

2017
00:38:47,509 --> 00:38:48,489
how are we actually handle the case

2018
00:38:48,489 --> 00:38:48,499
 

2019
00:38:48,499 --> 00:38:50,680
where we had threads down now down the

2020
00:38:50,680 --> 00:38:50,690
 

2021
00:38:50,690 --> 00:38:52,690
leaf nodes and they want to go left and

2022
00:38:52,690 --> 00:38:52,700
 

2023
00:38:52,700 --> 00:38:54,039
right because we have these sibling

2024
00:38:54,039 --> 00:38:54,049
 

2025
00:38:54,049 --> 00:38:56,890
pointers so let's look an example here

2026
00:38:56,890 --> 00:38:56,900
 

2027
00:38:56,900 --> 00:38:59,950
so we have a really simple B plus tree

2028
00:38:59,950 --> 00:38:59,960
 

2029
00:38:59,960 --> 00:39:01,989
we have this the keys 1 through 4 and

2030
00:39:01,989 --> 00:39:01,999
 

2031
00:39:01,999 --> 00:39:04,660
our thread here wants to find all the

2032
00:39:04,660 --> 00:39:04,670

2033
00:39:04,670 --> 00:39:07,989
keys that are less than 4 so we just do

2034
00:39:07,989 --> 00:39:07,999
 

2035
00:39:07,999 --> 00:39:10,359
the standard optimistic latch crabbing

2036
00:39:10,359 --> 00:39:10,369
 

2037
00:39:10,369 --> 00:39:12,579
technique we talked just talked about we

2038
00:39:12,579 --> 00:39:12,589
 

2039
00:39:12,589 --> 00:39:15,279
cry the reed latch on a then we jump

2040
00:39:15,279 --> 00:39:15,289
 

2041
00:39:15,289 --> 00:39:17,349
down get the real ash on C and then we

2042
00:39:17,349 --> 00:39:17,359
 

2043
00:39:17,359 --> 00:39:19,749
can our thread moves down the C so now

2044
00:39:19,749 --> 00:39:19,759
 

2045
00:39:19,759 --> 00:39:21,400
as we're scanning along we would we

2046
00:39:21,400 --> 00:39:21,410
 

2047
00:39:21,410 --> 00:39:23,440
would recognize that we still need to

2048
00:39:23,440 --> 00:39:23,450
 

2049
00:39:23,450 --> 00:39:25,720
read data on on this list leaf node over

2050
00:39:25,720 --> 00:39:25,730
 

2051
00:39:25,730 --> 00:39:27,339
here because we want to find everything

2052
00:39:27,339 --> 00:39:27,349
 

2053
00:39:27,349 --> 00:39:29,950
less than 4 so it's basically from 4 to

2054
00:39:29,950 --> 00:39:29,960
 

2055
00:39:29,960 --> 00:39:31,329
negative infinity so we want to go all

2056
00:39:31,329 --> 00:39:31,339
 

2057
00:39:31,339 --> 00:39:33,849
the way to the end of the tree I'm not

2058
00:39:33,849 --> 00:39:33,859
 

2059
00:39:33,859 --> 00:39:35,019
really talked about this here but

2060
00:39:35,019 --> 00:39:35,029
 

2061
00:39:35,029 --> 00:39:36,700
there's things called like fence keys or

2062
00:39:36,700 --> 00:39:36,710
 

2063
00:39:36,710 --> 00:39:38,289
or sibling keys where you can sort of

2064
00:39:38,289 --> 00:39:38,299
 

2065
00:39:38,299 --> 00:39:41,950
maintain a hint to say oh by the way if

2066
00:39:41,950 --> 00:39:41,960
 

2067
00:39:41,960 --> 00:39:43,960
you're jumping this direction this key

2068
00:39:43,960 --> 00:39:43,970
 

2069
00:39:43,970 --> 00:39:45,910
starts at 2 right there's some

2070
00:39:45,910 --> 00:39:45,920
 

2071
00:39:45,920 --> 00:39:47,530
needs to do like that but we can ignore

2072
00:39:47,530 --> 00:39:47,540
 

2073
00:39:47,540 --> 00:39:50,859
that for now okay so if I want to go now

2074
00:39:50,859 --> 00:39:50,869
 

2075
00:39:50,869 --> 00:39:53,289
and Traverse along my sibling to get to

2076
00:39:53,289 --> 00:39:53,299
 

2077
00:39:53,299 --> 00:39:56,140
B I have to do the same lat coupling or

2078
00:39:56,140 --> 00:39:56,150
 

2079
00:39:56,150 --> 00:39:57,670
carving technique that I did before I

2080
00:39:57,670 --> 00:39:57,680
 

2081
00:39:57,680 --> 00:40:02,470
can't acquire the latch on on B unless I

2082
00:40:02,470 --> 00:40:02,480
 

2083
00:40:02,480 --> 00:40:04,900
hold the latch on C so since I hold the

2084
00:40:04,900 --> 00:40:04,910
 

2085
00:40:04,910 --> 00:40:06,549
latch on see I'm up it's allowed to go

2086
00:40:06,549 --> 00:40:06,559
 

2087
00:40:06,559 --> 00:40:08,410
ahead and get the latch on B and then it

2088
00:40:08,410 --> 00:40:08,420
 

2089
00:40:08,420 --> 00:40:11,109
moves over to to this node and it's safe

2090
00:40:11,109 --> 00:40:11,119
 

2091
00:40:11,119 --> 00:40:14,740
for it to release C right the same

2092
00:40:14,740 --> 00:40:14,750
 

2093
00:40:14,750 --> 00:40:16,120
technique that we did before we're just

2094
00:40:16,120 --> 00:40:16,130
 

2095
00:40:16,130 --> 00:40:19,809
moving along horizontally so let's look

2096
00:40:19,809 --> 00:40:19,819
 

2097
00:40:19,819 --> 00:40:20,829
at more complicated example it's the

2098
00:40:20,829 --> 00:40:20,839
 

2099
00:40:20,839 --> 00:40:22,839
brig another thread in right yeah these

2100
00:40:22,839 --> 00:40:22,849
 

2101
00:40:22,849 --> 00:40:25,180
are both read-only so t1 was to find

2102
00:40:25,180 --> 00:40:25,190
 

2103
00:40:25,190 --> 00:40:27,220
keys less than for t2 wants to find keys

2104
00:40:27,220 --> 00:40:27,230
 

2105
00:40:27,230 --> 00:40:30,819
less than greater than 1 so the same

2106
00:40:30,819 --> 00:40:30,829
 

2107
00:40:30,829 --> 00:40:32,500
thing they both start at the same time

2108
00:40:32,500 --> 00:40:32,510
 

2109
00:40:32,510 --> 00:40:35,710
we acquire the read latch on on on the

2110
00:40:35,710 --> 00:40:35,720
 

2111
00:40:35,720 --> 00:40:40,059
root node a thread 2 gets the real a on

2112
00:40:40,059 --> 00:40:40,069
 

2113
00:40:40,069 --> 00:40:42,730
B moves down thread thread one gets the

2114
00:40:42,730 --> 00:40:42,740

2115
00:40:42,740 --> 00:40:44,770
read latch on C moves down and then now

2116
00:40:44,770 --> 00:40:44,780
 

2117
00:40:44,780 --> 00:40:46,210
they won't again but they want to both

2118
00:40:46,210 --> 00:40:46,220

2119
00:40:46,220 --> 00:40:49,569
scan and in both directions and at this

2120
00:40:49,569 --> 00:40:49,579
 

2121
00:40:49,579 --> 00:40:51,880
point here and since the read latches

2122
00:40:51,880 --> 00:40:51,890
 

2123
00:40:51,890 --> 00:40:54,849
are compatible with each other the

2124
00:40:54,849 --> 00:40:54,859
 

2125
00:40:54,859 --> 00:40:56,799
thread one can get the real a on B and

2126
00:40:56,799 --> 00:40:56,809
 

2127
00:40:56,809 --> 00:40:58,450
thread two can get the read latch on C

2128
00:40:58,450 --> 00:40:58,460
 

2129
00:40:58,460 --> 00:41:00,549
and then cuz that latch can be held by

2130
00:41:00,549 --> 00:41:00,559
 

2131
00:41:00,559 --> 00:41:01,990
both threads at the same time in the

2132
00:41:01,990 --> 00:41:02,000
 

2133
00:41:02,000 --> 00:41:04,750
same mode and then they they swap over

2134
00:41:04,750 --> 00:41:04,760
 

2135
00:41:04,760 --> 00:41:09,160
to our scan and at this point now thread

2136
00:41:09,160 --> 00:41:09,170
 

2137
00:41:09,170 --> 00:41:11,680
1 will release the latch on on C and

2138
00:41:11,680 --> 00:41:11,690
 

2139
00:41:11,690 --> 00:41:14,440
thread two releases latch on B and we're

2140
00:41:14,440 --> 00:41:14,450
 

2141
00:41:14,450 --> 00:41:16,990
fine right this is read-only so it's

2142
00:41:16,990 --> 00:41:17,000
 

2143
00:41:17,000 --> 00:41:19,859
super simple there are no dead locks

2144
00:41:19,859 --> 00:41:19,869

2145
00:41:19,869 --> 00:41:24,270
so now let's throw in some updates so

2146
00:41:24,270 --> 00:41:24,280
 

2147
00:41:24,280 --> 00:41:28,120
thread one wants athlete for and thread

2148
00:41:28,120 --> 00:41:28,130
 

2149
00:41:28,130 --> 00:41:29,770
two once the find key is greater than

2150
00:41:29,770 --> 00:41:29,780
 

2151
00:41:29,780 --> 00:41:34,660
one so say we start off thread 1 sorry

2152
00:41:34,660 --> 00:41:34,670
 

2153
00:41:34,670 --> 00:41:37,120
thread 2 gets the read last one a and

2154
00:41:37,120 --> 00:41:37,130
 

2155
00:41:37,130 --> 00:41:38,319
say also till we're doing on the mystic

2156
00:41:38,319 --> 00:41:38,329
 

2157
00:41:38,329 --> 00:41:40,030
lock coupling so we're gonna get the

2158
00:41:40,030 --> 00:41:40,040

2159
00:41:40,040 --> 00:41:42,609
real a CH on on our parent and only get

2160
00:41:42,609 --> 00:41:42,619
 

2161
00:41:42,619 --> 00:41:44,680
the right latch on on the root on the

2162
00:41:44,680 --> 00:41:44,690

2163
00:41:44,690 --> 00:41:47,740
leaf node so thread thread two goes down

2164
00:41:47,740 --> 00:41:47,750
 

2165
00:41:47,750 --> 00:41:50,920
to be with the read latch thread one

2166
00:41:50,920 --> 00:41:50,930
 

2167
00:41:50,930 --> 00:41:53,020
goes down to C with the right latch at

2168
00:41:53,020 --> 00:41:53,030
 

2169
00:41:53,030 --> 00:41:54,760
this point we released a latch on a

2170
00:41:54,760 --> 00:41:54,770
 

2171
00:41:54,770 --> 00:41:57,520
because we're doing a lot coupling but

2172
00:41:57,520 --> 00:41:57,530
 

2173
00:41:57,530 --> 00:41:59,359
now thread two once

2174
00:41:59,359 --> 00:41:59,369
 

2175
00:41:59,369 --> 00:42:01,970
to scan across leaf nodes and get the

2176
00:42:01,970 --> 00:42:01,980
 

2177
00:42:01,980 --> 00:42:05,870
real a Chauncey but it can't because

2178
00:42:05,870 --> 00:42:05,880
 

2179
00:42:05,880 --> 00:42:09,019
thread thread one already holds this

2180
00:42:09,019 --> 00:42:09,029
 

2181
00:42:09,029 --> 00:42:13,670
latch in right mode all right so what

2182
00:42:13,670 --> 00:42:13,680
 

2183
00:42:13,680 --> 00:42:19,509
should happen here take a guess

2184
00:42:19,509 --> 00:42:19,519


2185
00:42:19,519 --> 00:42:23,059
should it wait she's shaking her head

2186
00:42:23,059 --> 00:42:23,069
 

2187
00:42:23,069 --> 00:42:24,049
yes raise your head up you think I

2188
00:42:24,049 --> 00:42:24,059
 

2189
00:42:24,059 --> 00:42:28,609
should wait hmmm about half bridge Hana

2190
00:42:28,609 --> 00:42:28,619
 

2191
00:42:28,619 --> 00:42:32,170
I think it should just kill herself

2192
00:42:32,170 --> 00:42:32,180


2193
00:42:32,180 --> 00:42:34,039
raise your hand if you're a thug and

2194
00:42:34,039 --> 00:42:34,049
 

2195
00:42:34,049 --> 00:42:36,109
pink thread too should kill thread one

2196
00:42:36,109 --> 00:42:36,119
 

2197
00:42:36,119 --> 00:42:38,630
and steel is latch which is actually a

2198
00:42:38,630 --> 00:42:38,640
 

2199
00:42:38,640 --> 00:42:40,099
real thing does not you know maybe not

2200
00:42:40,099 --> 00:42:40,109
 

2201
00:42:40,109 --> 00:42:43,609
for this all right so we don't at this

2202
00:42:43,609 --> 00:42:43,619
 

2203
00:42:43,619 --> 00:42:45,559
point thread two doesn't know anything

2204
00:42:45,559 --> 00:42:45,569
 

2205
00:42:45,569 --> 00:42:48,259
about what thread one is doing right

2206
00:42:48,259 --> 00:42:48,269
 

2207
00:42:48,269 --> 00:42:50,749
these latches are sort of the sort of

2208
00:42:50,749 --> 00:42:50,759
 

2209
00:42:50,759 --> 00:42:53,989
thing that looks like dumb blocks or

2210
00:42:53,989 --> 00:42:53,999
 

2211
00:42:53,999 --> 00:42:54,829
knees weren't interlock with are dumb

2212
00:42:54,829 --> 00:42:54,839
 

2213
00:42:54,839 --> 00:42:57,140
latches right it just knows it's in

2214
00:42:57,140 --> 00:42:57,150
 

2215
00:42:57,150 --> 00:42:59,120
right mode I can't get a read mode latch

2216
00:42:59,120 --> 00:42:59,130
 

2217
00:42:59,130 --> 00:43:00,319
because that's not come out with me so I

2218
00:43:00,319 --> 00:43:00,329
 

2219
00:43:00,329 --> 00:43:01,640
don't know I have no idea what it's

2220
00:43:01,640 --> 00:43:01,650
 

2221
00:43:01,650 --> 00:43:05,539
doing so what will happen here is rather

2222
00:43:05,539 --> 00:43:05,549
 

2223
00:43:05,549 --> 00:43:08,299
than wait around and see whether thread

2224
00:43:08,299 --> 00:43:08,309
 

2225
00:43:08,309 --> 00:43:12,049
one is gonna give up that latch I'm just

2226
00:43:12,049 --> 00:43:12,059
 

2227
00:43:12,059 --> 00:43:14,269
gonna go ahead and kill myself right and

2228
00:43:14,269 --> 00:43:14,279
 

2229
00:43:14,279 --> 00:43:16,549
abort my operation and this come back

2230
00:43:16,549 --> 00:43:16,559
 

2231
00:43:16,559 --> 00:43:19,190
and retry it right and the reason why we

2232
00:43:19,190 --> 00:43:19,200
 

2233
00:43:19,200 --> 00:43:20,420
want to do this is go otherwise we could

2234
00:43:20,420 --> 00:43:20,430
 

2235
00:43:20,430 --> 00:43:22,269
have a deadlock because like I said

2236
00:43:22,269 --> 00:43:22,279
 

2237
00:43:22,279 --> 00:43:24,710
threat to doesn't know that thread one

2238
00:43:24,710 --> 00:43:24,720
 

2239
00:43:24,720 --> 00:43:26,720
is either you're just gonna do its

2240
00:43:26,720 --> 00:43:26,730
 

2241
00:43:26,730 --> 00:43:28,249
update on see and then immediately give

2242
00:43:28,249 --> 00:43:28,259
 

2243
00:43:28,259 --> 00:43:30,200
up the latch or it's gonna scan across

2244
00:43:30,200 --> 00:43:30,210
 

2245
00:43:30,210 --> 00:43:32,029
and try to get the latch on B which it

2246
00:43:32,029 --> 00:43:32,039
 

2247
00:43:32,039 --> 00:43:33,739
holds and therefore you would have a

2248
00:43:33,739 --> 00:43:33,749
 

2249
00:43:33,749 --> 00:43:37,309
deadlock so to avoid all this but how to

2250
00:43:37,309 --> 00:43:37,319
 

2251
00:43:37,319 --> 00:43:39,049
do anything sophisticated we just say I

2252
00:43:39,049 --> 00:43:39,059
 

2253
00:43:39,059 --> 00:43:40,700
can't get the latch I want I'm dead

2254
00:43:40,700 --> 00:43:40,710

2255
00:43:40,710 --> 00:43:45,079
restart right and that makes the

2256
00:43:45,079 --> 00:43:45,089
 

2257
00:43:45,089 --> 00:43:47,420
protocol super simple it's not the most

2258
00:43:47,420 --> 00:43:47,430
 

2259
00:43:47,430 --> 00:43:49,940
efficient thing right because again we

2260
00:43:49,940 --> 00:43:49,950
 

2261
00:43:49,950 --> 00:43:51,319
can try to be sophisticated and say oh

2262
00:43:51,319 --> 00:43:51,329
 

2263
00:43:51,329 --> 00:43:53,210
well I know that it's just doing you

2264
00:43:53,210 --> 00:43:53,220
 

2265
00:43:53,220 --> 00:43:54,979
know a single delete it'll give it up in

2266
00:43:54,979 --> 00:43:54,989
 

2267
00:43:54,989 --> 00:43:56,749
a few microseconds so let's say for me

2268
00:43:56,749 --> 00:43:56,759
 

2269
00:43:56,759 --> 00:43:58,460
to do it I don't do any of that I'd say

2270
00:43:58,460 --> 00:43:58,470
 

2271
00:43:58,470 --> 00:43:59,210
I can't get it

2272
00:43:59,210 --> 00:43:59,220
 

2273
00:43:59,220 --> 00:44:04,190
I just abort and and retry this is how

2274
00:44:04,190 --> 00:44:04,200
 

2275
00:44:04,200 --> 00:44:05,450
so this is how we're gonna have yes the

2276
00:44:05,450 --> 00:44:05,460
 

2277
00:44:05,460 --> 00:44:12,420
bat

2278
00:44:12,420 --> 00:44:12,430


2279
00:44:12,430 --> 00:44:14,920
so his question is would it be more

2280
00:44:14,920 --> 00:44:14,930
 

2281
00:44:14,930 --> 00:44:17,530
efficient if the writing thread thread

2282
00:44:17,530 --> 00:44:17,540
 

2283
00:44:17,540 --> 00:44:23,350
one would kill thread would kill the

2284
00:44:23,350 --> 00:44:23,360
 

2285
00:44:23,360 --> 00:44:27,760
thread - if it sees it waiting for the

2286
00:44:27,760 --> 00:44:27,770
 

2287
00:44:27,770 --> 00:44:37,720
the latchet holds so he says the so

2288
00:44:37,720 --> 00:44:37,730
 

2289
00:44:37,730 --> 00:44:40,090
threat thread - could just spin here

2290
00:44:40,090 --> 00:44:40,100
 

2291
00:44:40,100 --> 00:44:41,710
keep you trying to car the latch and

2292
00:44:41,710 --> 00:44:41,720
 

2293
00:44:41,720 --> 00:44:44,620
then if thread one wants to go over to

2294
00:44:44,620 --> 00:44:44,630
 

2295
00:44:44,630 --> 00:44:46,330
the B and sees that thread two is

2296
00:44:46,330 --> 00:44:46,340
 

2297
00:44:46,340 --> 00:44:48,609
waiting for it it'll kill it otherwise

2298
00:44:48,609 --> 00:44:48,619
 

2299
00:44:48,619 --> 00:44:52,540
he just lets ahead and spin it um so the

2300
00:44:52,540 --> 00:44:52,550
 

2301
00:44:52,550 --> 00:44:54,070
first question is where are you gonna

2302
00:44:54,070 --> 00:44:54,080
 

2303
00:44:54,080 --> 00:44:57,670
maintain that thread one is thread two

2304
00:44:57,670 --> 00:44:57,680
 

2305
00:44:57,680 --> 00:45:03,160
is is spinning for the latch on C right

2306
00:45:03,160 --> 00:45:03,170
 

2307
00:45:03,170 --> 00:45:04,600
you have to maintain that somewhere like

2308
00:45:04,600 --> 00:45:04,610
 

2309
00:45:04,610 --> 00:45:07,510
some global data structure right or you

2310
00:45:07,510 --> 00:45:07,520
 

2311
00:45:07,520 --> 00:45:08,800
have to you have to have your thread and

2312
00:45:08,800 --> 00:45:08,810
 

2313
00:45:08,810 --> 00:45:10,480
look through every single location of

2314
00:45:10,480 --> 00:45:10,490
 

2315
00:45:10,490 --> 00:45:12,070
every every transaction or every thread

2316
00:45:12,070 --> 00:45:12,080
 

2317
00:45:12,080 --> 00:45:13,780
that could be running say hey are you

2318
00:45:13,780 --> 00:45:13,790
 

2319
00:45:13,790 --> 00:45:15,849
waiting for the thing that I have right

2320
00:45:15,849 --> 00:45:15,859
 

2321
00:45:15,859 --> 00:45:18,130
you can do it but it's a bunch of extra

2322
00:45:18,130 --> 00:45:18,140
 

2323
00:45:18,140 --> 00:45:19,960
work and it's not worth it and this

2324
00:45:19,960 --> 00:45:19,970
 

2325
00:45:19,970 --> 00:45:21,760
makes coding this thing way more way

2326
00:45:21,760 --> 00:45:21,770
 

2327
00:45:21,770 --> 00:45:24,340
harder all right so it's just better off

2328
00:45:24,340 --> 00:45:24,350
 

2329
00:45:24,350 --> 00:45:26,200
just to immediately kill yourself and

2330
00:45:26,200 --> 00:45:26,210
 

2331
00:45:26,210 --> 00:45:29,200
then just retry it we'll see something

2332
00:45:29,200 --> 00:45:29,210
 

2333
00:45:29,210 --> 00:45:30,970
like this when we talk about terms like

2334
00:45:30,970 --> 00:45:30,980
 

2335
00:45:30,980 --> 00:45:33,400
transaction blocks but in this case here

2336
00:45:33,400 --> 00:45:33,410
 

2337
00:45:33,410 --> 00:45:35,650
again we want these critical sections to

2338
00:45:35,650 --> 00:45:35,660
 

2339
00:45:35,660 --> 00:45:38,380
be as short as possible right so it's

2340
00:45:38,380 --> 00:45:38,390
 

2341
00:45:38,390 --> 00:45:39,790
better off to saying I can't get it boom

2342
00:45:39,790 --> 00:45:39,800
 

2343
00:45:39,800 --> 00:45:41,740
don't restart then try to do something

2344
00:45:41,740 --> 00:45:41,750
 

2345
00:45:41,750 --> 00:45:48,270
way more complicated yes

2346
00:45:48,270 --> 00:45:48,280


2347
00:45:48,280 --> 00:45:51,160
this question is if two writers are

2348
00:45:51,160 --> 00:45:51,170
 

2349
00:45:51,170 --> 00:45:53,710
trying to go in in both directions if at

2350
00:45:53,710 --> 00:45:53,720
 

2351
00:45:53,720 --> 00:45:55,690
the exact moment they try to get the

2352
00:45:55,690 --> 00:45:55,700
 

2353
00:45:55,700 --> 00:45:57,760
right latch on the other direction then

2354
00:45:57,760 --> 00:45:57,770
 

2355
00:45:57,770 --> 00:46:00,099
yes they would both restart but you know

2356
00:46:00,099 --> 00:46:00,109
 

2357
00:46:00,109 --> 00:46:01,750
in if you think about in practice one's

2358
00:46:01,750 --> 00:46:01,760
 

2359
00:46:01,760 --> 00:46:03,790
gonna be slightly behind the other so

2360
00:46:03,790 --> 00:46:03,800
 

2361
00:46:03,800 --> 00:46:07,030
the the first guy would try can't get it

2362
00:46:07,030 --> 00:46:07,040
 

2363
00:46:07,040 --> 00:46:08,349
he kills himself the second guy would

2364
00:46:08,349 --> 00:46:08,359

2365
00:46:08,359 --> 00:46:10,780
then be able to get the latch right but

2366
00:46:10,780 --> 00:46:10,790
 

2367
00:46:10,790 --> 00:46:13,560
it can't happen

2368
00:46:13,560 --> 00:46:13,570


2369
00:46:13,570 --> 00:46:16,000
so again the main thing I want to

2370
00:46:16,000 --> 00:46:16,010
 

2371
00:46:16,010 --> 00:46:17,829
emphasize here is we don't need to be

2372
00:46:17,829 --> 00:46:17,839
 

2373
00:46:17,839 --> 00:46:19,660
smart we don't need to be clever to be

2374
00:46:19,660 --> 00:46:19,670
 

2375
00:46:19,670 --> 00:46:21,609
super simple and that's actually gonna

2376
00:46:21,609 --> 00:46:21,619
 

2377
00:46:21,619 --> 00:46:22,750
turn out to be the most of most

2378
00:46:22,750 --> 00:46:22,760
 

2379
00:46:22,760 --> 00:46:23,920
efficient way to actually implement this

2380
00:46:23,920 --> 00:46:23,930
 

2381
00:46:23,930 --> 00:46:29,589
and we could have you know sir the

2382
00:46:29,589 --> 00:46:29,599
 

2383
00:46:29,599 --> 00:46:31,770
question he was he was that the

2384
00:46:31,770 --> 00:46:31,780
 

2385
00:46:31,780 --> 00:46:34,480
suggestion he had was oh well I can look

2386
00:46:34,480 --> 00:46:34,490
 

2387
00:46:34,490 --> 00:46:36,040
to see the thread one sees that threat

2388
00:46:36,040 --> 00:46:36,050
 

2389
00:46:36,050 --> 00:46:37,750
to is waiting for me therefore I can

2390
00:46:37,750 --> 00:46:37,760
 

2391
00:46:37,760 --> 00:46:39,609
maybe kill him or give him a hint about

2392
00:46:39,609 --> 00:46:39,619
 

2393
00:46:39,619 --> 00:46:41,380
something I had to store that somewhere

2394
00:46:41,380 --> 00:46:41,390
 

2395
00:46:41,390 --> 00:46:43,930
I could store that now in my node to say

2396
00:46:43,930 --> 00:46:43,940
 

2397
00:46:43,940 --> 00:46:45,190
hey here's the list of threads that are

2398
00:46:45,190 --> 00:46:45,200
 

2399
00:46:45,200 --> 00:46:47,140
waiting for you but now I'm storing that

2400
00:46:47,140 --> 00:46:47,150
 

2401
00:46:47,150 --> 00:46:50,589
instead of actually well data all right

2402
00:46:50,589 --> 00:46:50,599
 

2403
00:46:50,599 --> 00:46:52,180
because that need to be a bearable size

2404
00:46:52,180 --> 00:46:52,190
 

2405
00:46:52,190 --> 00:46:54,700
because knows how many threads could be

2406
00:46:54,700 --> 00:46:54,710
 

2407
00:46:54,710 --> 00:46:56,680
accessing this so as far as I know

2408
00:46:56,680 --> 00:46:56,690
 

2409
00:46:56,690 --> 00:46:58,240
nobody does this everyone just does

2410
00:46:58,240 --> 00:46:58,250
 

2411
00:46:58,250 --> 00:47:07,450
something really simple yes so his

2412
00:47:07,450 --> 00:47:07,460
 

2413
00:47:07,460 --> 00:47:10,060
question is when I say a thread kills

2414
00:47:10,060 --> 00:47:10,070

2415
00:47:10,070 --> 00:47:12,640
himself this guy dies and he restarts is

2416
00:47:12,640 --> 00:47:12,650
 

2417
00:47:12,650 --> 00:47:16,060
he going to this thread going to just

2418
00:47:16,060 --> 00:47:16,070
 

2419
00:47:16,070 --> 00:47:17,890
maybe wait a little bit and then retry

2420
00:47:17,890 --> 00:47:17,900
 

2421
00:47:17,900 --> 00:47:20,320
or just try it right again depends on

2422
00:47:20,320 --> 00:47:20,330
 

2423
00:47:20,330 --> 00:47:22,450
the implementation right so you can do

2424
00:47:22,450 --> 00:47:22,460
 

2425
00:47:22,460 --> 00:47:24,609
like a standard technique would be

2426
00:47:24,609 --> 00:47:24,619
 

2427
00:47:24,619 --> 00:47:26,589
what's called a sort of exponential

2428
00:47:26,589 --> 00:47:26,599
 

2429
00:47:26,599 --> 00:47:27,099
back-off

2430
00:47:27,099 --> 00:47:27,109

2431
00:47:27,109 --> 00:47:30,970
it's like TP tcp right so I try right

2432
00:47:30,970 --> 00:47:30,980
 

2433
00:47:30,980 --> 00:47:33,070
away if I know that I restarted twice

2434
00:47:33,070 --> 00:47:33,080
 

2435
00:47:33,080 --> 00:47:35,410
the me the next time I'll wait half a

2436
00:47:35,410 --> 00:47:35,420
 

2437
00:47:35,420 --> 00:47:37,000
millisecond and then maybe a millisecond

2438
00:47:37,000 --> 00:47:37,010
 

2439
00:47:37,010 --> 00:47:52,060
two milliseconds and so forth yeah so

2440
00:47:52,060 --> 00:47:52,070
 

2441
00:47:52,070 --> 00:47:57,820
his statement is okay there's a

2442
00:47:57,820 --> 00:47:57,830
 

2443
00:47:57,830 --> 00:47:59,050
possibility your thread could get

2444
00:47:59,050 --> 00:47:59,060
 

2445
00:47:59,060 --> 00:48:01,000
starved that no matter how many times it

2446
00:48:01,000 --> 00:48:01,010
 

2447
00:48:01,010 --> 00:48:03,820
tries it can never get it done that's

2448
00:48:03,820 --> 00:48:03,830
 

2449
00:48:03,830 --> 00:48:06,250
solute yes again we'll see this in

2450
00:48:06,250 --> 00:48:06,260
 

2451
00:48:06,260 --> 00:48:08,800
transactions with logs and there's a way

2452
00:48:08,800 --> 00:48:08,810
 

2453
00:48:08,810 --> 00:48:10,540
to handle this by because now we have

2454
00:48:10,540 --> 00:48:10,550
 

2455
00:48:10,550 --> 00:48:11,890
some global information about what what

2456
00:48:11,890 --> 00:48:11,900
 

2457
00:48:11,900 --> 00:48:13,870
transactions are running you can do

2458
00:48:13,870 --> 00:48:13,880
 

2459
00:48:13,880 --> 00:48:15,579
things like give priority to the oldest

2460
00:48:15,579 --> 00:48:15,589
 

2461
00:48:15,589 --> 00:48:16,690
time it turns actually the oldest

2462
00:48:16,690 --> 00:48:16,700

2463
00:48:16,700 --> 00:48:19,089
timestamp like it you know this

2464
00:48:19,089 --> 00:48:19,099
 

2465
00:48:19,099 --> 00:48:21,160
so we I was sort of joking about like in

2466
00:48:21,160 --> 00:48:21,170
 

2467
00:48:21,170 --> 00:48:22,839
this case here when I decided should I

2468
00:48:22,839 --> 00:48:22,849
 

2469
00:48:22,849 --> 00:48:26,520
wait or should I kill myself or kill him

2470
00:48:26,520 --> 00:48:26,530
 

2471
00:48:26,530 --> 00:48:28,770
transactions with locking will do we'll

2472
00:48:28,770 --> 00:48:28,780
 

2473
00:48:28,780 --> 00:48:30,420
make those decisions in this case here

2474
00:48:30,420 --> 00:48:30,430
 

2475
00:48:30,430 --> 00:48:32,280
we just we don't do any coordination we

2476
00:48:32,280 --> 00:48:32,290
 

2477
00:48:32,290 --> 00:48:37,750
just kill ourself immediately yes

2478
00:48:37,750 --> 00:48:37,760
 

2479
00:48:37,760 --> 00:48:41,690
[Music]

2480
00:48:41,690 --> 00:48:41,700


2481
00:48:41,700 --> 00:48:46,760
question is say 81 is a read lock on C T

2482
00:48:46,760 --> 00:48:46,770
 

2483
00:48:46,770 --> 00:48:50,190
2 has a write lock on this what should

2484
00:48:50,190 --> 00:48:50,200
 

2485
00:48:50,200 --> 00:49:02,940
happen in read mode in write mode her

2486
00:49:02,940 --> 00:49:02,950
 

2487
00:49:02,950 --> 00:49:06,210
question is do do do-do-do threads I

2488
00:49:06,210 --> 00:49:06,220
 

2489
00:49:06,220 --> 00:49:08,280
want to get latches in write mode have

2490
00:49:08,280 --> 00:49:08,290
 

2491
00:49:08,290 --> 00:49:11,339
higher preference to latches in read

2492
00:49:11,339 --> 00:49:11,349
 

2493
00:49:11,349 --> 00:49:16,710
mode again like you you'd have to have

2494
00:49:16,710 --> 00:49:16,720
 

2495
00:49:16,720 --> 00:49:18,540
some kind of coordination mechanism to

2496
00:49:18,540 --> 00:49:18,550
 

2497
00:49:18,550 --> 00:49:21,750
make that kind of decision right because

2498
00:49:21,750 --> 00:49:21,760
 

2499
00:49:21,760 --> 00:49:24,000
in this case here all you know at this

2500
00:49:24,000 --> 00:49:24,010
 

2501
00:49:24,010 --> 00:49:26,160
point here is that this thing is in

2502
00:49:26,160 --> 00:49:26,170
 

2503
00:49:26,170 --> 00:49:29,640
write mode in that tit right you don't

2504
00:49:29,640 --> 00:49:29,650
 

2505
00:49:29,650 --> 00:49:30,990
know that this guy's trying to come over

2506
00:49:30,990 --> 00:49:31,000
 

2507
00:49:31,000 --> 00:49:33,030
here and get this in in read mode or

2508
00:49:33,030 --> 00:49:33,040
 

2509
00:49:33,040 --> 00:49:34,710
some other mode right you just say I

2510
00:49:34,710 --> 00:49:34,720
 

2511
00:49:34,720 --> 00:49:36,060
can't get it I just kill myself right

2512
00:49:36,060 --> 00:49:36,070
 

2513
00:49:36,070 --> 00:49:38,160
away the most simplest thing actually

2514
00:49:38,160 --> 00:49:38,170
 

2515
00:49:38,170 --> 00:49:43,500
turns out to be the best all right yes

2516
00:49:43,500 --> 00:49:43,510
 

2517
00:49:43,510 --> 00:50:05,099
more okay so his daemon is why is

2518
00:50:05,099 --> 00:50:05,109
 

2519
00:50:05,109 --> 00:50:09,480
retrying better than just waiting so the

2520
00:50:09,480 --> 00:50:09,490
 

2521
00:50:09,490 --> 00:50:12,000
way over the face it is not waiting

2522
00:50:12,000 --> 00:50:12,010
 

2523
00:50:12,010 --> 00:50:14,160
indefinitely been waiting with the time

2524
00:50:14,160 --> 00:50:14,170
 

2525
00:50:14,170 --> 00:50:17,910
out so you could in theory say all right

2526
00:50:17,910 --> 00:50:17,920
 

2527
00:50:17,920 --> 00:50:19,560
I think this guy's gonna give it up

2528
00:50:19,560 --> 00:50:19,570
 

2529
00:50:19,570 --> 00:50:23,339
which is probably true so maybe I'll

2530
00:50:23,339 --> 00:50:23,349
 

2531
00:50:23,349 --> 00:50:26,730
just spin for a millisecond and then I

2532
00:50:26,730 --> 00:50:26,740
 

2533
00:50:26,740 --> 00:50:29,310
if I get it great if not I restart you

2534
00:50:29,310 --> 00:50:29,320
 

2535
00:50:29,320 --> 00:50:31,140
could do it that way but in the end like

2536
00:50:31,140 --> 00:50:31,150
 

2537
00:50:31,150 --> 00:50:34,130
you can it's it's

2538
00:50:34,130 --> 00:50:34,140
 

2539
00:50:34,140 --> 00:50:36,739
in that case again you're deadlocked for

2540
00:50:36,739 --> 00:50:36,749
 

2541
00:50:36,749 --> 00:50:39,039
that one millisecond until you timeout

2542
00:50:39,039 --> 00:50:39,049
 

2543
00:50:39,049 --> 00:50:54,529
right your block you're not right in be

2544
00:50:54,529 --> 00:50:54,539
 

2545
00:50:54,539 --> 00:50:56,650
very careful you could you can wait

2546
00:50:56,650 --> 00:50:56,660
 

2547
00:50:56,660 --> 00:50:58,670
there could be a deadlock but you need a

2548
00:50:58,670 --> 00:50:58,680
 

2549
00:50:58,680 --> 00:50:59,120
timeout

2550
00:50:59,120 --> 00:50:59,130

2551
00:50:59,130 --> 00:51:00,890
you don't wait forever because again

2552
00:51:00,890 --> 00:51:00,900
 

2553
00:51:00,900 --> 00:51:04,789
with laches there's no like like God and

2554
00:51:04,789 --> 00:51:04,799
 

2555
00:51:04,799 --> 00:51:06,229
the clouds have come down and say oh you

2556
00:51:06,229 --> 00:51:06,239

2557
00:51:06,239 --> 00:51:08,089
guys are deadlocked let me fix this

2558
00:51:08,089 --> 00:51:08,099
 

2559
00:51:08,099 --> 00:51:09,829
right we don't have that here we had

2560
00:51:09,829 --> 00:51:09,839
 

2561
00:51:09,839 --> 00:51:11,660
that for transaction locks forgiven

2562
00:51:11,660 --> 00:51:11,670
 

2563
00:51:11,670 --> 00:51:13,370
we'll cover this later we don't have

2564
00:51:13,370 --> 00:51:13,380
 

2565
00:51:13,380 --> 00:51:15,079
here we have nothing all right we're

2566
00:51:15,079 --> 00:51:15,089
 

2567
00:51:15,089 --> 00:51:16,099
like driving a car without a seatbelt

2568
00:51:16,099 --> 00:51:16,109
 

2569
00:51:16,109 --> 00:51:20,539
right so we could have this guy spin on

2570
00:51:20,539 --> 00:51:20,549
 

2571
00:51:20,549 --> 00:51:24,710
this latch for one millisecond if he

2572
00:51:24,710 --> 00:51:24,720
 

2573
00:51:24,720 --> 00:51:27,549
gets it great if not abort and restart

2574
00:51:27,549 --> 00:51:27,559
 

2575
00:51:27,559 --> 00:51:29,960
right doubt about that would work as

2576
00:51:29,960 --> 00:51:29,970
 

2577
00:51:29,970 --> 00:51:31,430
well that's that's still correct but

2578
00:51:31,430 --> 00:51:31,440
 

2579
00:51:31,440 --> 00:51:32,839
again for that one millisecond if we

2580
00:51:32,839 --> 00:51:32,849
 

2581
00:51:32,849 --> 00:51:36,609
have a deadlock we're doing nothing

2582
00:51:36,609 --> 00:51:36,619
 

2583
00:51:36,619 --> 00:51:39,769
right and again it's more like in this

2584
00:51:39,769 --> 00:51:39,779
 

2585
00:51:39,779 --> 00:51:41,390
simple example it's only a two-level

2586
00:51:41,390 --> 00:51:41,400
 

2587
00:51:41,400 --> 00:51:43,160
tree right so there's only I only have

2588
00:51:43,160 --> 00:51:43,170
 

2589
00:51:43,170 --> 00:51:45,109
one latch here but like if he's

2590
00:51:45,109 --> 00:51:45,119

2591
00:51:45,119 --> 00:51:46,819
modifying bunch of crap I may hold a

2592
00:51:46,819 --> 00:51:46,829
 

2593
00:51:46,829 --> 00:51:48,589
bunch of right latches above me and

2594
00:51:48,589 --> 00:51:48,599
 

2595
00:51:48,599 --> 00:51:51,200
that's blocking everybody else so again

2596
00:51:51,200 --> 00:51:51,210
 

2597
00:51:51,210 --> 00:51:52,789
you could be more sophisticated and say

2598
00:51:52,789 --> 00:51:52,799
 

2599
00:51:52,799 --> 00:51:56,299
all right well I I'm this guy here it

2600
00:51:56,299 --> 00:51:56,309
 

2601
00:51:56,309 --> 00:51:57,680
has a right latch and I have like five

2602
00:51:57,680 --> 00:51:57,690
 

2603
00:51:57,690 --> 00:51:59,989
right latches above me and therefore I

2604
00:51:59,989 --> 00:51:59,999
 

2605
00:51:59,999 --> 00:52:02,569
want to go this way and I can't get it

2606
00:52:02,569 --> 00:52:02,579
 

2607
00:52:02,579 --> 00:52:03,979
so I thought I should abort right away

2608
00:52:03,979 --> 00:52:03,989
 

2609
00:52:03,989 --> 00:52:05,930
because I released a bunch of latches or

2610
00:52:05,930 --> 00:52:05,940
 

2611
00:52:05,940 --> 00:52:07,640
if I know I only have one right latch

2612
00:52:07,640 --> 00:52:07,650

2613
00:52:07,650 --> 00:52:10,009
then yeah who cares the nobody else is

2614
00:52:10,009 --> 00:52:10,019
 

2615
00:52:10,019 --> 00:52:11,359
blocked behind me so I'll wait for a

2616
00:52:11,359 --> 00:52:11,369
 

2617
00:52:11,369 --> 00:52:14,269
millisecond you could do that but still

2618
00:52:14,269 --> 00:52:14,279
 

2619
00:52:14,279 --> 00:52:18,829
it's still correct but then what

2620
00:52:18,829 --> 00:52:18,839
 

2621
00:52:18,839 --> 00:52:20,089
commercial systems do for this I don't

2622
00:52:20,089 --> 00:52:20,099
 

2623
00:52:20,099 --> 00:52:21,650
know I don't I

2624
00:52:21,650 --> 00:52:21,660
 

2625
00:52:21,660 --> 00:52:22,970
actually I don't know what post Christ

2626
00:52:22,970 --> 00:52:22,980
 

2627
00:52:22,980 --> 00:52:28,249
does either or my Siegel okay all right

2628
00:52:28,249 --> 00:52:28,259
 

2629
00:52:28,259 --> 00:52:30,529
so again the the the main takeaway

2630
00:52:30,529 --> 00:52:30,539
 

2631
00:52:30,539 --> 00:52:34,039
Howard Hanna leaf nodes is that we just

2632
00:52:34,039 --> 00:52:34,049
 

2633
00:52:34,049 --> 00:52:36,710
do our the the the the coupling of the

2634
00:52:36,710 --> 00:52:36,720
 

2635
00:52:36,720 --> 00:52:39,079
crowding along the leaf nodes but if we

2636
00:52:39,079 --> 00:52:39,089
 

2637
00:52:39,089 --> 00:52:41,059
can't get the latch we want we should

2638
00:52:41,059 --> 00:52:41,069

2639
00:52:41,069 --> 00:52:44,569
just kill ourselves right away right

2640
00:52:44,569 --> 00:52:44,579
 

2641
00:52:44,579 --> 00:52:46,309
which is different than how we got

2642
00:52:46,309 --> 00:52:46,319
 

2643
00:52:46,319 --> 00:52:49,130
laches going top-down going top-down we

2644
00:52:49,130 --> 00:52:49,140
 

2645
00:52:49,140 --> 00:52:50,809
were allowed to wait because we know

2646
00:52:50,809 --> 00:52:50,819
 

2647
00:52:50,819 --> 00:52:52,370
there could never be a deadlock going

2648
00:52:52,370 --> 00:52:52,380
 

2649
00:52:52,380 --> 00:52:54,049
left and right there could be a deadlock

2650
00:52:54,049 --> 00:52:54,059
 

2651
00:52:54,059 --> 00:52:56,509
so therefore to just avoid all this we

2652
00:52:56,509 --> 00:52:56,519
 

2653
00:52:56,519 --> 00:52:58,400
just kill ourselves right away and again

2654
00:52:58,400 --> 00:52:58,410
 

2655
00:52:58,410 --> 00:53:01,969
this is this is us being good

2656
00:53:01,969 --> 00:53:01,979

2657
00:53:01,979 --> 00:53:04,370
programmers good database developers and

2658
00:53:04,370 --> 00:53:04,380
 

2659
00:53:04,380 --> 00:53:06,979
software engineers that have to design

2660
00:53:06,979 --> 00:53:06,989
 

2661
00:53:06,989 --> 00:53:09,469
our data structure to be B thread safe

2662
00:53:09,469 --> 00:53:09,479
 

2663
00:53:09,479 --> 00:53:12,979
and protected all right it's it's hard

2664
00:53:12,979 --> 00:53:12,989
 

2665
00:53:12,989 --> 00:53:16,640
to do all right so the last thing we

2666
00:53:16,640 --> 00:53:16,650
 

2667
00:53:16,650 --> 00:53:18,890
talked about is a optimization again

2668
00:53:18,890 --> 00:53:18,900
 

2669
00:53:18,900 --> 00:53:21,319
that was better here at CMU for the be

2670
00:53:21,319 --> 00:53:21,329
 

2671
00:53:21,329 --> 00:53:22,429
linked from the bead link tree paper

2672
00:53:22,429 --> 00:53:22,439
 

2673
00:53:22,439 --> 00:53:24,859
which was from like 1981 or something or

2674
00:53:24,859 --> 00:53:24,869
 

2675
00:53:24,869 --> 00:53:27,829
maybe in the 70s by Philip Lehman who's

2676
00:53:27,829 --> 00:53:27,839
 

2677
00:53:27,839 --> 00:53:31,729
he's in the dean's office at SCS so can

2678
00:53:31,729 --> 00:53:31,739
 

2679
00:53:31,739 --> 00:53:33,769
the the the the only thing you'd really

2680
00:53:33,769 --> 00:53:33,779
 

2681
00:53:33,779 --> 00:53:34,880
understand about the be link tree is

2682
00:53:34,880 --> 00:53:34,890
 

2683
00:53:34,890 --> 00:53:37,400
that it has the pointers the sibling

2684
00:53:37,400 --> 00:53:37,410
 

2685
00:53:37,410 --> 00:53:38,929
pointers along the leaf nodes the

2686
00:53:38,929 --> 00:53:38,939
 

2687
00:53:38,939 --> 00:53:40,249
original B plus tree doesn't have that

2688
00:53:40,249 --> 00:53:40,259
 

2689
00:53:40,259 --> 00:53:42,529
every modern implementation has this

2690
00:53:42,529 --> 00:53:42,539
 

2691
00:53:42,539 --> 00:53:45,469
this aspect of the p1 tree so the

2692
00:53:45,469 --> 00:53:45,479
 

2693
00:53:45,479 --> 00:53:47,749
observation that they made was that any

2694
00:53:47,749 --> 00:53:47,759
 

2695
00:53:47,759 --> 00:53:50,689
time that I was gonna do an insert that

2696
00:53:50,689 --> 00:53:50,699
 

2697
00:53:50,699 --> 00:53:54,289
if I had to split my node my leaf no

2698
00:53:54,289 --> 00:53:54,299
 

2699
00:53:54,299 --> 00:53:58,130
because it overflowed then at meet that

2700
00:53:58,130 --> 00:53:58,140
 

2701
00:53:58,140 --> 00:54:00,199
I would have to update at least three

2702
00:54:00,199 --> 00:54:00,209
 

2703
00:54:00,209 --> 00:54:02,779
nodes in my tree or write to three nodes

2704
00:54:02,779 --> 00:54:02,789
 

2705
00:54:02,789 --> 00:54:04,759
so you got the right to obviously to the

2706
00:54:04,759 --> 00:54:04,769
 

2707
00:54:04,769 --> 00:54:06,829
node that you're splitting the need

2708
00:54:06,829 --> 00:54:06,839
 

2709
00:54:06,839 --> 00:54:07,759
right to the other node that you

2710
00:54:07,759 --> 00:54:07,769
 

2711
00:54:07,769 --> 00:54:09,469
overflowed into and write all its keys

2712
00:54:09,469 --> 00:54:09,479
 

2713
00:54:09,479 --> 00:54:11,689
into it and then you have to write into

2714
00:54:11,689 --> 00:54:11,699
 

2715
00:54:11,699 --> 00:54:13,759
your parent right to say here's the new

2716
00:54:13,759 --> 00:54:13,769
 

2717
00:54:13,769 --> 00:54:15,169
separator here's the new key here's the

2718
00:54:15,169 --> 00:54:15,179
 

2719
00:54:15,179 --> 00:54:17,059
here's the pointer to the new leaf node

2720
00:54:17,059 --> 00:54:17,069
 

2721
00:54:17,069 --> 00:54:19,400
that I just created you may have to go

2722
00:54:19,400 --> 00:54:19,410
 

2723
00:54:19,410 --> 00:54:20,809
out further in the tree but for our

2724
00:54:20,809 --> 00:54:20,819
 

2725
00:54:20,819 --> 00:54:23,049
purposes now we can we can ignore that

2726
00:54:23,049 --> 00:54:23,059
 

2727
00:54:23,059 --> 00:54:26,150
so the optimization that baby posed was

2728
00:54:26,150 --> 00:54:26,160
 

2729
00:54:26,160 --> 00:54:29,569
that anytime that a leaf node overflows

2730
00:54:29,569 --> 00:54:29,579
 

2731
00:54:29,579 --> 00:54:32,689
you can do a split just delay updating

2732
00:54:32,689 --> 00:54:32,699

2733
00:54:32,699 --> 00:54:36,079
its parent node right don't take the

2734
00:54:36,079 --> 00:54:36,089
 

2735
00:54:36,089 --> 00:54:37,819
right latch on it give it up right away

2736
00:54:37,819 --> 00:54:37,829
 

2737
00:54:37,829 --> 00:54:40,039
and this at some later point you'll go

2738
00:54:40,039 --> 00:54:40,049
 

2739
00:54:40,049 --> 00:54:42,410
ahead and update it as well see in a

2740
00:54:42,410 --> 00:54:42,420
 

2741
00:54:42,420 --> 00:54:46,219
second it still guarantees that the that

2742
00:54:46,219 --> 00:54:46,229
 

2743
00:54:46,229 --> 00:54:49,549
the the contents of the the B+ tree is

2744
00:54:49,549 --> 00:54:49,559
 

2745
00:54:49,559 --> 00:54:50,660
sound and the internal internal

2746
00:54:50,660 --> 00:54:50,670
 

2747
00:54:50,670 --> 00:54:52,549
representation so say I'm going to use

2748
00:54:52,549 --> 00:54:52,559
 

2749
00:54:52,559 --> 00:54:53,719
that example again well we want to

2750
00:54:53,719 --> 00:54:53,729
 

2751
00:54:53,729 --> 00:54:56,719
insert 25 so we do the optimistic alap

2752
00:54:56,719 --> 00:54:56,729
 

2753
00:54:56,729 --> 00:54:58,460
coupling that we showed before we take

2754
00:54:58,460 --> 00:54:58,470
 

2755
00:54:58,470 --> 00:55:01,490
all the way down we get down to see

2756
00:55:01,490 --> 00:55:01,500
 

2757
00:55:01,500 --> 00:55:03,700
again we still take the reed latch

2758
00:55:03,700 --> 00:55:03,710
 

2759
00:55:03,710 --> 00:55:07,309
release on B now we do the right latch

2760
00:55:07,309 --> 00:55:07,319
 

2761
00:55:07,319 --> 00:55:09,140
on F and now we see that we're gonna

2762
00:55:09,140 --> 00:55:09,150
 

2763
00:55:09,150 --> 00:55:11,510
have to do a split but instead of

2764
00:55:11,510 --> 00:55:11,520
 

2765
00:55:11,520 --> 00:55:14,870
restarting which actually would have to

2766
00:55:14,870 --> 00:55:14,880
 

2767
00:55:14,880 --> 00:55:16,370
do in this case here because yeah

2768
00:55:16,370 --> 00:55:16,380
 

2769
00:55:16,380 --> 00:55:18,079
instead of restarting and coming back

2770
00:55:18,079 --> 00:55:18,089
 

2771
00:55:18,089 --> 00:55:20,540
and getting the red latch on C we just

2772
00:55:20,540 --> 00:55:20,550
 

2773
00:55:20,550 --> 00:55:23,180
keep going and then what we're gonna do

2774
00:55:23,180 --> 00:55:23,190
 

2775
00:55:23,190 --> 00:55:26,900
now is we're gonna go ahead and do the

2776
00:55:26,900 --> 00:55:26,910
 

2777
00:55:26,910 --> 00:55:29,000
split on F we hold the Reed latch Tory

2778
00:55:29,000 --> 00:55:29,010
 

2779
00:55:29,010 --> 00:55:30,170
we hold the right latch on it so we can

2780
00:55:30,170 --> 00:55:30,180
 

2781
00:55:30,180 --> 00:55:31,220
go ahead and do that no one's gonna get

2782
00:55:31,220 --> 00:55:31,230
 

2783
00:55:31,230 --> 00:55:35,180
to us and what we're not gonna update C

2784
00:55:35,180 --> 00:55:35,190
 

2785
00:55:35,190 --> 00:55:37,510
because we don't hold a latch on that

2786
00:55:37,510 --> 00:55:37,520
 

2787
00:55:37,520 --> 00:55:41,480
alright so we we insert 25 we add the

2788
00:55:41,480 --> 00:55:41,490
 

2789
00:55:41,490 --> 00:55:43,250
new leaf node we connect it to our earth

2790
00:55:43,250 --> 00:55:43,260
 

2791
00:55:43,260 --> 00:55:45,380
or the sibling pointers and then we're

2792
00:55:45,380 --> 00:55:45,390
 

2793
00:55:45,390 --> 00:55:47,870
done and then now we're gonna do is

2794
00:55:47,870 --> 00:55:47,880
 

2795
00:55:47,880 --> 00:55:52,010
we're gonna post some information in our

2796
00:55:52,010 --> 00:55:52,020
 

2797
00:55:52,020 --> 00:55:54,650
data structure to say that the next time

2798
00:55:54,650 --> 00:55:54,660
 

2799
00:55:54,660 --> 00:55:57,170
someone comes along and takes the right

2800
00:55:57,170 --> 00:55:57,180
 

2801
00:55:57,180 --> 00:56:01,250
Lac on C go ahead and add separator key

2802
00:56:01,250 --> 00:56:01,260
 

2803
00:56:01,260 --> 00:56:04,280
that we didn't put into it right so at

2804
00:56:04,280 --> 00:56:04,290
 

2805
00:56:04,290 --> 00:56:08,300
this point here we've inserted 25 we

2806
00:56:08,300 --> 00:56:08,310
 

2807
00:56:08,310 --> 00:56:10,760
split with 31 it off and you know but it

2808
00:56:10,760 --> 00:56:10,770
 

2809
00:56:10,770 --> 00:56:13,910
has 31 at this point here if any threat

2810
00:56:13,910 --> 00:56:13,920
 

2811
00:56:13,920 --> 00:56:16,130
comes along it's looking for 25 or 30 1

2812
00:56:16,130 --> 00:56:16,140
 

2813
00:56:16,140 --> 00:56:19,099
it can find it even though we don't have

2814
00:56:19,099 --> 00:56:19,109
 

2815
00:56:19,109 --> 00:56:21,319
this pointer from C to this new node

2816
00:56:21,319 --> 00:56:21,329
 

2817
00:56:21,329 --> 00:56:23,569
here right if you look at this if I want

2818
00:56:23,569 --> 00:56:23,579
 

2819
00:56:23,579 --> 00:56:26,300
so if I'm looking for 31 I'll go from 20

2820
00:56:26,300 --> 00:56:26,310
 

2821
00:56:26,310 --> 00:56:28,120
I go down this way 35 go down this way

2822
00:56:28,120 --> 00:56:28,130

2823
00:56:28,130 --> 00:56:31,099
31 is greater than 23 so I go here and

2824
00:56:31,099 --> 00:56:31,109
 

2825
00:56:31,109 --> 00:56:32,990
then there's some little information we

2826
00:56:32,990 --> 00:56:33,000
 

2827
00:56:33,000 --> 00:56:35,210
can we maintain about what the the next

2828
00:56:35,210 --> 00:56:35,220

2829
00:56:35,220 --> 00:56:37,520
sibling key would be so we would say all

2830
00:56:37,520 --> 00:56:37,530
 

2831
00:56:37,530 --> 00:56:39,200
right well I know that if I'm skating

2832
00:56:39,200 --> 00:56:39,210
 

2833
00:56:39,210 --> 00:56:42,200
along here that I'm looking for 31 my

2834
00:56:42,200 --> 00:56:42,210
 

2835
00:56:42,210 --> 00:56:46,130
range for this node F is 23 to 25 but oh

2836
00:56:46,130 --> 00:56:46,140
 

2837
00:56:46,140 --> 00:56:47,270
by the way if you're looking for

2838
00:56:47,270 --> 00:56:47,280
 

2839
00:56:47,280 --> 00:56:50,870
something greater than from 25 but less

2840
00:56:50,870 --> 00:56:50,880
 

2841
00:56:50,880 --> 00:56:53,240
than 35 go over and follow this node

2842
00:56:53,240 --> 00:56:53,250
 

2843
00:56:53,250 --> 00:56:56,329
here so I can still find 31 if I'm

2844
00:56:56,329 --> 00:56:56,339

2845
00:56:56,339 --> 00:56:58,130
looking for it I just didn't do it

2846
00:56:58,130 --> 00:56:58,140
 

2847
00:56:58,140 --> 00:57:00,140
through C I just did about following

2848
00:57:00,140 --> 00:57:00,150
 

2849
00:57:00,150 --> 00:57:01,700
along scanning along the leaf nodes and

2850
00:57:01,700 --> 00:57:01,710
 

2851
00:57:01,710 --> 00:57:03,559
again I do that leaf node scan crabbing

2852
00:57:03,559 --> 00:57:03,569
 

2853
00:57:03,569 --> 00:57:06,319
that we talked about before so now it's

2854
00:57:06,319 --> 00:57:06,329
 

2855
00:57:06,329 --> 00:57:07,700
some later point some of the thread

2856
00:57:07,700 --> 00:57:07,710
 

2857
00:57:07,710 --> 00:57:10,250
comes along and say it wants to do an

2858
00:57:10,250 --> 00:57:10,260
 

2859
00:57:10,260 --> 00:57:11,510
update

2860
00:57:11,510 --> 00:57:11,520

2861
00:57:11,520 --> 00:57:14,990
and it comes down here you've read Latin

2862
00:57:14,990 --> 00:57:15,000
 

2863
00:57:15,000 --> 00:57:17,180
B and then it knows that there's a

2864
00:57:17,180 --> 00:57:17,190
 

2865
00:57:17,190 --> 00:57:19,010
pending update foresee that needs to be

2866
00:57:19,010 --> 00:57:19,020
 

2867
00:57:19,020 --> 00:57:21,740
applied it can go ahead and inquire see

2868
00:57:21,740 --> 00:57:21,750
 

2869
00:57:21,750 --> 00:57:24,890
in right right latch mode so then and

2870
00:57:24,890 --> 00:57:24,900
 

2871
00:57:24,900 --> 00:57:25,970
when it comes there says all right now

2872
00:57:25,970 --> 00:57:25,980
 

2873
00:57:25,980 --> 00:57:27,800
actually I can post my new separator key

2874
00:57:27,800 --> 00:57:27,810
 

2875
00:57:27,810 --> 00:57:31,010
31 and have it point to the the new page

2876
00:57:31,010 --> 00:57:31,020

2877
00:57:31,020 --> 00:57:33,890
at the other guy created right the idea

2878
00:57:33,890 --> 00:57:33,900
 

2879
00:57:33,900 --> 00:57:35,359
here is again that we wanted we want to

2880
00:57:35,359 --> 00:57:35,369
 

2881
00:57:35,369 --> 00:57:37,430
delay having your update because

2882
00:57:37,430 --> 00:57:37,440
 

2883
00:57:37,440 --> 00:57:38,660
otherwise we'd have to review the

2884
00:57:38,660 --> 00:57:38,670
 

2885
00:57:38,670 --> 00:57:41,359
restart acquire the right latch but we

2886
00:57:41,359 --> 00:57:41,369
 

2887
00:57:41,369 --> 00:57:43,340
can we come back the second time we can

2888
00:57:43,340 --> 00:57:43,350
 

2889
00:57:43,350 --> 00:57:45,320
kind of acquire the right latch on C and

2890
00:57:45,320 --> 00:57:45,330
 

2891
00:57:45,330 --> 00:57:49,580
actually do the update right it's pretty

2892
00:57:49,580 --> 00:57:49,590
 

2893
00:57:49,590 --> 00:57:52,310
obvious optimization actually I don't

2894
00:57:52,310 --> 00:57:52,320
 

2895
00:57:52,320 --> 00:57:55,250
know how common this is but it does

2896
00:57:55,250 --> 00:57:55,260
 

2897
00:57:55,260 --> 00:57:56,930
appear in the literature a lot of times

2898
00:57:56,930 --> 00:57:56,940
 

2899
00:57:56,940 --> 00:57:57,950
when people talk about B plus trees

2900
00:57:57,950 --> 00:57:57,960
 

2901
00:57:57,960 --> 00:58:01,220
please the modern variants of them okay

2902
00:58:01,220 --> 00:58:01,230
 

2903
00:58:01,230 --> 00:58:04,850
so any questions about latch crabbing or

2904
00:58:04,850 --> 00:58:04,860
 

2905
00:58:04,860 --> 00:58:09,609
coupling in D plus trees yes the back

2906
00:58:09,609 --> 00:58:09,619


2907
00:58:09,619 --> 00:58:11,870
this question is it's a late update only

2908
00:58:11,870 --> 00:58:11,880

2909
00:58:11,880 --> 00:58:19,340
on insert yes all right so hopefully I

2910
00:58:19,340 --> 00:58:19,350
 

2911
00:58:19,350 --> 00:58:22,340
made it sound well actually not

2912
00:58:22,340 --> 00:58:22,350

2913
00:58:22,350 --> 00:58:24,620
hopefully but hopefully I conveyed to

2914
00:58:24,620 --> 00:58:24,630
 

2915
00:58:24,630 --> 00:58:28,390
you that at a high level the protocol of

2916
00:58:28,390 --> 00:58:28,400
 

2917
00:58:28,400 --> 00:58:33,410
making a B+ tree thread save is easy to

2918
00:58:33,410 --> 00:58:33,420
 

2919
00:58:33,420 --> 00:58:35,660
understand but I would say in practice

2920
00:58:35,660 --> 00:58:35,670
 

2921
00:58:35,670 --> 00:58:36,890
it's actually very difficult to

2922
00:58:36,890 --> 00:58:36,900
 

2923
00:58:36,900 --> 00:58:39,200
implement and get correct now for the

2924
00:58:39,200 --> 00:58:39,210
 

2925
00:58:39,210 --> 00:58:40,340
guy when you guys be implementing in

2926
00:58:40,340 --> 00:58:40,350
 

2927
00:58:40,350 --> 00:58:41,780
project 2 you know you don't have to

2928
00:58:41,780 --> 00:58:41,790
 

2929
00:58:41,790 --> 00:58:43,190
implement all the various optimizations

2930
00:58:43,190 --> 00:58:43,200
 

2931
00:58:43,200 --> 00:58:44,900
that we talked about you can sort of do

2932
00:58:44,900 --> 00:58:44,910
 

2933
00:58:44,910 --> 00:58:47,000
this straightforward method and going

2934
00:58:47,000 --> 00:58:47,010
 

2935
00:58:47,010 --> 00:58:49,940
always top down and left to right with

2936
00:58:49,940 --> 00:58:49,950
 

2937
00:58:49,950 --> 00:58:51,590
you know dis aborting should be pretty

2938
00:58:51,590 --> 00:58:51,600
 

2939
00:58:51,600 --> 00:58:54,380
straightforward the other thing I want

2940
00:58:54,380 --> 00:58:54,390

2941
00:58:54,390 --> 00:58:59,030
to convey also too is that although we

2942
00:58:59,030 --> 00:58:59,040
 

2943
00:58:59,040 --> 00:59:01,099
described all these mechanisms to

2944
00:59:01,099 --> 00:59:01,109
 

2945
00:59:01,109 --> 00:59:02,240
protect the data structure in the

2946
00:59:02,240 --> 00:59:02,250
 

2947
00:59:02,250 --> 00:59:05,690
context of a B+ tree these higher high

2948
00:59:05,690 --> 00:59:05,700
 

2949
00:59:05,700 --> 00:59:07,130
level techniques that we're using here

2950
00:59:07,130 --> 00:59:07,140
 

2951
00:59:07,140 --> 00:59:08,750
are applicable to all sorts of different

2952
00:59:08,750 --> 00:59:08,760

2953
00:59:08,760 --> 00:59:12,200
types of data structures I think of

2954
00:59:12,200 --> 00:59:12,210
 

2955
00:59:12,210 --> 00:59:14,450
things like an oak wiring latches always

2956
00:59:14,450 --> 00:59:14,460
 

2957
00:59:14,460 --> 00:59:16,700
in the same order to avoid deadlocks

2958
00:59:16,700 --> 00:59:16,710
 

2959
00:59:16,710 --> 00:59:18,710
killing yourself right away and

2960
00:59:18,710 --> 00:59:18,720
 

2961
00:59:18,720 --> 00:59:20,990
restarting right all those things you

2962
00:59:20,990 --> 00:59:21,000
 

2963
00:59:21,000 --> 00:59:23,090
can apply to other areas or other facets

2964
00:59:23,090 --> 00:59:23,100
 

2965
00:59:23,100 --> 00:59:23,960
of computer science or the data

2966
00:59:23,960 --> 00:59:23,970
 

2967
00:59:23,970 --> 00:59:24,950
structures as well

2968
00:59:24,950 --> 00:59:24,960
 

2969
00:59:24,960 --> 00:59:27,859
so it's not just in yes we're doing it B

2970
00:59:27,859 --> 00:59:27,869
 

2971
00:59:27,869 --> 00:59:28,700
plus trees because that's the most

2972
00:59:28,700 --> 00:59:28,710

2973
00:59:28,710 --> 00:59:31,160
common thing in databases but for hash

2974
00:59:31,160 --> 00:59:31,170
 

2975
00:59:31,170 --> 00:59:34,400
table is for red black trees and splay

2976
00:59:34,400 --> 00:59:34,410
 

2977
00:59:34,410 --> 00:59:35,450
trees and other things you can do the

2978
00:59:35,450 --> 00:59:35,460
 

2979
00:59:35,460 --> 00:59:39,740
same kind of thing okay all right so any

2980
00:59:39,740 --> 00:59:39,750
 

2981
00:59:39,750 --> 00:59:43,839
questions about flashing or crabbing

2982
00:59:43,839 --> 00:59:43,849


2983
00:59:43,849 --> 00:59:46,819
permit you're all salivating for project

2984
00:59:46,819 --> 00:59:46,829
 

2985
00:59:46,829 --> 00:59:51,589
two okay so project two you guys be

2986
00:59:51,589 --> 00:59:51,599
 

2987
00:59:51,599 --> 00:59:54,770
building a thread safe B+ tree can using

2988
00:59:54,770 --> 00:59:54,780
 

2989
00:59:54,780 --> 00:59:56,329
the the latching and crabbing techniques

2990
00:59:56,329 --> 00:59:56,339
 

2991
00:59:56,339 --> 00:59:58,400
we're talking about here today so the

2992
00:59:58,400 --> 00:59:58,410
 

2993
00:59:58,410 --> 01:00:00,109
project has broken up to four parts the

2994
01:00:00,109 --> 01:00:00,119
 

2995
01:00:00,119 --> 01:00:02,870
first one is defining the page layout

2996
01:00:02,870 --> 01:00:02,880
 

2997
01:00:02,880 --> 01:00:03,770
then you have to build your data

2998
01:00:03,770 --> 01:00:03,780
 

2999
01:00:03,780 --> 01:00:05,569
structure then you have to make a

3000
01:00:05,569 --> 01:00:05,579
 

3001
01:00:05,579 --> 01:00:07,670
iterator class or wrapper around it and

3002
01:00:07,670 --> 01:00:07,680

3003
01:00:07,680 --> 01:00:11,839
then implement latch crap so the way

3004
01:00:11,839 --> 01:00:11,849
 

3005
01:00:11,849 --> 01:00:12,650
it's going to work is that we're gonna

3006
01:00:12,650 --> 01:00:12,660
 

3007
01:00:12,660 --> 01:00:14,180
provide you guys with again the scalp

3008
01:00:14,180 --> 01:00:14,190
 

3009
01:00:14,190 --> 01:00:15,920
owning the API the you guys have to

3010
01:00:15,920 --> 01:00:15,930
 

3011
01:00:15,930 --> 01:00:16,849
implement the same way we did for

3012
01:00:16,849 --> 01:00:16,859
 

3013
01:00:16,859 --> 01:00:18,770
project one and then you guys just fill

3014
01:00:18,770 --> 01:00:18,780
 

3015
01:00:18,780 --> 01:00:20,780
in your implementations and you're free

3016
01:00:20,780 --> 01:00:20,790
 

3017
01:00:20,790 --> 01:00:22,190
to add whatever additional private

3018
01:00:22,190 --> 01:00:22,200
 

3019
01:00:22,200 --> 01:00:24,770
classes or private data structures or or

3020
01:00:24,770 --> 01:00:24,780
 

3021
01:00:24,780 --> 01:00:28,190
or private methods you want inside of

3022
01:00:28,190 --> 01:00:28,200
 

3023
01:00:28,200 --> 01:00:29,990
your class but you the highest level you

3024
01:00:29,990 --> 01:00:30,000
 

3025
01:00:30,000 --> 01:00:31,280
need to implement the API that we give

3026
01:00:31,280 --> 01:00:31,290
 

3027
01:00:31,290 --> 01:00:34,849
you okay so the one thing we're doing

3028
01:00:34,849 --> 01:00:34,859
 

3029
01:00:34,859 --> 01:00:36,170
differently this year is that we're

3030
01:00:36,170 --> 01:00:36,180
 

3031
01:00:36,180 --> 01:00:37,579
breaking up the project up again into

3032
01:00:37,579 --> 01:00:37,589
 

3033
01:00:37,589 --> 01:00:40,010
two checkpoints so the first checkpoint

3034
01:00:40,010 --> 01:00:40,020
 

3035
01:00:40,020 --> 01:00:41,809
we do October eighth which I think is on

3036
01:00:41,809 --> 01:00:41,819
 

3037
01:00:41,819 --> 01:00:43,190
Monday at midnight

3038
01:00:43,190 --> 01:00:43,200

3039
01:00:43,200 --> 01:00:45,049
again you just Smit this on great scope

3040
01:00:45,049 --> 01:00:45,059
 

3041
01:00:45,059 --> 01:00:46,940
and it'll be the sort of the first half

3042
01:00:46,940 --> 01:00:46,950
 

3043
01:00:46,950 --> 01:00:49,010
of the project so you know implement the

3044
01:00:49,010 --> 01:00:49,020
 

3045
01:00:49,020 --> 01:00:50,839
page layouts for the internal node and

3046
01:00:50,839 --> 01:00:50,849

3047
01:00:50,849 --> 01:00:55,010
the belief nodes and you only need to

3048
01:00:55,010 --> 01:00:55,020
 

3049
01:00:55,020 --> 01:00:56,630
actually support unique keys or making

3050
01:00:56,630 --> 01:00:56,640
 

3051
01:00:56,640 --> 01:00:58,370
it much more simple you have to worry

3052
01:00:58,370 --> 01:00:58,380
 

3053
01:00:58,380 --> 01:01:00,650
about I think also we don't make you

3054
01:01:00,650 --> 01:01:00,660
 

3055
01:01:00,660 --> 01:01:01,789
support variable length keys either

3056
01:01:01,789 --> 01:01:01,799
 

3057
01:01:01,799 --> 01:01:04,849
everything we fix line and then you

3058
01:01:04,849 --> 01:01:04,859
 

3059
01:01:04,859 --> 01:01:06,410
start building out your B plus tree and

3060
01:01:06,410 --> 01:01:06,420
 

3061
01:01:06,420 --> 01:01:08,630
in the first checkpoint you only need to

3062
01:01:08,630 --> 01:01:08,640
 

3063
01:01:08,640 --> 01:01:11,660
support search and insert all right

3064
01:01:11,660 --> 01:01:11,670
 

3065
01:01:11,670 --> 01:01:13,670
insert you obviously need to in order to

3066
01:01:13,670 --> 01:01:13,680
 

3067
01:01:13,680 --> 01:01:15,109
populate it and then searches you just

3068
01:01:15,109 --> 01:01:15,119
 

3069
01:01:15,119 --> 01:01:16,670
needed to check whether you know things

3070
01:01:16,670 --> 01:01:16,680
 

3071
01:01:16,680 --> 01:01:19,579
are there that should be there so nobody

3072
01:01:19,579 --> 01:01:19,589
 

3073
01:01:19,589 --> 01:01:20,780
think what business you only need its

3074
01:01:20,780 --> 01:01:20,790
 

3075
01:01:20,790 --> 01:01:22,760
support inserts with with splitting and

3076
01:01:22,760 --> 01:01:22,770
 

3077
01:01:22,770 --> 01:01:25,390
not delete it in the first checkpoint

3078
01:01:25,390 --> 01:01:25,400
 

3079
01:01:25,400 --> 01:01:27,650
and just like before we'll provide you

3080
01:01:27,650 --> 01:01:27,660
 

3081
01:01:27,660 --> 01:01:29,180
with some rudimentary test cases to

3082
01:01:29,180 --> 01:01:29,190
 

3083
01:01:29,190 --> 01:01:32,329
evaluate your work the great scope one

3084
01:01:32,329 --> 01:01:32,339
 

3085
01:01:32,339 --> 01:01:35,299
will have more comprehensive tests but

3086
01:01:35,299 --> 01:01:35,309

3087
01:01:35,309 --> 01:01:36,589
you're also encouraged to write your own

3088
01:01:36,589 --> 01:01:36,599
 

3089
01:01:36,599 --> 01:01:37,400
you can

3090
01:01:37,400 --> 01:01:37,410
 

3091
01:01:37,410 --> 01:01:40,970
sort of testing firm can we give you the

3092
01:01:40,970 --> 01:01:40,980
 

3093
01:01:40,980 --> 01:01:42,410
first to this first checkpoint be worth

3094
01:01:42,410 --> 01:01:42,420
 

3095
01:01:42,420 --> 01:01:44,600
40% of the grade and then for the second

3096
01:01:44,600 --> 01:01:44,610
 

3097
01:01:44,610 --> 01:01:45,890
project second checkpoint that's worth

3098
01:01:45,890 --> 01:01:45,900
 

3099
01:01:45,900 --> 01:01:48,650
60% and that's due October 19th which is

3100
01:01:48,650 --> 01:01:48,660

3101
01:01:48,660 --> 01:01:52,730
a Friday I think the midterm is that

3102
01:01:52,730 --> 01:01:52,740
 

3103
01:01:52,740 --> 01:01:55,610
Wednesday the 17th so this will be do

3104
01:01:55,610 --> 01:01:55,620
 

3105
01:01:55,620 --> 01:01:57,170
after after two days after the midterm

3106
01:01:57,170 --> 01:01:57,180
 

3107
01:01:57,180 --> 01:01:59,510
so now in the second checkpoint you have

3108
01:01:59,510 --> 01:01:59,520
 

3109
01:01:59,520 --> 01:02:01,640
to implement deletion right with with

3110
01:02:01,640 --> 01:02:01,650
 

3111
01:02:01,650 --> 01:02:04,670
with merging or sibling stealing and

3112
01:02:04,670 --> 01:02:04,680

3113
01:02:04,680 --> 01:02:06,530
then you have to implement an sto index

3114
01:02:06,530 --> 01:02:06,540
 

3115
01:02:06,540 --> 01:02:08,030
rapper or iterate a wrapper around your

3116
01:02:08,030 --> 01:02:08,040
 

3117
01:02:08,040 --> 01:02:09,950
index and that means you have to do the

3118
01:02:09,950 --> 01:02:09,960
 

3119
01:02:09,960 --> 01:02:13,270
leaf notes can to make them thread save

3120
01:02:13,270 --> 01:02:13,280

3121
01:02:13,280 --> 01:02:15,530
actually yeah this is the second

3122
01:02:15,530 --> 01:02:15,540
 

3123
01:02:15,540 --> 01:02:16,670
checkpoint overall you have to make

3124
01:02:16,670 --> 01:02:16,680
 

3125
01:02:16,680 --> 01:02:18,710
everything be thread safe so you the

3126
01:02:18,710 --> 01:02:18,720
 

3127
01:02:18,720 --> 01:02:20,360
latch crabbing and coupling techniques

3128
01:02:20,360 --> 01:02:20,370
 

3129
01:02:20,370 --> 01:02:21,320
we're talking about here and it's up to

3130
01:02:21,320 --> 01:02:21,330

3131
01:02:21,330 --> 01:02:22,250
you to decide whether you want to use

3132
01:02:22,250 --> 01:02:22,260
 

3133
01:02:22,260 --> 01:02:24,260
the optimistic one or not are you wanna

3134
01:02:24,260 --> 01:02:24,270
 

3135
01:02:24,270 --> 01:02:25,790
do delayed updates or whether other

3136
01:02:25,790 --> 01:02:25,800
 

3137
01:02:25,800 --> 01:02:27,260
optimizations you want to do it's

3138
01:02:27,260 --> 01:02:27,270
 

3139
01:02:27,270 --> 01:02:28,400
entirely up to you guys

3140
01:02:28,400 --> 01:02:28,410
 

3141
01:02:28,410 --> 01:02:30,140
but then what won't we'll benchmark you

3142
01:02:30,140 --> 01:02:30,150
 

3143
01:02:30,150 --> 01:02:31,520
guys opponent with the leaderboard and

3144
01:02:31,520 --> 01:02:31,530
 

3145
01:02:31,530 --> 01:02:37,540
see who has the fastest one question

3146
01:02:37,540 --> 01:02:37,550


3147
01:02:37,550 --> 01:02:40,190
this question is can use always lock the

3148
01:02:40,190 --> 01:02:40,200
 

3149
01:02:40,200 --> 01:02:43,760
root of the tree well latch the root of

3150
01:02:43,760 --> 01:02:43,770
 

3151
01:02:43,770 --> 01:02:49,490
the tree no you can do that to start

3152
01:02:49,490 --> 01:02:49,500
 

3153
01:02:49,500 --> 01:02:53,840
right so you could do this for like at

3154
01:02:53,840 --> 01:02:53,850
 

3155
01:02:53,850 --> 01:02:56,030
this point here like like if you would

3156
01:02:56,030 --> 01:02:56,040

3157
01:02:56,040 --> 01:02:58,220
submit it with a single latch of the

3158
01:02:58,220 --> 01:02:58,230
 

3159
01:02:58,230 --> 01:03:03,380
entire thing I think if I remember

3160
01:03:03,380 --> 01:03:03,390
 

3161
01:03:03,390 --> 01:03:04,910
correctly from the test I think we have

3162
01:03:04,910 --> 01:03:04,920
 

3163
01:03:04,920 --> 01:03:08,570
hooks so that we can pause threads in

3164
01:03:08,570 --> 01:03:08,580
 

3165
01:03:08,580 --> 01:03:11,300
the tests and check to see whether you

3166
01:03:11,300 --> 01:03:11,310
 

3167
01:03:11,310 --> 01:03:12,740
are actually supporting concurrent

3168
01:03:12,740 --> 01:03:12,750

3169
01:03:12,750 --> 01:03:14,570
threads at the same time so we had

3170
01:03:14,570 --> 01:03:14,580
 

3171
01:03:14,580 --> 01:03:15,800
things like that we're like instead of

3172
01:03:15,800 --> 01:03:15,810
 

3173
01:03:15,810 --> 01:03:17,660
like just you know give me a key and

3174
01:03:17,660 --> 01:03:17,670
 

3175
01:03:17,670 --> 01:03:19,850
then it comes back we have hooks in the

3176
01:03:19,850 --> 01:03:19,860
 

3177
01:03:19,860 --> 01:03:22,370
in the traversal steps so that maybe we

3178
01:03:22,370 --> 01:03:22,380
 

3179
01:03:22,380 --> 01:03:23,660
get to like the level two and let me

3180
01:03:23,660 --> 01:03:23,670
 

3181
01:03:23,670 --> 01:03:25,340
pause and then try to have somebody else

3182
01:03:25,340 --> 01:03:25,350
 

3183
01:03:25,350 --> 01:03:26,360
come behind you and see whether you

3184
01:03:26,360 --> 01:03:26,370
 

3185
01:03:26,370 --> 01:03:27,590
actually support concurrent up you know

3186
01:03:27,590 --> 01:03:27,600
 

3187
01:03:27,600 --> 01:03:30,560
current operations right because that

3188
01:03:30,560 --> 01:03:30,570
 

3189
01:03:30,570 --> 01:03:31,880
way you know when threads going down a

3190
01:03:31,880 --> 01:03:31,890
 

3191
01:03:31,890 --> 01:03:33,710
different path and it should be allowed

3192
01:03:33,710 --> 01:03:33,720
 

3193
01:03:33,720 --> 01:03:35,360
if it one thread is Paul's inside of it

3194
01:03:35,360 --> 01:03:35,370
 

3195
01:03:35,370 --> 01:03:37,250
so that that's what we check from the

3196
01:03:37,250 --> 01:03:37,260
 

3197
01:03:37,260 --> 01:03:39,720
current index

3198
01:03:39,720 --> 01:03:39,730

3199
01:03:39,730 --> 01:03:43,779
alright alright some general develop

3200
01:03:43,779 --> 01:03:43,789
 

3201
01:03:43,789 --> 01:03:45,910
hints I would say is that the way it's

3202
01:03:45,910 --> 01:03:45,920

3203
01:03:45,920 --> 01:03:48,039
implemented is almost exactly how it's

3204
01:03:48,039 --> 01:03:48,049
 

3205
01:03:48,049 --> 01:03:49,329
described in the textbook

3206
01:03:49,329 --> 01:03:49,339
 

3207
01:03:49,339 --> 01:03:51,999
I think it's chapter 1510 like the even

3208
01:03:51,999 --> 01:03:52,009
 

3209
01:03:52,009 --> 01:03:53,650
like the seam down like that the method

3210
01:03:53,650 --> 01:03:53,660
 

3211
01:03:53,660 --> 01:03:55,210
names are exactly what's in the textbook

3212
01:03:55,210 --> 01:03:55,220

3213
01:03:55,220 --> 01:03:57,339
alright so you if you follow that follow

3214
01:03:57,339 --> 01:03:57,349
 

3215
01:03:57,349 --> 01:04:01,210
the semantics that that'll help you

3216
01:04:01,210 --> 01:04:01,220
 

3217
01:04:01,220 --> 01:04:03,130
understand things I had it one of the

3218
01:04:03,130 --> 01:04:03,140
 

3219
01:04:03,140 --> 01:04:04,630
TAS took the class last shared he says

3220
01:04:04,630 --> 01:04:04,640
 

3221
01:04:04,640 --> 01:04:06,370
like it was until I went and read the

3222
01:04:06,370 --> 01:04:06,380
 

3223
01:04:06,380 --> 01:04:08,230
textbook well in their discussion I'll

3224
01:04:08,230 --> 01:04:08,240
 

3225
01:04:08,240 --> 01:04:09,700
be plus tree and crabbing did the

3226
01:04:09,700 --> 01:04:09,710
 

3227
01:04:09,710 --> 01:04:10,900
project actually make sense to me so I

3228
01:04:10,900 --> 01:04:10,910
 

3229
01:04:10,910 --> 01:04:13,059
encourage you to go do that first before

3230
01:04:13,059 --> 01:04:13,069
 

3231
01:04:13,069 --> 01:04:14,950
you get started the other thing you can

3232
01:04:14,950 --> 01:04:14,960
 

3233
01:04:14,960 --> 01:04:16,779
do also and we have this on the project

3234
01:04:16,779 --> 01:04:16,789
 

3235
01:04:16,789 --> 01:04:19,599
page you're encouraged maybe to set your

3236
01:04:19,599 --> 01:04:19,609
 

3237
01:04:19,609 --> 01:04:21,249
nose size to be smaller than four

3238
01:04:21,249 --> 01:04:21,259
 

3239
01:04:21,259 --> 01:04:25,120
kilobytes no size is a page size but now

3240
01:04:25,120 --> 01:04:25,130
 

3241
01:04:25,130 --> 01:04:27,009
if you have that if you have it be four

3242
01:04:27,009 --> 01:04:27,019
 

3243
01:04:27,019 --> 01:04:28,420
kilobytes then you have to assert a lot

3244
01:04:28,420 --> 01:04:28,430

3245
01:04:28,430 --> 01:04:29,740
of stuff before it starts splitting and

3246
01:04:29,740 --> 01:04:29,750
 

3247
01:04:29,750 --> 01:04:30,880
merging or sorry before it starts

3248
01:04:30,880 --> 01:04:30,890
 

3249
01:04:30,890 --> 01:04:33,279
splitting so if you use a smaller page

3250
01:04:33,279 --> 01:04:33,289

3251
01:04:33,289 --> 01:04:36,039
size like our node size like 5 5 and 12

3252
01:04:36,039 --> 01:04:36,049
 

3253
01:04:36,049 --> 01:04:39,009
bytes then it doesn't take it doesn't

3254
01:04:39,009 --> 01:04:39,019
 

3255
01:04:39,019 --> 01:04:41,109
take very much insertions before it

3256
01:04:41,109 --> 01:04:41,119
 

3257
01:04:41,119 --> 01:04:42,370
starts splitting and you test that to

3258
01:04:42,370 --> 01:04:42,380
 

3259
01:04:42,380 --> 01:04:43,180
see whether your things working

3260
01:04:43,180 --> 01:04:43,190
 

3261
01:04:43,190 --> 01:04:46,240
correctly and then the last one else to

3262
01:04:46,240 --> 01:04:46,250
 

3263
01:04:46,250 --> 01:04:47,499
do and again this is this is in the

3264
01:04:47,499 --> 01:04:47,509
 

3265
01:04:47,509 --> 01:04:49,180
documentation of the project page you

3266
01:04:49,180 --> 01:04:49,190
 

3267
01:04:49,190 --> 01:04:50,849
want to make sure that you protect the

3268
01:04:50,849 --> 01:04:50,859
 

3269
01:04:50,859 --> 01:04:53,200
internal pointer for the root page in

3270
01:04:53,200 --> 01:04:53,210
 

3271
01:04:53,210 --> 01:04:54,759
your in your B+ tree that's the thing

3272
01:04:54,759 --> 01:04:54,769
 

3273
01:04:54,769 --> 01:04:56,259
that people got fouled up on last year a

3274
01:04:56,259 --> 01:04:56,269
 

3275
01:04:56,269 --> 01:04:59,470
lot right if I start doing splits and I

3276
01:04:59,470 --> 01:04:59,480
 

3277
01:04:59,480 --> 01:05:02,079
update mom my pointer to my root node

3278
01:05:02,079 --> 01:05:02,089
 

3279
01:05:02,089 --> 01:05:03,789
which is recognize representative

3280
01:05:03,789 --> 01:05:03,799
 

3281
01:05:03,799 --> 01:05:05,890
through this root page ID then when you

3282
01:05:05,890 --> 01:05:05,900
 

3283
01:05:05,900 --> 01:05:08,069
come back you're now pulling a garbage

3284
01:05:08,069 --> 01:05:08,079
 

3285
01:05:08,079 --> 01:05:12,069
ok all right so the way you're gonna do

3286
01:05:12,069 --> 01:05:12,079
 

3287
01:05:12,079 --> 01:05:13,029
this is that we're gonna give you a new

3288
01:05:13,029 --> 01:05:13,039
 

3289
01:05:13,039 --> 01:05:15,999
car ball we'll give you a simple some

3290
01:05:15,999 --> 01:05:16,009
 

3291
01:05:16,009 --> 01:05:17,710
you know batch command to copy in the

3292
01:05:17,710 --> 01:05:17,720
 

3293
01:05:17,720 --> 01:05:20,710
files from project 1 into the new tar

3294
01:05:20,710 --> 01:05:20,720
 

3295
01:05:20,720 --> 01:05:25,710
ball I can have some updated code and

3296
01:05:25,710 --> 01:05:25,720
 

3297
01:05:25,720 --> 01:05:28,180
when you submit it you only want to

3298
01:05:28,180 --> 01:05:28,190
 

3299
01:05:28,190 --> 01:05:31,269
submit the 10 files that you modified

3300
01:05:31,269 --> 01:05:31,279
 

3301
01:05:31,279 --> 01:05:34,539
plus the 6 files that from project 1 so

3302
01:05:34,539 --> 01:05:34,549
 

3303
01:05:34,549 --> 01:05:35,890
everything's sort of built on top of

3304
01:05:35,890 --> 01:05:35,900
 

3305
01:05:35,900 --> 01:05:37,599
what you've done before is it cumulative

3306
01:05:37,599 --> 01:05:37,609
 

3307
01:05:37,609 --> 01:05:38,349
ok

3308
01:05:38,349 --> 01:05:38,359
 

3309
01:05:38,359 --> 01:05:40,059
and then as always post your questions

3310
01:05:40,059 --> 01:05:40,069
 

3311
01:05:40,069 --> 01:05:42,160
on Piazza or come to TLS hours and then

3312
01:05:42,160 --> 01:05:42,170
 

3313
01:05:42,170 --> 01:05:45,059
obviously don't don't don't cheat

3314
01:05:45,059 --> 01:05:45,069

3315
01:05:45,069 --> 01:05:47,170
there are implementations of people

3316
01:05:47,170 --> 01:05:47,180
 

3317
01:05:47,180 --> 01:05:49,120
streets on the internet you can look at

3318
01:05:49,120 --> 01:05:49,130
 

3319
01:05:49,130 --> 01:05:50,589
them you follow them but but copying

3320
01:05:50,589 --> 01:05:50,599

3321
01:05:50,599 --> 01:05:52,210
them into your code is not gonna help

3322
01:05:52,210 --> 01:05:52,220
 

3323
01:05:52,220 --> 01:05:52,750
you

3324
01:05:52,750 --> 01:05:52,760

3325
01:05:52,760 --> 01:05:55,990
it's the API is different and don't put

3326
01:05:55,990 --> 01:05:56,000
 

3327
01:05:56,000 --> 01:05:57,550
anything to put any your code or

3328
01:05:57,550 --> 01:05:57,560
 

3329
01:05:57,560 --> 01:06:00,090
solutions on github okay

3330
01:06:00,090 --> 01:06:00,100
 

3331
01:06:00,100 --> 01:06:09,280
alright any questions yes they say it

3332
01:06:09,280 --> 01:06:09,290
 

3333
01:06:09,290 --> 01:06:18,220
again sorry yes for projects to our

3334
01:06:18,220 --> 01:06:18,230
 

3335
01:06:18,230 --> 01:06:22,810
project one should be today well check

3336
01:06:22,810 --> 01:06:22,820
 

3337
01:06:22,820 --> 01:06:30,100
this in the last day is well it's her

3338
01:06:30,100 --> 01:06:30,110
 

3339
01:06:30,110 --> 01:06:32,260
again so every day you're late it's 25%

3340
01:06:32,260 --> 01:06:32,270
 

3341
01:06:32,270 --> 01:06:36,400
off so it's yeah and you get for late

3342
01:06:36,400 --> 01:06:36,410
 

3343
01:06:36,410 --> 01:06:38,380
days so you can submit it at least for

3344
01:06:38,380 --> 01:06:38,390
 

3345
01:06:38,390 --> 01:06:41,380
late days then it's four more days after

3346
01:06:41,380 --> 01:06:41,390

3347
01:06:41,390 --> 01:06:42,400
that before you get a zero

3348
01:06:42,400 --> 01:06:42,410
 

3349
01:06:42,410 --> 01:06:45,360
so technically eight days to submit it

3350
01:06:45,360 --> 01:06:45,370
 

3351
01:06:45,370 --> 01:06:50,200
ok ok all right next class we'll

3352
01:06:50,200 --> 01:06:50,210
 

3353
01:06:50,210 --> 01:06:51,460
probably actually start looking how to

3354
01:06:51,460 --> 01:06:51,470
 

3355
01:06:51,470 --> 01:06:52,600
actually exit queries we sort of been

3356
01:06:52,600 --> 01:06:52,610
 

3357
01:06:52,610 --> 01:06:53,770
beating around the bush keep saying like

3358
01:06:53,770 --> 01:06:53,780
 

3359
01:06:53,780 --> 01:06:54,910
oh we have queries

3360
01:06:54,910 --> 01:06:54,920
 

3361
01:06:54,920 --> 01:06:57,340
they'll come later we read a B+ tree we

3362
01:06:57,340 --> 01:06:57,350
 

3363
01:06:57,350 --> 01:06:59,440
read our pages with tuples now I'll

3364
01:06:59,440 --> 01:06:59,450
 

3365
01:06:59,450 --> 01:07:00,370
actually talk about how to see how to do

3366
01:07:00,370 --> 01:07:00,380
 

3367
01:07:00,380 --> 01:07:02,230
this again building up the layers in the

3368
01:07:02,230 --> 01:07:02,240
 

3369
01:07:02,240 --> 01:07:03,610
system buildings have the B plus trees

3370
01:07:03,610 --> 01:07:03,620
 

3371
01:07:03,620 --> 01:07:05,410
built on the buffer pool manager now we

3372
01:07:05,410 --> 01:07:05,420
 

3373
01:07:05,420 --> 01:07:13,060
can run queries ok

3374
01:07:13,060 --> 01:07:13,070


3375
01:07:13,070 --> 01:07:18,290
yes it's the SD cricket IDE mess I make

3376
01:07:18,290 --> 01:07:18,300
 

3377
01:07:18,300 --> 01:07:21,170
a mess unless I can do it like a gia are

3378
01:07:21,170 --> 01:07:21,180
 

3379
01:07:21,180 --> 01:07:24,590
you with the G to the e to the T comes

3380
01:07:24,590 --> 01:07:24,600
 

3381
01:07:24,600 --> 01:07:27,620
dope I play the game where's mommy's on

3382
01:07:27,620 --> 01:07:27,630
 

3383
01:07:27,630 --> 01:07:42,860
the cuff of the bus a cap on the party

3384
01:07:42,860 --> 01:07:42,870
 

3385
01:07:42,870 --> 01:07:45,950
by the 12-pack case seven four six pack

3386
01:07:45,950 --> 01:07:45,960
 

3387
01:07:45,960 --> 01:07:49,130
for the egg it's the Real ID replete

3388
01:07:49,130 --> 01:07:49,140
 

3389
01:07:49,140 --> 01:07:51,260
with your drinking proper 12 ow

3390
01:07:51,260 --> 01:07:51,270
 

3391
01:07:51,270 --> 01:07:53,660
they say build nation flat out what's a

3392
01:07:53,660 --> 01:07:53,670
 

3393
01:07:53,670 --> 01:07:55,550
nice is straight so it really don't

3394
01:07:55,550 --> 01:07:55,560
 

3395
01:07:55,560 --> 01:07:57,740
matter

