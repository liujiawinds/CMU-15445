1
00:00:00,740 --> 00:00:10,640
[Music]

2
00:00:10,640 --> 00:00:10,650

3
00:00:10,650 --> 00:00:15,390
they'd be on the jill's Nick okay this

4
00:00:15,390 --> 00:00:15,400
 

5
00:00:15,400 --> 00:00:18,150
Thursday we have another speaker coming

6
00:00:18,150 --> 00:00:18,160
 

7
00:00:18,160 --> 00:00:20,550
for our seminar series on hardware

8
00:00:20,550 --> 00:00:20,560
 

9
00:00:20,560 --> 00:00:22,950
accelerator databases this would be Todd

10
00:00:22,950 --> 00:00:22,960
 

11
00:00:22,960 --> 00:00:26,609
Moe stack from map D he's the CEO and

12
00:00:26,609 --> 00:00:26,619
 

13
00:00:26,619 --> 00:00:28,290
co-founder so again this is another

14
00:00:28,290 --> 00:00:28,300
 

15
00:00:28,300 --> 00:00:32,159
database system that uses cheap used to

16
00:00:32,159 --> 00:00:32,169
 

17
00:00:32,169 --> 00:00:34,770
accelerate the execution of queries so

18
00:00:34,770 --> 00:00:34,780
 

19
00:00:34,780 --> 00:00:37,439
we're not quite there yet in discussing

20
00:00:37,439 --> 00:00:37,449
 

21
00:00:37,449 --> 00:00:40,590
how we execute queries but sort of we've

22
00:00:40,590 --> 00:00:40,600
 

23
00:00:40,600 --> 00:00:41,669
talked a little bit about doing some

24
00:00:41,669 --> 00:00:41,679
 

25
00:00:41,679 --> 00:00:43,619
actual scans these systems are

26
00:00:43,619 --> 00:00:43,629
 

27
00:00:43,629 --> 00:00:45,540
essentially doing super parallel special

28
00:00:45,540 --> 00:00:45,550
 

29
00:00:45,550 --> 00:00:48,149
scans on data that's been put inside of

30
00:00:48,149 --> 00:00:48,159
 

31
00:00:48,159 --> 00:00:50,069
the GPU and they can run that own

32
00:00:50,069 --> 00:00:50,079
 

33
00:00:50,079 --> 00:00:53,040
parallel really fast of course the

34
00:00:53,040 --> 00:00:53,050
 

35
00:00:53,050 --> 00:00:55,229
downside as we know we've been talking

36
00:00:55,229 --> 00:00:55,239
 

37
00:00:55,239 --> 00:00:56,759
about this already about how to move

38
00:00:56,759 --> 00:00:56,769
 

39
00:00:56,769 --> 00:00:58,799
data back and forth between the disk and

40
00:00:58,799 --> 00:00:58,809
 

41
00:00:58,809 --> 00:01:00,899
to our buffer pool in memory these guys

42
00:01:00,899 --> 00:01:00,909
 

43
00:01:00,909 --> 00:01:02,099
have another problem they gotta move the

44
00:01:02,099 --> 00:01:02,109
 

45
00:01:02,109 --> 00:01:05,130
data from memory up on the CPU down to

46
00:01:05,130 --> 00:01:05,140
 

47
00:01:05,140 --> 00:01:08,310
memory in the GPU right so these talks

48
00:01:08,310 --> 00:01:08,320
 

49
00:01:08,320 --> 00:01:09,959
are describing how they actually want to

50
00:01:09,959 --> 00:01:09,969
 

51
00:01:09,969 --> 00:01:12,990
manage that so administrative things is

52
00:01:12,990 --> 00:01:13,000
 

53
00:01:13,000 --> 00:01:15,270
that reminder the homework started

54
00:01:15,270 --> 00:01:15,280
 

55
00:01:15,280 --> 00:01:17,340
project one is due Wednesday September

56
00:01:17,340 --> 00:01:17,350
 

57
00:01:17,350 --> 00:01:18,749
26 that's next week

58
00:01:18,749 --> 00:01:18,759
 

59
00:01:18,759 --> 00:01:21,330
at midnight homework 2 will go out later

60
00:01:21,330 --> 00:01:21,340
 

61
00:01:21,340 --> 00:01:23,880
today after class originally was due the

62
00:01:23,880 --> 00:01:23,890
 

63
00:01:23,890 --> 00:01:26,340
same day as project 1 but I bump that to

64
00:01:26,340 --> 00:01:26,350
 

65
00:01:26,350 --> 00:01:28,889
be the Friday on the 28th but I just

66
00:01:28,889 --> 00:01:28,899
 

67
00:01:28,899 --> 00:01:30,810
sort of give you some extra time ok

68
00:01:30,810 --> 00:01:30,820
 

69
00:01:30,820 --> 00:01:32,669
again everything's everything's on great

70
00:01:32,669 --> 00:01:32,679
 

71
00:01:32,679 --> 00:01:34,859
scope so any questions so far about

72
00:01:34,859 --> 00:01:34,869
 

73
00:01:34,869 --> 00:01:36,630
project 1 and no couple you have some

74
00:01:36,630 --> 00:01:36,640
 

75
00:01:36,640 --> 00:01:40,620
technical questions on on Piazza we'll

76
00:01:40,620 --> 00:01:40,630
 

77
00:01:40,630 --> 00:01:54,080
sort of those things out yes yes

78
00:01:54,080 --> 00:01:54,090


79
00:01:54,090 --> 00:02:06,840
yes if you feel the first one it doesn't

80
00:02:06,840 --> 00:02:06,850
 

81
00:02:06,850 --> 00:02:20,160
do the after meeting yes okay okay did

82
00:02:20,160 --> 00:02:20,170
 

83
00:02:20,170 --> 00:02:22,260
you post on Piazza about this a person

84
00:02:22,260 --> 00:02:22,270
 

85
00:02:22,270 --> 00:02:25,259
pee outside will fix it okay any like

86
00:02:25,259 --> 00:02:25,269
 

87
00:02:25,269 --> 00:02:27,030
non-technical like the greater the

88
00:02:27,030 --> 00:02:27,040
 

89
00:02:27,040 --> 00:02:28,290
greater thing doesn't work right so to

90
00:02:28,290 --> 00:02:28,300
 

91
00:02:28,300 --> 00:02:32,430
high-level questions I'm a fist

92
00:02:32,430 --> 00:02:32,440
 

93
00:02:32,440 --> 00:02:33,600
confident they can filter my buffer pool

94
00:02:33,600 --> 00:02:33,610
 

95
00:02:33,610 --> 00:02:38,880
manager right okay the last thing I also

96
00:02:38,880 --> 00:02:38,890
 

97
00:02:38,890 --> 00:02:40,229
want to bring up is just a reminder what

98
00:02:40,229 --> 00:02:40,239
 

99
00:02:40,239 --> 00:02:42,900
I said at the beginning the semester I

100
00:02:42,900 --> 00:02:42,910
 

101
00:02:42,910 --> 00:02:45,210
really want you guys to stop me as we go

102
00:02:45,210 --> 00:02:45,220
 

103
00:02:45,220 --> 00:02:46,830
along if you have questions about the

104
00:02:46,830 --> 00:02:46,840
 

105
00:02:46,840 --> 00:02:48,390
material as as I'm speaking right now

106
00:02:48,390 --> 00:02:48,400
 

107
00:02:48,400 --> 00:02:50,759
but I don't want is for people to come

108
00:02:50,759 --> 00:02:50,769
 

109
00:02:50,769 --> 00:02:51,900
up with the front and ask me questions

110
00:02:51,900 --> 00:02:51,910
 

111
00:02:51,910 --> 00:02:54,330
about there's something on slide 20 that

112
00:02:54,330 --> 00:02:54,340
 

113
00:02:54,340 --> 00:02:56,729
occurred 30 minutes ago right this

114
00:02:56,729 --> 00:02:56,739
 

115
00:02:56,739 --> 00:02:58,979
serves two purposes one if you have

116
00:02:58,979 --> 00:02:58,989
 

117
00:02:58,989 --> 00:03:00,780
questions about material then somebody

118
00:03:00,780 --> 00:03:00,790
 

119
00:03:00,790 --> 00:03:02,160
else probably does too so it's better

120
00:03:02,160 --> 00:03:02,170
 

121
00:03:02,170 --> 00:03:04,560
just to stop me and make sure I clarify

122
00:03:04,560 --> 00:03:04,570
 

123
00:03:04,570 --> 00:03:06,240
or speak more clearly about what it is

124
00:03:06,240 --> 00:03:06,250
 

125
00:03:06,250 --> 00:03:08,430
that you're confused about but also it

126
00:03:08,430 --> 00:03:08,440
 

127
00:03:08,440 --> 00:03:12,300
serves a you know as sort of a way to

128
00:03:12,300 --> 00:03:12,310
 

129
00:03:12,310 --> 00:03:14,160
make this material better for the next

130
00:03:14,160 --> 00:03:14,170
 

131
00:03:14,170 --> 00:03:15,420
year because I can always go back and

132
00:03:15,420 --> 00:03:15,430
 

133
00:03:15,430 --> 00:03:16,890
watch the video and see what you know

134
00:03:16,890 --> 00:03:16,900
 

135
00:03:16,900 --> 00:03:18,240
the students ask this question this part

136
00:03:18,240 --> 00:03:18,250
 

137
00:03:18,250 --> 00:03:19,680
wasn't clear and actually try to make

138
00:03:19,680 --> 00:03:19,690
 

139
00:03:19,690 --> 00:03:21,930
the slides better so that you know the

140
00:03:21,930 --> 00:03:21,940
 

141
00:03:21,940 --> 00:03:23,759
thing you were confused about can be

142
00:03:23,759 --> 00:03:23,769
 

143
00:03:23,769 --> 00:03:25,920
described in a better way the next time

144
00:03:25,920 --> 00:03:25,930
 

145
00:03:25,930 --> 00:03:29,039
around okay so it means again if you

146
00:03:29,039 --> 00:03:29,049
 

147
00:03:29,049 --> 00:03:30,960
come up at the end of the smell at end

148
00:03:30,960 --> 00:03:30,970
 

149
00:03:30,970 --> 00:03:32,250
of the class and ask questions about the

150
00:03:32,250 --> 00:03:32,260
 

151
00:03:32,260 --> 00:03:33,539
some of it something that's not about

152
00:03:33,539 --> 00:03:33,549
 

153
00:03:33,549 --> 00:03:36,240
like the homeworks or something you know

154
00:03:36,240 --> 00:03:36,250
 

155
00:03:36,250 --> 00:03:39,000
beyond the course material I will not

156
00:03:39,000 --> 00:03:39,010
 

157
00:03:39,010 --> 00:03:40,680
answer the question right I'm not trying

158
00:03:40,680 --> 00:03:40,690
 

159
00:03:40,690 --> 00:03:42,780
to be an asshole just like just I want

160
00:03:42,780 --> 00:03:42,790
 

161
00:03:42,790 --> 00:03:44,460
you guys to stop me because it's not you

162
00:03:44,460 --> 00:03:44,470
 

163
00:03:44,470 --> 00:03:45,990
know I just want to speak here for hour

164
00:03:45,990 --> 00:03:46,000
 

165
00:03:46,000 --> 00:03:47,970
and a half and just go through all the

166
00:03:47,970 --> 00:03:47,980
 

167
00:03:47,980 --> 00:03:49,740
slides if you have questions stop me and

168
00:03:49,740 --> 00:03:49,750
 

169
00:03:49,750 --> 00:03:51,270
we can we can go over things more detail

170
00:03:51,270 --> 00:03:51,280
 

171
00:03:51,280 --> 00:03:54,449
okay again there's no stupid question

172
00:03:54,449 --> 00:03:54,459
 

173
00:03:54,459 --> 00:03:56,039
the only stupid question there is is is

174
00:03:56,039 --> 00:03:56,049
 

175
00:03:56,049 --> 00:03:56,819
this a stupid question

176
00:03:56,819 --> 00:03:56,829

177
00:03:56,829 --> 00:04:00,629
right so you can ask me anything I don't

178
00:04:00,629 --> 00:04:00,639
 

179
00:04:00,639 --> 00:04:01,650
care

180
00:04:01,650 --> 00:04:01,660

181
00:04:01,660 --> 00:04:05,550
all right so where we're at now again

182
00:04:05,550 --> 00:04:05,560
 

183
00:04:05,560 --> 00:04:07,260
just to ground ourselves understanding

184
00:04:07,260 --> 00:04:07,270
 

185
00:04:07,270 --> 00:04:08,580
where we're going along in the semester

186
00:04:08,580 --> 00:04:08,590
 

187
00:04:08,590 --> 00:04:14,460
is now we're started talking about after

188
00:04:14,460 --> 00:04:14,470
 

189
00:04:14,470 --> 00:04:16,560
we know how to organize our data from on

190
00:04:16,560 --> 00:04:16,570
 

191
00:04:16,570 --> 00:04:18,510
disk and memory now we're going up

192
00:04:18,510 --> 00:04:18,520
 

193
00:04:18,520 --> 00:04:20,010
further up the stack and talking about

194
00:04:20,010 --> 00:04:20,020
 

195
00:04:20,020 --> 00:04:22,760
how we're actually going to have queries

196
00:04:22,760 --> 00:04:22,770
 

197
00:04:22,770 --> 00:04:26,280
execute execute in our system and read

198
00:04:26,280 --> 00:04:26,290
 

199
00:04:26,290 --> 00:04:28,620
and write data so for today's lecture

200
00:04:28,620 --> 00:04:28,630
 

201
00:04:28,630 --> 00:04:29,580
we're sort of talking about how we

202
00:04:29,580 --> 00:04:29,590
 

203
00:04:29,590 --> 00:04:33,480
support them to internally maintaining

204
00:04:33,480 --> 00:04:33,490
 

205
00:04:33,490 --> 00:04:36,660
metadata among other things but sort of

206
00:04:36,660 --> 00:04:36,670
 

207
00:04:36,670 --> 00:04:37,830
broadly you can think of like we're at

208
00:04:37,830 --> 00:04:37,840
 

209
00:04:37,840 --> 00:04:39,270
this point here called access methods

210
00:04:39,270 --> 00:04:39,280
 

211
00:04:39,280 --> 00:04:41,700
Naxos methods are the you know sort of

212
00:04:41,700 --> 00:04:41,710
 

213
00:04:41,710 --> 00:04:42,150
mislike

214
00:04:42,150 --> 00:04:42,160
 

215
00:04:42,160 --> 00:04:44,130
self-describing they're the methods or

216
00:04:44,130 --> 00:04:44,140
 

217
00:04:44,140 --> 00:04:45,900
the mechanisms inside our data system

218
00:04:45,900 --> 00:04:45,910
 

219
00:04:45,910 --> 00:04:48,630
that's gonna allow queries or threads to

220
00:04:48,630 --> 00:04:48,640

221
00:04:48,640 --> 00:04:53,760
access data and the the data structures

222
00:04:53,760 --> 00:04:53,770

223
00:04:53,770 --> 00:04:54,960
we'll be talking about for the next two

224
00:04:54,960 --> 00:04:54,970
 

225
00:04:54,970 --> 00:04:58,020
weeks can be grouped in sort of two

226
00:04:58,020 --> 00:04:58,030
 

227
00:04:58,030 --> 00:05:00,270
categories we'll have the hash tables

228
00:05:00,270 --> 00:05:00,280
 

229
00:05:00,280 --> 00:05:02,820
that we talked about today and then

230
00:05:02,820 --> 00:05:02,830
 

231
00:05:02,830 --> 00:05:04,050
we'll have the order preserving trees

232
00:05:04,050 --> 00:05:04,060
 

233
00:05:04,060 --> 00:05:07,770
that we'll talk about on on Wednesday

234
00:05:07,770 --> 00:05:07,780
 

235
00:05:07,780 --> 00:05:10,740
this week and then Monday next week so

236
00:05:10,740 --> 00:05:10,750
 

237
00:05:10,750 --> 00:05:12,690
to understand where these data structure

238
00:05:12,690 --> 00:05:12,700

239
00:05:12,700 --> 00:05:13,650
is going to be used and how they're

240
00:05:13,650 --> 00:05:13,660
 

241
00:05:13,660 --> 00:05:16,380
gonna help us xq queries we refer to our

242
00:05:16,380 --> 00:05:16,390
 

243
00:05:16,390 --> 00:05:17,910
what are some cases where can we

244
00:05:17,910 --> 00:05:17,920
 

245
00:05:17,920 --> 00:05:18,960
actually use them inside of our air

246
00:05:18,960 --> 00:05:18,970
 

247
00:05:18,970 --> 00:05:22,290
system so as as I first already said we

248
00:05:22,290 --> 00:05:22,300
 

249
00:05:22,300 --> 00:05:23,640
can use these to maintain the internal

250
00:05:23,640 --> 00:05:23,650
 

251
00:05:23,650 --> 00:05:26,610
metadata of the database system and you

252
00:05:26,610 --> 00:05:26,620
 

253
00:05:26,620 --> 00:05:27,780
guys are already doing this for your

254
00:05:27,780 --> 00:05:27,790
 

255
00:05:27,790 --> 00:05:29,370
buffer pool right you have to build a

256
00:05:29,370 --> 00:05:29,380
 

257
00:05:29,380 --> 00:05:32,340
hash table for the page table to map

258
00:05:32,340 --> 00:05:32,350

259
00:05:32,350 --> 00:05:34,800
page IDs to frames in the buffer pool

260
00:05:34,800 --> 00:05:34,810

261
00:05:34,810 --> 00:05:36,600
right that's what I mean by internal

262
00:05:36,600 --> 00:05:36,610
 

263
00:05:36,610 --> 00:05:39,540
metadata it can also be used for the

264
00:05:39,540 --> 00:05:39,550
 

265
00:05:39,550 --> 00:05:42,030
core data storage of the system so we

266
00:05:42,030 --> 00:05:42,040

267
00:05:42,040 --> 00:05:43,860
can use either hash table or an order

268
00:05:43,860 --> 00:05:43,870
 

269
00:05:43,870 --> 00:05:46,290
preserving tree to actually organize the

270
00:05:46,290 --> 00:05:46,300
 

271
00:05:46,300 --> 00:05:48,990
underlying pages or tuples inside of our

272
00:05:48,990 --> 00:05:49,000
 

273
00:05:49,000 --> 00:05:51,420
pages so the easiest way to think about

274
00:05:51,420 --> 00:05:51,430
 

275
00:05:51,430 --> 00:05:53,370
this for a hash table right I'll there's

276
00:05:53,370 --> 00:05:53,380
 

277
00:05:53,380 --> 00:05:54,990
some no sequel systems that are key

278
00:05:54,990 --> 00:05:55,000

279
00:05:55,000 --> 00:05:56,880
value stores or these are just hatchet

280
00:05:56,880 --> 00:05:56,890
 

281
00:05:56,890 --> 00:05:59,730
with that map keys to to values in the

282
00:05:59,730 --> 00:05:59,740
 

283
00:05:59,740 --> 00:06:01,230
case of order preserving trees like B

284
00:06:01,230 --> 00:06:01,240
 

285
00:06:01,240 --> 00:06:03,360
plus trees but we'll see some systems

286
00:06:03,360 --> 00:06:03,370

287
00:06:03,370 --> 00:06:05,550
like my sequel actually organize all

288
00:06:05,550 --> 00:06:05,560

289
00:06:05,560 --> 00:06:07,520
that the pages and the tables themselves

290
00:06:07,520 --> 00:06:07,530
 

291
00:06:07,530 --> 00:06:10,650
inside of the trees right it's not just

292
00:06:10,650 --> 00:06:10,660
 

293
00:06:10,660 --> 00:06:12,540
sort of like a service of separate

294
00:06:12,540 --> 00:06:12,550
 

295
00:06:12,550 --> 00:06:15,090
auxiliary data structure

296
00:06:15,090 --> 00:06:15,100
 

297
00:06:15,100 --> 00:06:16,140
the the next thing we can use them for

298
00:06:16,140 --> 00:06:16,150
 

299
00:06:16,150 --> 00:06:18,060
is temporary data structures during

300
00:06:18,060 --> 00:06:18,070
 

301
00:06:18,070 --> 00:06:21,450
query execution so that means as we're

302
00:06:21,450 --> 00:06:21,460
 

303
00:06:21,460 --> 00:06:23,310
executing our query we can actually

304
00:06:23,310 --> 00:06:23,320
 

305
00:06:23,320 --> 00:06:26,010
build a hash table on the fly based on

306
00:06:26,010 --> 00:06:26,020
 

307
00:06:26,020 --> 00:06:28,530
the query the data were reading for our

308
00:06:28,530 --> 00:06:28,540
 

309
00:06:28,540 --> 00:06:30,600
query do whatever it is that we need to

310
00:06:30,600 --> 00:06:30,610
 

311
00:06:30,610 --> 00:06:33,480
do using that hash table and then blow

312
00:06:33,480 --> 00:06:33,490
 

313
00:06:33,490 --> 00:06:34,830
it away throw it away immediately when

314
00:06:34,830 --> 00:06:34,840
 

315
00:06:34,840 --> 00:06:37,380
the query is done right and this

316
00:06:37,380 --> 00:06:37,390
 

317
00:06:37,390 --> 00:06:38,850
actually turns out to be much faster

318
00:06:38,850 --> 00:06:38,860
 

319
00:06:38,860 --> 00:06:40,590
than just having to scruncho scans over

320
00:06:40,590 --> 00:06:40,600
 

321
00:06:40,600 --> 00:06:42,720
and over again right well see this case

322
00:06:42,720 --> 00:06:42,730
 

323
00:06:42,730 --> 00:06:44,340
and hash joins but you can Pete

324
00:06:44,340 --> 00:06:44,350
 

325
00:06:44,350 --> 00:06:46,650
aggregations this way right the group by

326
00:06:46,650 --> 00:06:46,660

327
00:06:46,660 --> 00:06:48,030
clause you can think of that just again

328
00:06:48,030 --> 00:06:48,040
 

329
00:06:48,040 --> 00:06:51,450
using a hash table to group the you know

330
00:06:51,450 --> 00:06:51,460
 

331
00:06:51,460 --> 00:06:52,500
they differ different categories or

332
00:06:52,500 --> 00:06:52,510

333
00:06:52,510 --> 00:06:55,500
clusters together and the last one it's

334
00:06:55,500 --> 00:06:55,510
 

335
00:06:55,510 --> 00:06:56,610
probably what most people think about

336
00:06:56,610 --> 00:06:56,620
 

337
00:06:56,620 --> 00:06:58,200
when they think about hash tables and

338
00:06:58,200 --> 00:06:58,210
 

339
00:06:58,210 --> 00:07:00,570
and and or preserving trees is using

340
00:07:00,570 --> 00:07:00,580
 

341
00:07:00,580 --> 00:07:04,800
them for for table indexes and the the

342
00:07:04,800 --> 00:07:04,810

343
00:07:04,810 --> 00:07:06,120
main takeaway I want to get from this is

344
00:07:06,120 --> 00:07:06,130
 

345
00:07:06,130 --> 00:07:08,280
that there's certain trade-offs as we go

346
00:07:08,280 --> 00:07:08,290
 

347
00:07:08,290 --> 00:07:09,720
along that we'll talk about where

348
00:07:09,720 --> 00:07:09,730
 

349
00:07:09,730 --> 00:07:12,240
sometimes the design decisions for

350
00:07:12,240 --> 00:07:12,250

351
00:07:12,250 --> 00:07:13,530
certain hash tables or certain order

352
00:07:13,530 --> 00:07:13,540
 

353
00:07:13,540 --> 00:07:16,440
preserving trees will be good for table

354
00:07:16,440 --> 00:07:16,450
 

355
00:07:16,450 --> 00:07:18,600
indexes but may be bad for internal data

356
00:07:18,600 --> 00:07:18,610
 

357
00:07:18,610 --> 00:07:22,230
structures right may the mitten the way

358
00:07:22,230 --> 00:07:22,240
 

359
00:07:22,240 --> 00:07:25,140
we maybe design our hash table to do our

360
00:07:25,140 --> 00:07:25,150
 

361
00:07:25,150 --> 00:07:26,910
page table is not the same way we want

362
00:07:26,910 --> 00:07:26,920
 

363
00:07:26,920 --> 00:07:29,760
to do a hash table to do joins because

364
00:07:29,760 --> 00:07:29,770
 

365
00:07:29,770 --> 00:07:30,900
again they have different trade-offs in

366
00:07:30,900 --> 00:07:30,910
 

367
00:07:30,910 --> 00:07:31,950
terms of performance for the amount of

368
00:07:31,950 --> 00:07:31,960
 

369
00:07:31,960 --> 00:07:34,920
memory they have to maintain so again

370
00:07:34,920 --> 00:07:34,930
 

371
00:07:34,930 --> 00:07:36,570
we'll see this as we go along throughout

372
00:07:36,570 --> 00:07:36,580
 

373
00:07:36,580 --> 00:07:38,160
the semester but this is what we're an

374
00:07:38,160 --> 00:07:38,170
 

375
00:07:38,170 --> 00:07:40,110
ability talking about this week or the

376
00:07:40,110 --> 00:07:40,120
 

377
00:07:40,120 --> 00:07:42,060
building blocks we want to use to solve

378
00:07:42,060 --> 00:07:42,070
 

379
00:07:42,070 --> 00:07:44,160
all these problems and then we can build

380
00:07:44,160 --> 00:07:44,170
 

381
00:07:44,170 --> 00:07:45,540
on top of this and do more complicated

382
00:07:45,540 --> 00:07:45,550
 

383
00:07:45,550 --> 00:07:49,620
things so the two major design decisions

384
00:07:49,620 --> 00:07:49,630
 

385
00:07:49,630 --> 00:07:51,780
we're going to have in in just when

386
00:07:51,780 --> 00:07:51,790
 

387
00:07:51,790 --> 00:07:54,300
discussing our data structures are the

388
00:07:54,300 --> 00:07:54,310
 

389
00:07:54,310 --> 00:07:57,180
data organization and the concurrency

390
00:07:57,180 --> 00:07:57,190
 

391
00:07:57,190 --> 00:07:59,820
methods so data relation is essentially

392
00:07:59,820 --> 00:07:59,830

393
00:07:59,830 --> 00:08:02,310
just how we're gonna lay out the the

394
00:08:02,310 --> 00:08:02,320
 

395
00:08:02,320 --> 00:08:05,880
physical bits of the data we're trying

396
00:08:05,880 --> 00:08:05,890
 

397
00:08:05,890 --> 00:08:08,160
to store in our data structure in in

398
00:08:08,160 --> 00:08:08,170
 

399
00:08:08,170 --> 00:08:10,680
either memory in the heap or in pages on

400
00:08:10,680 --> 00:08:10,690
 

401
00:08:10,690 --> 00:08:13,440
disk so that we can support efficient

402
00:08:13,440 --> 00:08:13,450
 

403
00:08:13,450 --> 00:08:15,980
access to that the data that we want

404
00:08:15,980 --> 00:08:15,990
 

405
00:08:15,990 --> 00:08:18,960
right and it's getting it's it's how

406
00:08:18,960 --> 00:08:18,970
 

407
00:08:18,970 --> 00:08:20,250
we're gonna at the data plus the usual

408
00:08:20,250 --> 00:08:20,260
 

409
00:08:20,260 --> 00:08:21,780
metadata we may have to store inside of

410
00:08:21,780 --> 00:08:21,790
 

411
00:08:21,790 --> 00:08:24,030
our data structure to figure out what

412
00:08:24,030 --> 00:08:24,040
 

413
00:08:24,040 --> 00:08:27,720
what what we need the second part is how

414
00:08:27,720 --> 00:08:27,730
 

415
00:08:27,730 --> 00:08:29,010
to allow

416
00:08:29,010 --> 00:08:29,020

417
00:08:29,020 --> 00:08:31,320
multiple threads to safely access and

418
00:08:31,320 --> 00:08:31,330
 

419
00:08:31,330 --> 00:08:35,779
modify our data structures at runtime so

420
00:08:35,779 --> 00:08:35,789
 

421
00:08:35,789 --> 00:08:39,350
for this discussion for this week and

422
00:08:39,350 --> 00:08:39,360
 

423
00:08:39,360 --> 00:08:41,850
for Monday next week we're actually

424
00:08:41,850 --> 00:08:41,860
 

425
00:08:41,860 --> 00:08:43,649
going to for the most part assume that

426
00:08:43,649 --> 00:08:43,659
 

427
00:08:43,659 --> 00:08:45,660
we're only going to have a single thread

428
00:08:45,660 --> 00:08:45,670
 

429
00:08:45,670 --> 00:08:47,060
accessing our data structure but

430
00:08:47,060 --> 00:08:47,070
 

431
00:08:47,070 --> 00:08:49,410
obviously in a modern system we can have

432
00:08:49,410 --> 00:08:49,420
 

433
00:08:49,420 --> 00:08:50,550
multiple cores and multiple threads

434
00:08:50,550 --> 00:08:50,560
 

435
00:08:50,560 --> 00:08:52,949
running so you're gonna want to have you

436
00:08:52,949 --> 00:08:52,959
 

437
00:08:52,959 --> 00:08:54,240
know multiple threats access your data

438
00:08:54,240 --> 00:08:54,250
 

439
00:08:54,250 --> 00:08:55,800
structure at the same time and now you

440
00:08:55,800 --> 00:08:55,810
 

441
00:08:55,810 --> 00:08:58,139
need to protect its contents both at a

442
00:08:58,139 --> 00:08:58,149
 

443
00:08:58,149 --> 00:09:00,510
logical level and a physical level to

444
00:09:00,510 --> 00:09:00,520
 

445
00:09:00,520 --> 00:09:01,920
make sure that one thread doesn't write

446
00:09:01,920 --> 00:09:01,930
 

447
00:09:01,930 --> 00:09:03,329
something that another thread is reading

448
00:09:03,329 --> 00:09:03,339
 

449
00:09:03,339 --> 00:09:06,090
and get and it gets corrupted data so by

450
00:09:06,090 --> 00:09:06,100
 

451
00:09:06,100 --> 00:09:07,590
logical versus physical what I would

452
00:09:07,590 --> 00:09:07,600
 

453
00:09:07,600 --> 00:09:09,540
mean is the physical data structure

454
00:09:09,540 --> 00:09:09,550
 

455
00:09:09,550 --> 00:09:11,699
would be again the underlying bits that

456
00:09:11,699 --> 00:09:11,709
 

457
00:09:11,709 --> 00:09:12,990
are stored inside of the data structure

458
00:09:12,990 --> 00:09:13,000
 

459
00:09:13,000 --> 00:09:15,569
and we don't want to modify something

460
00:09:15,569 --> 00:09:15,579
 

461
00:09:15,579 --> 00:09:16,889
that calls us to have an out a pointer

462
00:09:16,889 --> 00:09:16,899
 

463
00:09:16,899 --> 00:09:19,560
to an invalid memory location all right

464
00:09:19,560 --> 00:09:19,570
 

465
00:09:19,570 --> 00:09:20,610
that's what people normally think about

466
00:09:20,610 --> 00:09:20,620
 

467
00:09:20,620 --> 00:09:23,100
when they think about allowing willful

468
00:09:23,100 --> 00:09:23,110
 

469
00:09:23,110 --> 00:09:25,889
threads to access a data structure and

470
00:09:25,889 --> 00:09:25,899
 

471
00:09:25,899 --> 00:09:27,240
we can protect you know we can protect

472
00:09:27,240 --> 00:09:27,250
 

473
00:09:27,250 --> 00:09:29,720
the data structure using latches the

474
00:09:29,720 --> 00:09:29,730
 

475
00:09:29,730 --> 00:09:31,769
logical contents of protecting the

476
00:09:31,769 --> 00:09:31,779
 

477
00:09:31,779 --> 00:09:33,210
logical contents of the data structure

478
00:09:33,210 --> 00:09:33,220

479
00:09:33,220 --> 00:09:36,930
has to do with things like what queries

480
00:09:36,930 --> 00:09:36,940

481
00:09:36,940 --> 00:09:38,040
are actually seeing while they're

482
00:09:38,040 --> 00:09:38,050
 

483
00:09:38,050 --> 00:09:40,650
running while other queries are running

484
00:09:40,650 --> 00:09:40,660
 

485
00:09:40,660 --> 00:09:42,750
at the same time so this is a more

486
00:09:42,750 --> 00:09:42,760
 

487
00:09:42,760 --> 00:09:44,430
complicated nuanced topic we'll cover

488
00:09:44,430 --> 00:09:44,440
 

489
00:09:44,440 --> 00:09:45,510
much later on when we talk about

490
00:09:45,510 --> 00:09:45,520
 

491
00:09:45,520 --> 00:09:47,370
transactions the way to sort of think

492
00:09:47,370 --> 00:09:47,380
 

493
00:09:47,380 --> 00:09:48,960
about this is a simple example would be

494
00:09:48,960 --> 00:09:48,970
 

495
00:09:48,970 --> 00:09:52,800
say I had my query delete an entry in my

496
00:09:52,800 --> 00:09:52,810
 

497
00:09:52,810 --> 00:09:55,860
in my data structure my hash table if I

498
00:09:55,860 --> 00:09:55,870
 

499
00:09:55,870 --> 00:09:57,569
go back and check to see whether that

500
00:09:57,569 --> 00:09:57,579
 

501
00:09:57,579 --> 00:09:59,460
key is still there it better not come

502
00:09:59,460 --> 00:09:59,470
 

503
00:09:59,470 --> 00:10:01,470
back and say it's it's still there right

504
00:10:01,470 --> 00:10:01,480
 

505
00:10:01,480 --> 00:10:02,880
physically could still be there because

506
00:10:02,880 --> 00:10:02,890
 

507
00:10:02,890 --> 00:10:04,170
maybe the data structure is going to

508
00:10:04,170 --> 00:10:04,180
 

509
00:10:04,180 --> 00:10:05,519
remove it later on with a garbage

510
00:10:05,519 --> 00:10:05,529
 

511
00:10:05,529 --> 00:10:09,120
collection process but the the the bits

512
00:10:09,120 --> 00:10:09,130
 

513
00:10:09,130 --> 00:10:10,530
are still there but logically we don't

514
00:10:10,530 --> 00:10:10,540
 

515
00:10:10,540 --> 00:10:13,230
see it so there's a whole bunch of other

516
00:10:13,230 --> 00:10:13,240
 

517
00:10:13,240 --> 00:10:14,699
mechanisms we're gonna need to protect

518
00:10:14,699 --> 00:10:14,709
 

519
00:10:14,709 --> 00:10:16,110
these data structures to make sure this

520
00:10:16,110 --> 00:10:16,120
 

521
00:10:16,120 --> 00:10:18,680
occurs and we'll cover this actually on

522
00:10:18,680 --> 00:10:18,690

523
00:10:18,690 --> 00:10:20,760
Wednesday next week and let's see this

524
00:10:20,760 --> 00:10:20,770
 

525
00:10:20,770 --> 00:10:21,920
more in detail when we talk about

526
00:10:21,920 --> 00:10:21,930
 

527
00:10:21,930 --> 00:10:25,050
transactions and control so our purpose

528
00:10:25,050 --> 00:10:25,060
 

529
00:10:25,060 --> 00:10:26,370
here for this discussion is really going

530
00:10:26,370 --> 00:10:26,380
 

531
00:10:26,380 --> 00:10:28,050
to focus on the first one here and we're

532
00:10:28,050 --> 00:10:28,060
 

533
00:10:28,060 --> 00:10:29,639
the first design decision and we're just

534
00:10:29,639 --> 00:10:29,649
 

535
00:10:29,649 --> 00:10:31,710
going to assume that we have a single

536
00:10:31,710 --> 00:10:31,720
 

537
00:10:31,720 --> 00:10:33,810
thread accessing our our data structure

538
00:10:33,810 --> 00:10:33,820

539
00:10:33,820 --> 00:10:37,650
it makes things much much easier so our

540
00:10:37,650 --> 00:10:37,660
 

541
00:10:37,660 --> 00:10:41,189
focus today is on hash tables so the at

542
00:10:41,189 --> 00:10:41,199
 

543
00:10:41,199 --> 00:10:42,630
a high level a hash table

544
00:10:42,630 --> 00:10:42,640
 

545
00:10:42,640 --> 00:10:44,180
it's gonna provide you with a

546
00:10:44,180 --> 00:10:44,190
 

547
00:10:44,190 --> 00:10:46,949
associative array interface that is

548
00:10:46,949 --> 00:10:46,959
 

549
00:10:46,959 --> 00:10:50,579
gonna map keys to values right for some

550
00:10:50,579 --> 00:10:50,589
 

551
00:10:50,589 --> 00:10:52,860
arbitrary key we want to map it to a

552
00:10:52,860 --> 00:10:52,870
 

553
00:10:52,870 --> 00:10:55,470
value if you're familiar with Python

554
00:10:55,470 --> 00:10:55,480
 

555
00:10:55,480 --> 00:10:57,150
it's the dick data structure the

556
00:10:57,150 --> 00:10:57,160
 

557
00:10:57,160 --> 00:10:58,620
dictionary data structure same thing if

558
00:10:58,620 --> 00:10:58,630

559
00:10:58,630 --> 00:11:00,720
you've written Java it's the Java hash

560
00:11:00,720 --> 00:11:00,730
 

561
00:11:00,730 --> 00:11:02,940
map class and the same idea keys to

562
00:11:02,940 --> 00:11:02,950
 

563
00:11:02,950 --> 00:11:07,800
values so the sort of chord concept of

564
00:11:07,800 --> 00:11:07,810
 

565
00:11:07,810 --> 00:11:08,910
how this is all going to work is that

566
00:11:08,910 --> 00:11:08,920
 

567
00:11:08,920 --> 00:11:10,940
we're going to have a hash function that

568
00:11:10,940 --> 00:11:10,950
 

569
00:11:10,950 --> 00:11:14,790
we can use to compute some location or

570
00:11:14,790 --> 00:11:14,800
 

571
00:11:14,800 --> 00:11:19,350
offset in a in dissociative array that

572
00:11:19,350 --> 00:11:19,360
 

573
00:11:19,360 --> 00:11:21,449
will that can point us to the value that

574
00:11:21,449 --> 00:11:21,459
 

575
00:11:21,459 --> 00:11:24,509
we're looking for for our given key so

576
00:11:24,509 --> 00:11:24,519
 

577
00:11:24,519 --> 00:11:26,519
the the absolute easiest way to

578
00:11:26,519 --> 00:11:26,529
 

579
00:11:26,529 --> 00:11:29,880
implement a hash hash table is what is

580
00:11:29,880 --> 00:11:29,890
 

581
00:11:29,890 --> 00:11:32,460
called a static hash table so think of

582
00:11:32,460 --> 00:11:32,470
 

583
00:11:32,470 --> 00:11:37,100
this is just a giant array of slots and

584
00:11:37,100 --> 00:11:37,110
 

585
00:11:37,110 --> 00:11:39,120
for this we're going to assume that the

586
00:11:39,120 --> 00:11:39,130
 

587
00:11:39,130 --> 00:11:42,000
values we want to store in our and our

588
00:11:42,000 --> 00:11:42,010
 

589
00:11:42,010 --> 00:11:44,340
hash table are fixed length so we know

590
00:11:44,340 --> 00:11:44,350
 

591
00:11:44,350 --> 00:11:47,850
that the the offset at every location we

592
00:11:47,850 --> 00:11:47,860
 

593
00:11:47,860 --> 00:11:49,380
know how to jump to it based on you know

594
00:11:49,380 --> 00:11:49,390
 

595
00:11:49,390 --> 00:11:51,030
whether we want the tenth item or the

596
00:11:51,030 --> 00:11:51,040
 

597
00:11:51,040 --> 00:11:52,470
hundred item we know how to do that

598
00:11:52,470 --> 00:11:52,480
 

599
00:11:52,480 --> 00:11:54,030
rithmetic to jump to that memory

600
00:11:54,030 --> 00:11:54,040
 

601
00:11:54,040 --> 00:11:56,939
location so what will happen is that

602
00:11:56,939 --> 00:11:56,949
 

603
00:11:56,949 --> 00:11:59,180
we'll just have some hash function and

604
00:11:59,180 --> 00:11:59,190
 

605
00:11:59,190 --> 00:12:01,710
it'll for the given key we want to look

606
00:12:01,710 --> 00:12:01,720
 

607
00:12:01,720 --> 00:12:03,030
up the simple hash function could just

608
00:12:03,030 --> 00:12:03,040
 

609
00:12:03,040 --> 00:12:06,269
take the key and the bits and modify the

610
00:12:06,269 --> 00:12:06,279
 

611
00:12:06,279 --> 00:12:08,160
number of elements that we have so we

612
00:12:08,160 --> 00:12:08,170
 

613
00:12:08,170 --> 00:12:10,050
just order these different slots from 0

614
00:12:10,050 --> 00:12:10,060

615
00:12:10,060 --> 00:12:13,019
to n assuming that we have and n keys

616
00:12:13,019 --> 00:12:13,029
 

617
00:12:13,029 --> 00:12:15,090
that we want to store and then now we

618
00:12:15,090 --> 00:12:15,100
 

619
00:12:15,100 --> 00:12:16,860
want to store something again we just

620
00:12:16,860 --> 00:12:16,870
 

621
00:12:16,870 --> 00:12:18,780
hash the key and then we can dump the

622
00:12:18,780 --> 00:12:18,790
 

623
00:12:18,790 --> 00:12:21,800
value inside of there right

624
00:12:21,800 --> 00:12:21,810
 

625
00:12:21,810 --> 00:12:23,880
super simple this is the easiest hash

626
00:12:23,880 --> 00:12:23,890
 

627
00:12:23,890 --> 00:12:26,160
table you could actually build what are

628
00:12:26,160 --> 00:12:26,170

629
00:12:26,170 --> 00:12:29,790
some obvious problems with this what

630
00:12:29,790 --> 00:12:29,800
 

631
00:12:29,800 --> 00:12:33,689
assumptions did I make no collisions but

632
00:12:33,689 --> 00:12:33,699
 

633
00:12:33,699 --> 00:12:37,120
why would it be no collisions

634
00:12:37,120 --> 00:12:37,130


635
00:12:37,130 --> 00:12:41,140
first of all what is a collision right

636
00:12:41,140 --> 00:12:41,150
 

637
00:12:41,150 --> 00:12:43,150
he said the same key hashes the same the

638
00:12:43,150 --> 00:12:43,160
 

639
00:12:43,160 --> 00:12:45,820
same officer in AI array so why am i

640
00:12:45,820 --> 00:12:45,830
 

641
00:12:45,830 --> 00:12:52,080
assuming that there's no collisions

642
00:12:52,080 --> 00:12:52,090


643
00:12:52,090 --> 00:12:54,370
because I'm assuming I know exactly the

644
00:12:54,370 --> 00:12:54,380
 

645
00:12:54,380 --> 00:12:57,460
number of keys I want to store n right

646
00:12:57,460 --> 00:12:57,470
 

647
00:12:57,470 --> 00:13:00,040
and I just take every key and just mod

648
00:13:00,040 --> 00:13:00,050
 

649
00:13:00,050 --> 00:13:01,630
by n it's gonna put me in the same

650
00:13:01,630 --> 00:13:01,640
 

651
00:13:01,640 --> 00:13:03,940
location right it's sort of real simple

652
00:13:03,940 --> 00:13:03,950
 

653
00:13:03,950 --> 00:13:06,220
case they're here the other big

654
00:13:06,220 --> 00:13:06,230
 

655
00:13:06,230 --> 00:13:09,310
assumption is that my values are fixed

656
00:13:09,310 --> 00:13:09,320
 

657
00:13:09,320 --> 00:13:12,000
length so I know how to jump exactly to

658
00:13:12,000 --> 00:13:12,010
 

659
00:13:12,010 --> 00:13:14,710
the location that I want so that's not a

660
00:13:14,710 --> 00:13:14,720
 

661
00:13:14,720 --> 00:13:17,200
big deal right to handle arbitrary

662
00:13:17,200 --> 00:13:17,210
 

663
00:13:17,210 --> 00:13:19,090
length keys all we have to do is sort of

664
00:13:19,090 --> 00:13:19,100
 

665
00:13:19,100 --> 00:13:20,410
have this sort of separate storage

666
00:13:20,410 --> 00:13:20,420
 

667
00:13:20,420 --> 00:13:23,080
location over here and now our giant

668
00:13:23,080 --> 00:13:23,090

669
00:13:23,090 --> 00:13:25,930
array doesn't actually contain values it

670
00:13:25,930 --> 00:13:25,940

671
00:13:25,940 --> 00:13:28,420
contains pointers to some other memory

672
00:13:28,420 --> 00:13:28,430
 

673
00:13:28,430 --> 00:13:30,220
location or some other page location

674
00:13:30,220 --> 00:13:30,230

675
00:13:30,230 --> 00:13:34,470
that has the values that we want right

676
00:13:34,470 --> 00:13:34,480
 

677
00:13:34,480 --> 00:13:37,750
so again we the problems with this

678
00:13:37,750 --> 00:13:37,760
 

679
00:13:37,760 --> 00:13:39,250
approach is that we assume that we know

680
00:13:39,250 --> 00:13:39,260
 

681
00:13:39,260 --> 00:13:42,160
the exact number keys that we had ahead

682
00:13:42,160 --> 00:13:42,170
 

683
00:13:42,170 --> 00:13:44,710
of time we also assumed that all the

684
00:13:44,710 --> 00:13:44,720
 

685
00:13:44,720 --> 00:13:47,590
keys would be unique which in many cases

686
00:13:47,590 --> 00:13:47,600
 

687
00:13:47,600 --> 00:13:50,680
it's not going to be and at this point

688
00:13:50,680 --> 00:13:50,690
 

689
00:13:50,690 --> 00:13:53,500
we don't have any way to handle that and

690
00:13:53,500 --> 00:13:53,510
 

691
00:13:53,510 --> 00:13:56,140
also assume that we had what is called a

692
00:13:56,140 --> 00:13:56,150
 

693
00:13:56,150 --> 00:13:58,450
perfect hash function so a perfect hash

694
00:13:58,450 --> 00:13:58,460
 

695
00:13:58,460 --> 00:14:01,500
function is a theoretical function that

696
00:14:01,500 --> 00:14:01,510
 

697
00:14:01,510 --> 00:14:04,780
given two keys that don't actually are

698
00:14:04,780 --> 00:14:04,790
 

699
00:14:04,790 --> 00:14:07,800
not equal to each other the the hash

700
00:14:07,800 --> 00:14:07,810
 

701
00:14:07,810 --> 00:14:09,640
generally about our perfect hash

702
00:14:09,640 --> 00:14:09,650
 

703
00:14:09,650 --> 00:14:14,650
function will not be equal either right

704
00:14:14,650 --> 00:14:14,660
 

705
00:14:14,660 --> 00:14:16,150
you sort of think of this there's like

706
00:14:16,150 --> 00:14:16,160
 

707
00:14:16,160 --> 00:14:17,680
if hey my domain of every single

708
00:14:17,680 --> 00:14:17,690
 

709
00:14:17,690 --> 00:14:19,840
possible key I could ever have I can

710
00:14:19,840 --> 00:14:19,850
 

711
00:14:19,850 --> 00:14:22,630
have a unique hash output or hash value

712
00:14:22,630 --> 00:14:22,640
 

713
00:14:22,640 --> 00:14:26,140
for every single key again these exist

714
00:14:26,140 --> 00:14:26,150
 

715
00:14:26,150 --> 00:14:27,730
in literature in theory you can just

716
00:14:27,730 --> 00:14:27,740
 

717
00:14:27,740 --> 00:14:29,950
build this with an additional hash table

718
00:14:29,950 --> 00:14:29,960
 

719
00:14:29,960 --> 00:14:32,410
or additional giant giant you know

720
00:14:32,410 --> 00:14:32,420
 

721
00:14:32,420 --> 00:14:35,260
slotted array map but in practice nobody

722
00:14:35,260 --> 00:14:35,270

723
00:14:35,270 --> 00:14:36,610
actually does this because this be very

724
00:14:36,610 --> 00:14:36,620

725
00:14:36,620 --> 00:14:40,240
expensive to maintain so the way one

726
00:14:40,240 --> 00:14:40,250
 

727
00:14:40,250 --> 00:14:44,470
handle do this is by approximating

728
00:14:44,470 --> 00:14:44,480


729
00:14:44,480 --> 00:14:47,050
so the two design decisions we're going

730
00:14:47,050 --> 00:14:47,060
 

731
00:14:47,060 --> 00:14:49,930
to have in our hashed hash table is what

732
00:14:49,930 --> 00:14:49,940

733
00:14:49,940 --> 00:14:51,820
hash function we want to use and what

734
00:14:51,820 --> 00:14:51,830
 

735
00:14:51,830 --> 00:14:53,920
hashing scheme we want to use and I

736
00:14:53,920 --> 00:14:53,930
 

737
00:14:53,930 --> 00:14:55,360
would say that the combination of these

738
00:14:55,360 --> 00:14:55,370
 

739
00:14:55,370 --> 00:14:57,430
two things is actually what defines a

740
00:14:57,430 --> 00:14:57,440
 

741
00:14:57,440 --> 00:15:00,310
hash table right when you say I have a

742
00:15:00,310 --> 00:15:00,320
 

743
00:15:00,320 --> 00:15:02,470
hash table implementation it's you have

744
00:15:02,470 --> 00:15:02,480
 

745
00:15:02,480 --> 00:15:05,770
to you have these two things so the hash

746
00:15:05,770 --> 00:15:05,780
 

747
00:15:05,780 --> 00:15:07,060
function the way think about this again

748
00:15:07,060 --> 00:15:07,070
 

749
00:15:07,070 --> 00:15:10,680
is we want to take a large key space of

750
00:15:10,680 --> 00:15:10,690

751
00:15:10,690 --> 00:15:13,540
every possible key b1 or store and we

752
00:15:13,540 --> 00:15:13,550
 

753
00:15:13,550 --> 00:15:17,230
want to map it to a smaller domain right

754
00:15:17,230 --> 00:15:17,240
 

755
00:15:17,240 --> 00:15:18,160
and the reason why I want to do this

756
00:15:18,160 --> 00:15:18,170
 

757
00:15:18,170 --> 00:15:19,570
because otherwise we have that store I

758
00:15:19,570 --> 00:15:19,580
 

759
00:15:19,580 --> 00:15:21,160
don't have a perfect hash function or

760
00:15:21,160 --> 00:15:21,170
 

761
00:15:21,170 --> 00:15:24,730
store you know a potential slot for

762
00:15:24,730 --> 00:15:24,740
 

763
00:15:24,740 --> 00:15:27,880
every single key you could ever see so

764
00:15:27,880 --> 00:15:27,890
 

765
00:15:27,890 --> 00:15:29,500
for this the big trade-off is when we

766
00:15:29,500 --> 00:15:29,510
 

767
00:15:29,510 --> 00:15:31,360
talk about how what hash function we

768
00:15:31,360 --> 00:15:31,370
 

769
00:15:31,370 --> 00:15:33,250
actually want to use is gonna be this

770
00:15:33,250 --> 00:15:33,260
 

771
00:15:33,260 --> 00:15:35,560
this trade-off between how fast our hash

772
00:15:35,560 --> 00:15:35,570
 

773
00:15:35,570 --> 00:15:37,210
function is and versus what our

774
00:15:37,210 --> 00:15:37,220
 

775
00:15:37,220 --> 00:15:39,580
collision rate is right because again

776
00:15:39,580 --> 00:15:39,590
 

777
00:15:39,590 --> 00:15:41,470
we're doing this running queries we're

778
00:15:41,470 --> 00:15:41,480
 

779
00:15:41,480 --> 00:15:43,930
doing this while we're you know trying

780
00:15:43,930 --> 00:15:43,940

781
00:15:43,940 --> 00:15:45,880
to access pages and our page table we

782
00:15:45,880 --> 00:15:45,890
 

783
00:15:45,890 --> 00:15:47,170
want our hash function to be really fast

784
00:15:47,170 --> 00:15:47,180
 

785
00:15:47,180 --> 00:15:48,460
cuz you don't want to have to maybe you

786
00:15:48,460 --> 00:15:48,470
 

787
00:15:48,470 --> 00:15:49,960
know do this huge traversal and long

788
00:15:49,960 --> 00:15:49,970
 

789
00:15:49,970 --> 00:15:52,720
lookup just to figure out where the key

790
00:15:52,720 --> 00:15:52,730
 

791
00:15:52,730 --> 00:15:55,150
is that we want in our hash table so you

792
00:15:55,150 --> 00:15:55,160
 

793
00:15:55,160 --> 00:15:57,280
want to be really fast but then we don't

794
00:15:57,280 --> 00:15:57,290
 

795
00:15:57,290 --> 00:15:59,380
want to have all our keys mapped to the

796
00:15:59,380 --> 00:15:59,390
 

797
00:15:59,390 --> 00:16:02,380
same location because as I'll see in a

798
00:16:02,380 --> 00:16:02,390
 

799
00:16:02,390 --> 00:16:03,520
second depending on your hashing scheme

800
00:16:03,520 --> 00:16:03,530
 

801
00:16:03,530 --> 00:16:05,410
this isn't required you to do

802
00:16:05,410 --> 00:16:05,420
 

803
00:16:05,420 --> 00:16:07,150
essentially a scruncho scan to find the

804
00:16:07,150 --> 00:16:07,160
 

805
00:16:07,160 --> 00:16:09,640
thing that you're looking for so what's

806
00:16:09,640 --> 00:16:09,650
 

807
00:16:09,650 --> 00:16:11,320
this what's the fastest hash function

808
00:16:11,320 --> 00:16:11,330

809
00:16:11,330 --> 00:16:15,280
you could ever possibly build what's the

810
00:16:15,280 --> 00:16:15,290
 

811
00:16:15,290 --> 00:16:17,910
dumbest fastest hash function yes

812
00:16:17,910 --> 00:16:17,920

813
00:16:17,920 --> 00:16:20,320
exactly always she said always return a

814
00:16:20,320 --> 00:16:20,330
 

815
00:16:20,330 --> 00:16:21,730
number I'll make it even easier always

816
00:16:21,730 --> 00:16:21,740
 

817
00:16:21,740 --> 00:16:24,310
return one so every single possible key

818
00:16:24,310 --> 00:16:24,320
 

819
00:16:24,320 --> 00:16:26,290
no matter you know what name you have in

820
00:16:26,290 --> 00:16:26,300
 

821
00:16:26,300 --> 00:16:28,630
the directory what email address it is

822
00:16:28,630 --> 00:16:28,640
 

823
00:16:28,640 --> 00:16:30,610
always returns one it's super fast

824
00:16:30,610 --> 00:16:30,620
 

825
00:16:30,620 --> 00:16:32,860
because it's just return one the problem

826
00:16:32,860 --> 00:16:32,870
 

827
00:16:32,870 --> 00:16:35,050
is collision rate is abysmal because

828
00:16:35,050 --> 00:16:35,060
 

829
00:16:35,060 --> 00:16:36,490
everybody's gonna map to one it's gonna

830
00:16:36,490 --> 00:16:36,500
 

831
00:16:36,500 --> 00:16:39,610
map to the same location in our in our

832
00:16:39,610 --> 00:16:39,620

833
00:16:39,620 --> 00:16:41,770
array so we want to be able to smarter

834
00:16:41,770 --> 00:16:41,780
 

835
00:16:41,780 --> 00:16:43,090
about this and that this is what we can

836
00:16:43,090 --> 00:16:43,100
 

837
00:16:43,100 --> 00:16:45,360
have different hash functions do for us

838
00:16:45,360 --> 00:16:45,370
 

839
00:16:45,370 --> 00:16:47,380
the next decision we have to make is the

840
00:16:47,380 --> 00:16:47,390
 

841
00:16:47,390 --> 00:16:49,210
hashing scheme and this is essentially

842
00:16:49,210 --> 00:16:49,220
 

843
00:16:49,220 --> 00:16:50,970
how we're going to handle collisions

844
00:16:50,970 --> 00:16:50,980
 

845
00:16:50,980 --> 00:16:52,900
which are gonna be unavoidable because

846
00:16:52,900 --> 00:16:52,910
 

847
00:16:52,910 --> 00:16:54,250
we don't have a perfect cache function

848
00:16:54,250 --> 00:16:54,260
 

849
00:16:54,260 --> 00:16:56,050
and we're not trying to store a giant

850
00:16:56,050 --> 00:16:56,060
 

851
00:16:56,060 --> 00:16:57,910
array they could handle every possible

852
00:16:57,910 --> 00:16:57,920
 

853
00:16:57,920 --> 00:16:58,240
slow

854
00:16:58,240 --> 00:16:58,250

855
00:16:58,250 --> 00:17:00,940
Franky's so you want to have a a hashing

856
00:17:00,940 --> 00:17:00,950
 

857
00:17:00,950 --> 00:17:02,770
scheme that describes exactly what

858
00:17:02,770 --> 00:17:02,780

859
00:17:02,780 --> 00:17:04,390
method our heuristic we're going to use

860
00:17:04,390 --> 00:17:04,400
 

861
00:17:04,400 --> 00:17:09,130
to handle collisions when they occur and

862
00:17:09,130 --> 00:17:09,140
 

863
00:17:09,140 --> 00:17:11,079
again for this the trade off is going to

864
00:17:11,079 --> 00:17:11,089
 

865
00:17:11,089 --> 00:17:12,699
be almost the classic computer science

866
00:17:12,699 --> 00:17:12,709
 

867
00:17:12,709 --> 00:17:16,350
trade-off where we're going to sacrifice

868
00:17:16,350 --> 00:17:16,360
 

869
00:17:16,360 --> 00:17:20,290
or give allow us to use less memory to

870
00:17:20,290 --> 00:17:20,300
 

871
00:17:20,300 --> 00:17:22,420
store a hash table in exchange for

872
00:17:22,420 --> 00:17:22,430
 

873
00:17:22,430 --> 00:17:24,970
having to execute more instructions to

874
00:17:24,970 --> 00:17:24,980
 

875
00:17:24,980 --> 00:17:26,740
deal with collisions when they occur and

876
00:17:26,740 --> 00:17:26,750

877
00:17:26,750 --> 00:17:30,070
again if I just had a I could build my

878
00:17:30,070 --> 00:17:30,080
 

879
00:17:30,080 --> 00:17:33,100
hash map that's two to the 64 possible

880
00:17:33,100 --> 00:17:33,110
 

881
00:17:33,110 --> 00:17:35,050
entries that possibly take all the

882
00:17:35,050 --> 00:17:35,060
 

883
00:17:35,060 --> 00:17:37,210
memory I have in my single machine I'll

884
00:17:37,210 --> 00:17:37,220
 

885
00:17:37,220 --> 00:17:38,740
never have a collision so the number

886
00:17:38,740 --> 00:17:38,750
 

887
00:17:38,750 --> 00:17:39,970
instructions I have to execute they deal

888
00:17:39,970 --> 00:17:39,980
 

889
00:17:39,980 --> 00:17:41,500
with collisions will be will be minimal

890
00:17:41,500 --> 00:17:41,510
 

891
00:17:41,510 --> 00:17:44,110
but I've allocated that all that memory

892
00:17:44,110 --> 00:17:44,120
 

893
00:17:44,120 --> 00:17:46,060
and now I can't do anything else not in

894
00:17:46,060 --> 00:17:46,070
 

895
00:17:46,070 --> 00:17:48,550
my machine right so again this is

896
00:17:48,550 --> 00:17:48,560
 

897
00:17:48,560 --> 00:17:49,870
classic trade-off that we want that we

898
00:17:49,870 --> 00:17:49,880
 

899
00:17:49,880 --> 00:17:52,210
want to handle one I do not want to get

900
00:17:52,210 --> 00:17:52,220
 

901
00:17:52,220 --> 00:17:53,560
better with Windows and do not want

902
00:17:53,560 --> 00:17:53,570
 

903
00:17:53,570 --> 00:17:57,790
update okay so for today we're going to

904
00:17:57,790 --> 00:17:57,800
 

905
00:17:57,800 --> 00:17:58,780
turn up talking about the different type

906
00:17:58,780 --> 00:17:58,790
 

907
00:17:58,790 --> 00:18:00,100
of hash functions you can possibly have

908
00:18:00,100 --> 00:18:00,110
 

909
00:18:00,110 --> 00:18:02,830
and this isn't you know this is not an

910
00:18:02,830 --> 00:18:02,840
 

911
00:18:02,840 --> 00:18:04,030
algorithms class this is not a

912
00:18:04,030 --> 00:18:04,040
 

913
00:18:04,040 --> 00:18:05,980
cryptography class so we don't really

914
00:18:05,980 --> 00:18:05,990
 

915
00:18:05,990 --> 00:18:07,630
care how it's actually implemented we're

916
00:18:07,630 --> 00:18:07,640
 

917
00:18:07,640 --> 00:18:09,670
more interested in the the properties

918
00:18:09,670 --> 00:18:09,680
 

919
00:18:09,680 --> 00:18:12,760
that they have and then we'll talk about

920
00:18:12,760 --> 00:18:12,770
 

921
00:18:12,770 --> 00:18:14,080
the two different types of hashing

922
00:18:14,080 --> 00:18:14,090
 

923
00:18:14,090 --> 00:18:15,310
schemes that you can have you can have

924
00:18:15,310 --> 00:18:15,320
 

925
00:18:15,320 --> 00:18:17,110
static hashing and dynamic hashing and

926
00:18:17,110 --> 00:18:17,120
 

927
00:18:17,120 --> 00:18:20,710
the extent just you know as a ground you

928
00:18:20,710 --> 00:18:20,720

929
00:18:20,720 --> 00:18:22,030
guys what we're talking about the

930
00:18:22,030 --> 00:18:22,040
 

931
00:18:22,040 --> 00:18:24,430
extendable hashing is an example of a

932
00:18:24,430 --> 00:18:24,440
 

933
00:18:24,440 --> 00:18:29,710
diamond dynamic hashing scheme okay okay

934
00:18:29,710 --> 00:18:29,720
 

935
00:18:29,720 --> 00:18:35,220
so for a hash function

936
00:18:35,220 --> 00:18:35,230


937
00:18:35,230 --> 00:18:37,360
can anybody give me an example of a hash

938
00:18:37,360 --> 00:18:37,370
 

939
00:18:37,370 --> 00:18:39,610
function area with the one that needed

940
00:18:39,610 --> 00:18:39,620
 

941
00:18:39,620 --> 00:18:41,320
used in you know at an internship or

942
00:18:41,320 --> 00:18:41,330
 

943
00:18:41,330 --> 00:18:49,390
further projects other than STD hash crc

944
00:18:49,390 --> 00:18:49,400
 

945
00:18:49,400 --> 00:18:53,340
yes that's a good one

946
00:18:53,340 --> 00:18:53,350


947
00:18:53,350 --> 00:18:57,610
sha-256 perfect example okay so CRC is

948
00:18:57,610 --> 00:18:57,620
 

949
00:18:57,620 --> 00:19:00,460
is a non cryptographic hash right you

950
00:19:00,460 --> 00:19:00,470

951
00:19:00,470 --> 00:19:01,960
can take some arbitrary byte stream and

952
00:19:01,960 --> 00:19:01,970
 

953
00:19:01,970 --> 00:19:04,810
it'll generate you a a you know a hash

954
00:19:04,810 --> 00:19:04,820
 

955
00:19:04,820 --> 00:19:08,680
function he said sha-256 sha-256 is a

956
00:19:08,680 --> 00:19:08,690
 

957
00:19:08,690 --> 00:19:11,260
cryptographic hash function we don't and

958
00:19:11,260 --> 00:19:11,270
 

959
00:19:11,270 --> 00:19:11,800
has certain

960
00:19:11,800 --> 00:19:11,810

961
00:19:11,810 --> 00:19:13,720
properties that it's not gonna leak data

962
00:19:13,720 --> 00:19:13,730
 

963
00:19:13,730 --> 00:19:15,570
either the more keys that you give it

964
00:19:15,570 --> 00:19:15,580
 

965
00:19:15,580 --> 00:19:18,000
right and it's very difficult to reverse

966
00:19:18,000 --> 00:19:18,010
 

967
00:19:18,010 --> 00:19:20,200
we don't care about security on the

968
00:19:20,200 --> 00:19:20,210
 

969
00:19:20,210 --> 00:19:22,840
inside of our system right the caveat

970
00:19:22,840 --> 00:19:22,850
 

971
00:19:22,850 --> 00:19:24,490
that for our eternal data structures

972
00:19:24,490 --> 00:19:24,500
 

973
00:19:24,500 --> 00:19:26,950
that the information is never gonna be

974
00:19:26,950 --> 00:19:26,960
 

975
00:19:26,960 --> 00:19:28,870
exposed to the outside world we don't

976
00:19:28,870 --> 00:19:28,880
 

977
00:19:28,880 --> 00:19:30,880
care about cybersecurity or don't care

978
00:19:30,880 --> 00:19:30,890
 

979
00:19:30,890 --> 00:19:33,010
about cryptography inside of this so

980
00:19:33,010 --> 00:19:33,020
 

981
00:19:33,020 --> 00:19:35,230
sha-256 is an overkill for what we want

982
00:19:35,230 --> 00:19:35,240
 

983
00:19:35,240 --> 00:19:37,540
first of all it's expensive it's you

984
00:19:37,540 --> 00:19:37,550
 

985
00:19:37,550 --> 00:19:39,700
know it's more expensive than crc32

986
00:19:39,700 --> 00:19:39,710
 

987
00:19:39,710 --> 00:19:42,220
which is a single instruction on on x86

988
00:19:42,220 --> 00:19:42,230
 

989
00:19:42,230 --> 00:19:45,880
CPUs and it actually can reverse it if

990
00:19:45,880 --> 00:19:45,890
 

991
00:19:45,890 --> 00:19:47,560
you have the public the public private

992
00:19:47,560 --> 00:19:47,570
 

993
00:19:47,570 --> 00:19:48,850
key you can take a shot to v6 and

994
00:19:48,850 --> 00:19:48,860
 

995
00:19:48,860 --> 00:19:50,470
reverse it right we don't care about

996
00:19:50,470 --> 00:19:50,480
 

997
00:19:50,480 --> 00:19:52,030
reversing it we just want to know what

998
00:19:52,030 --> 00:19:52,040
 

999
00:19:52,040 --> 00:19:55,120
what offset do we jump to in our you

1000
00:19:55,120 --> 00:19:55,130

1001
00:19:55,130 --> 00:19:58,300
know in in our and our and our table so

1002
00:19:58,300 --> 00:19:58,310
 

1003
00:19:58,310 --> 00:19:59,800
we don't want to use cryptographic hash

1004
00:19:59,800 --> 00:19:59,810
 

1005
00:19:59,810 --> 00:20:01,060
function we have something we want

1006
00:20:01,060 --> 00:20:01,070

1007
00:20:01,070 --> 00:20:02,860
something that's fast and something that

1008
00:20:02,860 --> 00:20:02,870
 

1009
00:20:02,870 --> 00:20:05,440
provides us with a local Asian rate so

1010
00:20:05,440 --> 00:20:05,450
 

1011
00:20:05,450 --> 00:20:07,390
crc32 is a good example and we'll see

1012
00:20:07,390 --> 00:20:07,400
 

1013
00:20:07,400 --> 00:20:08,680
some other ones from Google and some

1014
00:20:08,680 --> 00:20:08,690
 

1015
00:20:08,690 --> 00:20:12,010
other people that are pretty common so

1016
00:20:12,010 --> 00:20:12,020
 

1017
00:20:12,020 --> 00:20:17,250
the I should actually conclude crc32

1018
00:20:17,250 --> 00:20:17,260
 

1019
00:20:17,260 --> 00:20:20,220
next year I'll I'm opponent but the

1020
00:20:20,220 --> 00:20:20,230
 

1021
00:20:20,230 --> 00:20:22,240
these are some of the most common hash

1022
00:20:22,240 --> 00:20:22,250
 

1023
00:20:22,250 --> 00:20:23,530
functions that are used in real systems

1024
00:20:23,530 --> 00:20:23,540

1025
00:20:23,540 --> 00:20:26,440
today I will say the commercial guys and

1026
00:20:26,440 --> 00:20:26,450
 

1027
00:20:26,450 --> 00:20:28,240
Postgres and my sequel these are much

1028
00:20:28,240 --> 00:20:28,250

1029
00:20:28,250 --> 00:20:30,400
older systems so they have their own

1030
00:20:30,400 --> 00:20:30,410
 

1031
00:20:30,410 --> 00:20:34,240
custom hash function but most of the

1032
00:20:34,240 --> 00:20:34,250
 

1033
00:20:34,250 --> 00:20:35,890
data new data systems that I know about

1034
00:20:35,890 --> 00:20:35,900
 

1035
00:20:35,900 --> 00:20:38,100
that come out in last ten years or so

1036
00:20:38,100 --> 00:20:38,110
 

1037
00:20:38,110 --> 00:20:40,210
when I we talk to the developers they

1038
00:20:40,210 --> 00:20:40,220
 

1039
00:20:40,220 --> 00:20:42,160
tell us they're using one of these guys

1040
00:20:42,160 --> 00:20:42,170
 

1041
00:20:42,170 --> 00:20:45,130
here and these are all open source so

1042
00:20:45,130 --> 00:20:45,140
 

1043
00:20:45,140 --> 00:20:48,760
murmur hash came out in in 2008 it was

1044
00:20:48,760 --> 00:20:48,770
 

1045
00:20:48,770 --> 00:20:50,230
really put out with some random dude on

1046
00:20:50,230 --> 00:20:50,240
 

1047
00:20:50,240 --> 00:20:51,460
the internet posted on github or

1048
00:20:51,460 --> 00:20:51,470
 

1049
00:20:51,470 --> 00:20:53,080
something right and then people who sort

1050
00:20:53,080 --> 00:20:53,090
 

1051
00:20:53,090 --> 00:20:55,330
of picked it up and started using it it

1052
00:20:55,330 --> 00:20:55,340
 

1053
00:20:55,340 --> 00:20:58,060
is designed to be a fast general-purpose

1054
00:20:58,060 --> 00:20:58,070
 

1055
00:20:58,070 --> 00:20:59,410
hash function again these are one-way

1056
00:20:59,410 --> 00:20:59,420
 

1057
00:20:59,420 --> 00:21:00,610
hash functions where we gave him some

1058
00:21:00,610 --> 00:21:00,620
 

1059
00:21:00,620 --> 00:21:03,400
key it produces some output and in

1060
00:21:03,400 --> 00:21:03,410
 

1061
00:21:03,410 --> 00:21:06,100
theory if you saw enough of the keys a

1062
00:21:06,100 --> 00:21:06,110
 

1063
00:21:06,110 --> 00:21:08,590
key value pairs or keys to hashes you

1064
00:21:08,590 --> 00:21:08,600
 

1065
00:21:08,600 --> 00:21:10,060
could reverse it but we don't care about

1066
00:21:10,060 --> 00:21:10,070
 

1067
00:21:10,070 --> 00:21:11,470
that right we're not we're not worried

1068
00:21:11,470 --> 00:21:11,480
 

1069
00:21:11,480 --> 00:21:12,760
about leaking any information because

1070
00:21:12,760 --> 00:21:12,770
 

1071
00:21:12,770 --> 00:21:15,760
it's all internal so murmur hash again

1072
00:21:15,760 --> 00:21:15,770
 

1073
00:21:15,770 --> 00:21:17,020
was designed be this fresh beyond a

1074
00:21:17,020 --> 00:21:17,030
 

1075
00:21:17,030 --> 00:21:19,270
purpose hash function Google ended up

1076
00:21:19,270 --> 00:21:19,280
 

1077
00:21:19,280 --> 00:21:22,300
picking it up in and actually extending

1078
00:21:22,300 --> 00:21:22,310
 

1079
00:21:22,310 --> 00:21:25,120
the version two of member hash and they

1080
00:21:25,120 --> 00:21:25,130
 

1081
00:21:25,130 --> 00:21:25,539
design

1082
00:21:25,539 --> 00:21:25,549

1083
00:21:25,549 --> 00:21:28,810
to be better faster for shorter keys

1084
00:21:28,810 --> 00:21:28,820
 

1085
00:21:28,820 --> 00:21:31,869
keys are less than 64 bytes right and

1086
00:21:31,869 --> 00:21:31,879
 

1087
00:21:31,879 --> 00:21:33,489
they wanted to do this because in their

1088
00:21:33,489 --> 00:21:33,499
 

1089
00:21:33,499 --> 00:21:34,899
in their internal workload and their

1090
00:21:34,899 --> 00:21:34,909
 

1091
00:21:34,909 --> 00:21:37,149
services this is what the kind of data

1092
00:21:37,149 --> 00:21:37,159
 

1093
00:21:37,159 --> 00:21:38,710
they saw all the time and so they wanted

1094
00:21:38,710 --> 00:21:38,720
 

1095
00:21:38,720 --> 00:21:40,659
a hash function that was optimized for

1096
00:21:40,659 --> 00:21:40,669
 

1097
00:21:40,669 --> 00:21:43,479
these things and then Google standard

1098
00:21:43,479 --> 00:21:43,489
 

1099
00:21:43,489 --> 00:21:46,840
City hash in 2014 with farm hash and

1100
00:21:46,840 --> 00:21:46,850
 

1101
00:21:46,850 --> 00:21:49,350
this was further improved to have better

1102
00:21:49,350 --> 00:21:49,360
 

1103
00:21:49,360 --> 00:21:53,350
better better collision rates in 2016

1104
00:21:53,350 --> 00:21:53,360
 

1105
00:21:53,360 --> 00:21:54,519
they actually came out with another hash

1106
00:21:54,519 --> 00:21:54,529
 

1107
00:21:54,529 --> 00:21:56,649
function called Highway hash this is one

1108
00:21:56,649 --> 00:21:56,659
 

1109
00:21:56,659 --> 00:21:57,460
that actually does have some

1110
00:21:57,460 --> 00:21:57,470
 

1111
00:21:57,470 --> 00:21:59,739
cryptographic guarantees our protections

1112
00:21:59,739 --> 00:21:59,749
 

1113
00:21:59,749 --> 00:22:02,529
against analysis on the data again we

1114
00:22:02,529 --> 00:22:02,539
 

1115
00:22:02,539 --> 00:22:03,549
don't care about that so we're not gonna

1116
00:22:03,549 --> 00:22:03,559
 

1117
00:22:03,559 --> 00:22:05,739
use that for this and then the last one

1118
00:22:05,739 --> 00:22:05,749
 

1119
00:22:05,749 --> 00:22:07,869
here is steel hash so this was

1120
00:22:07,869 --> 00:22:07,879
 

1121
00:22:07,879 --> 00:22:09,340
interesting this one came out of Canada

1122
00:22:09,340 --> 00:22:09,350
 

1123
00:22:09,350 --> 00:22:11,739
from a professor up in Montreal named

1124
00:22:11,739 --> 00:22:11,749
 

1125
00:22:11,749 --> 00:22:14,109
Daniel Amir and this is actually using a

1126
00:22:14,109 --> 00:22:14,119
 

1127
00:22:14,119 --> 00:22:15,580
different kind of math called carry less

1128
00:22:15,580 --> 00:22:15,590
 

1129
00:22:15,590 --> 00:22:18,129
multiplication there's a link there for

1130
00:22:18,129 --> 00:22:18,139
 

1131
00:22:18,139 --> 00:22:19,330
the Wikipedia article you want to learn

1132
00:22:19,330 --> 00:22:19,340
 

1133
00:22:19,340 --> 00:22:20,799
more about it but it was interesting

1134
00:22:20,799 --> 00:22:20,809

1135
00:22:20,809 --> 00:22:22,629
about this is that the idea of carry

1136
00:22:22,629 --> 00:22:22,639
 

1137
00:22:22,639 --> 00:22:24,879
less multiplication is not new it's just

1138
00:22:24,879 --> 00:22:24,889
 

1139
00:22:24,889 --> 00:22:28,869
in 2014 or so Intel and AMD added

1140
00:22:28,869 --> 00:22:28,879
 

1141
00:22:28,879 --> 00:22:31,330
instructions to do this kind of math in

1142
00:22:31,330 --> 00:22:31,340
 

1143
00:22:31,340 --> 00:22:33,279
the hardware itself so now is actually

1144
00:22:33,279 --> 00:22:33,289
 

1145
00:22:33,289 --> 00:22:34,930
possible to do this arithmetic very very

1146
00:22:34,930 --> 00:22:34,940
 

1147
00:22:34,940 --> 00:22:36,849
fast so this hash function became an

1148
00:22:36,849 --> 00:22:36,859
 

1149
00:22:36,859 --> 00:22:41,440
actual a viable option so just to give

1150
00:22:41,440 --> 00:22:41,450
 

1151
00:22:41,450 --> 00:22:42,519
you an idea what these things sort of

1152
00:22:42,519 --> 00:22:42,529
 

1153
00:22:42,529 --> 00:22:44,289
look like in terms of performance so

1154
00:22:44,289 --> 00:22:44,299
 

1155
00:22:44,299 --> 00:22:46,690
this is this is an experiment I ran on

1156
00:22:46,690 --> 00:22:46,700
 

1157
00:22:46,700 --> 00:22:49,930
my workstation which is a newer one of

1158
00:22:49,930 --> 00:22:49,940
 

1159
00:22:49,940 --> 00:22:53,590
the newer Intel Core i7 CPUs so this is

1160
00:22:53,590 --> 00:22:53,600
 

1161
00:22:53,600 --> 00:22:54,940
written by somebody on github and I

1162
00:22:54,940 --> 00:22:54,950
 

1163
00:22:54,950 --> 00:22:57,310
sorta extended it to use Co hash so

1164
00:22:57,310 --> 00:22:57,320
 

1165
00:22:57,320 --> 00:22:58,810
basically what they're doing is they're

1166
00:22:58,810 --> 00:22:58,820
 

1167
00:22:58,820 --> 00:23:01,659
gonna hash a key a bunch of random

1168
00:23:01,659 --> 00:23:01,669
 

1169
00:23:01,669 --> 00:23:03,970
strings of different sizes as fast as

1170
00:23:03,970 --> 00:23:03,980
 

1171
00:23:03,980 --> 00:23:05,109
possible and measure what the throughput

1172
00:23:05,109 --> 00:23:05,119
 

1173
00:23:05,119 --> 00:23:08,080
rate is and so what you see is that when

1174
00:23:08,080 --> 00:23:08,090
 

1175
00:23:08,090 --> 00:23:09,729
the keys are kind of small the hash

1176
00:23:09,729 --> 00:23:09,739
 

1177
00:23:09,739 --> 00:23:11,289
function is all sort of more or less the

1178
00:23:11,289 --> 00:23:11,299
 

1179
00:23:11,299 --> 00:23:13,149
same but then as you increase the key

1180
00:23:13,149 --> 00:23:13,159
 

1181
00:23:13,159 --> 00:23:16,359
size and then though the y-axis is

1182
00:23:16,359 --> 00:23:16,369
 

1183
00:23:16,369 --> 00:23:18,999
throughput so it's how many how many

1184
00:23:18,999 --> 00:23:19,009
 

1185
00:23:19,009 --> 00:23:20,830
bytes of a key can you can you hash as

1186
00:23:20,830 --> 00:23:20,840
 

1187
00:23:20,840 --> 00:23:23,139
fast as possible so up to a certain

1188
00:23:23,139 --> 00:23:23,149
 

1189
00:23:23,149 --> 00:23:25,169
point they all sort of sort of plateau

1190
00:23:25,169 --> 00:23:25,179
 

1191
00:23:25,179 --> 00:23:27,399
and you can see the sed hash in there

1192
00:23:27,399 --> 00:23:27,409
 

1193
00:23:27,409 --> 00:23:28,570
the black line that you guys are using

1194
00:23:28,570 --> 00:23:28,580
 

1195
00:23:28,580 --> 00:23:31,509
for your for your for your project again

1196
00:23:31,509 --> 00:23:31,519
 

1197
00:23:31,519 --> 00:23:33,460
it's it's reasonably good but the two

1198
00:23:33,460 --> 00:23:33,470
 

1199
00:23:33,470 --> 00:23:35,739
psaltery pattern lines are from the the

1200
00:23:35,739 --> 00:23:35,749
 

1201
00:23:35,749 --> 00:23:37,690
city hash and farm hash from google and

1202
00:23:37,690 --> 00:23:37,700
 

1203
00:23:37,700 --> 00:23:39,340
as I said they designed it

1204
00:23:39,340 --> 00:23:39,350

1205
00:23:39,350 --> 00:23:43,990
be optimized for 64 64 bytes or less

1206
00:23:43,990 --> 00:23:44,000
 

1207
00:23:44,000 --> 00:23:46,720
than 64 bytes and then the the the

1208
00:23:46,720 --> 00:23:46,730
 

1209
00:23:46,730 --> 00:23:48,430
points where it sort of goes up and goes

1210
00:23:48,430 --> 00:23:48,440
 

1211
00:23:48,440 --> 00:23:51,159
back down these are where they're

1212
00:23:51,159 --> 00:23:51,169
 

1213
00:23:51,169 --> 00:23:56,020
aligned to cache lines so cache line is

1214
00:23:56,020 --> 00:23:56,030
 

1215
00:23:56,030 --> 00:23:59,080
when you do a fetch into memory you just

1216
00:23:59,080 --> 00:23:59,090
 

1217
00:23:59,090 --> 00:24:00,760
don't get like just the one thing you

1218
00:24:00,760 --> 00:24:00,770
 

1219
00:24:00,770 --> 00:24:02,159
want you get a whole bunch of stuff

1220
00:24:02,159 --> 00:24:02,169
 

1221
00:24:02,169 --> 00:24:04,390
along with it that are nearby because it

1222
00:24:04,390 --> 00:24:04,400
 

1223
00:24:04,400 --> 00:24:05,680
assumes your apply gonna need that too

1224
00:24:05,680 --> 00:24:05,690
 

1225
00:24:05,690 --> 00:24:07,750
and then you can start packing them into

1226
00:24:07,750 --> 00:24:07,760
 

1227
00:24:07,760 --> 00:24:10,750
64 byte cache lines so now if you can do

1228
00:24:10,750 --> 00:24:10,760
 

1229
00:24:10,760 --> 00:24:13,899
a bunch of operations or instructions on

1230
00:24:13,899 --> 00:24:13,909
 

1231
00:24:13,909 --> 00:24:15,430
data that's sitting in a single cache

1232
00:24:15,430 --> 00:24:15,440
 

1233
00:24:15,440 --> 00:24:17,710
line you never have to go back and fetch

1234
00:24:17,710 --> 00:24:17,720
 

1235
00:24:17,720 --> 00:24:19,120
more to maybe the upper levels of your

1236
00:24:19,120 --> 00:24:19,130
 

1237
00:24:19,130 --> 00:24:21,460
cache so that's why you see this like

1238
00:24:21,460 --> 00:24:21,470

1239
00:24:21,470 --> 00:24:23,260
when it gets to 32 bytes or 64 bytes

1240
00:24:23,260 --> 00:24:23,270
 

1241
00:24:23,270 --> 00:24:25,480
it's on you know you're getting much

1242
00:24:25,480 --> 00:24:25,490
 

1243
00:24:25,490 --> 00:24:27,520
better performance because it's it's

1244
00:24:27,520 --> 00:24:27,530
 

1245
00:24:27,530 --> 00:24:31,180
from one cache miss they're doing a more

1246
00:24:31,180 --> 00:24:31,190
 

1247
00:24:31,190 --> 00:24:34,480
work as for one cache miss you're doing

1248
00:24:34,480 --> 00:24:34,490

1249
00:24:34,490 --> 00:24:36,970
you're generating more output for the

1250
00:24:36,970 --> 00:24:36,980

1251
00:24:36,980 --> 00:24:40,360
same amount of read data read/write so

1252
00:24:40,360 --> 00:24:40,370
 

1253
00:24:40,370 --> 00:24:43,060
that's why there's the salty pattern and

1254
00:24:43,060 --> 00:24:43,070
 

1255
00:24:43,070 --> 00:24:45,310
there's to throw CL hash and this again

1256
00:24:45,310 --> 00:24:45,320

1257
00:24:45,320 --> 00:24:47,470
you see the same kind of the same kind

1258
00:24:47,470 --> 00:24:47,480
 

1259
00:24:47,480 --> 00:24:50,890
of ups and downs based on how you're

1260
00:24:50,890 --> 00:24:50,900

1261
00:24:50,900 --> 00:24:54,029
actually packing thing into registers

1262
00:24:54,029 --> 00:24:54,039

1263
00:24:54,039 --> 00:24:56,200
the main takeaway I want to give you

1264
00:24:56,200 --> 00:24:56,210
 

1265
00:24:56,210 --> 00:24:58,180
guys for this is like for things that

1266
00:24:58,180 --> 00:24:58,190
 

1267
00:24:58,190 --> 00:25:00,039
are less than 64 bytes you can use City

1268
00:25:00,039 --> 00:25:00,049
 

1269
00:25:00,049 --> 00:25:02,649
hash or farm hash for larger strings you

1270
00:25:02,649 --> 00:25:02,659

1271
00:25:02,659 --> 00:25:04,659
maybe want to use something else for our

1272
00:25:04,659 --> 00:25:04,669
 

1273
00:25:04,669 --> 00:25:06,130
project purposes we're not trying to run

1274
00:25:06,130 --> 00:25:06,140
 

1275
00:25:06,140 --> 00:25:07,919
as fast as possible

1276
00:25:07,919 --> 00:25:07,929

1277
00:25:07,929 --> 00:25:10,120
you know because we're running you know

1278
00:25:10,120 --> 00:25:10,130
 

1279
00:25:10,130 --> 00:25:11,620
running in secret lighter and great

1280
00:25:11,620 --> 00:25:11,630
 

1281
00:25:11,630 --> 00:25:14,640
scope so this SE d hash is good enough

1282
00:25:14,640 --> 00:25:14,650
 

1283
00:25:14,650 --> 00:25:17,740
so the main takeaway here is that

1284
00:25:17,740 --> 00:25:17,750
 

1285
00:25:17,750 --> 00:25:19,210
different hash functions have different

1286
00:25:19,210 --> 00:25:19,220
 

1287
00:25:19,220 --> 00:25:20,830
properties and you may want to choose

1288
00:25:20,830 --> 00:25:20,840
 

1289
00:25:20,840 --> 00:25:23,169
one versus another based on what you

1290
00:25:23,169 --> 00:25:23,179
 

1291
00:25:23,179 --> 00:25:24,669
think the distribution of the data it is

1292
00:25:24,669 --> 00:25:24,679
 

1293
00:25:24,679 --> 00:25:25,690
and what you're actually trying to do

1294
00:25:25,690 --> 00:25:25,700
 

1295
00:25:25,700 --> 00:25:26,460
with it

1296
00:25:26,460 --> 00:25:26,470

1297
00:25:26,470 --> 00:25:30,100
but the hash functions are as far as I

1298
00:25:30,100 --> 00:25:30,110

1299
00:25:30,110 --> 00:25:31,390
know interchangeable with all the

1300
00:25:31,390 --> 00:25:31,400

1301
00:25:31,400 --> 00:25:32,470
hashing schemes that we'll talk about

1302
00:25:32,470 --> 00:25:32,480
 

1303
00:25:32,480 --> 00:25:34,630
next so when we talk about these hashing

1304
00:25:34,630 --> 00:25:34,640
 

1305
00:25:34,640 --> 00:25:36,159
schemes it doesn't matter whether using

1306
00:25:36,159 --> 00:25:36,169
 

1307
00:25:36,169 --> 00:25:38,409
City hash or murmer hash the actual

1308
00:25:38,409 --> 00:25:38,419
 

1309
00:25:38,419 --> 00:25:39,730
algorithm will still work the same it's

1310
00:25:39,730 --> 00:25:39,740
 

1311
00:25:39,740 --> 00:25:41,169
the question is whether you're gonna

1312
00:25:41,169 --> 00:25:41,179
 

1313
00:25:41,179 --> 00:25:43,240
have a higher collision rate with one

1314
00:25:43,240 --> 00:25:43,250

1315
00:25:43,250 --> 00:25:45,130
function versus another again and that

1316
00:25:45,130 --> 00:25:45,140

1317
00:25:45,140 --> 00:25:46,630
can depend on the distribution of your

1318
00:25:46,630 --> 00:25:46,640
 

1319
00:25:46,640 --> 00:25:50,590
data okay so now we're gonna talk about

1320
00:25:50,590 --> 00:25:50,600
 

1321
00:25:50,600 --> 00:25:52,360
static hashing seems so

1322
00:25:52,360 --> 00:25:52,370

1323
00:25:52,370 --> 00:25:54,850
and the hashing scheme is the the

1324
00:25:54,850 --> 00:25:54,860
 

1325
00:25:54,860 --> 00:25:58,030
protocol or the method that be that the

1326
00:25:58,030 --> 00:25:58,040
 

1327
00:25:58,040 --> 00:26:00,280
hash table is going to use when there's

1328
00:26:00,280 --> 00:26:00,290
 

1329
00:26:00,290 --> 00:26:02,950
a collision and we said collisions are

1330
00:26:02,950 --> 00:26:02,960
 

1331
00:26:02,960 --> 00:26:05,110
essentially unavoidable because we're

1332
00:26:05,110 --> 00:26:05,120
 

1333
00:26:05,120 --> 00:26:08,140
trying to store a large key space into a

1334
00:26:08,140 --> 00:26:08,150
 

1335
00:26:08,150 --> 00:26:10,870
small smaller amount of memory so things

1336
00:26:10,870 --> 00:26:10,880
 

1337
00:26:10,880 --> 00:26:12,760
may end up hashing to the same the same

1338
00:26:12,760 --> 00:26:12,770

1339
00:26:12,770 --> 00:26:15,040
key so first talk about talk about

1340
00:26:15,040 --> 00:26:15,050
 

1341
00:26:15,050 --> 00:26:17,680
linear probing hashing Robinhood hashing

1342
00:26:17,680 --> 00:26:17,690
 

1343
00:26:17,690 --> 00:26:20,980
and cuckoo hashing so linear linear

1344
00:26:20,980 --> 00:26:20,990

1345
00:26:20,990 --> 00:26:22,930
probe hashing is the probably the most

1346
00:26:22,930 --> 00:26:22,940
 

1347
00:26:22,940 --> 00:26:25,419
common hash table not the one everyone

1348
00:26:25,419 --> 00:26:25,429
 

1349
00:26:25,429 --> 00:26:27,130
thinks up because when you think of a

1350
00:26:27,130 --> 00:26:27,140
 

1351
00:26:27,140 --> 00:26:28,150
hash table most people think of the

1352
00:26:28,150 --> 00:26:28,160
 

1353
00:26:28,160 --> 00:26:29,470
chain hash table we'll just see in a

1354
00:26:29,470 --> 00:26:29,480
 

1355
00:26:29,480 --> 00:26:31,120
second but in terms of implementation

1356
00:26:31,120 --> 00:26:31,130

1357
00:26:31,130 --> 00:26:33,190
inside of database systems this is the

1358
00:26:33,190 --> 00:26:33,200
 

1359
00:26:33,200 --> 00:26:34,480
one that's that's the most common

1360
00:26:34,480 --> 00:26:34,490
 

1361
00:26:34,490 --> 00:26:36,810
because it's just so simple and so fast

1362
00:26:36,810 --> 00:26:36,820
 

1363
00:26:36,820 --> 00:26:39,490
so the hash table is just gonna be this

1364
00:26:39,490 --> 00:26:39,500
 

1365
00:26:39,500 --> 00:26:43,930
giant table slots and you take the key

1366
00:26:43,930 --> 00:26:43,940
 

1367
00:26:43,940 --> 00:26:46,390
you want to insert you hash it and that

1368
00:26:46,390 --> 00:26:46,400
 

1369
00:26:46,400 --> 00:26:49,210
that puts you in some position into into

1370
00:26:49,210 --> 00:26:49,220
 

1371
00:26:49,220 --> 00:26:52,900
the hash table right and so what

1372
00:26:52,900 --> 00:26:52,910
 

1373
00:26:52,910 --> 00:26:55,419
happened is f2 keys hash to the same

1374
00:26:55,419 --> 00:26:55,429

1375
00:26:55,429 --> 00:26:59,890
slot in our table then the we just keep

1376
00:26:59,890 --> 00:26:59,900
 

1377
00:26:59,900 --> 00:27:02,080
scanning down into our table until we

1378
00:27:02,080 --> 00:27:02,090
 

1379
00:27:02,090 --> 00:27:04,750
find a position that is free and that's

1380
00:27:04,750 --> 00:27:04,760
 

1381
00:27:04,760 --> 00:27:06,130
where we can go put our item in there

1382
00:27:06,130 --> 00:27:06,140

1383
00:27:06,140 --> 00:27:07,780
pick the thing that we're trying to

1384
00:27:07,780 --> 00:27:07,790
 

1385
00:27:07,790 --> 00:27:09,970
insert right and this is why is called

1386
00:27:09,970 --> 00:27:09,980
 

1387
00:27:09,980 --> 00:27:11,980
linear probing because you again we're

1388
00:27:11,980 --> 00:27:11,990
 

1389
00:27:11,990 --> 00:27:13,540
just going literally almost as a

1390
00:27:13,540 --> 00:27:13,550
 

1391
00:27:13,550 --> 00:27:15,340
sequential scan and the table going down

1392
00:27:15,340 --> 00:27:15,350
 

1393
00:27:15,350 --> 00:27:16,600
till we find the thing that we're

1394
00:27:16,600 --> 00:27:16,610
 

1395
00:27:16,610 --> 00:27:17,970
looking for

1396
00:27:17,970 --> 00:27:17,980
 

1397
00:27:17,980 --> 00:27:22,030
so for lookups we have again we do our

1398
00:27:22,030 --> 00:27:22,040
 

1399
00:27:22,040 --> 00:27:24,280
hash Mikey we landed some space we scan

1400
00:27:24,280 --> 00:27:24,290
 

1401
00:27:24,290 --> 00:27:25,450
down till we find the thing that we're

1402
00:27:25,450 --> 00:27:25,460
 

1403
00:27:25,460 --> 00:27:27,730
looking for or we find an empty spot at

1404
00:27:27,730 --> 00:27:27,740
 

1405
00:27:27,740 --> 00:27:30,430
which point we know that we've you know

1406
00:27:30,430 --> 00:27:30,440
 

1407
00:27:30,440 --> 00:27:32,640
the thing we're looking for is not there

1408
00:27:32,640 --> 00:27:32,650
 

1409
00:27:32,650 --> 00:27:34,870
of course now what's the problem with

1410
00:27:34,870 --> 00:27:34,880
 

1411
00:27:34,880 --> 00:27:45,880
with this for this approach yes he says

1412
00:27:45,880 --> 00:27:45,890
 

1413
00:27:45,890 --> 00:27:49,780
he says yes he's correct he said that

1414
00:27:49,780 --> 00:27:49,790
 

1415
00:27:49,790 --> 00:27:52,600
when you do a deletion you now make an

1416
00:27:52,600 --> 00:27:52,610
 

1417
00:27:52,610 --> 00:27:55,600
empty spot which sort of disconnects the

1418
00:27:55,600 --> 00:27:55,610
 

1419
00:27:55,610 --> 00:27:57,160
to the two chunks of the things next to

1420
00:27:57,160 --> 00:27:57,170
 

1421
00:27:57,170 --> 00:27:58,680
each other yes absolutely

1422
00:27:58,680 --> 00:27:58,690
 

1423
00:27:58,690 --> 00:28:00,760
what's another problem say I'm doing an

1424
00:28:00,760 --> 00:28:00,770
 

1425
00:28:00,770 --> 00:28:03,790
insert the thing I want is not there and

1426
00:28:03,790 --> 00:28:03,800
 

1427
00:28:03,800 --> 00:28:06,110
I keep scanning

1428
00:28:06,110 --> 00:28:06,120

1429
00:28:06,120 --> 00:28:08,420
what if I never stop right what if I

1430
00:28:08,420 --> 00:28:08,430
 

1431
00:28:08,430 --> 00:28:11,420
reach the bottom loop back around

1432
00:28:11,420 --> 00:28:11,430
 

1433
00:28:11,430 --> 00:28:13,250
I keep scanning down and now I land back

1434
00:28:13,250 --> 00:28:13,260
 

1435
00:28:13,260 --> 00:28:14,750
in the original position I started that

1436
00:28:14,750 --> 00:28:14,760
 

1437
00:28:14,760 --> 00:28:17,870
I'm stuck in an infinite loop right so

1438
00:28:17,870 --> 00:28:17,880
 

1439
00:28:17,880 --> 00:28:19,370
we also need when we when we do insert

1440
00:28:19,370 --> 00:28:19,380
 

1441
00:28:19,380 --> 00:28:21,470
through SME and and searches when you

1442
00:28:21,470 --> 00:28:21,480
 

1443
00:28:21,480 --> 00:28:22,850
keep track of where we left off so that

1444
00:28:22,850 --> 00:28:22,860
 

1445
00:28:22,860 --> 00:28:25,910
we don't loop forever so let's look at

1446
00:28:25,910 --> 00:28:25,920
 

1447
00:28:25,920 --> 00:28:29,120
an example alright so say on the on the

1448
00:28:29,120 --> 00:28:29,130
 

1449
00:28:29,130 --> 00:28:31,850
side here ABCDE F these are the keys I

1450
00:28:31,850 --> 00:28:31,860
 

1451
00:28:31,860 --> 00:28:33,740
went to insert and again my hash table

1452
00:28:33,740 --> 00:28:33,750

1453
00:28:33,750 --> 00:28:37,250
is this this giant array of slots so I

1454
00:28:37,250 --> 00:28:37,260
 

1455
00:28:37,260 --> 00:28:38,810
want to say in first first thing I'm

1456
00:28:38,810 --> 00:28:38,820
 

1457
00:28:38,820 --> 00:28:41,540
gonna do is insert a so I take a I hash

1458
00:28:41,540 --> 00:28:41,550
 

1459
00:28:41,550 --> 00:28:43,550
it and it lands at this position here

1460
00:28:43,550 --> 00:28:43,560
 

1461
00:28:43,560 --> 00:28:45,440
right because nobody's there I can go

1462
00:28:45,440 --> 00:28:45,450
 

1463
00:28:45,450 --> 00:28:47,750
ahead and take take take the slot so

1464
00:28:47,750 --> 00:28:47,760
 

1465
00:28:47,760 --> 00:28:51,140
inside of the the entry in my hash table

1466
00:28:51,140 --> 00:28:51,150
 

1467
00:28:51,150 --> 00:28:55,640
I need to store the key that I that I

1468
00:28:55,640 --> 00:28:55,650
 

1469
00:28:55,650 --> 00:28:58,250
just inserted the original key as well

1470
00:28:58,250 --> 00:28:58,260
 

1471
00:28:58,260 --> 00:29:01,610
as the value right mean the value could

1472
00:29:01,610 --> 00:29:01,620

1473
00:29:01,620 --> 00:29:05,450
be could be like a record ID even a page

1474
00:29:05,450 --> 00:29:05,460
 

1475
00:29:05,460 --> 00:29:07,220
ID and an offset could be an actual

1476
00:29:07,220 --> 00:29:07,230
 

1477
00:29:07,230 --> 00:29:11,990
value right it doesn't matter but I VI

1478
00:29:11,990 --> 00:29:12,000
 

1479
00:29:12,000 --> 00:29:14,060
need to store both and the reason is

1480
00:29:14,060 --> 00:29:14,070
 

1481
00:29:14,070 --> 00:29:16,340
because when I come back and try to

1482
00:29:16,340 --> 00:29:16,350
 

1483
00:29:16,350 --> 00:29:17,540
insert something else or do another

1484
00:29:17,540 --> 00:29:17,550
 

1485
00:29:17,550 --> 00:29:20,150
lookup the hash function is gonna tell

1486
00:29:20,150 --> 00:29:20,160
 

1487
00:29:20,160 --> 00:29:21,740
me where to jump into the hash table but

1488
00:29:21,740 --> 00:29:21,750
 

1489
00:29:21,750 --> 00:29:23,540
then then I need to still do a

1490
00:29:23,540 --> 00:29:23,550
 

1491
00:29:23,550 --> 00:29:25,100
comparison as I'm scanning to see

1492
00:29:25,100 --> 00:29:25,110
 

1493
00:29:25,110 --> 00:29:27,350
whether the entry I'm looking at is the

1494
00:29:27,350 --> 00:29:27,360
 

1495
00:29:27,360 --> 00:29:30,500
actual key that I want because again two

1496
00:29:30,500 --> 00:29:30,510
 

1497
00:29:30,510 --> 00:29:32,360
keys may hash to the same location I

1498
00:29:32,360 --> 00:29:32,370
 

1499
00:29:32,370 --> 00:29:35,060
need to know whether you know the the

1500
00:29:35,060 --> 00:29:35,070
 

1501
00:29:35,070 --> 00:29:36,590
entry is actually the key the same key

1502
00:29:36,590 --> 00:29:36,600

1503
00:29:36,600 --> 00:29:40,040
is me alright so now let's say we hash

1504
00:29:40,040 --> 00:29:40,050
 

1505
00:29:40,050 --> 00:29:42,500
be that points up here nobody's in there

1506
00:29:42,500 --> 00:29:42,510
 

1507
00:29:42,510 --> 00:29:46,010
so that's fine so now we want a hash c.c

1508
00:29:46,010 --> 00:29:46,020
 

1509
00:29:46,020 --> 00:29:49,130
points to the same slot that a is in but

1510
00:29:49,130 --> 00:29:49,140
 

1511
00:29:49,140 --> 00:29:51,590
that's occupied so okay and the linear

1512
00:29:51,590 --> 00:29:51,600
 

1513
00:29:51,600 --> 00:29:53,150
probe map that just says go down to the

1514
00:29:53,150 --> 00:29:53,160

1515
00:29:53,160 --> 00:29:56,870
next one and that's where we put C so

1516
00:29:56,870 --> 00:29:56,880
 

1517
00:29:56,880 --> 00:29:58,700
now if I do a lookup and see when I hash

1518
00:29:58,700 --> 00:29:58,710
 

1519
00:29:58,710 --> 00:30:01,100
it I'll land where a is I do my

1520
00:30:01,100 --> 00:30:01,110

1521
00:30:01,110 --> 00:30:03,290
comparison with the key and a and the

1522
00:30:03,290 --> 00:30:03,300
 

1523
00:30:03,300 --> 00:30:06,080
key or key of C they're not equal keep

1524
00:30:06,080 --> 00:30:06,090
 

1525
00:30:06,090 --> 00:30:09,100
scanning down then I find my match on C

1526
00:30:09,100 --> 00:30:09,110
 

1527
00:30:09,110 --> 00:30:11,240
right I do this and so forth and so

1528
00:30:11,240 --> 00:30:11,250
 

1529
00:30:11,250 --> 00:30:13,610
forth D goes where C is that's occupies

1530
00:30:13,610 --> 00:30:13,620
 

1531
00:30:13,620 --> 00:30:16,580
who has to go to one below egos where a

1532
00:30:16,580 --> 00:30:16,590
 

1533
00:30:16,590 --> 00:30:18,590
is that's occupied so it has to go all

1534
00:30:18,590 --> 00:30:18,600
 

1535
00:30:18,600 --> 00:30:19,820
the way down to it

1536
00:30:19,820 --> 00:30:19,830
 

1537
00:30:19,830 --> 00:30:22,490
finds a slot that is taken and then last

1538
00:30:22,490 --> 00:30:22,500
 

1539
00:30:22,500 --> 00:30:28,220
one for app right so I'm going to a he

1540
00:30:28,220 --> 00:30:28,230
 

1541
00:30:28,230 --> 00:30:29,480
brought up a good point about deletions

1542
00:30:29,480 --> 00:30:29,490
 

1543
00:30:29,490 --> 00:30:32,210
here we're gonna punt and make this easy

1544
00:30:32,210 --> 00:30:32,220
 

1545
00:30:32,220 --> 00:30:36,620
and just not deal with deletions so for

1546
00:30:36,620 --> 00:30:36,630
 

1547
00:30:36,630 --> 00:30:38,389
a hat for certain operations this is

1548
00:30:38,389 --> 00:30:38,399
 

1549
00:30:38,399 --> 00:30:41,659
fine for a hash join or aggregations

1550
00:30:41,659 --> 00:30:41,669
 

1551
00:30:41,669 --> 00:30:43,549
this is fine because you're not gonna go

1552
00:30:43,549 --> 00:30:43,559
 

1553
00:30:43,559 --> 00:30:44,720
back and delete the entry as you're

1554
00:30:44,720 --> 00:30:44,730
 

1555
00:30:44,730 --> 00:30:47,000
doing your hash drawing so just I

1556
00:30:47,000 --> 00:30:47,010
 

1557
00:30:47,010 --> 00:30:48,889
realized you might not about hash join

1558
00:30:48,889 --> 00:30:48,899
 

1559
00:30:48,899 --> 00:30:50,180
is but the basic idea is I want to join

1560
00:30:50,180 --> 00:30:50,190
 

1561
00:30:50,190 --> 00:30:52,580
two tables I build a hash table for once

1562
00:30:52,580 --> 00:30:52,590
 

1563
00:30:52,590 --> 00:30:54,980
I put the keys in there and then on the

1564
00:30:54,980 --> 00:30:54,990
 

1565
00:30:54,990 --> 00:30:56,450
other of your other table I do a program

1566
00:30:56,450 --> 00:30:56,460
 

1567
00:30:56,460 --> 00:30:57,590
the hash table I'll see whether I have a

1568
00:30:57,590 --> 00:30:57,600
 

1569
00:30:57,600 --> 00:31:00,200
match right so the the hash table is

1570
00:31:00,200 --> 00:31:00,210
 

1571
00:31:00,210 --> 00:31:01,730
read-only same thing for aggregations I

1572
00:31:01,730 --> 00:31:01,740
 

1573
00:31:01,740 --> 00:31:04,159
never go back and delete something so in

1574
00:31:04,159 --> 00:31:04,169
 

1575
00:31:04,169 --> 00:31:06,049
that case this is fine and this is super

1576
00:31:06,049 --> 00:31:06,059
 

1577
00:31:06,059 --> 00:31:08,480
fast for deletions exactly as he said

1578
00:31:08,480 --> 00:31:08,490

1579
00:31:08,490 --> 00:31:09,950
you have to do some reshuffling and copy

1580
00:31:09,950 --> 00:31:09,960
 

1581
00:31:09,960 --> 00:31:11,629
things around to fill in the gaps and

1582
00:31:11,629 --> 00:31:11,639
 

1583
00:31:11,639 --> 00:31:13,909
that becomes expensive so this is

1584
00:31:13,909 --> 00:31:13,919
 

1585
00:31:13,919 --> 00:31:15,500
another example of a trade-off where

1586
00:31:15,500 --> 00:31:15,510
 

1587
00:31:15,510 --> 00:31:17,480
this is be great for some operations

1588
00:31:17,480 --> 00:31:17,490
 

1589
00:31:17,490 --> 00:31:19,639
work insert only and read heavy but if

1590
00:31:19,639 --> 00:31:19,649
 

1591
00:31:19,649 --> 00:31:21,470
you want to do updates and deletions you

1592
00:31:21,470 --> 00:31:21,480
 

1593
00:31:21,480 --> 00:31:22,970
don't want actually use this a linear

1594
00:31:22,970 --> 00:31:22,980
 

1595
00:31:22,980 --> 00:31:26,629
leaner proving hashing method the other

1596
00:31:26,629 --> 00:31:26,639
 

1597
00:31:26,639 --> 00:31:28,070
big issue that we have to talk about is

1598
00:31:28,070 --> 00:31:28,080
 

1599
00:31:28,080 --> 00:31:29,810
how we actually handle non unique keys

1600
00:31:29,810 --> 00:31:29,820
 

1601
00:31:29,820 --> 00:31:32,210
so for this I've assumed that all our

1602
00:31:32,210 --> 00:31:32,220
 

1603
00:31:32,220 --> 00:31:35,840
keys are are unique but that's not

1604
00:31:35,840 --> 00:31:35,850
 

1605
00:31:35,850 --> 00:31:38,269
always the case so there's two

1606
00:31:38,269 --> 00:31:38,279
 

1607
00:31:38,279 --> 00:31:40,490
approaches you can do to handle non

1608
00:31:40,490 --> 00:31:40,500
 

1609
00:31:40,500 --> 00:31:42,620
unique keys so the first is that you

1610
00:31:42,620 --> 00:31:42,630
 

1611
00:31:42,630 --> 00:31:46,490
just maintain the values of the for the

1612
00:31:46,490 --> 00:31:46,500
 

1613
00:31:46,500 --> 00:31:48,350
duplicate key in a sort of separate

1614
00:31:48,350 --> 00:31:48,360
 

1615
00:31:48,360 --> 00:31:50,990
linked list area so let's say that I

1616
00:31:50,990 --> 00:31:51,000
 

1617
00:31:51,000 --> 00:31:53,950
have my hash table I have keys X Y Z ABC

1618
00:31:53,950 --> 00:31:53,960
 

1619
00:31:53,960 --> 00:31:56,269
these instead of having the values

1620
00:31:56,269 --> 00:31:56,279
 

1621
00:31:56,279 --> 00:31:58,039
embedded inside the hash table itself

1622
00:31:58,039 --> 00:31:58,049
 

1623
00:31:58,049 --> 00:32:01,009
they just have pointer to some pages or

1624
00:32:01,009 --> 00:32:01,019
 

1625
00:32:01,019 --> 00:32:03,019
some memory location in the heap we're

1626
00:32:03,019 --> 00:32:03,029
 

1627
00:32:03,029 --> 00:32:05,690
now just a list of those values so now

1628
00:32:05,690 --> 00:32:05,700
 

1629
00:32:05,700 --> 00:32:06,799
what I'm going to say give me all the

1630
00:32:06,799 --> 00:32:06,809
 

1631
00:32:06,809 --> 00:32:10,250
values for X Y Z I do might do my hash I

1632
00:32:10,250 --> 00:32:10,260
 

1633
00:32:10,260 --> 00:32:12,529
jump to my location in my hash table

1634
00:32:12,529 --> 00:32:12,539
 

1635
00:32:12,539 --> 00:32:14,120
I may have to scan down depends on where

1636
00:32:14,120 --> 00:32:14,130

1637
00:32:14,130 --> 00:32:15,950
it actually is and then I when I find

1638
00:32:15,950 --> 00:32:15,960
 

1639
00:32:15,960 --> 00:32:17,539
the entry that I want now I have a

1640
00:32:17,539 --> 00:32:17,549
 

1641
00:32:17,549 --> 00:32:19,639
pointer to this other area and then I

1642
00:32:19,639 --> 00:32:19,649
 

1643
00:32:19,649 --> 00:32:21,860
know that the the the elements are the

1644
00:32:21,860 --> 00:32:21,870
 

1645
00:32:21,870 --> 00:32:24,289
values in that area only correspond to

1646
00:32:24,289 --> 00:32:24,299
 

1647
00:32:24,299 --> 00:32:27,710
the key that was pointing to it the

1648
00:32:27,710 --> 00:32:27,720
 

1649
00:32:27,720 --> 00:32:29,870
other approach is to just restore the

1650
00:32:29,870 --> 00:32:29,880
 

1651
00:32:29,880 --> 00:32:31,460
store that we've done it keys and the

1652
00:32:31,460 --> 00:32:31,470
 

1653
00:32:31,470 --> 00:32:33,740
values together so

1654
00:32:33,740 --> 00:32:33,750
 

1655
00:32:33,750 --> 00:32:36,560
set up breaking it up at XYZ ABC and

1656
00:32:36,560 --> 00:32:36,570
 

1657
00:32:36,570 --> 00:32:38,900
their value separately in my hash table

1658
00:32:38,900 --> 00:32:38,910

1659
00:32:38,910 --> 00:32:41,690
I just store XYZ and the values together

1660
00:32:41,690 --> 00:32:41,700
 

1661
00:32:41,700 --> 00:32:46,370
like that so what are some downsides of

1662
00:32:46,370 --> 00:32:46,380
 

1663
00:32:46,380 --> 00:32:49,550
the top approach is it more space

1664
00:32:49,550 --> 00:32:49,560
 

1665
00:32:49,560 --> 00:32:54,080
efficient no because you know I'm not

1666
00:32:54,080 --> 00:32:54,090
 

1667
00:32:54,090 --> 00:32:55,640
just me allocating single entries for

1668
00:32:55,640 --> 00:32:55,650
 

1669
00:32:55,650 --> 00:32:57,380
every value I'm gonna organize things

1670
00:32:57,380 --> 00:32:57,390
 

1671
00:32:57,390 --> 00:33:00,290
usually in pages and so if a single key

1672
00:33:00,290 --> 00:33:00,300
 

1673
00:33:00,300 --> 00:33:02,960
has one value I may be storing you know

1674
00:33:02,960 --> 00:33:02,970
 

1675
00:33:02,970 --> 00:33:04,520
have to allocate an entire page just

1676
00:33:04,520 --> 00:33:04,530
 

1677
00:33:04,530 --> 00:33:06,830
store that one value we're in the bottom

1678
00:33:06,830 --> 00:33:06,840
 

1679
00:33:06,840 --> 00:33:08,210
approach I don't have to do that because

1680
00:33:08,210 --> 00:33:08,220
 

1681
00:33:08,220 --> 00:33:10,310
I just add another entry into into my

1682
00:33:10,310 --> 00:33:10,320
 

1683
00:33:10,320 --> 00:33:15,500
hash table the downside of course again

1684
00:33:15,500 --> 00:33:15,510

1685
00:33:15,510 --> 00:33:16,970
the top one is more efficient when I

1686
00:33:16,970 --> 00:33:16,980
 

1687
00:33:16,980 --> 00:33:18,170
want to say give me all the key give me

1688
00:33:18,170 --> 00:33:18,180
 

1689
00:33:18,180 --> 00:33:20,270
all the values for a single key I just

1690
00:33:20,270 --> 00:33:20,280
 

1691
00:33:20,280 --> 00:33:22,430
jump to my one key then you know find my

1692
00:33:22,430 --> 00:33:22,440
 

1693
00:33:22,440 --> 00:33:23,780
key then jump to the value listen

1694
00:33:23,780 --> 00:33:23,790
 

1695
00:33:23,790 --> 00:33:25,610
everything's already there in the bottom

1696
00:33:25,610 --> 00:33:25,620
 

1697
00:33:25,620 --> 00:33:28,640
approach I just have to scan through so

1698
00:33:28,640 --> 00:33:28,650
 

1699
00:33:28,650 --> 00:33:30,500
there's another example of trade off in

1700
00:33:30,500 --> 00:33:30,510
 

1701
00:33:30,510 --> 00:33:33,020
databases where do we want to favor the

1702
00:33:33,020 --> 00:33:33,030
 

1703
00:33:33,030 --> 00:33:35,660
reads versus the rights right the top

1704
00:33:35,660 --> 00:33:35,670
 

1705
00:33:35,670 --> 00:33:39,950
one is is is more efficient for for for

1706
00:33:39,950 --> 00:33:39,960
 

1707
00:33:39,960 --> 00:33:42,650
reads but maybe less efficient for

1708
00:33:42,650 --> 00:33:42,660

1709
00:33:42,660 --> 00:33:43,640
writes because we have to allocate the

1710
00:33:43,640 --> 00:33:43,650
 

1711
00:33:43,650 --> 00:33:45,620
sector space the bottom one is super

1712
00:33:45,620 --> 00:33:45,630
 

1713
00:33:45,630 --> 00:33:47,900
efficient for for for writes because you

1714
00:33:47,900 --> 00:33:47,910
 

1715
00:33:47,910 --> 00:33:49,580
just plop our new thing and they're not

1716
00:33:49,580 --> 00:33:49,590
 

1717
00:33:49,590 --> 00:33:51,380
to allocate any space but Riis may be

1718
00:33:51,380 --> 00:33:51,390
 

1719
00:33:51,390 --> 00:33:52,460
more expensive because you have to scan

1720
00:33:52,460 --> 00:33:52,470
 

1721
00:33:52,470 --> 00:33:55,280
through to find it so that's how you

1722
00:33:55,280 --> 00:33:55,290

1723
00:33:55,290 --> 00:33:56,750
handle non unique keys for our purposes

1724
00:33:56,750 --> 00:33:56,760
 

1725
00:33:56,760 --> 00:33:59,060
going forward for all my examples and

1726
00:33:59,060 --> 00:33:59,070
 

1727
00:33:59,070 --> 00:34:00,050
these hash tables we'll just assume that

1728
00:34:00,050 --> 00:34:00,060
 

1729
00:34:00,060 --> 00:34:01,880
keys are unique but you but if you need

1730
00:34:01,880 --> 00:34:01,890
 

1731
00:34:01,890 --> 00:34:03,410
a hand or non unique keys you have to do

1732
00:34:03,410 --> 00:34:03,420
 

1733
00:34:03,420 --> 00:34:04,670
something either one of these two

1734
00:34:04,670 --> 00:34:04,680
 

1735
00:34:04,680 --> 00:34:07,520
methods and I say most people do do the

1736
00:34:07,520 --> 00:34:07,530
 

1737
00:34:07,530 --> 00:34:08,690
bottom one I actually don't know anybody

1738
00:34:08,690 --> 00:34:08,700
 

1739
00:34:08,700 --> 00:34:15,140
that does the top one okay so we said

1740
00:34:15,140 --> 00:34:15,150
 

1741
00:34:15,150 --> 00:34:16,580
that one of the big issues with the

1742
00:34:16,580 --> 00:34:16,590
 

1743
00:34:16,590 --> 00:34:18,140
linear probing hashing method I have two

1744
00:34:18,140 --> 00:34:18,150
 

1745
00:34:18,150 --> 00:34:20,870
hashing scheme is that we have all of

1746
00:34:20,870 --> 00:34:20,880
 

1747
00:34:20,880 --> 00:34:22,880
these wasteful comparisons potentially

1748
00:34:22,880 --> 00:34:22,890
 

1749
00:34:22,890 --> 00:34:26,300
when we have collisions right again when

1750
00:34:26,300 --> 00:34:26,310
 

1751
00:34:26,310 --> 00:34:27,500
you try to pick a really good hash

1752
00:34:27,500 --> 00:34:27,510
 

1753
00:34:27,510 --> 00:34:28,700
function to produce there are collisions

1754
00:34:28,700 --> 00:34:28,710
 

1755
00:34:28,710 --> 00:34:31,850
that we have but in real data set it's

1756
00:34:31,850 --> 00:34:31,860
 

1757
00:34:31,860 --> 00:34:35,270
gonna be unavoidable so the issue is

1758
00:34:35,270 --> 00:34:35,280
 

1759
00:34:35,280 --> 00:34:38,150
again when we have a collision we have

1760
00:34:38,150 --> 00:34:38,160
 

1761
00:34:38,160 --> 00:34:40,700
to scan through linearly and and start

1762
00:34:40,700 --> 00:34:40,710
 

1763
00:34:40,710 --> 00:34:42,560
looking at you know every entry define

1764
00:34:42,560 --> 00:34:42,570
 

1765
00:34:42,570 --> 00:34:44,600
the thing that we want worst case

1766
00:34:44,600 --> 00:34:44,610
 

1767
00:34:44,610 --> 00:34:47,020
scenario is that the

1768
00:34:47,020 --> 00:34:47,030
 

1769
00:34:47,030 --> 00:34:50,619
the key that we want is the the previous

1770
00:34:50,619 --> 00:34:50,629
 

1771
00:34:50,629 --> 00:34:52,629
key in our hand our hash table so we

1772
00:34:52,629 --> 00:34:52,639
 

1773
00:34:52,639 --> 00:34:54,129
land at one position and then have to

1774
00:34:54,129 --> 00:34:54,139
 

1775
00:34:54,139 --> 00:34:55,840
scan through the entire thing loop back

1776
00:34:55,840 --> 00:34:55,850
 

1777
00:34:55,850 --> 00:34:58,240
around then get to the very end and just

1778
00:34:58,240 --> 00:34:58,250
 

1779
00:34:58,250 --> 00:34:59,230
find the thing that we're looking for

1780
00:34:59,230 --> 00:34:59,240
 

1781
00:34:59,240 --> 00:35:02,020
and in that that case you know the the

1782
00:35:02,020 --> 00:35:02,030

1783
00:35:02,030 --> 00:35:03,880
the hash table is essentially useless to

1784
00:35:03,880 --> 00:35:03,890
 

1785
00:35:03,890 --> 00:35:05,200
us because we could have just done a

1786
00:35:05,200 --> 00:35:05,210
 

1787
00:35:05,210 --> 00:35:07,630
special scan on the data and try to find

1788
00:35:07,630 --> 00:35:07,640
 

1789
00:35:07,640 --> 00:35:08,620
that thing when we were looking for it

1790
00:35:08,620 --> 00:35:08,630
 

1791
00:35:08,630 --> 00:35:09,850
but now we're paying this this penalty

1792
00:35:09,850 --> 00:35:09,860
 

1793
00:35:09,860 --> 00:35:11,710
or this cost overhead I'm maintaining

1794
00:35:11,710 --> 00:35:11,720
 

1795
00:35:11,720 --> 00:35:13,870
this hash table and building it and

1796
00:35:13,870 --> 00:35:13,880
 

1797
00:35:13,880 --> 00:35:16,030
didn't actually help us in any way right

1798
00:35:16,030 --> 00:35:16,040
 

1799
00:35:16,040 --> 00:35:17,800
what should have been an o1 lookup is

1800
00:35:17,800 --> 00:35:17,810
 

1801
00:35:17,810 --> 00:35:21,190
now an own Oh n lookup in the worst case

1802
00:35:21,190 --> 00:35:21,200
 

1803
00:35:21,200 --> 00:35:24,790
scenario so again I said the way we can

1804
00:35:24,790 --> 00:35:24,800
 

1805
00:35:24,800 --> 00:35:26,170
try to avoid the number of collisions is

1806
00:35:26,170 --> 00:35:26,180
 

1807
00:35:26,180 --> 00:35:28,420
just by allocating more memory the

1808
00:35:28,420 --> 00:35:28,430
 

1809
00:35:28,430 --> 00:35:29,890
theory works out the math works out that

1810
00:35:29,890 --> 00:35:29,900
 

1811
00:35:29,900 --> 00:35:33,310
on practice if you want to reduce you

1812
00:35:33,310 --> 00:35:33,320
 

1813
00:35:33,320 --> 00:35:34,720
know the sort of the best or an average

1814
00:35:34,720 --> 00:35:34,730
 

1815
00:35:34,730 --> 00:35:37,720
reduction of collisions would be

1816
00:35:37,720 --> 00:35:37,730
 

1817
00:35:37,730 --> 00:35:39,940
allocating a hash table that's two times

1818
00:35:39,940 --> 00:35:39,950
 

1819
00:35:39,950 --> 00:35:42,910
the amount of of keys you actually want

1820
00:35:42,910 --> 00:35:42,920
 

1821
00:35:42,920 --> 00:35:47,020
to store but it's still not gonna help

1822
00:35:47,020 --> 00:35:47,030
 

1823
00:35:47,030 --> 00:35:49,900
our case where well yeah this reduces

1824
00:35:49,900 --> 00:35:49,910
 

1825
00:35:49,910 --> 00:35:50,890
the collisions and reduce the amount of

1826
00:35:50,890 --> 00:35:50,900
 

1827
00:35:50,900 --> 00:35:52,240
work we have but maybe there's other

1828
00:35:52,240 --> 00:35:52,250
 

1829
00:35:52,250 --> 00:35:54,370
approaches we could apply to actually

1830
00:35:54,370 --> 00:35:54,380
 

1831
00:35:54,380 --> 00:35:56,530
reduce the number of scans we have to do

1832
00:35:56,530 --> 00:35:56,540
 

1833
00:35:56,540 --> 00:35:58,600
or lookups we have to do to find the

1834
00:35:58,600 --> 00:35:58,610
 

1835
00:35:58,610 --> 00:36:02,140
keys that we're looking for so the two

1836
00:36:02,140 --> 00:36:02,150
 

1837
00:36:02,150 --> 00:36:03,730
approaches to do this are robin hood

1838
00:36:03,730 --> 00:36:03,740
 

1839
00:36:03,740 --> 00:36:06,310
hashing and cuckoo hashing so Robin Hood

1840
00:36:06,310 --> 00:36:06,320
 

1841
00:36:06,320 --> 00:36:08,020
hashing is a variant of the linear

1842
00:36:08,020 --> 00:36:08,030
 

1843
00:36:08,030 --> 00:36:12,010
probing scheme where instead of a when

1844
00:36:12,010 --> 00:36:12,020
 

1845
00:36:12,020 --> 00:36:14,380
we do an insert instead of just finding

1846
00:36:14,380 --> 00:36:14,390
 

1847
00:36:14,390 --> 00:36:18,400
the first free slot that comes after the

1848
00:36:18,400 --> 00:36:18,410
 

1849
00:36:18,410 --> 00:36:20,530
you know where we should be in the in

1850
00:36:20,530 --> 00:36:20,540
 

1851
00:36:20,540 --> 00:36:22,810
the in the hash table we will actually

1852
00:36:22,810 --> 00:36:22,820
 

1853
00:36:22,820 --> 00:36:25,780
allow new keys that are be inserted to

1854
00:36:25,780 --> 00:36:25,790
 

1855
00:36:25,790 --> 00:36:29,650
steal the slot of existing keys if they

1856
00:36:29,650 --> 00:36:29,660
 

1857
00:36:29,660 --> 00:36:32,800
are richer in quotes than we are right

1858
00:36:32,800 --> 00:36:32,810
 

1859
00:36:32,810 --> 00:36:35,080
so Robin Hood is the you know the the

1860
00:36:35,080 --> 00:36:35,090
 

1861
00:36:35,090 --> 00:36:37,270
folklore that the tale of medieval

1862
00:36:37,270 --> 00:36:37,280
 

1863
00:36:37,280 --> 00:36:38,950
England Robin Hood would steal from the

1864
00:36:38,950 --> 00:36:38,960
 

1865
00:36:38,960 --> 00:36:39,910
rich people and give it to the poor

1866
00:36:39,910 --> 00:36:39,920
 

1867
00:36:39,920 --> 00:36:41,860
people so the idea of our hash table

1868
00:36:41,860 --> 00:36:41,870
 

1869
00:36:41,870 --> 00:36:44,500
here is you want to have poor keys steal

1870
00:36:44,500 --> 00:36:44,510
 

1871
00:36:44,510 --> 00:36:46,750
from the rich keys and I'm defining rich

1872
00:36:46,750 --> 00:36:46,760
 

1873
00:36:46,760 --> 00:36:49,690
in terms of how many positions or jumps

1874
00:36:49,690 --> 00:36:49,700
 

1875
00:36:49,700 --> 00:36:51,430
they are from where where they actually

1876
00:36:51,430 --> 00:36:51,440

1877
00:36:51,440 --> 00:36:53,410
should be in their optimal position in

1878
00:36:53,410 --> 00:36:53,420
 

1879
00:36:53,420 --> 00:36:55,990
the hash table so when we do an insert

1880
00:36:55,990 --> 00:36:56,000
 

1881
00:36:56,000 --> 00:36:58,240
if we can't get to our position where we

1882
00:36:58,240 --> 00:36:58,250
 

1883
00:36:58,250 --> 00:37:00,940
want to be if as we start scanning

1884
00:37:00,940 --> 00:37:00,950
 

1885
00:37:00,950 --> 00:37:04,810
if we come across a key that is closer

1886
00:37:04,810 --> 00:37:04,820

1887
00:37:04,820 --> 00:37:07,150
to where they want to be in terms of

1888
00:37:07,150 --> 00:37:07,160
 

1889
00:37:07,160 --> 00:37:08,290
their optimum position to where we

1890
00:37:08,290 --> 00:37:08,300
 

1891
00:37:08,300 --> 00:37:10,480
should be then we'll we'll go ahead and

1892
00:37:10,480 --> 00:37:10,490
 

1893
00:37:10,490 --> 00:37:12,760
steal their slot and then move them down

1894
00:37:12,760 --> 00:37:12,770
 

1895
00:37:12,770 --> 00:37:16,660
to a worser position so let's go back to

1896
00:37:16,660 --> 00:37:16,670
 

1897
00:37:16,670 --> 00:37:19,300
our table we had before again keys who

1898
00:37:19,300 --> 00:37:19,310
 

1899
00:37:19,310 --> 00:37:21,730
owned an insert as ABCDEF and we said

1900
00:37:21,730 --> 00:37:21,740
 

1901
00:37:21,740 --> 00:37:24,100
that a when we hash it and gets inserted

1902
00:37:24,100 --> 00:37:24,110
 

1903
00:37:24,110 --> 00:37:27,100
here and now you can see in our hash

1904
00:37:27,100 --> 00:37:27,110

1905
00:37:27,110 --> 00:37:29,170
table in addition to the original key

1906
00:37:29,170 --> 00:37:29,180
 

1907
00:37:29,180 --> 00:37:29,950
and the value

1908
00:37:29,950 --> 00:37:29,960

1909
00:37:29,960 --> 00:37:32,380
I'm also going to store this this

1910
00:37:32,380 --> 00:37:32,390
 

1911
00:37:32,390 --> 00:37:34,480
position that says that getting the

1912
00:37:34,480 --> 00:37:34,490
 

1913
00:37:34,490 --> 00:37:36,430
number of jumps who are from our optimal

1914
00:37:36,430 --> 00:37:36,440

1915
00:37:36,440 --> 00:37:39,010
first position so in this case here when

1916
00:37:39,010 --> 00:37:39,020

1917
00:37:39,020 --> 00:37:41,800
we inserted a nobody else was in a slot

1918
00:37:41,800 --> 00:37:41,810
 

1919
00:37:41,810 --> 00:37:44,470
so a got to take it so a is position for

1920
00:37:44,470 --> 00:37:44,480
 

1921
00:37:44,480 --> 00:37:47,620
that it's this it's distance from its

1922
00:37:47,620 --> 00:37:47,630
 

1923
00:37:47,630 --> 00:37:49,990
optimal position is 0 because it's 0

1924
00:37:49,990 --> 00:37:50,000
 

1925
00:37:50,000 --> 00:37:51,730
jumps from where it should be because

1926
00:37:51,730 --> 00:37:51,740
 

1927
00:37:51,740 --> 00:37:54,160
this is exactly where it should be same

1928
00:37:54,160 --> 00:37:54,170
 

1929
00:37:54,170 --> 00:37:56,920
thing for B be hashed up here it's it's

1930
00:37:56,920 --> 00:37:56,930
 

1931
00:37:56,930 --> 00:38:00,370
it's it's a position counter is 0 so now

1932
00:38:00,370 --> 00:38:00,380
 

1933
00:38:00,380 --> 00:38:03,100
we want to insert C C wants to go over a

1934
00:38:03,100 --> 00:38:03,110
 

1935
00:38:03,110 --> 00:38:05,860
is so now we want to do a comparison to

1936
00:38:05,860 --> 00:38:05,870
 

1937
00:38:05,870 --> 00:38:08,380
say what's a optimal position counter

1938
00:38:08,380 --> 00:38:08,390

1939
00:38:08,390 --> 00:38:10,330
versus our optimal position counter now

1940
00:38:10,330 --> 00:38:10,340
 

1941
00:38:10,340 --> 00:38:13,120
at this point seed it hasn't gone

1942
00:38:13,120 --> 00:38:13,130
 

1943
00:38:13,130 --> 00:38:14,620
anywhere right we merely hashed at this

1944
00:38:14,620 --> 00:38:14,630
 

1945
00:38:14,630 --> 00:38:17,160
slot here so our position counter at 0 a

1946
00:38:17,160 --> 00:38:17,170
 

1947
00:38:17,170 --> 00:38:20,080
special counter is 0 so we leave a alone

1948
00:38:20,080 --> 00:38:20,090
 

1949
00:38:20,090 --> 00:38:22,210
and we just do what we did before in

1950
00:38:22,210 --> 00:38:22,220
 

1951
00:38:22,220 --> 00:38:24,280
linear probing the original version and

1952
00:38:24,280 --> 00:38:24,290
 

1953
00:38:24,290 --> 00:38:26,560
just jump down to the next one but now

1954
00:38:26,560 --> 00:38:26,570
 

1955
00:38:26,570 --> 00:38:29,400
you see that for cases see we made its

1956
00:38:29,400 --> 00:38:29,410
 

1957
00:38:29,410 --> 00:38:32,050
optimal position counter b1 because

1958
00:38:32,050 --> 00:38:32,060
 

1959
00:38:32,060 --> 00:38:33,610
we're one jump away from where we want

1960
00:38:33,610 --> 00:38:33,620
 

1961
00:38:33,620 --> 00:38:36,970
to be which is where a is so now we want

1962
00:38:36,970 --> 00:38:36,980
 

1963
00:38:36,980 --> 00:38:41,680
to do a do insert on D D goes where C

1964
00:38:41,680 --> 00:38:41,690
 

1965
00:38:41,690 --> 00:38:45,640
wants to be DS position counter is 0 C's

1966
00:38:45,640 --> 00:38:45,650
 

1967
00:38:45,650 --> 00:38:47,740
position counter is 1 1 is greater than

1968
00:38:47,740 --> 00:38:47,750

1969
00:38:47,750 --> 00:38:50,380
0 so DS not allowed to stoop from C and

1970
00:38:50,380 --> 00:38:50,390
 

1971
00:38:50,390 --> 00:38:53,110
D has skipped moved down here now you

1972
00:38:53,110 --> 00:38:53,120
 

1973
00:38:53,120 --> 00:38:55,030
see this this stealing thing actually

1974
00:38:55,030 --> 00:38:55,040
 

1975
00:38:55,040 --> 00:38:57,640
work when we try to insert e so e wants

1976
00:38:57,640 --> 00:38:57,650
 

1977
00:38:57,650 --> 00:39:00,760
to go where a is but they're both 0 at

1978
00:39:00,760 --> 00:39:00,770
 

1979
00:39:00,770 --> 00:39:02,760
that point so it doesn't steal from a

1980
00:39:02,760 --> 00:39:02,770
 

1981
00:39:02,770 --> 00:39:05,140
then we go down here to where C is

1982
00:39:05,140 --> 00:39:05,150
 

1983
00:39:05,150 --> 00:39:08,650
seized position is one E's position

1984
00:39:08,650 --> 00:39:08,660
 

1985
00:39:08,660 --> 00:39:10,840
counter is 1 so that it leaves C alone

1986
00:39:10,840 --> 00:39:10,850
 

1987
00:39:10,850 --> 00:39:14,410
but now we go to D so now E is

1988
00:39:14,410 --> 00:39:14,420
 

1989
00:39:14,420 --> 00:39:17,500
two hops away from where it wants to be

1990
00:39:17,500 --> 00:39:17,510
 

1991
00:39:17,510 --> 00:39:21,789
e D is one hop away 2 is greater than 1

1992
00:39:21,789 --> 00:39:21,799
 

1993
00:39:21,799 --> 00:39:24,970
so E is allowed to steal from eat eat e

1994
00:39:24,970 --> 00:39:24,980
 

1995
00:39:24,980 --> 00:39:28,359
is a lot of soot from D steals its lot

1996
00:39:28,359 --> 00:39:28,369
 

1997
00:39:28,369 --> 00:39:30,579
kills it and it moves it down to the

1998
00:39:30,579 --> 00:39:30,589
 

1999
00:39:30,589 --> 00:39:33,370
next position here and now DS counter is

2000
00:39:33,370 --> 00:39:33,380
 

2001
00:39:33,380 --> 00:39:35,500
2 right

2002
00:39:35,500 --> 00:39:35,510
 

2003
00:39:35,510 --> 00:39:38,620
same thing with F one more time F once

2004
00:39:38,620 --> 00:39:38,630

2005
00:39:38,630 --> 00:39:41,440
ago over D is 2 is greater than 0 so f

2006
00:39:41,440 --> 00:39:41,450
 

2007
00:39:41,450 --> 00:39:43,059
can't go there so f goes down to the

2008
00:39:43,059 --> 00:39:43,069
 

2009
00:39:43,069 --> 00:39:46,480
down below right so this is this is

2010
00:39:46,480 --> 00:39:46,490
 

2011
00:39:46,490 --> 00:39:48,910
again this is a what we're trying to do

2012
00:39:48,910 --> 00:39:48,920
 

2013
00:39:48,920 --> 00:39:51,460
here or what this is supposed to do

2014
00:39:51,460 --> 00:39:51,470
 

2015
00:39:51,470 --> 00:39:53,559
better than the linear probing hashing

2016
00:39:53,559 --> 00:39:53,569
 

2017
00:39:53,569 --> 00:39:58,240
scheme is that on average the the amount

2018
00:39:58,240 --> 00:39:58,250
 

2019
00:39:58,250 --> 00:40:00,339
of scanning you have to do to find the

2020
00:40:00,339 --> 00:40:00,349
 

2021
00:40:00,349 --> 00:40:02,440
key that you're looking for is is

2022
00:40:02,440 --> 00:40:02,450
 

2023
00:40:02,450 --> 00:40:06,069
reduced right sort of cuz right where

2024
00:40:06,069 --> 00:40:06,079
 

2025
00:40:06,079 --> 00:40:08,579
we're sort of shuffling things around to

2026
00:40:08,579 --> 00:40:08,589
 

2027
00:40:08,589 --> 00:40:10,900
minimize the number of hops any one key

2028
00:40:10,900 --> 00:40:10,910
 

2029
00:40:10,910 --> 00:40:13,030
could actually ever be so my exam all

2030
00:40:13,030 --> 00:40:13,040
 

2031
00:40:13,040 --> 00:40:14,559
before ever I said it was in the worst

2032
00:40:14,559 --> 00:40:14,569
 

2033
00:40:14,569 --> 00:40:18,160
case scenario would be the the key that

2034
00:40:18,160 --> 00:40:18,170
 

2035
00:40:18,170 --> 00:40:20,410
I'm looking for this is actually 1 above

2036
00:40:20,410 --> 00:40:20,420
 

2037
00:40:20,420 --> 00:40:23,200
where I hash to that can't occur under

2038
00:40:23,200 --> 00:40:23,210
 

2039
00:40:23,210 --> 00:40:25,390
this scheme because before you got there

2040
00:40:25,390 --> 00:40:25,400
 

2041
00:40:25,400 --> 00:40:27,910
things will get swapped around right

2042
00:40:27,910 --> 00:40:27,920
 

2043
00:40:27,920 --> 00:40:29,020
because there's likely to be one that's

2044
00:40:29,020 --> 00:40:29,030
 

2045
00:40:29,030 --> 00:40:32,289
actually worse than than you so this is

2046
00:40:32,289 --> 00:40:32,299
 

2047
00:40:32,299 --> 00:40:34,930
an old technique this is from like 1985

2048
00:40:34,930 --> 00:40:34,940
 

2049
00:40:34,940 --> 00:40:36,190
and it's one of those things were like

2050
00:40:36,190 --> 00:40:36,200
 

2051
00:40:36,200 --> 00:40:38,349
the paper came out in 1985 no one

2052
00:40:38,349 --> 00:40:38,359
 

2053
00:40:38,359 --> 00:40:38,980
actually read it

2054
00:40:38,980 --> 00:40:38,990
 

2055
00:40:38,990 --> 00:40:41,470
and then or paid paid attention to it in

2056
00:40:41,470 --> 00:40:41,480
 

2057
00:40:41,480 --> 00:40:43,780
sort of the system's community and then

2058
00:40:43,780 --> 00:40:43,790
 

2059
00:40:43,790 --> 00:40:45,849
the last 10 years it sort of showed up

2060
00:40:45,849 --> 00:40:45,859
 

2061
00:40:45,859 --> 00:40:47,440
on Hacker News a couple of times and

2062
00:40:47,440 --> 00:40:47,450
 

2063
00:40:47,450 --> 00:40:49,270
some systems were actually implementing

2064
00:40:49,270 --> 00:40:49,280
 

2065
00:40:49,280 --> 00:40:53,260
this the in practice what I'll say

2066
00:40:53,260 --> 00:40:53,270

2067
00:40:53,270 --> 00:40:56,170
though is that the the research shows

2068
00:40:56,170 --> 00:40:56,180

2069
00:40:56,180 --> 00:40:58,870
that this actually does not this is not

2070
00:40:58,870 --> 00:40:58,880
 

2071
00:40:58,880 --> 00:41:00,309
better than linear probing it seems like

2072
00:41:00,309 --> 00:41:00,319
 

2073
00:41:00,319 --> 00:41:02,559
it would be but it's not because on

2074
00:41:02,559 --> 00:41:02,569
 

2075
00:41:02,569 --> 00:41:05,789
modern CPUs all this sort of these

2076
00:41:05,789 --> 00:41:05,799
 

2077
00:41:05,799 --> 00:41:08,109
checking these these these counters and

2078
00:41:08,109 --> 00:41:08,119
 

2079
00:41:08,119 --> 00:41:10,240
movie things if necessary this is doing

2080
00:41:10,240 --> 00:41:10,250
 

2081
00:41:10,250 --> 00:41:12,339
additional branch misprediction which is

2082
00:41:12,339 --> 00:41:12,349
 

2083
00:41:12,349 --> 00:41:14,230
slower on superscalar architectures I

2084
00:41:14,230 --> 00:41:14,240
 

2085
00:41:14,240 --> 00:41:16,390
get the flush your your your pipeline

2086
00:41:16,390 --> 00:41:16,400
 

2087
00:41:16,400 --> 00:41:18,460
cache your pipeline and load everything

2088
00:41:18,460 --> 00:41:18,470
 

2089
00:41:18,470 --> 00:41:21,910
back in and it's also extra copying so

2090
00:41:21,910 --> 00:41:21,920
 

2091
00:41:21,920 --> 00:41:24,370
for a single insert I may have to copy

2092
00:41:24,370 --> 00:41:24,380
 

2093
00:41:24,380 --> 00:41:26,020
one things out and move it to the next

2094
00:41:26,020 --> 00:41:26,030
 

2095
00:41:26,030 --> 00:41:28,120
one I don't do that on our linear

2096
00:41:28,120 --> 00:41:28,130
 

2097
00:41:28,130 --> 00:41:29,680
because I just keep scanning to the

2098
00:41:29,680 --> 00:41:29,690
 

2099
00:41:29,690 --> 00:41:31,660
final thing that I want and the scanning

2100
00:41:31,660 --> 00:41:31,670
 

2101
00:41:31,670 --> 00:41:45,070
is actually cheap yes your question is

2102
00:41:45,070 --> 00:41:45,080
 

2103
00:41:45,080 --> 00:41:49,210
back here when we were inserting e your

2104
00:41:49,210 --> 00:41:49,220
 

2105
00:41:49,220 --> 00:41:52,330
question is at this point here when we

2106
00:41:52,330 --> 00:41:52,340

2107
00:41:52,340 --> 00:41:55,660
want to steal from from from D we're

2108
00:41:55,660 --> 00:41:55,670
 

2109
00:41:55,670 --> 00:41:57,880
saying that your question is is this

2110
00:41:57,880 --> 00:41:57,890
 

2111
00:41:57,890 --> 00:42:00,790
ensure that D is no nakri worse than e

2112
00:42:00,790 --> 00:42:00,800
 

2113
00:42:00,800 --> 00:42:07,690
or e Zachry worse than D yes correct so

2114
00:42:07,690 --> 00:42:07,700
 

2115
00:42:07,700 --> 00:42:10,150
his statement is in this case here when

2116
00:42:10,150 --> 00:42:10,160
 

2117
00:42:10,160 --> 00:42:12,370
we're stealing the idea of stealing is

2118
00:42:12,370 --> 00:42:12,380
 

2119
00:42:12,380 --> 00:42:13,740
that we're gonna make it so that the

2120
00:42:13,740 --> 00:42:13,750
 

2121
00:42:13,750 --> 00:42:17,730
victim the person were stealing from

2122
00:42:17,730 --> 00:42:17,740
 

2123
00:42:17,740 --> 00:42:20,770
it's no it's gonna be they have the same

2124
00:42:20,770 --> 00:42:20,780
 

2125
00:42:20,780 --> 00:42:22,900
number of steps but it's not gonna be

2126
00:42:22,900 --> 00:42:22,910
 

2127
00:42:22,910 --> 00:42:24,730
worse and we're defining worse and then

2128
00:42:24,730 --> 00:42:24,740
 

2129
00:42:24,740 --> 00:42:26,050
again the number of jumps you are from

2130
00:42:26,050 --> 00:42:26,060
 

2131
00:42:26,060 --> 00:42:28,000
where you should be so in this case here

2132
00:42:28,000 --> 00:42:28,010

2133
00:42:28,010 --> 00:42:31,150
II was to D got moved down and then D

2134
00:42:31,150 --> 00:42:31,160
 

2135
00:42:31,160 --> 00:42:33,100
was gonna be two as well so it's not

2136
00:42:33,100 --> 00:42:33,110
 

2137
00:42:33,110 --> 00:42:34,990
going to the scenario where D would be

2138
00:42:34,990 --> 00:42:35,000
 

2139
00:42:35,000 --> 00:42:39,310
three right actually it could be

2140
00:42:39,310 --> 00:42:39,320
 

2141
00:42:39,320 --> 00:42:40,660
actually cuz because if the one below

2142
00:42:40,660 --> 00:42:40,670
 

2143
00:42:40,670 --> 00:42:42,610
this was two then D would keep going

2144
00:42:42,610 --> 00:42:42,620
 

2145
00:42:42,620 --> 00:42:45,040
down but then at some point it would it

2146
00:42:45,040 --> 00:42:45,050
 

2147
00:42:45,050 --> 00:42:47,320
did find somebody could steal from so

2148
00:42:47,320 --> 00:42:47,330
 

2149
00:42:47,330 --> 00:42:48,490
there's no guarantee that actually

2150
00:42:48,490 --> 00:42:48,500

2151
00:42:48,500 --> 00:42:49,930
stealing would actually not make you

2152
00:42:49,930 --> 00:42:49,940

2153
00:42:49,940 --> 00:42:53,110
worse than the one you stole from you so

2154
00:42:53,110 --> 00:42:53,120
 

2155
00:42:53,120 --> 00:42:55,000
way to think about this in sort of human

2156
00:42:55,000 --> 00:42:55,010
 

2157
00:42:55,010 --> 00:42:58,000
metaphor would be I could steal from a

2158
00:42:58,000 --> 00:42:58,010
 

2159
00:42:58,010 --> 00:42:59,470
rich person take all their money and now

2160
00:42:59,470 --> 00:42:59,480
 

2161
00:42:59,480 --> 00:43:01,480
they're more poor than I am all right

2162
00:43:01,480 --> 00:43:01,490
 

2163
00:43:01,490 --> 00:43:29,470
that can happen under this yes wait so

2164
00:43:29,470 --> 00:43:29,480
 

2165
00:43:29,480 --> 00:43:31,780
the statement is that like in my example

2166
00:43:31,780 --> 00:43:31,790
 

2167
00:43:31,790 --> 00:43:35,040
here the total amount of steps is is

2168
00:43:35,040 --> 00:43:35,050
 

2169
00:43:35,050 --> 00:43:38,020
essentially still the same for everyone

2170
00:43:38,020 --> 00:43:38,030
 

2171
00:43:38,030 --> 00:43:41,750
right

2172
00:43:41,750 --> 00:43:41,760


2173
00:43:41,760 --> 00:43:45,540
the in this example here the my hash

2174
00:43:45,540 --> 00:43:45,550
 

2175
00:43:45,550 --> 00:43:48,540
table is tightly packed right in a real

2176
00:43:48,540 --> 00:43:48,550
 

2177
00:43:48,550 --> 00:43:50,000
hash table if you allocated enough size

2178
00:43:50,000 --> 00:43:50,010
 

2179
00:43:50,010 --> 00:43:53,010
large enough then the likelihood that

2180
00:43:53,010 --> 00:43:53,020
 

2181
00:43:53,020 --> 00:43:54,630
they'll be an empty slot so that you're

2182
00:43:54,630 --> 00:43:54,640
 

2183
00:43:54,640 --> 00:43:56,940
not sort of just keep cascading down and

2184
00:43:56,940 --> 00:43:56,950

2185
00:43:56,950 --> 00:43:58,530
and still ending up in even worse

2186
00:43:58,530 --> 00:43:58,540
 

2187
00:43:58,540 --> 00:44:01,680
position is unlikely it's not always the

2188
00:44:01,680 --> 00:44:01,690
 

2189
00:44:01,690 --> 00:44:03,180
case the other thing I'll say too is

2190
00:44:03,180 --> 00:44:03,190
 

2191
00:44:03,190 --> 00:44:05,430
like own average this makes the the

2192
00:44:05,430 --> 00:44:05,440
 

2193
00:44:05,440 --> 00:44:18,390
number of steps per key minimum exactly

2194
00:44:18,390 --> 00:44:18,400
 

2195
00:44:18,400 --> 00:44:19,470
right so this is trying to avoid the

2196
00:44:19,470 --> 00:44:19,480
 

2197
00:44:19,480 --> 00:44:21,030
worst case scenario where that I have to

2198
00:44:21,030 --> 00:44:21,040
 

2199
00:44:21,040 --> 00:44:22,710
scan through the entire thing that's all

2200
00:44:22,710 --> 00:44:22,720
 

2201
00:44:22,720 --> 00:44:30,990
the scheme does yes right so the same it

2202
00:44:30,990 --> 00:44:31,000

2203
00:44:31,000 --> 00:44:32,580
is and I agree with it is that this is a

2204
00:44:32,580 --> 00:44:32,590
 

2205
00:44:32,590 --> 00:44:34,950
trade-off between the guys are in the

2206
00:44:34,950 --> 00:44:34,960
 

2207
00:44:34,960 --> 00:44:36,990
optimal position potentially versus ones

2208
00:44:36,990 --> 00:44:37,000

2209
00:44:37,000 --> 00:44:39,600
that actually be you know really bad yes

2210
00:44:39,600 --> 00:44:39,610
 

2211
00:44:39,610 --> 00:44:42,270
absolutely right so again the literature

2212
00:44:42,270 --> 00:44:42,280
 

2213
00:44:42,280 --> 00:44:43,860
says that although this seems kind of

2214
00:44:43,860 --> 00:44:43,870
 

2215
00:44:43,870 --> 00:44:46,530
like you know a need nifty idea this

2216
00:44:46,530 --> 00:44:46,540
 

2217
00:44:46,540 --> 00:44:48,150
actually is worse than linear probing

2218
00:44:48,150 --> 00:44:48,160
 

2219
00:44:48,160 --> 00:44:50,310
because you're not gonna always getting

2220
00:44:50,310 --> 00:44:50,320
 

2221
00:44:50,320 --> 00:44:52,200
to get the huge benefit that that you

2222
00:44:52,200 --> 00:44:52,210
 

2223
00:44:52,210 --> 00:44:54,270
know you're minimizing everyone's number

2224
00:44:54,270 --> 00:44:54,280

2225
00:44:54,280 --> 00:44:56,520
jumps are steps you have to take and we

2226
00:44:56,520 --> 00:44:56,530
 

2227
00:44:56,530 --> 00:44:57,750
have to do more work in order to

2228
00:44:57,750 --> 00:44:57,760
 

2229
00:44:57,760 --> 00:44:59,730
reshuffle things so in our linear

2230
00:44:59,730 --> 00:44:59,740
 

2231
00:44:59,740 --> 00:45:01,530
probing I just scan through until I find

2232
00:45:01,530 --> 00:45:01,540
 

2233
00:45:01,540 --> 00:45:03,570
my my slot that's free and just put it

2234
00:45:03,570 --> 00:45:03,580
 

2235
00:45:03,580 --> 00:45:06,570
in there right under this I have to do

2236
00:45:06,570 --> 00:45:06,580
 

2237
00:45:06,580 --> 00:45:09,120
the you know the copying of the new one

2238
00:45:09,120 --> 00:45:09,130
 

2239
00:45:09,130 --> 00:45:10,350
in and the copy the old one out and

2240
00:45:10,350 --> 00:45:10,360
 

2241
00:45:10,360 --> 00:45:12,540
moving it down so that means cache

2242
00:45:12,540 --> 00:45:12,550
 

2243
00:45:12,550 --> 00:45:15,410
misses branch mispredictions on the CPU

2244
00:45:15,410 --> 00:45:15,420
 

2245
00:45:15,420 --> 00:45:21,240
and other other issues like that alright

2246
00:45:21,240 --> 00:45:21,250
 

2247
00:45:21,250 --> 00:45:26,490
good so another alternative to handling

2248
00:45:26,490 --> 00:45:26,500
 

2249
00:45:26,500 --> 00:45:28,110
these collisions is to do what's called

2250
00:45:28,110 --> 00:45:28,120
 

2251
00:45:28,120 --> 00:45:29,000
cuckoo hashing

2252
00:45:29,000 --> 00:45:29,010

2253
00:45:29,010 --> 00:45:32,610
so with cuckoo hashing the idea is that

2254
00:45:32,610 --> 00:45:32,620
 

2255
00:45:32,620 --> 00:45:33,990
we're going to maintain actually

2256
00:45:33,990 --> 00:45:34,000
 

2257
00:45:34,000 --> 00:45:36,840
multiple hash tables at the same time

2258
00:45:36,840 --> 00:45:36,850
 

2259
00:45:36,850 --> 00:45:40,140
and use multiple hash functions to hash

2260
00:45:40,140 --> 00:45:40,150

2261
00:45:40,150 --> 00:45:41,790
keys to the different hash tables and

2262
00:45:41,790 --> 00:45:41,800

2263
00:45:41,800 --> 00:45:45,030
the idea is that a key can only exist in

2264
00:45:45,030 --> 00:45:45,040
 

2265
00:45:45,040 --> 00:45:46,890
either I or one of the to one of the

2266
00:45:46,890 --> 00:45:46,900
 

2267
00:45:46,900 --> 00:45:48,570
hash tables right so for simplicity

2268
00:45:48,570 --> 00:45:48,580
 

2269
00:45:48,580 --> 00:45:50,490
would say there's just two but you could

2270
00:45:50,490 --> 00:45:50,500
 

2271
00:45:50,500 --> 00:45:53,670
have more than two and when we want to

2272
00:45:53,670 --> 00:45:53,680
 

2273
00:45:53,680 --> 00:45:54,970
do an insert we hash

2274
00:45:54,970 --> 00:45:54,980
 

2275
00:45:54,980 --> 00:45:58,210
the key twice find a free slot in either

2276
00:45:58,210 --> 00:45:58,220
 

2277
00:45:58,220 --> 00:46:01,089
one and pick that free slob but we want

2278
00:46:01,089 --> 00:46:01,099
 

2279
00:46:01,099 --> 00:46:02,920
to do a lookup again we hash our key and

2280
00:46:02,920 --> 00:46:02,930
 

2281
00:46:02,930 --> 00:46:04,870
we we check both both of the hash tables

2282
00:46:04,870 --> 00:46:04,880
 

2283
00:46:04,880 --> 00:46:06,700
now the issue is that how we're gonna

2284
00:46:06,700 --> 00:46:06,710
 

2285
00:46:06,710 --> 00:46:08,380
handle collisions we're gonna sort of

2286
00:46:08,380 --> 00:46:08,390
 

2287
00:46:08,390 --> 00:46:10,810
ping pong back and forth between the two

2288
00:46:10,810 --> 00:46:10,820
 

2289
00:46:10,820 --> 00:46:12,790
hash tables because if we have a

2290
00:46:12,790 --> 00:46:12,800

2291
00:46:12,800 --> 00:46:14,170
collision as we want to insert something

2292
00:46:14,170 --> 00:46:14,180
 

2293
00:46:14,180 --> 00:46:16,599
and that slot is taken we'll steal from

2294
00:46:16,599 --> 00:46:16,609
 

2295
00:46:16,609 --> 00:46:17,980
the whoever's in there now and then move

2296
00:46:17,980 --> 00:46:17,990
 

2297
00:46:17,990 --> 00:46:20,380
them to the next hash table all right

2298
00:46:20,380 --> 00:46:20,390
 

2299
00:46:20,390 --> 00:46:22,180
the idea here is again we don't it's

2300
00:46:22,180 --> 00:46:22,190
 

2301
00:46:22,190 --> 00:46:27,339
it's to to to minimize the number of the

2302
00:46:27,339 --> 00:46:27,349
 

2303
00:46:27,349 --> 00:46:28,329
amount of work we have to do to do a

2304
00:46:28,329 --> 00:46:28,339
 

2305
00:46:28,339 --> 00:46:30,069
lookup but we're going to pay a penalty

2306
00:46:30,069 --> 00:46:30,079
 

2307
00:46:30,079 --> 00:46:32,970
about having more extensive insertions

2308
00:46:32,970 --> 00:46:32,980
 

2309
00:46:32,980 --> 00:46:35,230
so let's eat an example like this so

2310
00:46:35,230 --> 00:46:35,240
 

2311
00:46:35,240 --> 00:46:36,819
this again for simplicity say we have

2312
00:46:36,819 --> 00:46:36,829
 

2313
00:46:36,829 --> 00:46:39,819
two hash functions in practice everyone

2314
00:46:39,819 --> 00:46:39,829
 

2315
00:46:39,829 --> 00:46:42,550
pretty much always does - I have some

2316
00:46:42,550 --> 00:46:42,560
 

2317
00:46:42,560 --> 00:46:43,839
heard of some people use three but no

2318
00:46:43,839 --> 00:46:43,849
 

2319
00:46:43,849 --> 00:46:45,250
one does more than three writes just the

2320
00:46:45,250 --> 00:46:45,260
 

2321
00:46:45,260 --> 00:46:48,099
overhead is unnecessary so let's say I

2322
00:46:48,099 --> 00:46:48,109
 

2323
00:46:48,109 --> 00:46:51,520
want to insert a again I'm gonna have

2324
00:46:51,520 --> 00:46:51,530
 

2325
00:46:51,530 --> 00:46:52,900
two hash functions one for each hash

2326
00:46:52,900 --> 00:46:52,910

2327
00:46:52,910 --> 00:46:55,930
table so when I when it comes along I

2328
00:46:55,930 --> 00:46:55,940
 

2329
00:46:55,940 --> 00:46:57,640
hash both of them and it's going to

2330
00:46:57,640 --> 00:46:57,650
 

2331
00:46:57,650 --> 00:46:59,710
point to these two locations here and at

2332
00:46:59,710 --> 00:46:59,720
 

2333
00:46:59,720 --> 00:47:02,109
this point both hash tables are empty so

2334
00:47:02,109 --> 00:47:02,119
 

2335
00:47:02,119 --> 00:47:03,760
I could go in either one position but so

2336
00:47:03,760 --> 00:47:03,770
 

2337
00:47:03,770 --> 00:47:06,099
I'll just flip a coin and tell me go to

2338
00:47:06,099 --> 00:47:06,109
 

2339
00:47:06,109 --> 00:47:09,609
into the first one now I want to hash

2340
00:47:09,609 --> 00:47:09,619
 

2341
00:47:09,619 --> 00:47:12,250
beat or insert B same thing I'll hash it

2342
00:47:12,250 --> 00:47:12,260
 

2343
00:47:12,260 --> 00:47:14,589
twice the first hash function points to

2344
00:47:14,589 --> 00:47:14,599
 

2345
00:47:14,599 --> 00:47:16,300
where a was inserted in the first hash

2346
00:47:16,300 --> 00:47:16,310
 

2347
00:47:16,310 --> 00:47:19,420
table and that's occupied so we don't

2348
00:47:19,420 --> 00:47:19,430
 

2349
00:47:19,430 --> 00:47:22,270
want to steal it because in the hash to

2350
00:47:22,270 --> 00:47:22,280
 

2351
00:47:22,280 --> 00:47:24,300
the second hash table it's an empty slot

2352
00:47:24,300 --> 00:47:24,310
 

2353
00:47:24,310 --> 00:47:26,589
so we'll always choose the empty slot

2354
00:47:26,589 --> 00:47:26,599
 

2355
00:47:26,599 --> 00:47:29,740
and put put B in there so now let's say

2356
00:47:29,740 --> 00:47:29,750
 

2357
00:47:29,750 --> 00:47:32,260
we want an insert C we hash that twice

2358
00:47:32,260 --> 00:47:32,270
 

2359
00:47:32,270 --> 00:47:34,180
it points to our a is and it points to

2360
00:47:34,180 --> 00:47:34,190
 

2361
00:47:34,190 --> 00:47:36,790
where B is in the two hash tables so now

2362
00:47:36,790 --> 00:47:36,800
 

2363
00:47:36,800 --> 00:47:38,680
we need to make a decision which one we

2364
00:47:38,680 --> 00:47:38,690
 

2365
00:47:38,690 --> 00:47:41,380
actually want to steal from and in in

2366
00:47:41,380 --> 00:47:41,390
 

2367
00:47:41,390 --> 00:47:43,839
practice it's just random right you can

2368
00:47:43,839 --> 00:47:43,849
 

2369
00:47:43,849 --> 00:47:45,010
be a bit more sophisticated and maybe

2370
00:47:45,010 --> 00:47:45,020
 

2371
00:47:45,020 --> 00:47:47,230
assume make maybe compute some metadata

2372
00:47:47,230 --> 00:47:47,240
 

2373
00:47:47,240 --> 00:47:49,270
about the collision rate on one hash

2374
00:47:49,270 --> 00:47:49,280
 

2375
00:47:49,280 --> 00:47:51,579
table versus another but as far as I

2376
00:47:51,579 --> 00:47:51,589
 

2377
00:47:51,589 --> 00:47:52,900
know nobody actually does it's just not

2378
00:47:52,900 --> 00:47:52,910
 

2379
00:47:52,910 --> 00:47:55,059
worth the engineering overhead so we'll

2380
00:47:55,059 --> 00:47:55,069
 

2381
00:47:55,069 --> 00:47:56,650
flip a coin and decide that we want to

2382
00:47:56,650 --> 00:47:56,660
 

2383
00:47:56,660 --> 00:47:58,960
steal from the second hash table so

2384
00:47:58,960 --> 00:47:58,970
 

2385
00:47:58,970 --> 00:48:01,510
we'll still beat beasts slot put in C

2386
00:48:01,510 --> 00:48:01,520
 

2387
00:48:01,520 --> 00:48:04,150
there and now when you take B and put it

2388
00:48:04,150 --> 00:48:04,160
 

2389
00:48:04,160 --> 00:48:06,280
in the other hash table so now we'll use

2390
00:48:06,280 --> 00:48:06,290
 

2391
00:48:06,290 --> 00:48:08,240
the first hash function

2392
00:48:08,240 --> 00:48:08,250
 

2393
00:48:08,250 --> 00:48:10,220
corresponds hash-table 1 we hashed that

2394
00:48:10,220 --> 00:48:10,230
 

2395
00:48:10,230 --> 00:48:12,530
but as we saw in the beginning it wanted

2396
00:48:12,530 --> 00:48:12,540
 

2397
00:48:12,540 --> 00:48:14,810
to go where a is now right member we

2398
00:48:14,810 --> 00:48:14,820
 

2399
00:48:14,820 --> 00:48:16,550
started be a hash tre is and turn an

2400
00:48:16,550 --> 00:48:16,560
 

2401
00:48:16,560 --> 00:48:17,960
empty slot in the second hash table so

2402
00:48:17,960 --> 00:48:17,970
 

2403
00:48:17,970 --> 00:48:19,820
we chose the empty slot now we want to

2404
00:48:19,820 --> 00:48:19,830
 

2405
00:48:19,830 --> 00:48:21,890
put be back on the other side now we

2406
00:48:21,890 --> 00:48:21,900
 

2407
00:48:21,900 --> 00:48:23,510
have that collision again because we're

2408
00:48:23,510 --> 00:48:23,520
 

2409
00:48:23,520 --> 00:48:25,850
never going back where a is so here

2410
00:48:25,850 --> 00:48:25,860
 

2411
00:48:25,860 --> 00:48:28,790
again we steal from a put be there hash

2412
00:48:28,790 --> 00:48:28,800
 

2413
00:48:28,800 --> 00:48:31,580
a put the second hash function and then

2414
00:48:31,580 --> 00:48:31,590

2415
00:48:31,590 --> 00:48:33,880
that puts us into the second side here

2416
00:48:33,880 --> 00:48:33,890
 

2417
00:48:33,890 --> 00:48:37,280
right so these two hash functions

2418
00:48:37,280 --> 00:48:37,290
 

2419
00:48:37,290 --> 00:48:38,450
essentially could be the same thing I

2420
00:48:38,450 --> 00:48:38,460
 

2421
00:48:38,460 --> 00:48:39,740
can be murmured hashed can be city hash

2422
00:48:39,740 --> 00:48:39,750
 

2423
00:48:39,750 --> 00:48:41,360
we just provide it with a different

2424
00:48:41,360 --> 00:48:41,370
 

2425
00:48:41,370 --> 00:48:43,190
random seed so that they have different

2426
00:48:43,190 --> 00:48:43,200
 

2427
00:48:43,200 --> 00:48:45,200
distribution properties but it doesn't

2428
00:48:45,200 --> 00:48:45,210
 

2429
00:48:45,210 --> 00:48:46,160
happen when I say different hash

2430
00:48:46,160 --> 00:48:46,170
 

2431
00:48:46,170 --> 00:48:48,380
function hash function one hash function

2432
00:48:48,380 --> 00:48:48,390
 

2433
00:48:48,390 --> 00:48:50,030
- it can be the same algorithm it can

2434
00:48:50,030 --> 00:48:50,040
 

2435
00:48:50,040 --> 00:48:51,620
just be a different seed value to give

2436
00:48:51,620 --> 00:48:51,630
 

2437
00:48:51,630 --> 00:48:55,550
it different randomness right and of

2438
00:48:55,550 --> 00:48:55,560
 

2439
00:48:55,560 --> 00:48:57,050
course what's the issue with this for

2440
00:48:57,050 --> 00:48:57,060
 

2441
00:48:57,060 --> 00:48:58,160
doing these insertions and moving things

2442
00:48:58,160 --> 00:48:58,170
 

2443
00:48:58,170 --> 00:49:01,730
back and forth infinite loop exactly

2444
00:49:01,730 --> 00:49:01,740
 

2445
00:49:01,740 --> 00:49:03,590
right so we have to maintain some

2446
00:49:03,590 --> 00:49:03,600

2447
00:49:03,600 --> 00:49:05,570
metadata to say where did we start off

2448
00:49:05,570 --> 00:49:05,580
 

2449
00:49:05,580 --> 00:49:07,610
when we first inserted so that if we

2450
00:49:07,610 --> 00:49:07,620

2451
00:49:07,620 --> 00:49:09,290
come back around we see the same key

2452
00:49:09,290 --> 00:49:09,300
 

2453
00:49:09,300 --> 00:49:10,430
trying to put it back in the same spot

2454
00:49:10,430 --> 00:49:10,440
 

2455
00:49:10,440 --> 00:49:11,570
we know we're stuck in an infinite loop

2456
00:49:11,570 --> 00:49:11,580
 

2457
00:49:11,580 --> 00:49:14,360
and at that point we have to rebuild the

2458
00:49:14,360 --> 00:49:14,370
 

2459
00:49:14,370 --> 00:49:15,340
entire hash table

2460
00:49:15,340 --> 00:49:15,350
 

2461
00:49:15,350 --> 00:49:17,780
so again typically we didn't tell about

2462
00:49:17,780 --> 00:49:17,790
 

2463
00:49:17,790 --> 00:49:19,700
rebuilding so much for the other two but

2464
00:49:19,700 --> 00:49:19,710

2465
00:49:19,710 --> 00:49:20,750
typically what you do is when you

2466
00:49:20,750 --> 00:49:20,760
 

2467
00:49:20,760 --> 00:49:22,520
recognize that my collision rate is too

2468
00:49:22,520 --> 00:49:22,530
 

2469
00:49:22,530 --> 00:49:26,000
high and I'm stuck in all these infinite

2470
00:49:26,000 --> 00:49:26,010
 

2471
00:49:26,010 --> 00:49:28,700
loops you double the size of the hash

2472
00:49:28,700 --> 00:49:28,710
 

2473
00:49:28,710 --> 00:49:30,830
table so you would do the same thing

2474
00:49:30,830 --> 00:49:30,840
 

2475
00:49:30,840 --> 00:49:32,630
here if my hash table is too big for

2476
00:49:32,630 --> 00:49:32,640
 

2477
00:49:32,640 --> 00:49:34,280
actually for both of them because it's

2478
00:49:34,280 --> 00:49:34,290
 

2479
00:49:34,290 --> 00:49:35,720
too small I have too many collisions

2480
00:49:35,720 --> 00:49:35,730
 

2481
00:49:35,730 --> 00:49:39,170
I'll get a new hash table doubled that's

2482
00:49:39,170 --> 00:49:39,180
 

2483
00:49:39,180 --> 00:49:40,760
double the size and take all the keys

2484
00:49:40,760 --> 00:49:40,770
 

2485
00:49:40,770 --> 00:49:42,590
that's another in the first one and put

2486
00:49:42,590 --> 00:49:42,600
 

2487
00:49:42,600 --> 00:49:45,020
it back into the second one alright and

2488
00:49:45,020 --> 00:49:45,030
 

2489
00:49:45,030 --> 00:49:46,250
you have to potentially lock the hash

2490
00:49:46,250 --> 00:49:46,260
 

2491
00:49:46,260 --> 00:49:48,020
table or put a latch on it while you do

2492
00:49:48,020 --> 00:49:48,030
 

2493
00:49:48,030 --> 00:49:50,060
this anybody from reading writing it

2494
00:49:50,060 --> 00:49:50,070
 

2495
00:49:50,070 --> 00:49:51,590
because you're just an she's rebuilding

2496
00:49:51,590 --> 00:49:51,600
 

2497
00:49:51,600 --> 00:49:55,130
the entire thing from scratch so the

2498
00:49:55,130 --> 00:49:55,140
 

2499
00:49:55,140 --> 00:49:58,850
math works out that with two hash tables

2500
00:49:58,850 --> 00:49:58,860
 

2501
00:49:58,860 --> 00:50:01,810
and two hash functions that you probably

2502
00:50:01,810 --> 00:50:01,820
 

2503
00:50:01,820 --> 00:50:04,370
won't have to rebuild the tree or sort

2504
00:50:04,370 --> 00:50:04,380
 

2505
00:50:04,380 --> 00:50:06,140
of rebuild the hash table until you're

2506
00:50:06,140 --> 00:50:06,150
 

2507
00:50:06,150 --> 00:50:09,110
out 50% full in the likelihood that

2508
00:50:09,110 --> 00:50:09,120
 

2509
00:50:09,120 --> 00:50:10,640
you're going to hit a key that'll get

2510
00:50:10,640 --> 00:50:10,650
 

2511
00:50:10,650 --> 00:50:12,710
stuck in an infinite loop won't really

2512
00:50:12,710 --> 00:50:12,720

2513
00:50:12,720 --> 00:50:15,200
happen to about 50% pool if you have

2514
00:50:15,200 --> 00:50:15,210
 

2515
00:50:15,210 --> 00:50:16,670
three hash functions or three hash

2516
00:50:16,670 --> 00:50:16,680

2517
00:50:16,680 --> 00:50:18,650
tables the math works out that you

2518
00:50:18,650 --> 00:50:18,660
 

2519
00:50:18,660 --> 00:50:20,210
probably need to rebuild it until you're

2520
00:50:20,210 --> 00:50:20,220
 

2521
00:50:20,220 --> 00:50:22,070
90% pool

2522
00:50:22,070 --> 00:50:22,080
 

2523
00:50:22,080 --> 00:50:23,390
of course now this means again you're

2524
00:50:23,390 --> 00:50:23,400
 

2525
00:50:23,400 --> 00:50:24,740
allocating a third hash table so you're

2526
00:50:24,740 --> 00:50:24,750

2527
00:50:24,750 --> 00:50:27,770
paying the penalty of extra memory for

2528
00:50:27,770 --> 00:50:27,780
 

2529
00:50:27,780 --> 00:50:31,100
having to execute fewer instructions so

2530
00:50:31,100 --> 00:50:31,110

2531
00:50:31,110 --> 00:50:33,080
cuckoo hashing shows up in a couple

2532
00:50:33,080 --> 00:50:33,090
 

2533
00:50:33,090 --> 00:50:35,060
different systems I know IBM db2 does

2534
00:50:35,060 --> 00:50:35,070
 

2535
00:50:35,070 --> 00:50:38,720
this for their memory accelerator this

2536
00:50:38,720 --> 00:50:38,730
 

2537
00:50:38,730 --> 00:50:41,480
one actually is pretty common the best

2538
00:50:41,480 --> 00:50:41,490
 

2539
00:50:41,490 --> 00:50:42,950
open-source implementation of the cuckoo

2540
00:50:42,950 --> 00:50:42,960
 

2541
00:50:42,960 --> 00:50:44,900
hash table is actually from CMU from

2542
00:50:44,900 --> 00:50:44,910
 

2543
00:50:44,910 --> 00:50:46,520
dave anderson so if you google like lib

2544
00:50:46,520 --> 00:50:46,530
 

2545
00:50:46,530 --> 00:50:49,630
cuckoo you'll find the CMU version of it

2546
00:50:49,630 --> 00:50:49,640
 

2547
00:50:49,640 --> 00:50:51,650
was written by Dave Anderson and his

2548
00:50:51,650 --> 00:50:51,660
 

2549
00:50:51,660 --> 00:50:55,610
students with Robin Hood hashing I only

2550
00:50:55,610 --> 00:50:55,620
 

2551
00:50:55,620 --> 00:50:58,160
know one system that does this when we

2552
00:50:58,160 --> 00:50:58,170
 

2553
00:50:58,170 --> 00:50:59,870
asked him why they do this they said

2554
00:50:59,870 --> 00:50:59,880

2555
00:50:59,880 --> 00:51:01,190
that the engineer sold on Hacker News

2556
00:51:01,190 --> 00:51:01,200

2557
00:51:01,200 --> 00:51:02,420
thought it was a good idea so they

2558
00:51:02,420 --> 00:51:02,430
 

2559
00:51:02,430 --> 00:51:05,480
implemented that but the literature

2560
00:51:05,480 --> 00:51:05,490

2561
00:51:05,490 --> 00:51:06,620
pretty much shows that for all these

2562
00:51:06,620 --> 00:51:06,630
 

2563
00:51:06,630 --> 00:51:08,240
approaches the linear probing is always

2564
00:51:08,240 --> 00:51:08,250

2565
00:51:08,250 --> 00:51:10,460
good always the best there's always me

2566
00:51:10,460 --> 00:51:10,470
 

2567
00:51:10,470 --> 00:51:15,070
the fastest so searching for hash joins

2568
00:51:15,070 --> 00:51:15,080


2569
00:51:15,080 --> 00:51:20,360
okay so these again these were static

2570
00:51:20,360 --> 00:51:20,370
 

2571
00:51:20,370 --> 00:51:23,000
hashing schemes right that means we knew

2572
00:51:23,000 --> 00:51:23,010
 

2573
00:51:23,010 --> 00:51:24,920
what the the number of keys you want to

2574
00:51:24,920 --> 00:51:24,930
 

2575
00:51:24,930 --> 00:51:27,470
store it ahead of time and she may be

2576
00:51:27,470 --> 00:51:27,480
 

2577
00:51:27,480 --> 00:51:29,960
asking water you know when is this occur

2578
00:51:29,960 --> 00:51:29,970
 

2579
00:51:29,970 --> 00:51:33,740
right when what actually when when when

2580
00:51:33,740 --> 00:51:33,750
 

2581
00:51:33,750 --> 00:51:34,820
is it possible I would actually know the

2582
00:51:34,820 --> 00:51:34,830
 

2583
00:51:34,830 --> 00:51:36,530
number keys that I have in your page

2584
00:51:36,530 --> 00:51:36,540
 

2585
00:51:36,540 --> 00:51:39,320
table you don't right cuz you the data's

2586
00:51:39,320 --> 00:51:39,330
 

2587
00:51:39,330 --> 00:51:40,460
can always keep growing you add new

2588
00:51:40,460 --> 00:51:40,470
 

2589
00:51:40,470 --> 00:51:41,630
pages so you don't know the number of

2590
00:51:41,630 --> 00:51:41,640
 

2591
00:51:41,640 --> 00:51:47,090
keys you need to store the actually

2592
00:51:47,090 --> 00:51:47,100
 

2593
00:51:47,100 --> 00:51:48,020
that's not true and we'll come back to

2594
00:51:48,020 --> 00:51:48,030
 

2595
00:51:48,030 --> 00:51:50,450
that but a stable a static because your

2596
00:51:50,450 --> 00:51:50,460
 

2597
00:51:50,460 --> 00:51:51,860
profitable size of static so it's always

2598
00:51:51,860 --> 00:51:51,870
 

2599
00:51:51,870 --> 00:51:52,790
a fixed number of pages

2600
00:51:52,790 --> 00:51:52,800
 

2601
00:51:52,800 --> 00:51:55,910
it's the directory that grows so again a

2602
00:51:55,910 --> 00:51:55,920
 

2603
00:51:55,920 --> 00:51:57,890
really common scenario is again for hash

2604
00:51:57,890 --> 00:51:57,900
 

2605
00:51:57,900 --> 00:51:59,840
joins so say I have a simple query here

2606
00:51:59,840 --> 00:51:59,850
 

2607
00:51:59,850 --> 00:52:03,200
I don't have two filters

2608
00:52:03,200 --> 00:52:03,210
 

2609
00:52:03,210 --> 00:52:05,270
I already filters on these tables so I

2610
00:52:05,270 --> 00:52:05,280
 

2611
00:52:05,280 --> 00:52:07,220
know I'm gonna read or do a join on

2612
00:52:07,220 --> 00:52:07,230
 

2613
00:52:07,230 --> 00:52:08,870
exactly the number of tuples that I have

2614
00:52:08,870 --> 00:52:08,880
 

2615
00:52:08,880 --> 00:52:11,630
in both of these two tables right so in

2616
00:52:11,630 --> 00:52:11,640
 

2617
00:52:11,640 --> 00:52:13,610
this case I know exactly the size of my

2618
00:52:13,610 --> 00:52:13,620
 

2619
00:52:13,620 --> 00:52:15,380
hash table because I know the number of

2620
00:52:15,380 --> 00:52:15,390
 

2621
00:52:15,390 --> 00:52:16,970
keys I need to examine so I can use the

2622
00:52:16,970 --> 00:52:16,980

2623
00:52:16,980 --> 00:52:18,320
linear probing I can use cuckoo hashing

2624
00:52:18,320 --> 00:52:18,330
 

2625
00:52:18,330 --> 00:52:21,460
or I can use the throttle approach right

2626
00:52:21,460 --> 00:52:21,470
 

2627
00:52:21,470 --> 00:52:24,980
if we get too big then we have to sort

2628
00:52:24,980 --> 00:52:24,990
 

2629
00:52:24,990 --> 00:52:26,810
of stop the world and read you know

2630
00:52:26,810 --> 00:52:26,820
 

2631
00:52:26,820 --> 00:52:29,120
double size and rebuild it right and

2632
00:52:29,120 --> 00:52:29,130
 

2633
00:52:29,130 --> 00:52:30,170
we'll see this later on when we start

2634
00:52:30,170 --> 00:52:30,180
 

2635
00:52:30,180 --> 00:52:32,690
doing estimations of the cardinality or

2636
00:52:32,690 --> 00:52:32,700
 

2637
00:52:32,700 --> 00:52:34,310
selectivity of predicates in our query

2638
00:52:34,310 --> 00:52:34,320
 

2639
00:52:34,320 --> 00:52:36,090
plan we get this

2640
00:52:36,090 --> 00:52:36,100

2641
00:52:36,100 --> 00:52:37,620
all the time and that's gonna make it

2642
00:52:37,620 --> 00:52:37,630
 

2643
00:52:37,630 --> 00:52:39,630
really expensive for us if we have to

2644
00:52:39,630 --> 00:52:39,640
 

2645
00:52:39,640 --> 00:52:43,080
resize our hash table in the case which

2646
00:52:43,080 --> 00:52:43,090
 

2647
00:52:43,090 --> 00:52:44,100
you guys are ready for the buffer pool

2648
00:52:44,100 --> 00:52:44,110
 

2649
00:52:44,110 --> 00:52:47,400
the in-memory page table is always going

2650
00:52:47,400 --> 00:52:47,410
 

2651
00:52:47,410 --> 00:52:50,190
to be fixed size because you you have a

2652
00:52:50,190 --> 00:52:50,200
 

2653
00:52:50,200 --> 00:52:51,870
fixed amount of memory but the page

2654
00:52:51,870 --> 00:52:51,880
 

2655
00:52:51,880 --> 00:52:53,460
directory can always be increasing in

2656
00:52:53,460 --> 00:52:53,470
 

2657
00:52:53,470 --> 00:52:56,430
size so you may not want to use one of

2658
00:52:56,430 --> 00:52:56,440
 

2659
00:52:56,440 --> 00:52:58,260
these these methods we've been talking

2660
00:52:58,260 --> 00:52:58,270

2661
00:52:58,270 --> 00:52:59,430
about because you may have to resize it

2662
00:52:59,430 --> 00:52:59,440
 

2663
00:52:59,440 --> 00:53:01,590
as you go along so this is where a

2664
00:53:01,590 --> 00:53:01,600
 

2665
00:53:01,600 --> 00:53:03,810
dynamic hash tables gonna help us so the

2666
00:53:03,810 --> 00:53:03,820
 

2667
00:53:03,820 --> 00:53:04,920
basic idea is that we're gonna be able

2668
00:53:04,920 --> 00:53:04,930
 

2669
00:53:04,930 --> 00:53:08,480
to grow our hash table incrementally

2670
00:53:08,480 --> 00:53:08,490
 

2671
00:53:08,490 --> 00:53:10,770
based on whether the number of entries

2672
00:53:10,770 --> 00:53:10,780
 

2673
00:53:10,780 --> 00:53:12,870
get you know goes up or down without

2674
00:53:12,870 --> 00:53:12,880

2675
00:53:12,880 --> 00:53:14,160
having to stop the world and rebuild

2676
00:53:14,160 --> 00:53:14,170
 

2677
00:53:14,170 --> 00:53:16,440
everything so it actually should be

2678
00:53:16,440 --> 00:53:16,450
 

2679
00:53:16,450 --> 00:53:17,370
three approaches we're gonna look at

2680
00:53:17,370 --> 00:53:17,380
 

2681
00:53:17,380 --> 00:53:19,260
chain hashing cinema hashing and linear

2682
00:53:19,260 --> 00:53:19,270
 

2683
00:53:19,270 --> 00:53:23,700
hashing alright so chain hashing is what

2684
00:53:23,700 --> 00:53:23,710
 

2685
00:53:23,710 --> 00:53:24,870
pretty much everyone thinks of when they

2686
00:53:24,870 --> 00:53:24,880
 

2687
00:53:24,880 --> 00:53:26,550
when you think of a hash table right

2688
00:53:26,550 --> 00:53:26,560
 

2689
00:53:26,560 --> 00:53:27,900
this is what you get when you when you

2690
00:53:27,900 --> 00:53:27,910
 

2691
00:53:27,910 --> 00:53:31,470
create a you know use the hash map class

2692
00:53:31,470 --> 00:53:31,480
 

2693
00:53:31,480 --> 00:53:33,600
in Java and the JDK this is the

2694
00:53:33,600 --> 00:53:33,610
 

2695
00:53:33,610 --> 00:53:35,540
underlying data structure that they use

2696
00:53:35,540 --> 00:53:35,550
 

2697
00:53:35,550 --> 00:53:39,150
so we're just gonna have a we'll have a

2698
00:53:39,150 --> 00:53:39,160
 

2699
00:53:39,160 --> 00:53:42,150
slot array that's going to maintain the

2700
00:53:42,150 --> 00:53:42,160
 

2701
00:53:42,160 --> 00:53:45,660
these pointers for every single key to

2702
00:53:45,660 --> 00:53:45,670
 

2703
00:53:45,670 --> 00:53:47,670
these the head of a linked list of

2704
00:53:47,670 --> 00:53:47,680
 

2705
00:53:47,680 --> 00:53:49,920
buckets I'm just going to store all the

2706
00:53:49,920 --> 00:53:49,930
 

2707
00:53:49,930 --> 00:53:52,800
values we have in these buckets and the

2708
00:53:52,800 --> 00:53:52,810
 

2709
00:53:52,810 --> 00:53:54,240
way we're going to handle collisions is

2710
00:53:54,240 --> 00:53:54,250
 

2711
00:53:54,250 --> 00:53:56,580
that we're just gonna scan along

2712
00:53:56,580 --> 00:53:56,590
 

2713
00:53:56,590 --> 00:53:58,980
linearly inside the bucket until we find

2714
00:53:58,980 --> 00:53:58,990
 

2715
00:53:58,990 --> 00:54:02,250
either the thing that we want if we're

2716
00:54:02,250 --> 00:54:02,260
 

2717
00:54:02,260 --> 00:54:03,750
trying to do a lookup or we find a free

2718
00:54:03,750 --> 00:54:03,760
 

2719
00:54:03,760 --> 00:54:05,040
slot that allows us to insert something

2720
00:54:05,040 --> 00:54:05,050
 

2721
00:54:05,050 --> 00:54:09,300
right so it looks like this again we

2722
00:54:09,300 --> 00:54:09,310
 

2723
00:54:09,310 --> 00:54:11,310
have our slot array that's gonna point

2724
00:54:11,310 --> 00:54:11,320
 

2725
00:54:11,320 --> 00:54:14,700
to these linked lists if there's nothing

2726
00:54:14,700 --> 00:54:14,710
 

2727
00:54:14,710 --> 00:54:16,560
then if nothing is hash to a particular

2728
00:54:16,560 --> 00:54:16,570
 

2729
00:54:16,570 --> 00:54:18,360
position in our slot array then would

2730
00:54:18,360 --> 00:54:18,370
 

2731
00:54:18,370 --> 00:54:19,740
you store null right there's no reason

2732
00:54:19,740 --> 00:54:19,750
 

2733
00:54:19,750 --> 00:54:21,330
to the point of allocate memory that we

2734
00:54:21,330 --> 00:54:21,340

2735
00:54:21,340 --> 00:54:23,190
don't need yet and then we have our

2736
00:54:23,190 --> 00:54:23,200

2737
00:54:23,200 --> 00:54:24,330
buckets and the buckets again they're

2738
00:54:24,330 --> 00:54:24,340

2739
00:54:24,340 --> 00:54:26,310
just going to be the same entries that

2740
00:54:26,310 --> 00:54:26,320
 

2741
00:54:26,320 --> 00:54:28,290
we had in the linear probing hashing

2742
00:54:28,290 --> 00:54:28,300

2743
00:54:28,300 --> 00:54:29,910
method where we have to store the key

2744
00:54:29,910 --> 00:54:29,920
 

2745
00:54:29,920 --> 00:54:31,650
and and the original key and the value

2746
00:54:31,650 --> 00:54:31,660

2747
00:54:31,660 --> 00:54:33,960
and let's say that we want to do an

2748
00:54:33,960 --> 00:54:33,970
 

2749
00:54:33,970 --> 00:54:36,720
insert into this this first bucket at

2750
00:54:36,720 --> 00:54:36,730

2751
00:54:36,730 --> 00:54:38,880
the top and it's - and it's full as we

2752
00:54:38,880 --> 00:54:38,890
 

2753
00:54:38,890 --> 00:54:41,010
follow along the linked list then we all

2754
00:54:41,010 --> 00:54:41,020
 

2755
00:54:41,020 --> 00:54:42,840
we have to do is just allocate a new

2756
00:54:42,840 --> 00:54:42,850
 

2757
00:54:42,850 --> 00:54:46,050
bucket and extend out our bucket chain

2758
00:54:46,050 --> 00:54:46,060

2759
00:54:46,060 --> 00:54:48,240
or linked list like that right

2760
00:54:48,240 --> 00:54:48,250
 

2761
00:54:48,250 --> 00:54:50,140
now we sort of see the same kind of

2762
00:54:50,140 --> 00:54:50,150
 

2763
00:54:50,150 --> 00:54:51,570
issues we have in linear probing if

2764
00:54:51,570 --> 00:54:51,580
 

2765
00:54:51,580 --> 00:54:53,830
everything hashes to the same bucket

2766
00:54:53,830 --> 00:54:53,840
 

2767
00:54:53,840 --> 00:54:56,250
then I'm since you're going to do a

2768
00:54:56,250 --> 00:54:56,260
 

2769
00:54:56,260 --> 00:54:58,810
squinter scan or linear scan across

2770
00:54:58,810 --> 00:54:58,820
 

2771
00:54:58,820 --> 00:55:00,160
every single element in the bucket list

2772
00:55:00,160 --> 00:55:00,170
 

2773
00:55:00,170 --> 00:55:02,020
to find the thing I'm looking for or

2774
00:55:02,020 --> 00:55:02,030
 

2775
00:55:02,030 --> 00:55:03,970
find a you know a free slot to put

2776
00:55:03,970 --> 00:55:03,980
 

2777
00:55:03,980 --> 00:55:06,820
something yet right so it's sort of

2778
00:55:06,820 --> 00:55:06,830
 

2779
00:55:06,830 --> 00:55:08,140
unavoidable of you if you have a lot of

2780
00:55:08,140 --> 00:55:08,150

2781
00:55:08,150 --> 00:55:09,700
collisions then you and you end up sort

2782
00:55:09,700 --> 00:55:09,710
 

2783
00:55:09,710 --> 00:55:14,430
of degenerating into a scrunch will scan

2784
00:55:14,430 --> 00:55:14,440
 

2785
00:55:14,440 --> 00:55:19,300
the right so these bucket lists can can

2786
00:55:19,300 --> 00:55:19,310

2787
00:55:19,310 --> 00:55:21,820
grow infinitely and that becomes

2788
00:55:21,820 --> 00:55:21,830
 

2789
00:55:21,830 --> 00:55:25,720
problematic in terms of how you actually

2790
00:55:25,720 --> 00:55:25,730
 

2791
00:55:25,730 --> 00:55:28,090
MIT implement us to be thread safe it's

2792
00:55:28,090 --> 00:55:28,100
 

2793
00:55:28,100 --> 00:55:29,320
actually really easy because you just

2794
00:55:29,320 --> 00:55:29,330
 

2795
00:55:29,330 --> 00:55:31,270
have to take a latch on the actual

2796
00:55:31,270 --> 00:55:31,280
 

2797
00:55:31,280 --> 00:55:33,760
bucket itself right you can easiest

2798
00:55:33,760 --> 00:55:33,770
 

2799
00:55:33,770 --> 00:55:35,290
thing to do is to take a latching entire

2800
00:55:35,290 --> 00:55:35,300
 

2801
00:55:35,300 --> 00:55:37,870
hash table or use take a latch on the

2802
00:55:37,870 --> 00:55:37,880
 

2803
00:55:37,880 --> 00:55:39,700
slot inside of the the slot array with

2804
00:55:39,700 --> 00:55:39,710

2805
00:55:39,710 --> 00:55:41,830
the pointers but even you mean more

2806
00:55:41,830 --> 00:55:41,840
 

2807
00:55:41,840 --> 00:55:45,190
fine-grain latching would be take just

2808
00:55:45,190 --> 00:55:45,200
 

2809
00:55:45,200 --> 00:55:47,349
latches on the individual pages and you

2810
00:55:47,349 --> 00:55:47,359
 

2811
00:55:47,359 --> 00:55:49,030
know nobody's going to modify as you're

2812
00:55:49,030 --> 00:55:49,040
 

2813
00:55:49,040 --> 00:55:52,570
scanning it so again the downside of

2814
00:55:52,570 --> 00:55:52,580
 

2815
00:55:52,580 --> 00:55:53,650
this approach is that these these

2816
00:55:53,650 --> 00:55:53,660
 

2817
00:55:53,660 --> 00:55:55,720
buckets grow infinitely and it's real

2818
00:55:55,720 --> 00:55:55,730
 

2819
00:55:55,730 --> 00:55:57,160
hard it's hard to shoot or shuffle

2820
00:55:57,160 --> 00:55:57,170
 

2821
00:55:57,170 --> 00:55:59,020
things around because I essentially we

2822
00:55:59,020 --> 00:55:59,030
 

2823
00:55:59,030 --> 00:56:00,580
had to rehash everything or just rebuild

2824
00:56:00,580 --> 00:56:00,590
 

2825
00:56:00,590 --> 00:56:03,820
the entire hash table so a more

2826
00:56:03,820 --> 00:56:03,830
 

2827
00:56:03,830 --> 00:56:05,080
incremental approach is what you guys

2828
00:56:05,080 --> 00:56:05,090

2829
00:56:05,090 --> 00:56:06,849
are building in your for your first

2830
00:56:06,849 --> 00:56:06,859
 

2831
00:56:06,859 --> 00:56:08,550
project is called extendable hashing

2832
00:56:08,550 --> 00:56:08,560
 

2833
00:56:08,560 --> 00:56:10,780
again these are there's an old ideas

2834
00:56:10,780 --> 00:56:10,790

2835
00:56:10,790 --> 00:56:15,130
from like 1982-83 but it's it's widely

2836
00:56:15,130 --> 00:56:15,140
 

2837
00:56:15,140 --> 00:56:18,400
used in a bunch of different systems the

2838
00:56:18,400 --> 00:56:18,410
 

2839
00:56:18,410 --> 00:56:20,530
it's basically an extension of the chain

2840
00:56:20,530 --> 00:56:20,540
 

2841
00:56:20,540 --> 00:56:23,620
hashing approach but instead of letting

2842
00:56:23,620 --> 00:56:23,630
 

2843
00:56:23,630 --> 00:56:25,270
the link list of the buckets grow

2844
00:56:25,270 --> 00:56:25,280
 

2845
00:56:25,280 --> 00:56:27,670
forever we're gonna we're gonna split

2846
00:56:27,670 --> 00:56:27,680
 

2847
00:56:27,680 --> 00:56:31,240
them and and move elements around and

2848
00:56:31,240 --> 00:56:31,250
 

2849
00:56:31,250 --> 00:56:33,130
the idea here is that rather than again

2850
00:56:33,130 --> 00:56:33,140
 

2851
00:56:33,140 --> 00:56:35,410
rebuilding everything from scratch we

2852
00:56:35,410 --> 00:56:35,420
 

2853
00:56:35,420 --> 00:56:37,120
want to do this incrementally so that

2854
00:56:37,120 --> 00:56:37,130
 

2855
00:56:37,130 --> 00:56:39,280
the impact of having to do a split is

2856
00:56:39,280 --> 00:56:39,290
 

2857
00:56:39,290 --> 00:56:42,280
not a large you know major stall in our

2858
00:56:42,280 --> 00:56:42,290
 

2859
00:56:42,290 --> 00:56:44,440
thread that's executing all right again

2860
00:56:44,440 --> 00:56:44,450

2861
00:56:44,450 --> 00:56:46,030
we building entire hash table is

2862
00:56:46,030 --> 00:56:46,040
 

2863
00:56:46,040 --> 00:56:47,440
expensive we have take a latch entire

2864
00:56:47,440 --> 00:56:47,450
 

2865
00:56:47,450 --> 00:56:48,849
thing no one can read and write from it

2866
00:56:48,849 --> 00:56:48,859
 

2867
00:56:48,859 --> 00:56:50,440
and I have to you know copy everything

2868
00:56:50,440 --> 00:56:50,450

2869
00:56:50,450 --> 00:56:51,940
one hash table and put it to another one

2870
00:56:51,940 --> 00:56:51,950
 

2871
00:56:51,950 --> 00:56:53,800
the idea of extendable hashing is that

2872
00:56:53,800 --> 00:56:53,810

2873
00:56:53,810 --> 00:56:55,080
we can do this a little bit little

2874
00:56:55,080 --> 00:56:55,090
 

2875
00:56:55,090 --> 00:56:58,480
cooperatively to sort of smooth out the

2876
00:56:58,480 --> 00:56:58,490
 

2877
00:56:58,490 --> 00:57:02,140
the access time across all threads

2878
00:57:02,140 --> 00:57:02,150
 

2879
00:57:02,150 --> 00:57:03,880
so let's look an example so we're gonna

2880
00:57:03,880 --> 00:57:03,890
 

2881
00:57:03,890 --> 00:57:06,880
have our slot array again these are just

2882
00:57:06,880 --> 00:57:06,890
 

2883
00:57:06,890 --> 00:57:09,819
me Big B pointers to our bucket list and

2884
00:57:09,819 --> 00:57:09,829
 

2885
00:57:09,829 --> 00:57:11,650
then what we're gonna have these

2886
00:57:11,650 --> 00:57:11,660
 

2887
00:57:11,660 --> 00:57:13,690
different counters that that's gonna

2888
00:57:13,690 --> 00:57:13,700
 

2889
00:57:13,700 --> 00:57:15,759
keep track of the the depth of number of

2890
00:57:15,759 --> 00:57:15,769
 

2891
00:57:15,769 --> 00:57:17,079
bits we have to look at to figure out

2892
00:57:17,079 --> 00:57:17,089
 

2893
00:57:17,089 --> 00:57:20,079
what bucket we should be going to so

2894
00:57:20,079 --> 00:57:20,089
 

2895
00:57:20,089 --> 00:57:21,460
we're gonna have the global death that

2896
00:57:21,460 --> 00:57:21,470
 

2897
00:57:21,470 --> 00:57:24,370
says the the maximum number of bits we

2898
00:57:24,370 --> 00:57:24,380
 

2899
00:57:24,380 --> 00:57:27,039
have to examine across all of our slots

2900
00:57:27,039 --> 00:57:27,049
 

2901
00:57:27,049 --> 00:57:29,230
and then for each bucket they're gonna

2902
00:57:29,230 --> 00:57:29,240
 

2903
00:57:29,240 --> 00:57:30,910
have a local death that says the number

2904
00:57:30,910 --> 00:57:30,920
 

2905
00:57:30,920 --> 00:57:33,460
of bits we need to that you need to get

2906
00:57:33,460 --> 00:57:33,470
 

2907
00:57:33,470 --> 00:57:34,779
get here or whatever we're actually

2908
00:57:34,779 --> 00:57:34,789
 

2909
00:57:34,789 --> 00:57:38,499
representing so for the local deaths we

2910
00:57:38,499 --> 00:57:38,509
 

2911
00:57:38,509 --> 00:57:40,630
don't actually need these to figure out

2912
00:57:40,630 --> 00:57:40,640
 

2913
00:57:40,640 --> 00:57:42,880
where we need to go the global death we

2914
00:57:42,880 --> 00:57:42,890
 

2915
00:57:42,890 --> 00:57:45,069
do we do need but the local deaths are

2916
00:57:45,069 --> 00:57:45,079

2917
00:57:45,079 --> 00:57:46,839
essentially metadata for us to keep

2918
00:57:46,839 --> 00:57:46,849
 

2919
00:57:46,849 --> 00:57:49,509
track of you know who's pointing can be

2920
00:57:49,509 --> 00:57:49,519
 

2921
00:57:49,519 --> 00:57:51,910
potentially pointing to us right so that

2922
00:57:51,910 --> 00:57:51,920
 

2923
00:57:51,920 --> 00:57:55,029
we can reverse this all right so the

2924
00:57:55,029 --> 00:57:55,039
 

2925
00:57:55,039 --> 00:57:56,499
first thing we see that now in our in

2926
00:57:56,499 --> 00:57:56,509
 

2927
00:57:56,509 --> 00:57:59,920
our in our slot array we have the values

2928
00:57:59,920 --> 00:57:59,930
 

2929
00:57:59,930 --> 00:58:01,420
that you have the output of our hash

2930
00:58:01,420 --> 00:58:01,430
 

2931
00:58:01,430 --> 00:58:03,549
hash function of the hash values and for

2932
00:58:03,549 --> 00:58:03,559

2933
00:58:03,559 --> 00:58:05,200
this purpose here the global death is

2934
00:58:05,200 --> 00:58:05,210
 

2935
00:58:05,210 --> 00:58:07,539
two so I only care about the first two

2936
00:58:07,539 --> 00:58:07,549
 

2937
00:58:07,549 --> 00:58:11,890
bits of the hash value so in my example

2938
00:58:11,890 --> 00:58:11,900
 

2939
00:58:11,900 --> 00:58:14,229
here I'm going from left to right I

2940
00:58:14,229 --> 00:58:14,239
 

2941
00:58:14,239 --> 00:58:15,849
think the text book goes left to right

2942
00:58:15,849 --> 00:58:15,859
 

2943
00:58:15,859 --> 00:58:17,979
some of the examples go right the left

2944
00:58:17,979 --> 00:58:17,989
 

2945
00:58:17,989 --> 00:58:19,809
it doesn't actually matter the algorithm

2946
00:58:19,809 --> 00:58:19,819
 

2947
00:58:19,819 --> 00:58:21,160
is still the same whether you go from

2948
00:58:21,160 --> 00:58:21,170
 

2949
00:58:21,170 --> 00:58:22,569
least significant or most significant

2950
00:58:22,569 --> 00:58:22,579

2951
00:58:22,579 --> 00:58:26,170
bit it's everything's still the same so

2952
00:58:26,170 --> 00:58:26,180
 

2953
00:58:26,180 --> 00:58:28,720
let's say I want to do a find on a so

2954
00:58:28,720 --> 00:58:28,730
 

2955
00:58:28,730 --> 00:58:30,489
the first thing I do is take the value a

2956
00:58:30,489 --> 00:58:30,499
 

2957
00:58:30,499 --> 00:58:33,130
the key a and I'm gonna hash it and I

2958
00:58:33,130 --> 00:58:33,140
 

2959
00:58:33,140 --> 00:58:34,509
could produce some some bit sequence

2960
00:58:34,509 --> 00:58:34,519
 

2961
00:58:34,519 --> 00:58:37,269
like that and then I look at my global

2962
00:58:37,269 --> 00:58:37,279
 

2963
00:58:37,279 --> 00:58:39,309
death and says I need to examine the

2964
00:58:39,309 --> 00:58:39,319
 

2965
00:58:39,319 --> 00:58:42,880
first two bits of the value of the hash

2966
00:58:42,880 --> 00:58:42,890
 

2967
00:58:42,890 --> 00:58:44,739
function to figure out where I need to

2968
00:58:44,739 --> 00:58:44,749
 

2969
00:58:44,749 --> 00:58:45,999
go to find the element that I'm looking

2970
00:58:45,999 --> 00:58:46,009
 

2971
00:58:46,009 --> 00:58:47,589
for or fine to find the bucket that I

2972
00:58:47,589 --> 00:58:47,599
 

2973
00:58:47,599 --> 00:58:50,289
want so in this case here I need to look

2974
00:58:50,289 --> 00:58:50,299
 

2975
00:58:50,299 --> 00:58:52,930
at the first two bits which is 0 1 so

2976
00:58:52,930 --> 00:58:52,940
 

2977
00:58:52,940 --> 00:58:55,450
that tells me I want that entry in the

2978
00:58:55,450 --> 00:58:55,460
 

2979
00:58:55,460 --> 00:58:57,729
in my slot array and it's gonna point to

2980
00:58:57,729 --> 00:58:57,739
 

2981
00:58:57,739 --> 00:59:00,609
the this bucket here at the top and then

2982
00:59:00,609 --> 00:59:00,619
 

2983
00:59:00,619 --> 00:59:02,259
I just do a special scan and that and I

2984
00:59:02,259 --> 00:59:02,269
 

2985
00:59:02,269 --> 00:59:04,380
find the thing that I'm looking for so

2986
00:59:04,380 --> 00:59:04,390
 

2987
00:59:04,390 --> 00:59:06,700
this is a good example of the difference

2988
00:59:06,700 --> 00:59:06,710
 

2989
00:59:06,710 --> 00:59:08,349
being the global death and the local

2990
00:59:08,349 --> 00:59:08,359
 

2991
00:59:08,359 --> 00:59:10,450
death the global death is to means I

2992
00:59:10,450 --> 00:59:10,460
 

2993
00:59:10,460 --> 00:59:12,729
always have to look at two bits but as

2994
00:59:12,729 --> 00:59:12,739
 

2995
00:59:12,739 --> 00:59:15,670
we see 0 0 and 0 1

2996
00:59:15,670 --> 00:59:15,680
 

2997
00:59:15,680 --> 00:59:17,800
Matt - the same bucket that has a local

2998
00:59:17,800 --> 00:59:17,810
 

2999
00:59:17,810 --> 00:59:21,160
depth of 1 so that means that to get to

3000
00:59:21,160 --> 00:59:21,170
 

3001
00:59:21,170 --> 00:59:23,380
get here the way what happened was I

3002
00:59:23,380 --> 00:59:23,390
 

3003
00:59:23,390 --> 00:59:25,690
only had to look at the first bit which

3004
00:59:25,690 --> 00:59:25,700
 

3005
00:59:25,700 --> 00:59:27,220
was zero and that's why they get back to

3006
00:59:27,220 --> 00:59:27,230
 

3007
00:59:27,230 --> 00:59:31,710
the same the same location here right

3008
00:59:31,710 --> 00:59:31,720
 

3009
00:59:31,720 --> 00:59:33,940
again global death you use for the look

3010
00:59:33,940 --> 00:59:33,950
 

3011
00:59:33,950 --> 00:59:35,830
up the local deaths to keep track of

3012
00:59:35,830 --> 00:59:35,840
 

3013
00:59:35,840 --> 00:59:39,430
what what you had to do to get there so

3014
00:59:39,430 --> 00:59:39,440
 

3015
00:59:39,440 --> 00:59:41,170
now I want to do ok and in certain on B

3016
00:59:41,170 --> 00:59:41,180
 

3017
00:59:41,180 --> 00:59:43,330
same thing I look at the global death

3018
00:59:43,330 --> 00:59:43,340
 

3019
00:59:43,340 --> 00:59:45,700
achill death is 2 so when I hash it I

3020
00:59:45,700 --> 00:59:45,710
 

3021
00:59:45,710 --> 00:59:47,320
just want to look at the first 2 bits of

3022
00:59:47,320 --> 00:59:47,330
 

3023
00:59:47,330 --> 00:59:50,860
the hash value that points me to 1 0

3024
00:59:50,860 --> 00:59:50,870
 

3025
00:59:50,870 --> 00:59:53,380
here and that points to the second

3026
00:59:53,380 --> 00:59:53,390

3027
00:59:53,390 --> 00:59:55,690
bucket and there was a free slot so I go

3028
00:59:55,690 --> 00:59:55,700
 

3029
00:59:55,700 --> 00:59:58,900
ahead and and add my entry right that's

3030
00:59:58,900 --> 00:59:58,910
 

3031
00:59:58,910 --> 01:00:00,060
fine

3032
01:00:00,060 --> 01:00:00,070

3033
01:00:00,070 --> 01:00:02,350
now let's say I wanna do another insert

3034
01:00:02,350 --> 01:00:02,360

3035
01:00:02,360 --> 01:00:07,270
on C and again global death is 2 I look

3036
01:00:07,270 --> 01:00:07,280
 

3037
01:00:07,280 --> 01:00:09,880
at the the first two bits that tells me

3038
01:00:09,880 --> 01:00:09,890
 

3039
01:00:09,890 --> 01:00:13,090
to look at here but now it's pointing to

3040
01:00:13,090 --> 01:00:13,100
 

3041
01:00:13,100 --> 01:00:14,260
the second bucket but there's no more

3042
01:00:14,260 --> 01:00:14,270

3043
01:00:14,270 --> 01:00:17,740
free slots so this bucket is full under

3044
01:00:17,740 --> 01:00:17,750

3045
01:00:17,750 --> 01:00:20,410
chain hashing I just have a new bucket

3046
01:00:20,410 --> 01:00:20,420
 

3047
01:00:20,420 --> 01:00:22,740
and extend out the linked list but

3048
01:00:22,740 --> 01:00:22,750
 

3049
01:00:22,750 --> 01:00:24,790
understandable hashing I'm actually

3050
01:00:24,790 --> 01:00:24,800

3051
01:00:24,800 --> 01:00:31,210
gonna split this and and and rehash it

3052
01:00:31,210 --> 01:00:31,220
 

3053
01:00:31,220 --> 01:00:32,530
so that some of the elements in the

3054
01:00:32,530 --> 01:00:32,540
 

3055
01:00:32,540 --> 01:00:34,810
bucket went to the to the new new bucket

3056
01:00:34,810 --> 01:00:34,820
 

3057
01:00:34,820 --> 01:00:36,660
and some almost stay in the old bucket

3058
01:00:36,660 --> 01:00:36,670

3059
01:00:36,670 --> 01:00:38,830
so what happened here just go back and

3060
01:00:38,830 --> 01:00:38,840
 

3061
01:00:38,840 --> 01:00:41,920
again right I'm gonna change the the

3062
01:00:41,920 --> 01:00:41,930
 

3063
01:00:41,930 --> 01:00:44,020
global depth of 3 extend out Mike my

3064
01:00:44,020 --> 01:00:44,030
 

3065
01:00:44,030 --> 01:00:47,380
hash array and for this bucket the

3066
01:00:47,380 --> 01:00:47,390
 

3067
01:00:47,390 --> 01:00:49,060
global death was now 3 and that's good

3068
01:00:49,060 --> 01:00:49,070
 

3069
01:00:49,070 --> 01:00:51,550
updated like that and so I'm gonna look

3070
01:00:51,550 --> 01:00:51,560
 

3071
01:00:51,560 --> 01:00:54,220
now at for all these elements on a look

3072
01:00:54,220 --> 01:00:54,230
 

3073
01:00:54,230 --> 01:00:57,250
at the first three bits and then I use

3074
01:00:57,250 --> 01:00:57,260
 

3075
01:00:57,260 --> 01:00:58,870
that to figure out my hash table where

3076
01:00:58,870 --> 01:00:58,880
 

3077
01:00:58,880 --> 01:01:01,120
they belong to so I should have maybe

3078
01:01:01,120 --> 01:01:01,130
 

3079
01:01:01,130 --> 01:01:03,790
drawn this and more more steps so back

3080
01:01:03,790 --> 01:01:03,800
 

3081
01:01:03,800 --> 01:01:06,430
here I say oh I need to split I'm too

3082
01:01:06,430 --> 01:01:06,440
 

3083
01:01:06,440 --> 01:01:08,800
big so now I look at my global death is

3084
01:01:08,800 --> 01:01:08,810
 

3085
01:01:08,810 --> 01:01:13,000
2 so my local death is 2 so that says

3086
01:01:13,000 --> 01:01:13,010
 

3087
01:01:13,010 --> 01:01:14,920
now I need to go to 3 and so now I'm

3088
01:01:14,920 --> 01:01:14,930
 

3089
01:01:14,930 --> 01:01:16,330
gonna look for each key in here I'm

3090
01:01:16,330 --> 01:01:16,340
 

3091
01:01:16,340 --> 01:01:18,120
gonna look at the first three bits and

3092
01:01:18,120 --> 01:01:18,130
 

3093
01:01:18,130 --> 01:01:21,660
when I extend out my slot array

3094
01:01:21,660 --> 01:01:21,670

3095
01:01:21,670 --> 01:01:24,220
that'll tell me whether I stay in the

3096
01:01:24,220 --> 01:01:24,230
 

3097
01:01:24,230 --> 01:01:25,980
original bucket or I go to the new one

3098
01:01:25,980 --> 01:01:25,990
 

3099
01:01:25,990 --> 01:01:28,660
with now the local death is 3 as well

3100
01:01:28,660 --> 01:01:28,670
 

3101
01:01:28,670 --> 01:01:29,380
and the globe

3102
01:01:29,380 --> 01:01:29,390

3103
01:01:29,390 --> 01:01:30,970
gets up to d23 because that's the

3104
01:01:30,970 --> 01:01:30,980
 

3105
01:01:30,980 --> 01:01:34,240
largest number of the local death we've

3106
01:01:34,240 --> 01:01:34,250
 

3107
01:01:34,250 --> 01:01:36,820
seen so far so now I haven't still

3108
01:01:36,820 --> 01:01:36,830
 

3109
01:01:36,830 --> 01:01:39,700
haven't started C yet right because I

3110
01:01:39,700 --> 01:01:39,710
 

3111
01:01:39,710 --> 01:01:40,840
just did my split because I couldn't

3112
01:01:40,840 --> 01:01:40,850
 

3113
01:01:40,850 --> 01:01:42,850
have sorted what I wanted so now when I

3114
01:01:42,850 --> 01:01:42,860
 

3115
01:01:42,860 --> 01:01:44,560
go and do insert and see now I look at

3116
01:01:44,560 --> 01:01:44,570
 

3117
01:01:44,570 --> 01:01:47,110
three bits and then that points me to

3118
01:01:47,110 --> 01:01:47,120
 

3119
01:01:47,120 --> 01:01:48,880
this bucket here and tells me where I

3120
01:01:48,880 --> 01:01:48,890
 

3121
01:01:48,890 --> 01:01:55,240
need to go I'm seeing blank faces is

3122
01:01:55,240 --> 01:01:55,250
 

3123
01:01:55,250 --> 01:01:58,480
this clear alright it's not found that

3124
01:01:58,480 --> 01:01:58,490
 

3125
01:01:58,490 --> 01:02:08,020
tricky right yes his question is when I

3126
01:02:08,020 --> 01:02:08,030
 

3127
01:02:08,030 --> 01:02:10,390
find a bucket do I still have to do a

3128
01:02:10,390 --> 01:02:10,400
 

3129
01:02:10,400 --> 01:02:11,770
spiritual scan to find a free slot net

3130
01:02:11,770 --> 01:02:11,780
 

3131
01:02:11,780 --> 01:02:15,190
yes right this is just some block of

3132
01:02:15,190 --> 01:02:15,200
 

3133
01:02:15,200 --> 01:02:17,980
memory and I know where my starting

3134
01:02:17,980 --> 01:02:17,990

3135
01:02:17,990 --> 01:02:19,360
point is and I said to scan to find the

3136
01:02:19,360 --> 01:02:19,370
 

3137
01:02:19,370 --> 01:02:20,740
slots of them but hey I know what my

3138
01:02:20,740 --> 01:02:20,750
 

3139
01:02:20,750 --> 01:02:23,170
boundary is of the bucket so if I go

3140
01:02:23,170 --> 01:02:23,180
 

3141
01:02:23,180 --> 01:02:34,000
beyond that then I need to split correct

3142
01:02:34,000 --> 01:02:34,010
 

3143
01:02:34,010 --> 01:02:36,130
so his statement is the local death is

3144
01:02:36,130 --> 01:02:36,140

3145
01:02:36,140 --> 01:02:37,930
just for extending it's not actually

3146
01:02:37,930 --> 01:02:37,940
 

3147
01:02:37,940 --> 01:02:39,010
used to find what you're looking for

3148
01:02:39,010 --> 01:02:39,020
 

3149
01:02:39,020 --> 01:02:41,910
right so once you're inside the bucket

3150
01:02:41,910 --> 01:02:41,920
 

3151
01:02:41,920 --> 01:02:44,290
you don't care the number of bits that

3152
01:02:44,290 --> 01:02:44,300
 

3153
01:02:44,300 --> 01:02:46,690
you use to get there you just actually

3154
01:02:46,690 --> 01:02:46,700
 

3155
01:02:46,700 --> 01:02:48,130
do the same checking that you would do

3156
01:02:48,130 --> 01:02:48,140
 

3157
01:02:48,140 --> 01:02:49,750
in all the other cases it's when you

3158
01:02:49,750 --> 01:02:49,760
 

3159
01:02:49,760 --> 01:02:51,160
split and say all right I version was

3160
01:02:51,160 --> 01:02:51,170
 

3161
01:02:51,170 --> 01:02:51,610
too

3162
01:02:51,610 --> 01:02:51,620
 

3163
01:02:51,620 --> 01:02:54,130
now I'm three so anything that's inside

3164
01:02:54,130 --> 01:02:54,140
 

3165
01:02:54,140 --> 01:02:55,840
of me now I need to figure out where

3166
01:02:55,840 --> 01:02:55,850
 

3167
01:02:55,850 --> 01:02:57,100
that actually needs to go and I could

3168
01:02:57,100 --> 01:02:57,110
 

3169
01:02:57,110 --> 01:02:58,420
stay in the bucket that I was originally

3170
01:02:58,420 --> 01:02:58,430
 

3171
01:02:58,430 --> 01:03:00,610
or can go into the new bucket I just

3172
01:03:00,610 --> 01:03:00,620
 

3173
01:03:00,620 --> 01:03:06,190
generated yes the statement is

3174
01:03:06,190 --> 01:03:06,200
 

3175
01:03:06,200 --> 01:03:07,120
essentially if they're still at the

3176
01:03:07,120 --> 01:03:07,130
 

3177
01:03:07,130 --> 01:03:09,250
rebuild everything rebuild everything

3178
01:03:09,250 --> 01:03:09,260

3179
01:03:09,260 --> 01:03:11,200
inside the bucket and the entire hash

3180
01:03:11,200 --> 01:03:11,210
 

3181
01:03:11,210 --> 01:03:14,590
table no so it's just this question is

3182
01:03:14,590 --> 01:03:14,600
 

3183
01:03:14,600 --> 01:03:15,670
do I start the rebuild everything in the

3184
01:03:15,670 --> 01:03:15,680
 

3185
01:03:15,680 --> 01:03:16,090
hash table

3186
01:03:16,090 --> 01:03:16,100

3187
01:03:16,100 --> 01:03:18,820
no the change is localized to just the

3188
01:03:18,820 --> 01:03:18,830
 

3189
01:03:18,830 --> 01:03:21,580
bucket back and that overflowed all

3190
01:03:21,580 --> 01:03:21,590
 

3191
01:03:21,590 --> 01:03:22,900
right so all of these like all these

3192
01:03:22,900 --> 01:03:22,910
 

3193
01:03:22,910 --> 01:03:24,640
other ones here this guy here and this

3194
01:03:24,640 --> 01:03:24,650
 

3195
01:03:24,650 --> 01:03:26,790
guy here the bottom they stayed the same

3196
01:03:26,790 --> 01:03:26,800
 

3197
01:03:26,800 --> 01:03:29,260
and actually now when I go and I'm

3198
01:03:29,260 --> 01:03:29,270

3199
01:03:29,270 --> 01:03:30,460
staying my slaughter right now I'm

3200
01:03:30,460 --> 01:03:30,470

3201
01:03:30,470 --> 01:03:33,220
looking at three bits I see that the the

3202
01:03:33,220 --> 01:03:33,230
 

3203
01:03:33,230 --> 01:03:35,590
first two guys they were still pointing

3204
01:03:35,590 --> 01:03:35,600
 

3205
01:03:35,600 --> 01:03:37,210
the first bucket they still do and then

3206
01:03:37,210 --> 01:03:37,220
 

3207
01:03:37,220 --> 01:03:39,340
now these guys over here are still now

3208
01:03:39,340 --> 01:03:39,350
 

3209
01:03:39,350 --> 01:03:41,200
pointing to this one as well again if

3210
01:03:41,200 --> 01:03:41,210

3211
01:03:41,210 --> 01:03:43,289
I'm just looking at bit

3212
01:03:43,289 --> 01:03:43,299
 

3213
01:03:43,299 --> 01:03:45,520
0:04 these two guys in the first bit

3214
01:03:45,520 --> 01:03:45,530
 

3215
01:03:45,530 --> 01:03:47,799
0:04 these cool guys first bit they're

3216
01:03:47,799 --> 01:03:47,809
 

3217
01:03:47,809 --> 01:03:49,270
all still still pointing to the same

3218
01:03:49,270 --> 01:03:49,280
 

3219
01:03:49,280 --> 01:03:59,039
bucket with a local depth of one yes

3220
01:03:59,039 --> 01:03:59,049


3221
01:03:59,049 --> 01:04:11,260
it's gotta collect yes yes yes yes you

3222
01:04:11,260 --> 01:04:11,270
 

3223
01:04:11,270 --> 01:04:12,609
are increasing the slides of the size of

3224
01:04:12,609 --> 01:04:12,619
 

3225
01:04:12,619 --> 01:04:14,200
the slot array like you have to double

3226
01:04:14,200 --> 01:04:14,210
 

3227
01:04:14,210 --> 01:04:17,890
the size of that but like that's not

3228
01:04:17,890 --> 01:04:17,900
 

3229
01:04:17,900 --> 01:04:19,450
that's not the big part the big part is

3230
01:04:19,450 --> 01:04:19,460
 

3231
01:04:19,460 --> 01:04:20,680
all this crap in here right because

3232
01:04:20,680 --> 01:04:20,690
 

3233
01:04:20,690 --> 01:04:22,480
again I'm storing keys and values if I

3234
01:04:22,480 --> 01:04:22,490
 

3235
01:04:22,490 --> 01:04:24,400
have to reshuffle this that's expensive

3236
01:04:24,400 --> 01:04:24,410
 

3237
01:04:24,410 --> 01:04:33,220
extending that is easy you you rebuild

3238
01:04:33,220 --> 01:04:33,230
 

3239
01:04:33,230 --> 01:04:34,240
actually means something very specific

3240
01:04:34,240 --> 01:04:34,250
 

3241
01:04:34,250 --> 01:04:35,799
and a hash table it means like literally

3242
01:04:35,799 --> 01:04:35,809
 

3243
01:04:35,809 --> 01:04:37,809
rebuilding a brand-new hash table this

3244
01:04:37,809 --> 01:04:37,819
 

3245
01:04:37,819 --> 01:04:40,029
is just a small change internally to the

3246
01:04:40,029 --> 01:04:40,039
 

3247
01:04:40,039 --> 01:04:42,549
the internal metadata which is cheap

3248
01:04:42,549 --> 01:04:42,559
 

3249
01:04:42,559 --> 01:04:46,059
right because I can all like okay these

3250
01:04:46,059 --> 01:04:46,069
 

3251
01:04:46,069 --> 01:04:47,910
are all gonna be 64-bit pointers and

3252
01:04:47,910 --> 01:04:47,920
 

3253
01:04:47,920 --> 01:04:50,620
it's gonna be some a small array right I

3254
01:04:50,620 --> 01:04:50,630
 

3255
01:04:50,630 --> 01:04:52,510
can create the new one copy everything

3256
01:04:52,510 --> 01:04:52,520

3257
01:04:52,520 --> 01:04:54,130
over and do compare and swap to put the

3258
01:04:54,130 --> 01:04:54,140
 

3259
01:04:54,140 --> 01:04:56,049
new one and install it in right that's

3260
01:04:56,049 --> 01:04:56,059
 

3261
01:04:56,059 --> 01:04:58,870
way cheaper than hashing and reshuffling

3262
01:04:58,870 --> 01:04:58,880

3263
01:04:58,880 --> 01:05:08,769
everything yes so this question is what

3264
01:05:08,769 --> 01:05:08,779
 

3265
01:05:08,779 --> 01:05:11,440
would happen if for for this first

3266
01:05:11,440 --> 01:05:11,450
 

3267
01:05:11,450 --> 01:05:12,970
bucket if I inserted maybe two more

3268
01:05:12,970 --> 01:05:12,980
 

3269
01:05:12,980 --> 01:05:14,760
things in it and it and it overflows

3270
01:05:14,760 --> 01:05:14,770
 

3271
01:05:14,770 --> 01:05:17,529
right so again the global the local

3272
01:05:17,529 --> 01:05:17,539
 

3273
01:05:17,539 --> 01:05:20,799
depth is 1 so I'll increase its local

3274
01:05:20,799 --> 01:05:20,809
 

3275
01:05:20,809 --> 01:05:23,079
depth of 2 so now for every single key I

3276
01:05:23,079 --> 01:05:23,089
 

3277
01:05:23,089 --> 01:05:26,170
have in here I'll look at the the first

3278
01:05:26,170 --> 01:05:26,180
 

3279
01:05:26,180 --> 01:05:28,299
two bits and that'll tell me where I

3280
01:05:28,299 --> 01:05:28,309
 

3281
01:05:28,309 --> 01:05:32,589
need to go so the the first else of the

3282
01:05:32,589 --> 01:05:32,599
 

3283
01:05:32,599 --> 01:05:34,000
first two bits will then get split up to

3284
01:05:34,000 --> 01:05:34,010
 

3285
01:05:34,010 --> 01:05:35,620
do separate buckets so everybody

3286
01:05:35,620 --> 01:05:35,630
 

3287
01:05:35,630 --> 01:05:37,660
everybody was pointing everybody the

3288
01:05:37,660 --> 01:05:37,670
 

3289
01:05:37,670 --> 01:05:39,160
starts at the zero points of this one

3290
01:05:39,160 --> 01:05:39,170
 

3291
01:05:39,170 --> 01:05:42,760
here right zero zero zero zero so now I

3292
01:05:42,760 --> 01:05:42,770
 

3293
01:05:42,770 --> 01:05:43,990
look at two bits so I'll have a bucket

3294
01:05:43,990 --> 01:05:44,000
 

3295
01:05:44,000 --> 01:05:47,049
for zero zero and a bucket for 0 1 0 0 0

3296
01:05:47,049 --> 01:05:47,059
 

3297
01:05:47,059 --> 01:05:50,740
1 so it'll be two new buckets the 0 0

3298
01:05:50,740 --> 01:05:50,750
1 so it'll be two new buckets the 0 0
 

3299
01:05:50,750 --> 01:05:52,690
1 so it'll be two new buckets the 0 0
guys will point to that one the 0 1 guys

3300
01:05:52,690 --> 01:05:52,700
 

3301
01:05:52,700 --> 01:05:54,099
will point to the other one and then I

3302
01:05:54,099 --> 01:05:54,109
 

3303
01:05:54,109 --> 01:05:55,810
look at the two bits

3304
01:05:55,810 --> 01:05:55,820
 

3305
01:05:55,820 --> 01:05:57,190
for all my keys and that tells me which

3306
01:05:57,190 --> 01:05:57,200
 

3307
01:05:57,200 --> 01:06:04,660
of the two I want to go into his

3308
01:06:04,660 --> 01:06:04,670
 

3309
01:06:04,670 --> 01:06:06,040
question is rights do I start to

3310
01:06:06,040 --> 01:06:06,050
 

3311
01:06:06,050 --> 01:06:08,110
maintain a pointer from the bucket back

3312
01:06:08,110 --> 01:06:08,120
 

3313
01:06:08,120 --> 01:06:11,560
to the global slot why now you know what

3314
01:06:11,560 --> 01:06:11,570
 

3315
01:06:11,570 --> 01:06:13,450
you get local death tells you who's

3316
01:06:13,450 --> 01:06:13,460

3317
01:06:13,460 --> 01:06:22,000
pointing to you because you know who's

3318
01:06:22,000 --> 01:06:22,010
 

3319
01:06:22,010 --> 01:06:23,110
pointing to you based on your local

3320
01:06:23,110 --> 01:06:23,120
 

3321
01:06:23,120 --> 01:06:28,210
depth right local death is one that

3322
01:06:28,210 --> 01:06:28,220
 

3323
01:06:28,220 --> 01:06:32,880
means that anybody that has right

3324
01:06:32,880 --> 01:06:32,890
 

3325
01:06:32,890 --> 01:06:36,070
anybody that has zero in the first bit

3326
01:06:36,070 --> 01:06:36,080
 

3327
01:06:36,080 --> 01:06:37,240
because I can look up what's inside of

3328
01:06:37,240 --> 01:06:37,250

3329
01:06:37,250 --> 01:06:47,340
me it has to be pointing to me right

3330
01:06:47,340 --> 01:06:47,350


3331
01:06:47,350 --> 01:07:03,550
it's cheap it's nothing yeah yes so his

3332
01:07:03,550 --> 01:07:03,560
 

3333
01:07:03,560 --> 01:07:06,010
question is are you asking in the real

3334
01:07:06,010 --> 01:07:06,020
 

3335
01:07:06,020 --> 01:07:07,300
world asking for the project his

3336
01:07:07,300 --> 01:07:07,310
 

3337
01:07:07,310 --> 01:07:08,530
question is do we have to shrink the

3338
01:07:08,530 --> 01:07:08,540
 

3339
01:07:08,540 --> 01:07:11,500
hash table in the real world yes and the

3340
01:07:11,500 --> 01:07:11,510
 

3341
01:07:11,510 --> 01:07:13,670
project now

3342
01:07:13,670 --> 01:07:13,680

3343
01:07:13,680 --> 01:07:16,430
we'll see in later hashing can with a

3344
01:07:16,430 --> 01:07:16,440
 

3345
01:07:16,440 --> 01:07:17,690
little time in linear hashing it's

3346
01:07:17,690 --> 01:07:17,700
 

3347
01:07:17,700 --> 01:07:18,950
actually really easy to do it's actually

3348
01:07:18,950 --> 01:07:18,960
 

3349
01:07:18,960 --> 01:07:20,240
not hard to do this either right you

3350
01:07:20,240 --> 01:07:20,250
 

3351
01:07:20,250 --> 01:07:22,640
just have to recognize that like oh well

3352
01:07:22,640 --> 01:07:22,650
 

3353
01:07:22,650 --> 01:07:25,519
if I go back from three my global depth

3354
01:07:25,519 --> 01:07:25,529
 

3355
01:07:25,529 --> 01:07:26,799
of three to two

3356
01:07:26,799 --> 01:07:26,809

3357
01:07:26,809 --> 01:07:29,660
well like can I collapse the everything

3358
01:07:29,660 --> 01:07:29,670
 

3359
01:07:29,670 --> 01:07:32,420
and not have to you know reshuffle

3360
01:07:32,420 --> 01:07:32,430
 

3361
01:07:32,430 --> 01:07:34,339
everything it's more expensive to go

3362
01:07:34,339 --> 01:07:34,349

3363
01:07:34,349 --> 01:07:36,260
deletion in this case then then

3364
01:07:36,260 --> 01:07:36,270

3365
01:07:36,270 --> 01:07:40,490
extending whether that's yeah go around

3366
01:07:40,490 --> 01:07:40,500
 

3367
01:07:40,500 --> 01:07:49,460
yes this question is if I have four

3368
01:07:49,460 --> 01:07:49,470
 

3369
01:07:49,470 --> 01:07:51,940
entries the same hash key what do you do

3370
01:07:51,940 --> 01:07:51,950

3371
01:07:51,950 --> 01:08:02,289
after you split like so so we were here

3372
01:08:02,289 --> 01:08:02,299


3373
01:08:02,299 --> 01:08:05,900
yes sir I think sirs question is say in

3374
01:08:05,900 --> 01:08:05,910
 

3375
01:08:05,910 --> 01:08:08,510
this case here I did I'm gonna either

3376
01:08:08,510 --> 01:08:08,520
 

3377
01:08:08,520 --> 01:08:10,190
split because I'm gonna insert C because

3378
01:08:10,190 --> 01:08:10,200
 

3379
01:08:10,200 --> 01:08:11,779
I wanna put four elements and then I I

3380
01:08:11,779 --> 01:08:11,789
 

3381
01:08:11,789 --> 01:08:14,390
can only start three let's say I split

3382
01:08:14,390 --> 01:08:14,400
 

3383
01:08:14,400 --> 01:08:18,110
this again and worst case scenario it

3384
01:08:18,110 --> 01:08:18,120
 

3385
01:08:18,120 --> 01:08:20,450
hashes again to the same thing I'll do

3386
01:08:20,450 --> 01:08:20,460
 

3387
01:08:20,460 --> 01:08:21,740
the same bucket which which then

3388
01:08:21,740 --> 01:08:21,750
 

3389
01:08:21,750 --> 01:08:27,439
overflows you have to split again if the

3390
01:08:27,439 --> 01:08:27,449
 

3391
01:08:27,449 --> 01:08:32,930
whole edge key is the same then it's

3392
01:08:32,930 --> 01:08:32,940
 

3393
01:08:32,940 --> 01:08:35,599
always be the same then that's the worst

3394
01:08:35,599 --> 01:08:35,609
 

3395
01:08:35,609 --> 01:08:37,309
case scenario that means you have a

3396
01:08:37,309 --> 01:08:37,319
 

3397
01:08:37,319 --> 01:08:39,410
terrible collision rate then you have to

3398
01:08:39,410 --> 01:08:39,420
 

3399
01:08:39,420 --> 01:08:41,689
keep extending extending this thing over

3400
01:08:41,689 --> 01:08:41,699

3401
01:08:41,699 --> 01:08:47,149
here until it doesn't this question do

3402
01:08:47,149 --> 01:08:47,159
 

3403
01:08:47,159 --> 01:08:48,019
you not need to cover this in the

3404
01:08:48,019 --> 01:08:48,029
 

3405
01:08:48,029 --> 01:08:51,200
project your your page table is not

3406
01:08:51,200 --> 01:08:51,210
 

3407
01:08:51,210 --> 01:08:54,649
gonna be that big right so again this is

3408
01:08:54,649 --> 01:08:54,659
 

3409
01:08:54,659 --> 01:08:56,300
you're storing the number of bits is

3410
01:08:56,300 --> 01:08:56,310
 

3411
01:08:56,310 --> 01:08:59,450
could be up to 64 bits the likelihood

3412
01:08:59,450 --> 01:08:59,460
 

3413
01:08:59,460 --> 01:09:01,160
that a page ID and your project will map

3414
01:09:01,160 --> 01:09:01,170
 

3415
01:09:01,170 --> 01:09:03,740
to to the same value from to 264 is

3416
01:09:03,740 --> 01:09:03,750
 

3417
01:09:03,750 --> 01:09:05,749
unlikely okay

3418
01:09:05,749 --> 01:09:05,759
 

3419
01:09:05,759 --> 01:09:07,700
all right the bunch of the questions I

3420
01:09:07,700 --> 01:09:07,710
 

3421
01:09:07,710 --> 01:09:09,530
want to finish up and talk about linear

3422
01:09:09,530 --> 01:09:09,540
 

3423
01:09:09,540 --> 01:09:14,479
hashing before we run out of time so

3424
01:09:14,479 --> 01:09:14,489
 

3425
01:09:14,489 --> 01:09:15,649
linear hashing I don't actually don't

3426
01:09:15,649 --> 01:09:15,659
 

3427
01:09:15,659 --> 01:09:18,229
know if it's in the textbook this is

3428
01:09:18,229 --> 01:09:18,239
 

3429
01:09:18,239 --> 01:09:19,370
another approach I think it's kind of

3430
01:09:19,370 --> 01:09:19,380
 

3431
01:09:19,380 --> 01:09:20,930
elegant again same thing it's from the

3432
01:09:20,930 --> 01:09:20,940
 

3433
01:09:20,940 --> 01:09:24,860
1980s but a lot of systems use this word

3434
01:09:24,860 --> 01:09:24,870
 

3435
01:09:24,870 --> 01:09:25,879
you again we're gonna do incremental

3436
01:09:25,879 --> 01:09:25,889

3437
01:09:25,889 --> 01:09:27,109
splits

3438
01:09:27,109 --> 01:09:27,119
 

3439
01:09:27,119 --> 01:09:29,899
we're going to instead of just splitting

3440
01:09:29,899 --> 01:09:29,909
 

3441
01:09:29,909 --> 01:09:32,689
the exact bucket that overflowed we're

3442
01:09:32,689 --> 01:09:32,699
 

3443
01:09:32,699 --> 01:09:33,859
actually gonna have a pointer that can

3444
01:09:33,859 --> 01:09:33,869
 

3445
01:09:33,869 --> 01:09:35,209
say what's the neck bucket we want to

3446
01:09:35,209 --> 01:09:35,219

3447
01:09:35,219 --> 01:09:37,879
split and so what will happen is every

3448
01:09:37,879 --> 01:09:37,889
 

3449
01:09:37,889 --> 01:09:40,039
time we do a split because some other

3450
01:09:40,039 --> 01:09:40,049
 

3451
01:09:40,049 --> 01:09:41,570
bucket overflowed we split whatever

3452
01:09:41,570 --> 01:09:41,580
 

3453
01:09:41,580 --> 01:09:42,890
we're pointing to and they move the

3454
01:09:42,890 --> 01:09:42,900
 

3455
01:09:42,900 --> 01:09:45,800
pointer down by one and keep going to

3456
01:09:45,800 --> 01:09:45,810
 

3457
01:09:45,810 --> 01:09:47,089
reach the bottom and then loop back

3458
01:09:47,089 --> 01:09:47,099
 

3459
01:09:47,099 --> 01:09:49,490
around and then split again alright so

3460
01:09:49,490 --> 01:09:49,500
 

3461
01:09:49,500 --> 01:09:51,559
this is this is even more incremental so

3462
01:09:51,559 --> 01:09:51,569
 

3463
01:09:51,569 --> 01:09:54,260
we'll define overflow in in for our

3464
01:09:54,260 --> 01:09:54,270
 

3465
01:09:54,270 --> 01:09:56,479
purposes here it's just when the when we

3466
01:09:56,479 --> 01:09:56,489
 

3467
01:09:56,489 --> 01:09:58,700
go from one bucket to two buckets but in

3468
01:09:58,700 --> 01:09:58,710
 

3469
01:09:58,710 --> 01:09:59,930
your actual implementation it can mean a

3470
01:09:59,930 --> 01:09:59,940
 

3471
01:09:59,940 --> 01:10:01,580
bunch of different things right it can

3472
01:10:01,580 --> 01:10:01,590
 

3473
01:10:01,590 --> 01:10:03,530
mean that the length of the chain has

3474
01:10:03,530 --> 01:10:03,540
 

3475
01:10:03,540 --> 01:10:05,209
gotten too long on average for the

3476
01:10:05,209 --> 01:10:05,219
 

3477
01:10:05,219 --> 01:10:08,689
entire system you have low space

3478
01:10:08,689 --> 01:10:08,699
 

3479
01:10:08,699 --> 01:10:09,979
utilization for some buckets and you

3480
01:10:09,979 --> 01:10:09,989
 

3481
01:10:09,989 --> 01:10:11,600
want to go in different directions it

3482
01:10:11,600 --> 01:10:11,610
 

3483
01:10:11,610 --> 01:10:13,040
doesn't matter but for our purposes we

3484
01:10:13,040 --> 01:10:13,050
 

3485
01:10:13,050 --> 01:10:17,060
just assume that we the we assume that

3486
01:10:17,060 --> 01:10:17,070
 

3487
01:10:17,070 --> 01:10:19,790
it's whatever um whenever you go from

3488
01:10:19,790 --> 01:10:19,800
 

3489
01:10:19,800 --> 01:10:22,580
one bucket a two bucket the thing we're

3490
01:10:22,580 --> 01:10:22,590
 

3491
01:10:22,590 --> 01:10:24,470
trying to solve here and I think some of

3492
01:10:24,470 --> 01:10:24,480
 

3493
01:10:24,480 --> 01:10:25,459
you guys brought this up in an external

3494
01:10:25,459 --> 01:10:25,469
 

3495
01:10:25,469 --> 01:10:27,530
hashing is instead while hashing every

3496
01:10:27,530 --> 01:10:27,540
 

3497
01:10:27,540 --> 01:10:29,089
single time I did a split I had to

3498
01:10:29,089 --> 01:10:29,099
 

3499
01:10:29,099 --> 01:10:31,820
double the size of the that directory of

3500
01:10:31,820 --> 01:10:31,830
 

3501
01:10:31,830 --> 01:10:34,250
a slot array in linear hashing we don't

3502
01:10:34,250 --> 01:10:34,260

3503
01:10:34,260 --> 01:10:35,300
have this problem we don't have to do

3504
01:10:35,300 --> 01:10:35,310
 

3505
01:10:35,310 --> 01:10:36,439
this group we're gonna do this one at a

3506
01:10:36,439 --> 01:10:36,449
 

3507
01:10:36,449 --> 01:10:39,560
time alright so say it again we have

3508
01:10:39,560 --> 01:10:39,570
 

3509
01:10:39,570 --> 01:10:43,010
four elements and we have four four four

3510
01:10:43,010 --> 01:10:43,020
 

3511
01:10:43,020 --> 01:10:46,640
four buckets that were pointing to so

3512
01:10:46,640 --> 01:10:46,650
 

3513
01:10:46,650 --> 01:10:49,180
the split pointer again is going to be a

3514
01:10:49,180 --> 01:10:49,190
 

3515
01:10:49,190 --> 01:10:51,859
sum page or some sorry sum bucket we're

3516
01:10:51,859 --> 01:10:51,869
 

3517
01:10:51,869 --> 01:10:55,490
gonna split whenever we overflow so for

3518
01:10:55,490 --> 01:10:55,500

3519
01:10:55,500 --> 01:10:56,930
this also as well it's gonna look a lot

3520
01:10:56,930 --> 01:10:56,940
 

3521
01:10:56,940 --> 01:10:58,100
like cuckoo hashing we're going to have

3522
01:10:58,100 --> 01:10:58,110
 

3523
01:10:58,110 --> 01:11:00,350
multiple hash functions but instead of

3524
01:11:00,350 --> 01:11:00,360
 

3525
01:11:00,360 --> 01:11:02,000
actually applying them at the same time

3526
01:11:02,000 --> 01:11:02,010
 

3527
01:11:02,010 --> 01:11:07,100
we only apply them one at a time and we

3528
01:11:07,100 --> 01:11:07,110
 

3529
01:11:07,110 --> 01:11:08,689
don't need to go look at additional hash

3530
01:11:08,689 --> 01:11:08,699
 

3531
01:11:08,699 --> 01:11:10,910
functions if the thing we hash to is

3532
01:11:10,910 --> 01:11:10,920
 

3533
01:11:10,920 --> 01:11:14,030
below our split pointer that'll make

3534
01:11:14,030 --> 01:11:14,040
 

3535
01:11:14,040 --> 01:11:16,399
more sense in a second but as we extend

3536
01:11:16,399 --> 01:11:16,409
 

3537
01:11:16,409 --> 01:11:19,310
the directory add more hash functions we

3538
01:11:19,310 --> 01:11:19,320
 

3539
01:11:19,320 --> 01:11:20,419
always start off with the first hash

3540
01:11:20,419 --> 01:11:20,429

3541
01:11:20,429 --> 01:11:22,280
function and we may not need to go look

3542
01:11:22,280 --> 01:11:22,290
 

3543
01:11:22,290 --> 01:11:23,660
at the other hash functions unless we

3544
01:11:23,660 --> 01:11:23,670
 

3545
01:11:23,670 --> 01:11:27,290
are above the split pointer all right so

3546
01:11:27,290 --> 01:11:27,300
 

3547
01:11:27,300 --> 01:11:28,609
let's say we're going to find on six

3548
01:11:28,609 --> 01:11:28,619
 

3549
01:11:28,619 --> 01:11:30,290
again simple hash function we're just

3550
01:11:30,290 --> 01:11:30,300
 

3551
01:11:30,300 --> 01:11:31,910
gonna modify the number of slots we have

3552
01:11:31,910 --> 01:11:31,920
 

3553
01:11:31,920 --> 01:11:36,229
so 6 mod mod 4 goes to 2 so we go find

3554
01:11:36,229 --> 01:11:36,239
 

3555
01:11:36,239 --> 01:11:37,700
our entry there right that just looks

3556
01:11:37,700 --> 01:11:37,710
 

3557
01:11:37,710 --> 01:11:40,319
like chained hash table no problem

3558
01:11:40,319 --> 01:11:40,329
 

3559
01:11:40,329 --> 01:11:44,010
now when doing insert in 1717 mod for

3560
01:11:44,010 --> 01:11:44,020
 

3561
01:11:44,020 --> 01:11:47,069
hashes to 1 so that goes here but again

3562
01:11:47,069 --> 01:11:47,079
 

3563
01:11:47,079 --> 01:11:48,390
we can only store three entries so we

3564
01:11:48,390 --> 01:11:48,400
 

3565
01:11:48,400 --> 01:11:50,189
have an O it we have to extend it by

3566
01:11:50,189 --> 01:11:50,199
 

3567
01:11:50,199 --> 01:11:52,890
adding a an additional bucket now this

3568
01:11:52,890 --> 01:11:52,900
 

3569
01:11:52,900 --> 01:11:54,330
triggers our overflow because we said

3570
01:11:54,330 --> 01:11:54,340
 

3571
01:11:54,340 --> 01:11:55,530
every time we make a new bucket that

3572
01:11:55,530 --> 01:11:55,540
 

3573
01:11:55,540 --> 01:11:58,439
counts as an overflow so now what will

3574
01:11:58,439 --> 01:11:58,449

3575
01:11:58,449 --> 01:11:59,910
happen is this whatever the split

3576
01:11:59,910 --> 01:11:59,920
 

3577
01:11:59,920 --> 01:12:01,290
pointer is pointing at

3578
01:12:01,290 --> 01:12:01,300

3579
01:12:01,300 --> 01:12:02,729
that's the bucket we're going to split

3580
01:12:02,729 --> 01:12:02,739
 

3581
01:12:02,739 --> 01:12:05,609
not the one we just we just overflowed

3582
01:12:05,609 --> 01:12:05,619
 

3583
01:12:05,619 --> 01:12:07,020
the extendable hashing was always the

3584
01:12:07,020 --> 01:12:07,030
 

3585
01:12:07,030 --> 01:12:09,299
one that overflowed its foot pointer and

3586
01:12:09,299 --> 01:12:09,309
 

3587
01:12:09,309 --> 01:12:10,560
later Hachem it's always the one that

3588
01:12:10,560 --> 01:12:10,570
 

3589
01:12:10,570 --> 01:12:12,600
we're pointing to so in this case here

3590
01:12:12,600 --> 01:12:12,610

3591
01:12:12,610 --> 01:12:15,930
the slip pointer is pointing to position

3592
01:12:15,930 --> 01:12:15,940
 

3593
01:12:15,940 --> 01:12:17,669
zero so we're gonna want to split this

3594
01:12:17,669 --> 01:12:17,679
 

3595
01:12:17,679 --> 01:12:20,339
one at the top so all we have to do is

3596
01:12:20,339 --> 01:12:20,349
 

3597
01:12:20,349 --> 01:12:23,310
add an additional location to our slot

3598
01:12:23,310 --> 01:12:23,320
 

3599
01:12:23,320 --> 01:12:25,740
or a lot directory and add a new hash

3600
01:12:25,740 --> 01:12:25,750
 

3601
01:12:25,750 --> 01:12:29,069
function that's going to be based on the

3602
01:12:29,069 --> 01:12:29,079
 

3603
01:12:29,079 --> 01:12:32,430
number of keys times but the key mod by

3604
01:12:32,430 --> 01:12:32,440
 

3605
01:12:32,440 --> 01:12:36,330
the the the double the number of keys we

3606
01:12:36,330 --> 01:12:36,340
 

3607
01:12:36,340 --> 01:12:37,589
have in our slot all right now

3608
01:12:37,589 --> 01:12:37,599
 

3609
01:12:37,599 --> 01:12:39,689
so we region have n elements now when

3610
01:12:39,689 --> 01:12:39,699
 

3611
01:12:39,699 --> 01:12:41,310
we're gonna do a mod would have mod 2n

3612
01:12:41,310 --> 01:12:41,320
 

3613
01:12:41,320 --> 01:12:43,350
but as we'll see in a second nobody

3614
01:12:43,350 --> 01:12:43,360

3615
01:12:43,360 --> 01:12:45,000
although we haven't allocated to n

3616
01:12:45,000 --> 01:12:45,010
 

3617
01:12:45,010 --> 01:12:47,549
entries over here in the slot array no

3618
01:12:47,549 --> 01:12:47,559
 

3619
01:12:47,559 --> 01:12:48,569
one's actually actually going to ever

3620
01:12:48,569 --> 01:12:48,579
 

3621
01:12:48,579 --> 01:12:50,220
get to there because you have to first

3622
01:12:50,220 --> 01:12:50,230
 

3623
01:12:50,230 --> 01:12:51,689
always look at the hash function and if

3624
01:12:51,689 --> 01:12:51,699
 

3625
01:12:51,699 --> 01:12:53,580
you the hash function if you hash here

3626
01:12:53,580 --> 01:12:53,590
 

3627
01:12:53,590 --> 01:12:55,169
and you're above the split pointer then

3628
01:12:55,169 --> 01:12:55,179
 

3629
01:12:55,179 --> 01:12:56,910
you look at the second one and we know

3630
01:12:56,910 --> 01:12:56,920
 

3631
01:12:56,920 --> 01:12:58,140
that we're never gonna hit anything but

3632
01:12:58,140 --> 01:12:58,150
 

3633
01:12:58,150 --> 01:13:01,069
anything beyond we've already allocated

3634
01:13:01,069 --> 01:13:01,079
 

3635
01:13:01,079 --> 01:13:04,470
so in this case here we add four and

3636
01:13:04,470 --> 01:13:04,480
 

3637
01:13:04,480 --> 01:13:07,260
then we split the first guy here so it

3638
01:13:07,260 --> 01:13:07,270
 

3639
01:13:07,270 --> 01:13:10,459
had 20 in it now 20 goes at the bottom

3640
01:13:10,459 --> 01:13:10,469
 

3641
01:13:10,469 --> 01:13:12,870
and we would move the split pointer down

3642
01:13:12,870 --> 01:13:12,880
 

3643
01:13:12,880 --> 01:13:14,879
by one so now let's say we won't do a

3644
01:13:14,879 --> 01:13:14,889
 

3645
01:13:14,889 --> 01:13:17,399
look-up on 20 so we always start off

3646
01:13:17,399 --> 01:13:17,409
 

3647
01:13:17,409 --> 01:13:19,799
with the first hash function right 20

3648
01:13:19,799 --> 01:13:19,809
 

3649
01:13:19,809 --> 01:13:21,839
mod 4 which is the number Ellis we have

3650
01:13:21,839 --> 01:13:21,849
 

3651
01:13:21,849 --> 01:13:25,770
initially equals 0 so that points to the

3652
01:13:25,770 --> 01:13:25,780
 

3653
01:13:25,780 --> 01:13:28,589
slot array here at the top but now we've

3654
01:13:28,589 --> 01:13:28,599
 

3655
01:13:28,599 --> 01:13:31,890
said that we know that 0 is above where

3656
01:13:31,890 --> 01:13:31,900
 

3657
01:13:31,900 --> 01:13:34,049
the split pointer is I sort of think of

3658
01:13:34,049 --> 01:13:34,059
 

3659
01:13:34,059 --> 01:13:35,490
this the slip pointers a threshold and

3660
01:13:35,490 --> 01:13:35,500
 

3661
01:13:35,500 --> 01:13:38,879
anything above that says I not after

3662
01:13:38,879 --> 01:13:38,889
 

3663
01:13:38,889 --> 01:13:40,379
I've hashed the first use the first hash

3664
01:13:40,379 --> 01:13:40,389
 

3665
01:13:40,389 --> 01:13:42,450
function I found my above with slip

3666
01:13:42,450 --> 01:13:42,460

3667
01:13:42,460 --> 01:13:44,850
pointer is then I have to use the second

3668
01:13:44,850 --> 01:13:44,860
 

3669
01:13:44,860 --> 01:13:47,069
hash function and then that will map me

3670
01:13:47,069 --> 01:13:47,079
 

3671
01:13:47,079 --> 01:13:49,620
down down below and then I can find the

3672
01:13:49,620 --> 01:13:49,630
 

3673
01:13:49,630 --> 01:13:52,910
entry that I'm looking for

3674
01:13:52,910 --> 01:13:52,920


3675
01:13:52,920 --> 01:13:54,740
right so every time I had there's an

3676
01:13:54,740 --> 01:13:54,750
 

3677
01:13:54,750 --> 01:13:57,229
overflow I do a split and I move the

3678
01:13:57,229 --> 01:13:57,239
 

3679
01:13:57,239 --> 01:13:59,510
slip corner down by one if I hash the

3680
01:13:59,510 --> 01:13:59,520
 

3681
01:13:59,520 --> 01:14:01,490
first hash function I'll and two above

3682
01:14:01,490 --> 01:14:01,500
 

3683
01:14:01,500 --> 01:14:03,260
the slip pointer then eyes you have to

3684
01:14:03,260 --> 01:14:03,270
 

3685
01:14:03,270 --> 01:14:04,520
use a second hash function at where I

3686
01:14:04,520 --> 01:14:04,530
 

3687
01:14:04,530 --> 01:14:06,979
really need to go and the math works out

3688
01:14:06,979 --> 01:14:06,989
 

3689
01:14:06,989 --> 01:14:08,959
that again you could never have anything

3690
01:14:08,959 --> 01:14:08,969
 

3691
01:14:08,969 --> 01:14:11,180
mapped to five six seven eight even

3692
01:14:11,180 --> 01:14:11,190
 

3693
01:14:11,190 --> 01:14:12,709
though you haven't allocated those

3694
01:14:12,709 --> 01:14:12,719
 

3695
01:14:12,719 --> 01:14:15,530
spaces yet okay because anything that

3696
01:14:15,530 --> 01:14:15,540
 

3697
01:14:15,540 --> 01:14:17,660
could get there would always land in the

3698
01:14:17,660 --> 01:14:17,670
 

3699
01:14:17,670 --> 01:14:23,120
below with a split pointer yes he says

3700
01:14:23,120 --> 01:14:23,130

3701
01:14:23,130 --> 01:14:24,830
what if you want to find thirteen so

3702
01:14:24,830 --> 01:14:24,840
 

3703
01:14:24,840 --> 01:14:27,979
simple I take the first hash function 13

3704
01:14:27,979 --> 01:14:27,989
 

3705
01:14:27,989 --> 01:14:31,160
mod 4 would tell me that it's 1 1 is

3706
01:14:31,160 --> 01:14:31,170
 

3707
01:14:31,170 --> 01:14:32,360
below the split pointer so I don't need

3708
01:14:32,360 --> 01:14:32,370
 

3709
01:14:32,370 --> 01:14:33,610
to look at the second hash function

3710
01:14:33,610 --> 01:14:33,620

3711
01:14:33,620 --> 01:14:35,870
so I'm apt right to the bucket and find

3712
01:14:35,870 --> 01:14:35,880
 

3713
01:14:35,880 --> 01:14:40,280
what I want if I want to look up on 8 8

3714
01:14:40,280 --> 01:14:40,290
 

3715
01:14:40,290 --> 01:14:44,120
mod mod 4 will be 0 I know I'm above my

3716
01:14:44,120 --> 01:14:44,130
 

3717
01:14:44,130 --> 01:14:46,370
my split pointer so I look at the second

3718
01:14:46,370 --> 01:14:46,380

3719
01:14:46,380 --> 01:14:50,450
hash function 8 mod 8 is 0 so there you

3720
01:14:50,450 --> 01:14:50,460
 

3721
01:14:50,460 --> 01:14:59,150
go it's right there yes this question

3722
01:14:59,150 --> 01:14:59,160
 

3723
01:14:59,160 --> 01:15:02,540
this is only work for integer keys no

3724
01:15:02,540 --> 01:15:02,550
 

3725
01:15:02,550 --> 01:15:03,740
because the hash function is gonna

3726
01:15:03,740 --> 01:15:03,750
 

3727
01:15:03,750 --> 01:15:05,209
return you back where to always return

3728
01:15:05,209 --> 01:15:05,219
 

3729
01:15:05,219 --> 01:15:09,380
you a integer like 32-bit or 64-bit

3730
01:15:09,380 --> 01:15:09,390

3731
01:15:09,390 --> 01:15:11,360
I'm just showing integer keys to keep it

3732
01:15:11,360 --> 01:15:11,370
 

3733
01:15:11,370 --> 01:15:21,140
really simple here yes it's always with

3734
01:15:21,140 --> 01:15:21,150
 

3735
01:15:21,150 --> 01:15:23,840
me the same hash function it's but

3736
01:15:23,840 --> 01:15:23,850
 

3737
01:15:23,850 --> 01:15:25,250
you're just a mod but by a different

3738
01:15:25,250 --> 01:15:25,260
 

3739
01:15:25,260 --> 01:15:27,800
number right so again hash functions

3740
01:15:27,800 --> 01:15:27,810

3741
01:15:27,810 --> 01:15:29,810
return a value from 0 to you know 2 to

3742
01:15:29,810 --> 01:15:29,820
 

3743
01:15:29,820 --> 01:15:32,660
the 64 we always mod it by the number of

3744
01:15:32,660 --> 01:15:32,670
 

3745
01:15:32,670 --> 01:15:34,010
slots we have to ground us where we need

3746
01:15:34,010 --> 01:15:34,020
 

3747
01:15:34,020 --> 01:15:36,169
to go right within within the number

3748
01:15:36,169 --> 01:15:36,179
 

3749
01:15:36,179 --> 01:15:38,540
Ellis we have at some point the split

3750
01:15:38,540 --> 01:15:38,550
 

3751
01:15:38,550 --> 01:15:40,459
point will reach the bottom at that

3752
01:15:40,459 --> 01:15:40,469
 

3753
01:15:40,469 --> 01:15:42,260
point we've extended it out to be double

3754
01:15:42,260 --> 01:15:42,270

3755
01:15:42,270 --> 01:15:45,530
the size of the number Alice we started

3756
01:15:45,530 --> 01:15:45,540
 

3757
01:15:45,540 --> 01:15:47,540
up originally so then we delete the

3758
01:15:47,540 --> 01:15:47,550

3759
01:15:47,550 --> 01:15:50,870
first hash hash key and reset the slip

3760
01:15:50,870 --> 01:15:50,880
 

3761
01:15:50,880 --> 01:15:52,220
pointer back at the top and start start

3762
01:15:52,220 --> 01:15:52,230
 

3763
01:15:52,230 --> 01:15:57,740
over again yes

3764
01:15:57,740 --> 01:15:57,750


3765
01:15:57,750 --> 01:16:01,790
he says if you want to is hurt 21 so 21

3766
01:16:01,790 --> 01:16:01,800
 

3767
01:16:01,800 --> 01:16:06,540
was 21 mod for one right so you hashed a

3768
01:16:06,540 --> 01:16:06,550
 

3769
01:16:06,550 --> 01:16:10,290
one you land here you you this would be

3770
01:16:10,290 --> 01:16:10,300
 

3771
01:16:10,300 --> 01:16:11,970
overflow and you insert into there oh

3772
01:16:11,970 --> 01:16:11,980
 

3773
01:16:11,980 --> 01:16:14,190
yeah so yeah for this in here that would

3774
01:16:14,190 --> 01:16:14,200
 

3775
01:16:14,200 --> 01:16:16,470
count actually yes this question is with

3776
01:16:16,470 --> 01:16:16,480
 

3777
01:16:16,480 --> 01:16:20,670
that count as a overflow getting depends

3778
01:16:20,670 --> 01:16:20,680
 

3779
01:16:20,680 --> 01:16:22,380
on how you implemented it if you say

3780
01:16:22,380 --> 01:16:22,390

3781
01:16:22,390 --> 01:16:24,120
it's only when you create a new bucket

3782
01:16:24,120 --> 01:16:24,130

3783
01:16:24,130 --> 01:16:26,460
then no it wouldn't overflow if you say

3784
01:16:26,460 --> 01:16:26,470
 

3785
01:16:26,470 --> 01:16:28,590
that it's whenever you your the thing

3786
01:16:28,590 --> 01:16:28,600
 

3787
01:16:28,600 --> 01:16:34,050
you're pointing at has an additional

3788
01:16:34,050 --> 01:16:34,060
 

3789
01:16:34,060 --> 01:16:36,090
bucket then yes you would count as an

3790
01:16:36,090 --> 01:16:36,100
 

3791
01:16:36,100 --> 01:16:37,470
overflow depends on the implementation

3792
01:16:37,470 --> 01:16:37,480
 

3793
01:16:37,480 --> 01:16:39,180
the math still works out correctly in

3794
01:16:39,180 --> 01:16:39,190
 

3795
01:16:39,190 --> 01:16:47,490
both cases though so his question is how

3796
01:16:47,490 --> 01:16:47,500
 

3797
01:16:47,500 --> 01:16:49,230
do we determine when to split a bucket

3798
01:16:49,230 --> 01:16:49,240
 

3799
01:16:49,240 --> 01:16:50,820
in linear hashing it's whenever I run

3800
01:16:50,820 --> 01:16:50,830
 

3801
01:16:50,830 --> 01:16:53,400
out of space so the very beginning right

3802
01:16:53,400 --> 01:16:53,410
 

3803
01:16:53,410 --> 01:16:58,920
I was here I want to insert 17 it hashes

3804
01:16:58,920 --> 01:16:58,930
 

3805
01:16:58,930 --> 01:17:01,470
to this bucket 1 the bucket are here's

3806
01:17:01,470 --> 01:17:01,480
 

3807
01:17:01,480 --> 01:17:02,760
three elements I can't put another

3808
01:17:02,760 --> 01:17:02,770
 

3809
01:17:02,770 --> 01:17:05,450
element in so I have to overflow it

3810
01:17:05,450 --> 01:17:05,460
 

3811
01:17:05,460 --> 01:17:09,660
right and I said globally I said

3812
01:17:09,660 --> 01:17:09,670
 

3813
01:17:09,670 --> 01:17:12,390
whenever a bucket overflows creates a

3814
01:17:12,390 --> 01:17:12,400

3815
01:17:12,400 --> 01:17:15,660
new bucket in the chain that triggers

3816
01:17:15,660 --> 01:17:15,670
 

3817
01:17:15,670 --> 01:17:17,130
the split pointer to split whatever its

3818
01:17:17,130 --> 01:17:17,140
 

3819
01:17:17,140 --> 01:17:19,860
pointing at so we ended up then at this

3820
01:17:19,860 --> 01:17:19,870
 

3821
01:17:19,870 --> 01:17:33,170
point here we split the first one

3822
01:17:33,170 --> 01:17:33,180


3823
01:17:33,180 --> 01:17:35,730
depends on that's implemented if you say

3824
01:17:35,730 --> 01:17:35,740
 

3825
01:17:35,740 --> 01:17:37,800
again you can say whenever I create a

3826
01:17:37,800 --> 01:17:37,810
 

3827
01:17:37,810 --> 01:17:40,890
new bucket split or if the flip hunter

3828
01:17:40,890 --> 01:17:40,900
 

3829
01:17:40,900 --> 01:17:42,150
is pointing at a bucket that's already

3830
01:17:42,150 --> 01:17:42,160
 

3831
01:17:42,160 --> 01:17:44,550
overflowed then I split so you could

3832
01:17:44,550 --> 01:17:44,560
 

3833
01:17:44,560 --> 01:17:46,590
have it say okay I'm in my sleep owner

3834
01:17:46,590 --> 01:17:46,600
 

3835
01:17:46,600 --> 01:17:47,850
down here this thing's already

3836
01:17:47,850 --> 01:17:47,860
 

3837
01:17:47,860 --> 01:17:50,370
overflowed so immediately go then split

3838
01:17:50,370 --> 01:17:50,380
 

3839
01:17:50,380 --> 01:17:52,170
split it and move it down again it

3840
01:17:52,170 --> 01:17:52,180
 

3841
01:17:52,180 --> 01:17:53,760
depends on the implementation no one way

3842
01:17:53,760 --> 01:17:53,770
 

3843
01:17:53,770 --> 01:17:57,150
is better than another and so we have

3844
01:17:57,150 --> 01:17:57,160
 

3845
01:17:57,160 --> 01:17:58,680
like two minutes left there's a quiz a

3846
01:17:58,680 --> 01:17:58,690
 

3847
01:17:58,690 --> 01:18:00,549
quick question order

3848
01:18:00,549 --> 01:18:00,559

3849
01:18:00,559 --> 01:18:07,660
let's go question so what pointer points

3850
01:18:07,660 --> 01:18:07,670
 

3851
01:18:07,670 --> 01:18:11,260
to 17 this this one does this it's like

3852
01:18:11,260 --> 01:18:11,270
 

3853
01:18:11,270 --> 01:18:13,689
a chain hashing it's an overflow it just

3854
01:18:13,689 --> 01:18:13,699
 

3855
01:18:13,699 --> 01:18:15,729
says I it's like if the thing you're

3856
01:18:15,729 --> 01:18:15,739
 

3857
01:18:15,739 --> 01:18:17,560
looking for is not in this bucket oh by

3858
01:18:17,560 --> 01:18:17,570
 

3859
01:18:17,570 --> 01:18:18,669
the way here's a pointer to the next

3860
01:18:18,669 --> 01:18:18,679
 

3861
01:18:18,679 --> 01:18:20,589
book you should go scan and you have to

3862
01:18:20,589 --> 01:18:20,599
 

3863
01:18:20,599 --> 01:18:24,310
scan the entire thing okay

3864
01:18:24,310 --> 01:18:24,320
 

3865
01:18:24,320 --> 01:18:28,299
I think we covered most of this the only

3866
01:18:28,299 --> 01:18:28,309
 

3867
01:18:28,309 --> 01:18:29,620
thing I'll say also - about linear

3868
01:18:29,620 --> 01:18:29,630
 

3869
01:18:29,630 --> 01:18:30,850
hashing what's really nice about it is

3870
01:18:30,850 --> 01:18:30,860
 

3871
01:18:30,860 --> 01:18:32,229
it's really easy to go in the other

3872
01:18:32,229 --> 01:18:32,239
 

3873
01:18:32,239 --> 01:18:34,330
direction right you could say all right

3874
01:18:34,330 --> 01:18:34,340
 

3875
01:18:34,340 --> 01:18:39,700
well whatever my bucket is as empty then

3876
01:18:39,700 --> 01:18:39,710
 

3877
01:18:39,710 --> 01:18:42,430
that's the same thing as a as as a

3878
01:18:42,430 --> 01:18:42,440
 

3879
01:18:42,440 --> 01:18:46,089
reverse and I just go then do a reverse

3880
01:18:46,089 --> 01:18:46,099

3881
01:18:46,099 --> 01:18:48,160
split on whatever the slip pointer is

3882
01:18:48,160 --> 01:18:48,170
 

3883
01:18:48,170 --> 01:18:49,720
pointing at from before and move it back

3884
01:18:49,720 --> 01:18:49,730
 

3885
01:18:49,730 --> 01:18:53,049
up right so you can do addition and a

3886
01:18:53,049 --> 01:18:53,059
 

3887
01:18:53,059 --> 01:18:55,930
retraction very easily much more easily

3888
01:18:55,930 --> 01:18:55,940
 

3889
01:18:55,940 --> 01:18:57,160
than you can and some of the other

3890
01:18:57,160 --> 01:18:57,170
 

3891
01:18:57,170 --> 01:19:00,640
schemes alright so just to finish up I

3892
01:19:00,640 --> 01:19:00,650
 

3893
01:19:00,650 --> 01:19:03,850
would say that all the data structures

3894
01:19:03,850 --> 01:19:03,860
 

3895
01:19:03,860 --> 01:19:06,729
we talked about here today ideally will

3896
01:19:06,729 --> 01:19:06,739
 

3897
01:19:06,739 --> 01:19:08,129
give you oh and lookups

3898
01:19:08,129 --> 01:19:08,139

3899
01:19:08,139 --> 01:19:11,260
the constant factors actually matter and

3900
01:19:11,260 --> 01:19:11,270
 

3901
01:19:11,270 --> 01:19:12,760
it depends on your collision rate you

3902
01:19:12,760 --> 01:19:12,770
 

3903
01:19:12,770 --> 01:19:13,810
end up may having to do a sequential

3904
01:19:13,810 --> 01:19:13,820
 

3905
01:19:13,820 --> 01:19:15,850
scan across all elements or all keys to

3906
01:19:15,850 --> 01:19:15,860
 

3907
01:19:15,860 --> 01:19:17,560
find the thing you're looking for right

3908
01:19:17,560 --> 01:19:17,570
 

3909
01:19:17,570 --> 01:19:19,060
but it again there's this trade-off

3910
01:19:19,060 --> 01:19:19,070
 

3911
01:19:19,070 --> 01:19:23,620
between having very fast look ups and

3912
01:19:23,620 --> 01:19:23,630

3913
01:19:23,630 --> 01:19:25,000
insertions with the flexibility of not

3914
01:19:25,000 --> 01:19:25,010
 

3915
01:19:25,010 --> 01:19:26,410
having to rebuild everything every time

3916
01:19:26,410 --> 01:19:26,420
 

3917
01:19:26,420 --> 01:19:29,859
you touch it so I don't have time to do

3918
01:19:29,859 --> 01:19:29,869
 

3919
01:19:29,869 --> 01:19:31,810
the demo I mean we can just keep going

3920
01:19:31,810 --> 01:19:31,820
 

3921
01:19:31,820 --> 01:19:33,220
and people have to leave but I give a

3922
01:19:33,220 --> 01:19:33,230
 

3923
01:19:33,230 --> 01:19:36,430
quick Postgres demo what I'll say is

3924
01:19:36,430 --> 01:19:36,440
 

3925
01:19:36,440 --> 01:19:38,200
again that this is hash table they're

3926
01:19:38,200 --> 01:19:38,210
 

3927
01:19:38,210 --> 01:19:39,729
probably usually not what you want to

3928
01:19:39,729 --> 01:19:39,739
 

3929
01:19:39,739 --> 01:19:43,270
use for table indexes because they can

3930
01:19:43,270 --> 01:19:43,280
 

3931
01:19:43,280 --> 01:19:46,419
only do single key lookups does

3932
01:19:46,419 --> 01:19:46,429
 

3933
01:19:46,429 --> 01:19:48,760
something equal something you can't do

3934
01:19:48,760 --> 01:19:48,770

3935
01:19:48,770 --> 01:19:51,069
range scans right you can't have partial

3936
01:19:51,069 --> 01:19:51,079
 

3937
01:19:51,079 --> 01:19:52,390
keys you have to have all the key

3938
01:19:52,390 --> 01:19:52,400
 

3939
01:19:52,400 --> 01:19:53,500
because otherwise not gonna hash you the

3940
01:19:53,500 --> 01:19:53,510
 

3941
01:19:53,510 --> 01:19:56,470
same thing and the way we can do better

3942
01:19:56,470 --> 01:19:56,480
 

3943
01:19:56,480 --> 01:19:58,479
is to having the the order preserving

3944
01:19:58,479 --> 01:19:58,489
 

3945
01:19:58,489 --> 01:20:02,950
indexes like in B plus tree okay any

3946
01:20:02,950 --> 01:20:02,960
 

3947
01:20:02,960 --> 01:20:05,709
questions okay next class we're going to

3948
01:20:05,709 --> 01:20:05,719
 

3949
01:20:05,719 --> 01:20:09,160
do B plus trees so some most of time of

3950
01:20:09,160 --> 01:20:09,170
 

3951
01:20:09,170 --> 01:20:10,870
that we'll spend a little bit time on

3952
01:20:10,870 --> 01:20:10,880
 

3953
01:20:10,880 --> 01:20:13,850
skip lists and radix trees or tries but

3954
01:20:13,850 --> 01:20:13,860

3955
01:20:13,860 --> 01:20:15,800
trees are really the the the granddaddy

3956
01:20:15,800 --> 01:20:15,810
 

3957
01:20:15,810 --> 01:20:25,370
of all the data structures okay SP

3958
01:20:25,370 --> 01:20:25,380
 

3959
01:20:25,380 --> 01:20:29,419
cricket I des I make a mess unless I can

3960
01:20:29,419 --> 01:20:29,429
 

3961
01:20:29,429 --> 01:20:30,680
do it like a Geo

3962
01:20:30,680 --> 01:20:30,690
 

3963
01:20:30,690 --> 01:20:33,770
are you put the G to the e to the T

3964
01:20:33,770 --> 01:20:33,780
 

3965
01:20:33,780 --> 01:20:37,399
comes do I play the game wears on the

3966
01:20:37,399 --> 01:20:37,409
 

3967
01:20:37,409 --> 01:20:42,250
truck so y'all move about the buck a

3968
01:20:42,250 --> 01:20:42,260
 

3969
01:20:42,260 --> 01:20:51,609
[Music]

3970
01:20:51,609 --> 01:20:51,619


3971
01:20:51,619 --> 01:20:55,370
party by the 12-pack case of a four six

3972
01:20:55,370 --> 01:20:55,380
 

3973
01:20:55,380 --> 01:20:58,609
pack 40 act against the real I treat

3974
01:20:58,609 --> 01:20:58,619
 

3975
01:20:58,619 --> 01:21:00,830
please put your drinking proper 12 ow

3976
01:21:00,830 --> 01:21:00,840
 

3977
01:21:00,840 --> 01:21:03,709
they say build nation flap but sane eyes

3978
01:21:03,709 --> 01:21:03,719
 

3979
01:21:03,719 --> 01:21:07,489
are straight so it really don't matter

