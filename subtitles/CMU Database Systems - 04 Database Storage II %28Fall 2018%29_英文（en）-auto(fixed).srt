1
00:00:00,740 --> 00:00:10,640
[Music]

2
00:00:10,640 --> 00:00:10,650

3
00:00:10,650 --> 00:00:15,689
they'd be on the Jill's Nick okay so

4
00:00:15,689 --> 00:00:15,699
 

5
00:00:15,699 --> 00:00:17,880
real quick before we dive into the

6
00:00:17,880 --> 00:00:17,890
 

7
00:00:17,890 --> 00:00:21,690
material just again the reminders for

8
00:00:21,690 --> 00:00:21,700
 

9
00:00:21,700 --> 00:00:24,029
administrative things right homework one

10
00:00:24,029 --> 00:00:24,039
 

11
00:00:24,039 --> 00:00:28,590
is due tonight at midnight and then if

12
00:00:28,590 --> 00:00:28,600
 

13
00:00:28,600 --> 00:00:30,240
you if you're not gonna make tonight's

14
00:00:30,240 --> 00:00:30,250
 

15
00:00:30,250 --> 00:00:32,100
deadline check the syllabus all right

16
00:00:32,100 --> 00:00:32,110
 

17
00:00:32,110 --> 00:00:33,750
for both projects and homeworks you're

18
00:00:33,750 --> 00:00:33,760

19
00:00:33,760 --> 00:00:36,360
given for slip days so if you're one

20
00:00:36,360 --> 00:00:36,370
 

21
00:00:36,370 --> 00:00:38,130
minute over or whatever great scope says

22
00:00:38,130 --> 00:00:38,140
 

23
00:00:38,140 --> 00:00:40,520
is midnight then it's considered late

24
00:00:40,520 --> 00:00:40,530
 

25
00:00:40,530 --> 00:00:43,229
and then you're docked one one of those

26
00:00:43,229 --> 00:00:43,239
 

27
00:00:43,239 --> 00:00:46,439
four missed days the second announcement

28
00:00:46,439 --> 00:00:46,449
 

29
00:00:46,449 --> 00:00:50,189
is that in class on Wednesday I will be

30
00:00:50,189 --> 00:00:50,199
 

31
00:00:50,199 --> 00:00:52,559
releasing and presenting to you guys the

32
00:00:52,559 --> 00:00:52,569

33
00:00:52,569 --> 00:00:55,079
the first project and we'll spend a

34
00:00:55,079 --> 00:00:55,089
 

35
00:00:55,089 --> 00:00:57,719
little time sort out lying pallid before

36
00:00:57,719 --> 00:00:57,729
 

37
00:00:57,729 --> 00:00:59,369
projects that you're gonna be working on

38
00:00:59,369 --> 00:00:59,379
 

39
00:00:59,379 --> 00:01:02,129
fit together and how it's related to the

40
00:01:02,129 --> 00:01:02,139
 

41
00:01:02,139 --> 00:01:03,660
discussions we're having in the lecture

42
00:01:03,660 --> 00:01:03,670

43
00:01:03,670 --> 00:01:06,360
so far and then the last thing I want to

44
00:01:06,360 --> 00:01:06,370
 

45
00:01:06,370 --> 00:01:09,929
talk about is sort of a confession and

46
00:01:09,929 --> 00:01:09,939
 

47
00:01:09,939 --> 00:01:12,420
that is to say that I sort of lied at

48
00:01:12,420 --> 00:01:12,430
 

49
00:01:12,430 --> 00:01:13,800
the beginning the semester and I said

50
00:01:13,800 --> 00:01:13,810
 

51
00:01:13,810 --> 00:01:15,779
that the only two things I care about

52
00:01:15,779 --> 00:01:15,789
 

53
00:01:15,789 --> 00:01:19,289
are my wife and databases I really

54
00:01:19,289 --> 00:01:19,299
 

55
00:01:19,299 --> 00:01:20,730
really love vaccines

56
00:01:20,730 --> 00:01:20,740

57
00:01:20,740 --> 00:01:24,599
I've even got mine already today uh my

58
00:01:24,599 --> 00:01:24,609
 

59
00:01:24,609 --> 00:01:29,399
shirt says vaccinate kids so everyone

60
00:01:29,399 --> 00:01:29,409
 

61
00:01:29,409 --> 00:01:32,010
should go get the flu vaccines are free

62
00:01:32,010 --> 00:01:32,020
 

63
00:01:32,020 --> 00:01:33,749
again I've realized some people medical

64
00:01:33,749 --> 00:01:33,759
 

65
00:01:33,759 --> 00:01:35,490
conditions and you can't right but

66
00:01:35,490 --> 00:01:35,500
 

67
00:01:35,500 --> 00:01:37,349
there's no excuse if you're healthy you

68
00:01:37,349 --> 00:01:37,359
 

69
00:01:37,359 --> 00:01:39,060
should be getting a flu vaccine to give

70
00:01:39,060 --> 00:01:39,070
 

71
00:01:39,070 --> 00:01:40,499
you an idea how obsessed I am about

72
00:01:40,499 --> 00:01:40,509
 

73
00:01:40,509 --> 00:01:43,440
vaccines two years ago I try to get them

74
00:01:43,440 --> 00:01:43,450
 

75
00:01:43,450 --> 00:01:46,349
to set up the flu vaccine center or the

76
00:01:46,349 --> 00:01:46,359
 

77
00:01:46,359 --> 00:01:48,690
the table at the cs department gates

78
00:01:48,690 --> 00:01:48,700
 

79
00:01:48,700 --> 00:01:51,419
they wouldn't do that and then my first

80
00:01:51,419 --> 00:01:51,429
 

81
00:01:51,429 --> 00:01:52,980
year I try to give extra credit if you

82
00:01:52,980 --> 00:01:52,990
 

83
00:01:52,990 --> 00:01:54,630
got the flu vaccine if you had a selfie

84
00:01:54,630 --> 00:01:54,640

85
00:01:54,640 --> 00:01:55,859
of like them sticking the thing in your

86
00:01:55,859 --> 00:01:55,869
 

87
00:01:55,869 --> 00:01:58,050
arm apparently that's illegal and I

88
00:01:58,050 --> 00:01:58,060
 

89
00:01:58,060 --> 00:02:00,209
couldn't do that so then last year we

90
00:02:00,209 --> 00:02:00,219
 

91
00:02:00,219 --> 00:02:02,130
try to buy some illegal flu vaccine from

92
00:02:02,130 --> 00:02:02,140
 

93
00:02:02,140 --> 00:02:03,419
Mexico and started giving them out the

94
00:02:03,419 --> 00:02:03,429
 

95
00:02:03,429 --> 00:02:05,870
students apparently that's illegal too

96
00:02:05,870 --> 00:02:05,880
 

97
00:02:05,880 --> 00:02:08,730
but so I went through all this effort to

98
00:02:08,730 --> 00:02:08,740
 

99
00:02:08,740 --> 00:02:11,130
try to get vaccines it's super easy you

100
00:02:11,130 --> 00:02:11,140
 

101
00:02:11,140 --> 00:02:13,110
can make appointments or go whenever

102
00:02:13,110 --> 00:02:13,120
 

103
00:02:13,120 --> 00:02:17,280
they have the free clinics okay okay

104
00:02:17,280 --> 00:02:17,290
 

105
00:02:17,290 --> 00:02:19,259
all right so let's jump into databases

106
00:02:19,259 --> 00:02:19,269
 

107
00:02:19,269 --> 00:02:23,420
now my second love of my life okay so

108
00:02:23,420 --> 00:02:23,430
 

109
00:02:23,430 --> 00:02:25,890
there were some questions at the end of

110
00:02:25,890 --> 00:02:25,900
 

111
00:02:25,900 --> 00:02:28,530
last class that people were started

112
00:02:28,530 --> 00:02:28,540
 

113
00:02:28,540 --> 00:02:30,199
grappling with trying to understand

114
00:02:30,199 --> 00:02:30,209
 

115
00:02:30,209 --> 00:02:32,940
where I was going with you know this

116
00:02:32,940 --> 00:02:32,950
 

117
00:02:32,950 --> 00:02:35,339
this database storage the file level and

118
00:02:35,339 --> 00:02:35,349
 

119
00:02:35,349 --> 00:02:37,289
breaking things up the pages right and

120
00:02:37,289 --> 00:02:37,299
 

121
00:02:37,299 --> 00:02:38,460
they were trying to understand what's

122
00:02:38,460 --> 00:02:38,470
 

123
00:02:38,470 --> 00:02:40,710
the big picture of what I'm trying to

124
00:02:40,710 --> 00:02:40,720
 

125
00:02:40,720 --> 00:02:42,809
talk about here and how's this gonna fit

126
00:02:42,809 --> 00:02:42,819
 

127
00:02:42,819 --> 00:02:44,069
into the things that we talked about

128
00:02:44,069 --> 00:02:44,079
 

129
00:02:44,079 --> 00:02:46,470
talked about in in subsequent lectures

130
00:02:46,470 --> 00:02:46,480
 

131
00:02:46,480 --> 00:02:48,479
so everyone's been a little bit time

132
00:02:48,479 --> 00:02:48,489
 

133
00:02:48,489 --> 00:02:50,940
talking about sort of going over again

134
00:02:50,940 --> 00:02:50,950
 

135
00:02:50,950 --> 00:02:52,679
what I mean by a disk oriented database

136
00:02:52,679 --> 00:02:52,689
 

137
00:02:52,689 --> 00:02:54,690
system architecture and then I'll show

138
00:02:54,690 --> 00:02:54,700
 

139
00:02:54,700 --> 00:02:57,240
sort of an overview of what the sort of

140
00:02:57,240 --> 00:02:57,250
 

141
00:02:57,250 --> 00:03:00,300
the the high level semantics of the

142
00:03:00,300 --> 00:03:00,310
 

143
00:03:00,310 --> 00:03:01,949
system we're trying to build and why the

144
00:03:01,949 --> 00:03:01,959
 

145
00:03:01,959 --> 00:03:03,420
various things we've talked about so far

146
00:03:03,420 --> 00:03:03,430
 

147
00:03:03,430 --> 00:03:06,929
or how they fit into this this overall

148
00:03:06,929 --> 00:03:06,939
 

149
00:03:06,939 --> 00:03:10,020
system so I said this course is about

150
00:03:10,020 --> 00:03:10,030
 

151
00:03:10,030 --> 00:03:11,940
disk oriented database management

152
00:03:11,940 --> 00:03:11,950
 

153
00:03:11,950 --> 00:03:14,580
systems and the definition I gave for

154
00:03:14,580 --> 00:03:14,590
 

155
00:03:14,590 --> 00:03:17,580
disk oriented was a database management

156
00:03:17,580 --> 00:03:17,590
 

157
00:03:17,590 --> 00:03:19,559
system where the Edit the architecture

158
00:03:19,559 --> 00:03:19,569

159
00:03:19,569 --> 00:03:22,770
is predicated on the assumption that the

160
00:03:22,770 --> 00:03:22,780
 

161
00:03:22,780 --> 00:03:24,629
primary search location of the database

162
00:03:24,629 --> 00:03:24,639
 

163
00:03:24,639 --> 00:03:28,229
is on disk and so that means that any

164
00:03:28,229 --> 00:03:28,239
 

165
00:03:28,239 --> 00:03:30,960
time a query needs to read something I

166
00:03:30,960 --> 00:03:30,970
 

167
00:03:30,970 --> 00:03:33,509
read read a tuple and we've already

168
00:03:33,509 --> 00:03:33,519
 

169
00:03:33,519 --> 00:03:34,649
talked about how two balls are starting

170
00:03:34,649 --> 00:03:34,659
 

171
00:03:34,659 --> 00:03:36,479
pages and pages of shortened files right

172
00:03:36,479 --> 00:03:36,489
 

173
00:03:36,489 --> 00:03:37,530
whenever needs to read one of these

174
00:03:37,530 --> 00:03:37,540

175
00:03:37,540 --> 00:03:40,199
tuples it's going to assume that it's

176
00:03:40,199 --> 00:03:40,209
 

177
00:03:40,209 --> 00:03:42,000
not in memory and therefore it's gonna

178
00:03:42,000 --> 00:03:42,010
 

179
00:03:42,010 --> 00:03:44,490
go out the disk to get it copy it into

180
00:03:44,490 --> 00:03:44,500
 

181
00:03:44,500 --> 00:03:45,899
memory and then it can do whatever it is

182
00:03:45,899 --> 00:03:45,909
 

183
00:03:45,909 --> 00:03:49,770
that it wants to do on it and the reason

184
00:03:49,770 --> 00:03:49,780
 

185
00:03:49,780 --> 00:03:51,539
why that we're saying this is just going

186
00:03:51,539 --> 00:03:51,549
 

187
00:03:51,549 --> 00:03:53,759
to is its again is this major assumption

188
00:03:53,759 --> 00:03:53,769
 

189
00:03:53,769 --> 00:03:56,280
because a lot of things that we're going

190
00:03:56,280 --> 00:03:56,290
 

191
00:03:56,290 --> 00:03:58,530
to talk about as we go along will see

192
00:03:58,530 --> 00:03:58,540
 

193
00:03:58,540 --> 00:04:00,479
that we have to add certain protection

194
00:04:00,479 --> 00:04:00,489
 

195
00:04:00,489 --> 00:04:03,479
mechanisms or certain functionalities in

196
00:04:03,479 --> 00:04:03,489

197
00:04:03,489 --> 00:04:04,890
the components of the database minute

198
00:04:04,890 --> 00:04:04,900

199
00:04:04,900 --> 00:04:07,770
system just because anytime we go read

200
00:04:07,770 --> 00:04:07,780
 

201
00:04:07,780 --> 00:04:09,270
something it may actually not actually

202
00:04:09,270 --> 00:04:09,280
 

203
00:04:09,280 --> 00:04:11,849
be in memory right we'll see this when

204
00:04:11,849 --> 00:04:11,859
 

205
00:04:11,859 --> 00:04:12,839
we talk about concurrency control

206
00:04:12,839 --> 00:04:12,849
 

207
00:04:12,849 --> 00:04:14,999
allowing multiple queries or

208
00:04:14,999 --> 00:04:15,009
 

209
00:04:15,009 --> 00:04:16,710
transactions to run at the same time and

210
00:04:16,710 --> 00:04:16,720
 

211
00:04:16,720 --> 00:04:18,810
any given time I could read something

212
00:04:18,810 --> 00:04:18,820
 

213
00:04:18,820 --> 00:04:20,189
and it's not memory I'm gonna stall

214
00:04:20,189 --> 00:04:20,199
 

215
00:04:20,199 --> 00:04:21,569
because I have to go to disk and get it

216
00:04:21,569 --> 00:04:21,579
 

217
00:04:21,579 --> 00:04:23,550
and meanwhile all the queries are gonna

218
00:04:23,550 --> 00:04:23,560
 

219
00:04:23,560 --> 00:04:24,659
start running at the same time because

220
00:04:24,659 --> 00:04:24,669
 

221
00:04:24,669 --> 00:04:26,430
I'm running and therefore the database

222
00:04:26,430 --> 00:04:26,440
 

223
00:04:26,440 --> 00:04:28,589
management system needs to protect the

224
00:04:28,589 --> 00:04:28,599
 

225
00:04:28,599 --> 00:04:31,019
data so that when I say protection I

226
00:04:31,019 --> 00:04:31,029
 

227
00:04:31,029 --> 00:04:31,260
mean

228
00:04:31,260 --> 00:04:31,270

229
00:04:31,270 --> 00:04:34,110
sort of at a logical level from other

230
00:04:34,110 --> 00:04:34,120
 

231
00:04:34,120 --> 00:04:36,090
queries doing the same thing trying to

232
00:04:36,090 --> 00:04:36,100
 

233
00:04:36,100 --> 00:04:37,320
operate on the same date at the same

234
00:04:37,320 --> 00:04:37,330
 

235
00:04:37,330 --> 00:04:39,600
time right and get this will make more

236
00:04:39,600 --> 00:04:39,610
 

237
00:04:39,610 --> 00:04:40,590
sense when we talked about concurrent

238
00:04:40,590 --> 00:04:40,600
 

239
00:04:40,600 --> 00:04:42,420
whole unlocking and latching and other

240
00:04:42,420 --> 00:04:42,430
 

241
00:04:42,430 --> 00:04:44,490
things like that but that's the

242
00:04:44,490 --> 00:04:44,500
 

243
00:04:44,500 --> 00:04:46,950
high-level idea of what we're trying to

244
00:04:46,950 --> 00:04:46,960
 

245
00:04:46,960 --> 00:04:48,360
do here remember since you're trying to

246
00:04:48,360 --> 00:04:48,370
 

247
00:04:48,370 --> 00:04:49,770
manage the movement of data back and

248
00:04:49,770 --> 00:04:49,780
 

249
00:04:49,780 --> 00:04:51,870
forth to be disk in the memory so that

250
00:04:51,870 --> 00:04:51,880
 

251
00:04:51,880 --> 00:04:54,270
we can handle databases that are larger

252
00:04:54,270 --> 00:04:54,280
 

253
00:04:54,280 --> 00:04:55,530
than the total amount of memory that we

254
00:04:55,530 --> 00:04:55,540
 

255
00:04:55,540 --> 00:04:58,020
have so that is that clear for everyone

256
00:04:58,020 --> 00:04:58,030
 

257
00:04:58,030 --> 00:05:00,920
here right and yeah I was sort of as a

258
00:05:00,920 --> 00:05:00,930
 

259
00:05:00,930 --> 00:05:04,260
as a precursor or as a teaser for the

260
00:05:04,260 --> 00:05:04,270
 

261
00:05:04,270 --> 00:05:05,970
advanced class in the advanced class in

262
00:05:05,970 --> 00:05:05,980
 

263
00:05:05,980 --> 00:05:09,030
the spring the disk goes goes away we

264
00:05:09,030 --> 00:05:09,040
 

265
00:05:09,040 --> 00:05:11,160
assume everything's in memory for

266
00:05:11,160 --> 00:05:11,170

267
00:05:11,170 --> 00:05:12,690
reading writing data and that allows you

268
00:05:12,690 --> 00:05:12,700
 

269
00:05:12,700 --> 00:05:13,920
do a bunch of optimizations that we

270
00:05:13,920 --> 00:05:13,930
 

271
00:05:13,930 --> 00:05:16,110
can't actually do here right so you can

272
00:05:16,110 --> 00:05:16,120
 

273
00:05:16,120 --> 00:05:17,370
sort of take this as a classical

274
00:05:17,370 --> 00:05:17,380
 

275
00:05:17,380 --> 00:05:18,990
database system architecture well though

276
00:05:18,990 --> 00:05:19,000
 

277
00:05:19,000 --> 00:05:21,230
it's you know the most widely deployed

278
00:05:21,230 --> 00:05:21,240
 

279
00:05:21,240 --> 00:05:23,730
implementation that that's around and we

280
00:05:23,730 --> 00:05:23,740
 

281
00:05:23,740 --> 00:05:25,350
can make it more run faster in some

282
00:05:25,350 --> 00:05:25,360
 

283
00:05:25,360 --> 00:05:26,880
cases if we assume everything's in

284
00:05:26,880 --> 00:05:26,890
 

285
00:05:26,890 --> 00:05:28,530
memory for our purposes here we assume

286
00:05:28,530 --> 00:05:28,540
 

287
00:05:28,540 --> 00:05:30,630
there's a disk and we'll see how we

288
00:05:30,630 --> 00:05:30,640
 

289
00:05:30,640 --> 00:05:33,450
actually deal with that so to better

290
00:05:33,450 --> 00:05:33,460
 

291
00:05:33,460 --> 00:05:34,800
understand now what we've talked about

292
00:05:34,800 --> 00:05:34,810
 

293
00:05:34,810 --> 00:05:37,230
so far in the last lecture and how it's

294
00:05:37,230 --> 00:05:37,240
 

295
00:05:37,240 --> 00:05:38,340
going to fit into the subsequent

296
00:05:38,340 --> 00:05:38,350
 

297
00:05:38,350 --> 00:05:40,320
lectures that we go through I want to

298
00:05:40,320 --> 00:05:40,330
 

299
00:05:40,330 --> 00:05:41,760
sort of begin present this sort of

300
00:05:41,760 --> 00:05:41,770
 

301
00:05:41,770 --> 00:05:43,530
high-level diagram of what a database

302
00:05:43,530 --> 00:05:43,540
 

303
00:05:43,540 --> 00:05:44,850
meta system is going to look like and

304
00:05:44,850 --> 00:05:44,860
 

305
00:05:44,860 --> 00:05:46,620
you'll see how all the various pieces

306
00:05:46,620 --> 00:05:46,630
 

307
00:05:46,630 --> 00:05:49,770
fit together so I said last class we

308
00:05:49,770 --> 00:05:49,780
 

309
00:05:49,780 --> 00:05:51,990
talked about the database storage right

310
00:05:51,990 --> 00:05:52,000
 

311
00:05:52,000 --> 00:05:53,370
we assumed that it was going to be one

312
00:05:53,370 --> 00:05:53,380
 

313
00:05:53,380 --> 00:05:55,920
or more files on disk writes equal

314
00:05:55,920 --> 00:05:55,930
 

315
00:05:55,930 --> 00:05:57,390
lights a single file other systems will

316
00:05:57,390 --> 00:05:57,400
 

317
00:05:57,400 --> 00:05:58,530
break it up into different multiple

318
00:05:58,530 --> 00:05:58,540
 

319
00:05:58,540 --> 00:06:00,780
files sometimes it's like one file per

320
00:06:00,780 --> 00:06:00,790
 

321
00:06:00,790 --> 00:06:03,450
table one file per database all right

322
00:06:03,450 --> 00:06:03,460
 

323
00:06:03,460 --> 00:06:04,890
for our purposes it doesn't matter and

324
00:06:04,890 --> 00:06:04,900
 

325
00:06:04,900 --> 00:06:07,470
then we said that the way the database

326
00:06:07,470 --> 00:06:07,480
 

327
00:06:07,480 --> 00:06:09,090
type system was going to organize data

328
00:06:09,090 --> 00:06:09,100
 

329
00:06:09,100 --> 00:06:12,980
inside of these this file is in pages

330
00:06:12,980 --> 00:06:12,990
 

331
00:06:12,990 --> 00:06:15,300
right and we said there had to be sort

332
00:06:15,300 --> 00:06:15,310
 

333
00:06:15,310 --> 00:06:17,010
this this sort of special page it's

334
00:06:17,010 --> 00:06:17,020
 

335
00:06:17,020 --> 00:06:18,500
called the page directory that

336
00:06:18,500 --> 00:06:18,510
 

337
00:06:18,510 --> 00:06:21,270
essentially is a map to say if you want

338
00:06:21,270 --> 00:06:21,280
 

339
00:06:21,280 --> 00:06:23,880
page 1 2 3 here's the offset or here's

340
00:06:23,880 --> 00:06:23,890
 

341
00:06:23,890 --> 00:06:25,350
the file to go get the thing that you

342
00:06:25,350 --> 00:06:25,360
 

343
00:06:25,360 --> 00:06:28,680
want right so this this is what we see

344
00:06:28,680 --> 00:06:28,690
 

345
00:06:28,690 --> 00:06:30,210
when you know the database is at rest

346
00:06:30,210 --> 00:06:30,220
 

347
00:06:30,220 --> 00:06:33,570
it's just on disk right there's the you

348
00:06:33,570 --> 00:06:33,580
 

349
00:06:33,580 --> 00:06:34,830
can't actually operate on we've got to

350
00:06:34,830 --> 00:06:34,840
 

351
00:06:34,840 --> 00:06:37,260
bring everything in memory so now when

352
00:06:37,260 --> 00:06:37,270
 

353
00:06:37,270 --> 00:06:38,580
we start want to start operating on this

354
00:06:38,580 --> 00:06:38,590
 

355
00:06:38,590 --> 00:06:40,740
as I said you have to find the page you

356
00:06:40,740 --> 00:06:40,750
 

357
00:06:40,750 --> 00:06:42,690
want and copy it into memory and so

358
00:06:42,690 --> 00:06:42,700
 

359
00:06:42,700 --> 00:06:44,850
we'll discuss this in the next class

360
00:06:44,850 --> 00:06:44,860
 

361
00:06:44,860 --> 00:06:46,529
but the thing that we're gonna end up

362
00:06:46,529 --> 00:06:46,539
 

363
00:06:46,539 --> 00:06:48,089
building to manage this movement and

364
00:06:48,089 --> 00:06:48,099
 

365
00:06:48,099 --> 00:06:49,709
memory back and forth is called the

366
00:06:49,709 --> 00:06:49,719
 

367
00:06:49,719 --> 00:06:51,929
buffer pool now remember I said that we

368
00:06:51,929 --> 00:06:51,939
 

369
00:06:51,939 --> 00:06:53,939
could let the OS do this and use virtual

370
00:06:53,939 --> 00:06:53,949
 

371
00:06:53,949 --> 00:06:56,700
memory with with the with em map of the

372
00:06:56,700 --> 00:06:56,710
 

373
00:06:56,710 --> 00:06:59,279
memory map files but we said that for

374
00:06:59,279 --> 00:06:59,289
 

375
00:06:59,289 --> 00:07:02,189
our performance reasons and that we

376
00:07:02,189 --> 00:07:02,199
 

377
00:07:02,199 --> 00:07:03,420
don't actually want to do this actually

378
00:07:03,420 --> 00:07:03,430
 

379
00:07:03,430 --> 00:07:05,520
for correctness reasons as well we want

380
00:07:05,520 --> 00:07:05,530
 

381
00:07:05,530 --> 00:07:08,040
to manage everything ourselves so this

382
00:07:08,040 --> 00:07:08,050
 

383
00:07:08,050 --> 00:07:09,240
is what we're not end up having to build

384
00:07:09,240 --> 00:07:09,250
 

385
00:07:09,250 --> 00:07:11,339
this buffer pool thing so when you first

386
00:07:11,339 --> 00:07:11,349
 

387
00:07:11,349 --> 00:07:13,740
turned the database system on there's

388
00:07:13,740 --> 00:07:13,750
 

389
00:07:13,750 --> 00:07:15,689
nothing in the buffer pool right we had

390
00:07:15,689 --> 00:07:15,699
 

391
00:07:15,699 --> 00:07:17,040
these sort of empty frames or these

392
00:07:17,040 --> 00:07:17,050
 

393
00:07:17,050 --> 00:07:18,899
slots where pages could be but there's

394
00:07:18,899 --> 00:07:18,909

395
00:07:18,909 --> 00:07:20,879
no data actually in it yet that's not

396
00:07:20,879 --> 00:07:20,889
 

397
00:07:20,889 --> 00:07:22,290
actually true when you boot the system

398
00:07:22,290 --> 00:07:22,300
 

399
00:07:22,300 --> 00:07:23,640
they usually preload a bunch of stuff

400
00:07:23,640 --> 00:07:23,650
 

401
00:07:23,650 --> 00:07:25,439
but again for the simplistic diagram

402
00:07:25,439 --> 00:07:25,449
 

403
00:07:25,449 --> 00:07:28,709
here there's nothing in there so then we

404
00:07:28,709 --> 00:07:28,719
 

405
00:07:28,719 --> 00:07:30,179
come along now with this execution

406
00:07:30,179 --> 00:07:30,189
 

407
00:07:30,189 --> 00:07:31,619
engine this is the thing that's gonna

408
00:07:31,619 --> 00:07:31,629
 

409
00:07:31,629 --> 00:07:34,019
execute queries execute transactions and

410
00:07:34,019 --> 00:07:34,029
 

411
00:07:34,029 --> 00:07:36,540
read and write data I'm drawing this as

412
00:07:36,540 --> 00:07:36,550
 

413
00:07:36,550 --> 00:07:38,939
a cloud right to shut it trying to be

414
00:07:38,939 --> 00:07:38,949
 

415
00:07:38,949 --> 00:07:40,469
nebulous just to say that we don't

416
00:07:40,469 --> 00:07:40,479
 

417
00:07:40,479 --> 00:07:41,580
actually care at this point what this

418
00:07:41,580 --> 00:07:41,590
 

419
00:07:41,590 --> 00:07:42,059
actually is

420
00:07:42,059 --> 00:07:42,069

421
00:07:42,069 --> 00:07:44,610
we'll cover this later on but assume

422
00:07:44,610 --> 00:07:44,620
 

423
00:07:44,620 --> 00:07:45,749
that there's something up here that has

424
00:07:45,749 --> 00:07:45,759
 

425
00:07:45,759 --> 00:07:47,490
a sequel query and once they're reading

426
00:07:47,490 --> 00:07:47,500

427
00:07:47,500 --> 00:07:50,309
read and write data so the way it's

428
00:07:50,309 --> 00:07:50,319
 

429
00:07:50,319 --> 00:07:52,079
going to interact with sort of the

430
00:07:52,079 --> 00:07:52,089
 

431
00:07:52,089 --> 00:07:53,969
storage layer that we're building in

432
00:07:53,969 --> 00:07:53,979

433
00:07:53,979 --> 00:07:56,939
this first part of the semester is to go

434
00:07:56,939 --> 00:07:56,949
 

435
00:07:56,949 --> 00:07:58,950
to the buffer pool and say I want a page

436
00:07:58,950 --> 00:07:58,960
 

437
00:07:58,960 --> 00:08:01,290
that at this particular pick with this

438
00:08:01,290 --> 00:08:01,300
 

439
00:08:01,300 --> 00:08:03,899
particular page ID how it got it whether

440
00:08:03,899 --> 00:08:03,909

441
00:08:03,909 --> 00:08:06,089
you know it read an index or somehow

442
00:08:06,089 --> 00:08:06,099
 

443
00:08:06,099 --> 00:08:07,740
magically poured it out out of the air

444
00:08:07,740 --> 00:08:07,750
 

445
00:08:07,750 --> 00:08:09,869
it doesn't matter right this is the

446
00:08:09,869 --> 00:08:09,879
 

447
00:08:09,879 --> 00:08:11,610
interface that's gonna interact with the

448
00:08:11,610 --> 00:08:11,620
 

449
00:08:11,620 --> 00:08:13,950
the buffer pool so now the buffer pool

450
00:08:13,950 --> 00:08:13,960
 

451
00:08:13,960 --> 00:08:15,269
managers are gonna go down and say well

452
00:08:15,269 --> 00:08:15,279
 

453
00:08:15,279 --> 00:08:16,559
I need to figure out where this page

454
00:08:16,559 --> 00:08:16,569
 

455
00:08:16,569 --> 00:08:18,540
actually is so let me go get the page

456
00:08:18,540 --> 00:08:18,550
 

457
00:08:18,550 --> 00:08:20,579
directory page because I know where that

458
00:08:20,579 --> 00:08:20,589
 

459
00:08:20,589 --> 00:08:22,439
is because it's a sort of a special page

460
00:08:22,439 --> 00:08:22,449
 

461
00:08:22,449 --> 00:08:23,730
and it has to know where it is in order

462
00:08:23,730 --> 00:08:23,740
 

463
00:08:23,740 --> 00:08:25,860
to bootstrap anything and it goes and

464
00:08:25,860 --> 00:08:25,870
 

465
00:08:25,870 --> 00:08:27,600
copy the directory page into memory

466
00:08:27,600 --> 00:08:27,610
 

467
00:08:27,610 --> 00:08:29,730
right now it takes up a slot or frame

468
00:08:29,730 --> 00:08:29,740
 

469
00:08:29,740 --> 00:08:32,189
and our buffer pool and now we can go

470
00:08:32,189 --> 00:08:32,199
 

471
00:08:32,199 --> 00:08:33,569
and say we want page number two well

472
00:08:33,569 --> 00:08:33,579
 

473
00:08:33,579 --> 00:08:35,610
here is where it is let me go copy that

474
00:08:35,610 --> 00:08:35,620
 

475
00:08:35,620 --> 00:08:39,300
into memory and and and you know put it

476
00:08:39,300 --> 00:08:39,310
 

477
00:08:39,310 --> 00:08:42,089
into another free slot so then we get

478
00:08:42,089 --> 00:08:42,099
 

479
00:08:42,099 --> 00:08:45,060
back now a pointer to this page to the

480
00:08:45,060 --> 00:08:45,070
 

481
00:08:45,070 --> 00:08:47,819
execution engine and the sort of the

482
00:08:47,819 --> 00:08:47,829
 

483
00:08:47,829 --> 00:08:49,259
guarantee is at any time that its

484
00:08:49,259 --> 00:08:49,269
 

485
00:08:49,269 --> 00:08:51,630
operating on that page it will be pinned

486
00:08:51,630 --> 00:08:51,640
 

487
00:08:51,640 --> 00:08:53,460
in memory again we'll see how this works

488
00:08:53,460 --> 00:08:53,470
 

489
00:08:53,470 --> 00:08:55,199
in the next class right cuz obviously

490
00:08:55,199 --> 00:08:55,209
 

491
00:08:55,209 --> 00:08:56,639
would be bad if I try to start reading

492
00:08:56,639 --> 00:08:56,649
 

493
00:08:56,649 --> 00:08:58,350
data and the purple manager all

494
00:08:58,350 --> 00:08:58,360
 

495
00:08:58,360 --> 00:08:59,790
so then swaps out the page I was reading

496
00:08:59,790 --> 00:08:59,800
 

497
00:08:59,800 --> 00:09:01,769
while I was reading it and I would have

498
00:09:01,769 --> 00:09:01,779
 

499
00:09:01,779 --> 00:09:05,310
problems right and then there's some

500
00:09:05,310 --> 00:09:05,320
 

501
00:09:05,320 --> 00:09:07,860
additional logic up in the execution

502
00:09:07,860 --> 00:09:07,870
 

503
00:09:07,870 --> 00:09:10,410
engine that knows how to then interpret

504
00:09:10,410 --> 00:09:10,420
 

505
00:09:10,420 --> 00:09:13,199
whatever the layout is of that page to

506
00:09:13,199 --> 00:09:13,209
 

507
00:09:13,209 --> 00:09:14,670
do whatever it is that needed to do

508
00:09:14,670 --> 00:09:14,680
 

509
00:09:14,680 --> 00:09:16,290
remember we talked about the different

510
00:09:16,290 --> 00:09:16,300
 

511
00:09:16,300 --> 00:09:17,699
page layout schemes we'd have a log

512
00:09:17,699 --> 00:09:17,709
 

513
00:09:17,709 --> 00:09:19,380
structured one which is a pending law of

514
00:09:19,380 --> 00:09:19,390
 

515
00:09:19,390 --> 00:09:21,360
records you could have a slotted page we

516
00:09:21,360 --> 00:09:21,370
 

517
00:09:21,370 --> 00:09:23,160
have actual tuples and the slots to

518
00:09:23,160 --> 00:09:23,170
 

519
00:09:23,170 --> 00:09:24,540
point to where they are inside the page

520
00:09:24,540 --> 00:09:24,550
 

521
00:09:24,550 --> 00:09:27,300
right from our point of view here down

522
00:09:27,300 --> 00:09:27,310
 

523
00:09:27,310 --> 00:09:29,759
below in this storage layer we don't

524
00:09:29,759 --> 00:09:29,769
 

525
00:09:29,769 --> 00:09:31,560
actually care what the layout is we just

526
00:09:31,560 --> 00:09:31,570
 

527
00:09:31,570 --> 00:09:33,600
were told hey get us page two and we'll

528
00:09:33,600 --> 00:09:33,610
 

529
00:09:33,610 --> 00:09:34,949
go hand it off to something else in the

530
00:09:34,949 --> 00:09:34,959
 

531
00:09:34,959 --> 00:09:37,230
system who then knows how to interpret

532
00:09:37,230 --> 00:09:37,240
 

533
00:09:37,240 --> 00:09:42,030
it okay so now it's sort of map this to

534
00:09:42,030 --> 00:09:42,040
 

535
00:09:42,040 --> 00:09:43,949
the schedule for the semester

536
00:09:43,949 --> 00:09:43,959
 

537
00:09:43,959 --> 00:09:47,579
we've already covered pages in the last

538
00:09:47,579 --> 00:09:47,589
 

539
00:09:47,589 --> 00:09:48,900
class and we'll cover a little bit more

540
00:09:48,900 --> 00:09:48,910
 

541
00:09:48,910 --> 00:09:50,910
today all right so that's lecture three

542
00:09:50,910 --> 00:09:50,920
 

543
00:09:50,920 --> 00:09:53,130
and for the buffer pool manager stuff

544
00:09:53,130 --> 00:09:53,140
 

545
00:09:53,140 --> 00:09:54,680
will be covered on Wednesday's class

546
00:09:54,680 --> 00:09:54,690
 

547
00:09:54,690 --> 00:09:56,550
right because there's a lot of stuff

548
00:09:56,550 --> 00:09:56,560
 

549
00:09:56,560 --> 00:09:58,440
that's going on here that I'm yeah be

550
00:09:58,440 --> 00:09:58,450
 

551
00:09:58,450 --> 00:10:01,440
super high-level about right how do you

552
00:10:01,440 --> 00:10:01,450
 

553
00:10:01,450 --> 00:10:02,759
have to copy things in how do you make

554
00:10:02,759 --> 00:10:02,769
 

555
00:10:02,769 --> 00:10:03,930
sure that things don't get swapped out

556
00:10:03,930 --> 00:10:03,940
 

557
00:10:03,940 --> 00:10:05,670
how do you decide what the swap out

558
00:10:05,670 --> 00:10:05,680
 

559
00:10:05,680 --> 00:10:08,069
right we'll cover all that next class

560
00:10:08,069 --> 00:10:08,079
 

561
00:10:08,079 --> 00:10:09,360
and that'll be the first project you

562
00:10:09,360 --> 00:10:09,370
 

563
00:10:09,370 --> 00:10:11,939
guys implement then we'll just talk in

564
00:10:11,939 --> 00:10:11,949
 

565
00:10:11,949 --> 00:10:14,040
section lecture six how do we actually

566
00:10:14,040 --> 00:10:14,050
 

567
00:10:14,050 --> 00:10:15,960
represent in memory the page directory

568
00:10:15,960 --> 00:10:15,970
 

569
00:10:15,970 --> 00:10:18,810
with hash tables and then we'll cover

570
00:10:18,810 --> 00:10:18,820
 

571
00:10:18,820 --> 00:10:20,189
how do you have to interpret the bytes

572
00:10:20,189 --> 00:10:20,199
 

573
00:10:20,199 --> 00:10:22,290
in lecture ten and actually a bunch of

574
00:10:22,290 --> 00:10:22,300
 

575
00:10:22,300 --> 00:10:23,670
the other lectures that do query

576
00:10:23,670 --> 00:10:23,680
 

577
00:10:23,680 --> 00:10:25,670
processing okay

578
00:10:25,670 --> 00:10:25,680
 

579
00:10:25,680 --> 00:10:27,810
this make more sense now right we're at

580
00:10:27,810 --> 00:10:27,820
 

581
00:10:27,820 --> 00:10:29,100
words we're starting with files on disk

582
00:10:29,100 --> 00:10:29,110

583
00:10:29,110 --> 00:10:32,250
right we then copy them into memory and

584
00:10:32,250 --> 00:10:32,260
 

585
00:10:32,260 --> 00:10:33,900
then there's some layout to the to the

586
00:10:33,900 --> 00:10:33,910
 

587
00:10:33,910 --> 00:10:35,519
files and some layout to the pages that

588
00:10:35,519 --> 00:10:35,529
 

589
00:10:35,529 --> 00:10:37,410
other parts of the system know how to

590
00:10:37,410 --> 00:10:37,420
 

591
00:10:37,420 --> 00:10:40,050
deal with again we're going up the

592
00:10:40,050 --> 00:10:40,060
 

593
00:10:40,060 --> 00:10:42,410
layers of the database minute system

594
00:10:42,410 --> 00:10:42,420
 

595
00:10:42,420 --> 00:10:44,790
ideally it'd be nice if sort of a clean

596
00:10:44,790 --> 00:10:44,800
 

597
00:10:44,800 --> 00:10:46,620
abstraction from one layer to the next

598
00:10:46,620 --> 00:10:46,630
 

599
00:10:46,630 --> 00:10:47,759
but we'll see in a second that it's not

600
00:10:47,759 --> 00:10:47,769
 

601
00:10:47,769 --> 00:10:50,460
always the case cuz how how you're gonna

602
00:10:50,460 --> 00:10:50,470
 

603
00:10:50,470 --> 00:10:52,319
decide actually how you layout pages or

604
00:10:52,319 --> 00:10:52,329
 

605
00:10:52,329 --> 00:10:54,030
the data in pages will affect how you

606
00:10:54,030 --> 00:10:54,040
 

607
00:10:54,040 --> 00:10:55,889
build your execution engine all right so

608
00:10:55,889 --> 00:10:55,899
 

609
00:10:55,899 --> 00:10:57,509
it's not a clean abstraction in some

610
00:10:57,509 --> 00:10:57,519
 

611
00:10:57,519 --> 00:10:59,670
ways but at a high level it's it's it's

612
00:10:59,670 --> 00:10:59,680
 

613
00:10:59,680 --> 00:11:03,840
good enough okay I say this is sort of a

614
00:11:03,840 --> 00:11:03,850
 

615
00:11:03,850 --> 00:11:05,220
road map for us for the next level weeks

616
00:11:05,220 --> 00:11:05,230
 

617
00:11:05,230 --> 00:11:07,330
question now okay

618
00:11:07,330 --> 00:11:07,340
 

619
00:11:07,340 --> 00:11:10,600
all right so now today's class we're

620
00:11:10,600 --> 00:11:10,610
 

621
00:11:10,610 --> 00:11:11,980
gonna pick up where we left off last

622
00:11:11,980 --> 00:11:11,990
 

623
00:11:11,990 --> 00:11:15,460
class where we we were talking about the

624
00:11:15,460 --> 00:11:15,470
 

625
00:11:15,470 --> 00:11:17,620
the files we talked about the the the

626
00:11:17,620 --> 00:11:17,630
 

627
00:11:17,630 --> 00:11:19,810
the page directory we talked about the

628
00:11:19,810 --> 00:11:19,820
 

629
00:11:19,820 --> 00:11:22,570
the the page layout and then we talked

630
00:11:22,570 --> 00:11:22,580
 

631
00:11:22,580 --> 00:11:23,860
about how you actually layout tuples

632
00:11:23,860 --> 00:11:23,870
 

633
00:11:23,870 --> 00:11:25,990
inside those pages so now the first

634
00:11:25,990 --> 00:11:26,000
 

635
00:11:26,000 --> 00:11:27,160
thing I'm gonna talk about is how do you

636
00:11:27,160 --> 00:11:27,170
 

637
00:11:27,170 --> 00:11:28,960
actually represent into individual

638
00:11:28,960 --> 00:11:28,970
 

639
00:11:28,970 --> 00:11:32,200
values for tuples inside of a page and

640
00:11:32,200 --> 00:11:32,210
 

641
00:11:32,210 --> 00:11:34,150
then we'll talk about the system

642
00:11:34,150 --> 00:11:34,160
 

643
00:11:34,160 --> 00:11:35,760
catalogs at a high level which is the

644
00:11:35,760 --> 00:11:35,770
 

645
00:11:35,770 --> 00:11:38,290
internal metadata the database system is

646
00:11:38,290 --> 00:11:38,300
 

647
00:11:38,300 --> 00:11:41,260
going to maintain to figure out how to

648
00:11:41,260 --> 00:11:41,270
 

649
00:11:41,270 --> 00:11:42,850
actually you know what data is actually

650
00:11:42,850 --> 00:11:42,860

651
00:11:42,860 --> 00:11:44,560
being stored and how to actually

652
00:11:44,560 --> 00:11:44,570
 

653
00:11:44,570 --> 00:11:46,030
interpret the bytes that are inside of

654
00:11:46,030 --> 00:11:46,040
 

655
00:11:46,040 --> 00:11:48,730
tuples and then we'll finish off talking

656
00:11:48,730 --> 00:11:48,740
 

657
00:11:48,740 --> 00:11:51,700
about storage models which is a way to

658
00:11:51,700 --> 00:11:51,710
 

659
00:11:51,710 --> 00:11:54,790
think about how to then take data in

660
00:11:54,790 --> 00:11:54,800
 

661
00:11:54,800 --> 00:11:57,820
tables and then map them to pages or how

662
00:11:57,820 --> 00:11:57,830
 

663
00:11:57,830 --> 00:11:59,050
you actually organize the values in

664
00:11:59,050 --> 00:11:59,060
 

665
00:11:59,060 --> 00:12:01,150
pages which is sort of higher level

666
00:12:01,150 --> 00:12:01,160
 

667
00:12:01,160 --> 00:12:03,040
concept that goes beyond all the things

668
00:12:03,040 --> 00:12:03,050
 

669
00:12:03,050 --> 00:12:07,780
we talked about here so far okay okay so

670
00:12:07,780 --> 00:12:07,790
 

671
00:12:07,790 --> 00:12:11,290
as I said last class the tuples from the

672
00:12:11,290 --> 00:12:11,300
 

673
00:12:11,300 --> 00:12:13,030
data assistance perspective there's

674
00:12:13,030 --> 00:12:13,040
 

675
00:12:13,040 --> 00:12:15,520
nothing magical about them right it's

676
00:12:15,520 --> 00:12:15,530
 

677
00:12:15,530 --> 00:12:18,100
just a sequence of bytes and the

678
00:12:18,100 --> 00:12:18,110
 

679
00:12:18,110 --> 00:12:19,690
database minute system knows how to

680
00:12:19,690 --> 00:12:19,700
 

681
00:12:19,700 --> 00:12:22,200
interpret those bytes to then derive

682
00:12:22,200 --> 00:12:22,210
 

683
00:12:22,210 --> 00:12:25,720
structure on and and and extract values

684
00:12:25,720 --> 00:12:25,730

685
00:12:25,730 --> 00:12:28,450
from them right I can just open up you

686
00:12:28,450 --> 00:12:28,460
 

687
00:12:28,460 --> 00:12:30,070
know char array and see and write a

688
00:12:30,070 --> 00:12:30,080

689
00:12:30,080 --> 00:12:31,600
bunch of crap but then the database

690
00:12:31,600 --> 00:12:31,610
 

691
00:12:31,610 --> 00:12:33,010
system will know how to then take

692
00:12:33,010 --> 00:12:33,020
 

693
00:12:33,020 --> 00:12:35,680
different offsets in that byte array and

694
00:12:35,680 --> 00:12:35,690
 

695
00:12:35,690 --> 00:12:36,940
say well this is an integer I know how

696
00:12:36,940 --> 00:12:36,950
 

697
00:12:36,950 --> 00:12:40,630
to represent do whatever operations or

698
00:12:40,630 --> 00:12:40,640
 

699
00:12:40,640 --> 00:12:42,940
manipulations I want to do assuming that

700
00:12:42,940 --> 00:12:42,950
 

701
00:12:42,950 --> 00:12:47,140
it's 32 bits but the the CPU and the

702
00:12:47,140 --> 00:12:47,150
 

703
00:12:47,150 --> 00:12:48,580
operating system it doesn't see that it

704
00:12:48,580 --> 00:12:48,590
 

705
00:12:48,590 --> 00:12:50,890
doesn't know about the schema it just

706
00:12:50,890 --> 00:12:50,900
 

707
00:12:50,900 --> 00:12:53,710
sees a bunch of byte arrays and so we'll

708
00:12:53,710 --> 00:12:53,720
 

709
00:12:53,720 --> 00:12:55,150
see this in the catalog the catalogs

710
00:12:55,150 --> 00:12:55,160
 

711
00:12:55,160 --> 00:12:57,730
again is the metadata we're gonna use to

712
00:12:57,730 --> 00:12:57,740

713
00:12:57,740 --> 00:12:59,590
figure out what the actual values

714
00:12:59,590 --> 00:12:59,600
 

715
00:12:59,600 --> 00:13:02,310
actually mean in that in that byte array

716
00:13:02,310 --> 00:13:02,320
 

717
00:13:02,320 --> 00:13:04,240
so here we want to talk about the again

718
00:13:04,240 --> 00:13:04,250
 

719
00:13:04,250 --> 00:13:06,760
how do we actually represent basic types

720
00:13:06,760 --> 00:13:06,770
 

721
00:13:06,770 --> 00:13:09,880
in this byte array so there's sort of

722
00:13:09,880 --> 00:13:09,890
 

723
00:13:09,890 --> 00:13:12,730
four broad categories of types inside of

724
00:13:12,730 --> 00:13:12,740
 

725
00:13:12,740 --> 00:13:14,380
a database system will cover

726
00:13:14,380 --> 00:13:14,390
 

727
00:13:14,390 --> 00:13:16,150
user-defined types or complex types

728
00:13:16,150 --> 00:13:16,160
 

729
00:13:16,160 --> 00:13:17,980
later in the semester but at high level

730
00:13:17,980 --> 00:13:17,990
 

731
00:13:17,990 --> 00:13:18,940
when you think about it there's

732
00:13:18,940 --> 00:13:18,950
 

733
00:13:18,950 --> 00:13:21,230
essentially four things you could be

734
00:13:21,230 --> 00:13:21,240
 

735
00:13:21,240 --> 00:13:24,199
right you can have integer types and the

736
00:13:24,199 --> 00:13:24,209
 

737
00:13:24,209 --> 00:13:26,119
different types even you'd be you can

738
00:13:26,119 --> 00:13:26,129
 

739
00:13:26,129 --> 00:13:28,249
define determine how many bits you want

740
00:13:28,249 --> 00:13:28,259
 

741
00:13:28,259 --> 00:13:29,989
to use to store data all right seeking

742
00:13:29,989 --> 00:13:29,999
 

743
00:13:29,999 --> 00:13:32,989
of integer which is 32 bits 4 bytes big

744
00:13:32,989 --> 00:13:32,999
 

745
00:13:32,999 --> 00:13:36,079
in 64 bits small in 16 and tiny int is

746
00:13:36,079 --> 00:13:36,089
 

747
00:13:36,089 --> 00:13:39,980
is a single single byte or 8 bits right

748
00:13:39,980 --> 00:13:39,990
 

749
00:13:39,990 --> 00:13:42,859
and so for this we're gonna represent

750
00:13:42,859 --> 00:13:42,869
 

751
00:13:42,869 --> 00:13:47,179
this data just using the built in sort

752
00:13:47,179 --> 00:13:47,189
 

753
00:13:47,189 --> 00:13:50,019
of C or C++ representation of the data

754
00:13:50,019 --> 00:13:50,029
 

755
00:13:50,029 --> 00:13:52,699
right if I open up a seat you know make

756
00:13:52,699 --> 00:13:52,709
 

757
00:13:52,709 --> 00:13:54,439
it C program and I say int and declare

758
00:13:54,439 --> 00:13:54,449
 

759
00:13:54,449 --> 00:13:57,079
an integer right the internally the CPU

760
00:13:57,079 --> 00:13:57,089
 

761
00:13:57,089 --> 00:13:59,600
knows how to represent that those bits

762
00:13:59,600 --> 00:13:59,610
 

763
00:13:59,610 --> 00:14:01,280
to mean an integer and we're just gonna

764
00:14:01,280 --> 00:14:01,290
 

765
00:14:01,290 --> 00:14:03,530
leverage the same thing in inside of our

766
00:14:03,530 --> 00:14:03,540
 

767
00:14:03,540 --> 00:14:05,150
database system there's certain nothing

768
00:14:05,150 --> 00:14:05,160

769
00:14:05,160 --> 00:14:08,480
magical there again in C and C++

770
00:14:08,480 --> 00:14:08,490
 

771
00:14:08,490 --> 00:14:10,669
you have uncie you know 32-bit integer

772
00:14:10,669 --> 00:14:10,679
 

773
00:14:10,679 --> 00:14:13,160
64-bit integers all those map to to this

774
00:14:13,160 --> 00:14:13,170
 

775
00:14:13,170 --> 00:14:16,519
the sequel types where things get tricky

776
00:14:16,519 --> 00:14:16,529
 

777
00:14:16,529 --> 00:14:17,480
is when you want to start having

778
00:14:17,480 --> 00:14:17,490
 

779
00:14:17,490 --> 00:14:19,629
decimals or floating-point numbers and

780
00:14:19,629 --> 00:14:19,639
 

781
00:14:19,639 --> 00:14:22,309
there's this trade-off between having

782
00:14:22,309 --> 00:14:22,319

783
00:14:22,319 --> 00:14:24,489
what are called floating-point numbers

784
00:14:24,489 --> 00:14:24,499
 

785
00:14:24,499 --> 00:14:27,139
that are using the built in Hardware

786
00:14:27,139 --> 00:14:27,149
 

787
00:14:27,149 --> 00:14:29,509
primitives and then there's the fixed

788
00:14:29,509 --> 00:14:29,519
 

789
00:14:29,519 --> 00:14:31,160
point decimals where we're going to

790
00:14:31,160 --> 00:14:31,170
 

791
00:14:31,170 --> 00:14:32,629
manage that ourselves inside our

792
00:14:32,629 --> 00:14:32,639
 

793
00:14:32,639 --> 00:14:35,199
database system to ensure that we have

794
00:14:35,199 --> 00:14:35,209
 

795
00:14:35,209 --> 00:14:38,059
you know accurate calculations accurate

796
00:14:38,059 --> 00:14:38,069
 

797
00:14:38,069 --> 00:14:40,519
numbers so as a quick show of hands who

798
00:14:40,519 --> 00:14:40,529
 

799
00:14:40,529 --> 00:14:42,169
here has ever heard of the I Triple E

800
00:14:42,169 --> 00:14:42,179
 

801
00:14:42,179 --> 00:14:45,650
754 standard a few I actually a lot of

802
00:14:45,650 --> 00:14:45,660
 

803
00:14:45,660 --> 00:14:47,660
you awesome yeah all right so the 784

804
00:14:47,660 --> 00:14:47,670
 

805
00:14:47,670 --> 00:14:50,840
standard defines how Hardware should

806
00:14:50,840 --> 00:14:50,850
 

807
00:14:50,850 --> 00:14:53,929
actually represent data or these serves

808
00:14:53,929 --> 00:14:53,939
 

809
00:14:53,939 --> 00:14:55,699
for these floating-point numbers and it

810
00:14:55,699 --> 00:14:55,709
 

811
00:14:55,709 --> 00:14:57,169
tells you what should happen when you

812
00:14:57,169 --> 00:14:57,179

813
00:14:57,179 --> 00:15:00,049
when you manipulate them right and we'll

814
00:15:00,049 --> 00:15:00,059

815
00:15:00,059 --> 00:15:01,910
see in a second if they're if you're

816
00:15:01,910 --> 00:15:01,920
 

817
00:15:01,920 --> 00:15:03,619
having sort of a variable precision

818
00:15:03,619 --> 00:15:03,629

819
00:15:03,629 --> 00:15:04,039
numbers

820
00:15:04,039 --> 00:15:04,049

821
00:15:04,049 --> 00:15:05,509
you're not gonna guarantee accuracy in

822
00:15:05,509 --> 00:15:05,519

823
00:15:05,519 --> 00:15:06,859
your cab calculations but they can be

824
00:15:06,859 --> 00:15:06,869
 

825
00:15:06,869 --> 00:15:08,359
much faster because you can do this in

826
00:15:08,359 --> 00:15:08,369
 

827
00:15:08,369 --> 00:15:11,449
hardware whereas if you want a you want

828
00:15:11,449 --> 00:15:11,459
 

829
00:15:11,459 --> 00:15:13,939
to guarantee accuracy using fixed point

830
00:15:13,939 --> 00:15:13,949
 

831
00:15:13,949 --> 00:15:15,829
decimals we have to manage this

832
00:15:15,829 --> 00:15:15,839

833
00:15:15,839 --> 00:15:17,269
ourselves in our database system and we

834
00:15:17,269 --> 00:15:17,279
 

835
00:15:17,279 --> 00:15:19,669
course we pay a performance penalty to

836
00:15:19,669 --> 00:15:19,679
 

837
00:15:19,679 --> 00:15:23,269
do that then we can have variable length

838
00:15:23,269 --> 00:15:23,279
 

839
00:15:23,279 --> 00:15:26,689
values so varchar' VAR binary and blob

840
00:15:26,689 --> 00:15:26,699
 

841
00:15:26,699 --> 00:15:30,259
right varchars just is you know it's

842
00:15:30,259 --> 00:15:30,269
 

843
00:15:30,269 --> 00:15:32,150
like a string and it can be any

844
00:15:32,150 --> 00:15:32,160
 

845
00:15:32,160 --> 00:15:33,439
arbitrary length you could have a char

846
00:15:33,439 --> 00:15:33,449
 

847
00:15:33,449 --> 00:15:34,610
field

848
00:15:34,610 --> 00:15:34,620

849
00:15:34,620 --> 00:15:36,230
which is just always gonna be the same

850
00:15:36,230 --> 00:15:36,240
 

851
00:15:36,240 --> 00:15:39,800
size with padded with zeros or spaces at

852
00:15:39,800 --> 00:15:39,810
 

853
00:15:39,810 --> 00:15:42,050
the end and a varchar' typically what

854
00:15:42,050 --> 00:15:42,060
 

855
00:15:42,060 --> 00:15:44,000
happens is you you put the header in the

856
00:15:44,000 --> 00:15:44,010
 

857
00:15:44,010 --> 00:15:46,520
header the size of the value and that

858
00:15:46,520 --> 00:15:46,530
 

859
00:15:46,530 --> 00:15:48,920
tells you how how many bits to go into

860
00:15:48,920 --> 00:15:48,930
 

861
00:15:48,930 --> 00:15:50,990
your values complete right and we do

862
00:15:50,990 --> 00:15:51,000
 

863
00:15:51,000 --> 00:15:52,220
that instead of having an Ultraman in

864
00:15:52,220 --> 00:15:52,230
 

865
00:15:52,230 --> 00:15:53,810
there but I can see because we need to

866
00:15:53,810 --> 00:15:53,820
 

867
00:15:53,820 --> 00:15:55,880
know exactly where to jump to from one

868
00:15:55,880 --> 00:15:55,890
 

869
00:15:55,890 --> 00:15:58,970
value to the next and then you can have

870
00:15:58,970 --> 00:15:58,980
 

871
00:15:58,980 --> 00:16:02,140
timestamps and dates and times right

872
00:16:02,140 --> 00:16:02,150
 

873
00:16:02,150 --> 00:16:04,490
very often these are usually represented

874
00:16:04,490 --> 00:16:04,500
 

875
00:16:04,500 --> 00:16:05,990
as just the number of seconds since the

876
00:16:05,990 --> 00:16:06,000
 

877
00:16:06,000 --> 00:16:08,180
UNIX epoch I actually don't know what

878
00:16:08,180 --> 00:16:08,190
 

879
00:16:08,190 --> 00:16:09,650
Windows or sequel server does in Windows

880
00:16:09,650 --> 00:16:09,660
 

881
00:16:09,660 --> 00:16:13,370
for this and we saw I think a few

882
00:16:13,370 --> 00:16:13,380
 

883
00:16:13,380 --> 00:16:15,800
lectures ago how you know the various

884
00:16:15,800 --> 00:16:15,810
 

885
00:16:15,810 --> 00:16:16,970
systems to represent these things in

886
00:16:16,970 --> 00:16:16,980
 

887
00:16:16,980 --> 00:16:17,840
different ways and they have different

888
00:16:17,840 --> 00:16:17,850
 

889
00:16:17,850 --> 00:16:21,020
properties and different accuracy just

890
00:16:21,020 --> 00:16:21,030
 

891
00:16:21,030 --> 00:16:23,000
because everyone does different things

892
00:16:23,000 --> 00:16:23,010
 

893
00:16:23,010 --> 00:16:24,470
for this right the standard says one

894
00:16:24,470 --> 00:16:24,480
 

895
00:16:24,480 --> 00:16:25,850
thing but every one every one slightly

896
00:16:25,850 --> 00:16:25,860
 

897
00:16:25,860 --> 00:16:27,860
deviates so I want to spend more of our

898
00:16:27,860 --> 00:16:27,870
 

899
00:16:27,870 --> 00:16:29,300
time talking about the varible precision

900
00:16:29,300 --> 00:16:29,310
 

901
00:16:29,310 --> 00:16:30,440
numbers because again this is a good

902
00:16:30,440 --> 00:16:30,450
 

903
00:16:30,450 --> 00:16:32,840
example where you know we could this let

904
00:16:32,840 --> 00:16:32,850
 

905
00:16:32,850 --> 00:16:34,670
the OS or certainly hardware do this

906
00:16:34,670 --> 00:16:34,680
 

907
00:16:34,680 --> 00:16:37,010
Vivi's manage these data types for us

908
00:16:37,010 --> 00:16:37,020
 

909
00:16:37,020 --> 00:16:38,930
but if we do it ourselves we can get

910
00:16:38,930 --> 00:16:38,940

911
00:16:38,940 --> 00:16:40,390
better accuracy but we're gonna pay a

912
00:16:40,390 --> 00:16:40,400

913
00:16:40,400 --> 00:16:45,050
performance penalty for it so for baro

914
00:16:45,050 --> 00:16:45,060
 

915
00:16:45,060 --> 00:16:46,460
precision numbers as I said these are

916
00:16:46,460 --> 00:16:46,470
 

917
00:16:46,470 --> 00:16:49,340
represented by the 754 standard and

918
00:16:49,340 --> 00:16:49,350
 

919
00:16:49,350 --> 00:16:51,470
these would be float floats reals or

920
00:16:51,470 --> 00:16:51,480
 

921
00:16:51,480 --> 00:16:53,900
doubles sometimes real and double or

922
00:16:53,900 --> 00:16:53,910
 

923
00:16:53,910 --> 00:16:55,250
just map to the same thing they're

924
00:16:55,250 --> 00:16:55,260
 

925
00:16:55,260 --> 00:16:57,320
synonyms float would be a 32-bit

926
00:16:57,320 --> 00:16:57,330
 

927
00:16:57,330 --> 00:16:59,120
floating-point number and real and

928
00:16:59,120 --> 00:16:59,130

929
00:16:59,130 --> 00:17:02,450
double is a sickie little bit reown

930
00:17:02,450 --> 00:17:02,460
 

931
00:17:02,460 --> 00:17:05,420
double right the again the problem with

932
00:17:05,420 --> 00:17:05,430
 

933
00:17:05,430 --> 00:17:07,700
these native types is that they can't

934
00:17:07,700 --> 00:17:07,710
 

935
00:17:07,710 --> 00:17:10,820
actually accurately represent decimals

936
00:17:10,820 --> 00:17:10,830

937
00:17:10,830 --> 00:17:13,970
or floating-point numbers right because

938
00:17:13,970 --> 00:17:13,980

939
00:17:13,980 --> 00:17:16,040
it's just the the hardware can actually

940
00:17:16,040 --> 00:17:16,050
 

941
00:17:16,050 --> 00:17:17,390
can't handle this

942
00:17:17,390 --> 00:17:17,400

943
00:17:17,400 --> 00:17:19,550
so to give it a really simple example

944
00:17:19,550 --> 00:17:19,560
 

945
00:17:19,560 --> 00:17:21,380
say we have a little C program like this

946
00:17:21,380 --> 00:17:21,390
 

947
00:17:21,390 --> 00:17:25,220
and we want to take two 32-bit floats x

948
00:17:25,220 --> 00:17:25,230
 

949
00:17:25,230 --> 00:17:27,890
and y make one B zero point one and one

950
00:17:27,890 --> 00:17:27,900
 

951
00:17:27,900 --> 00:17:30,530
and one B zero point two if I just you

952
00:17:30,530 --> 00:17:30,540
 

953
00:17:30,540 --> 00:17:31,940
know add these two numbers together and

954
00:17:31,940 --> 00:17:31,950
 

955
00:17:31,950 --> 00:17:35,600
print it out I get widely different

956
00:17:35,600 --> 00:17:35,610
 

957
00:17:35,610 --> 00:17:37,850
numbers versus just outputting zero

958
00:17:37,850 --> 00:17:37,860
 

959
00:17:37,860 --> 00:17:39,590
point three right we as humans know that

960
00:17:39,590 --> 00:17:39,600
 

961
00:17:39,600 --> 00:17:41,150
one zero point one plus zero point two

962
00:17:41,150 --> 00:17:41,160

963
00:17:41,160 --> 00:17:43,640
should equal zero point three but in

964
00:17:43,640 --> 00:17:43,650
 

965
00:17:43,650 --> 00:17:46,550
both cases either just printing 0,3 or

966
00:17:46,550 --> 00:17:46,560

967
00:17:46,560 --> 00:17:47,960
adding those two numbers again

968
00:17:47,960 --> 00:17:47,970

969
00:17:47,970 --> 00:17:50,870
you get wildly different numbers this is

970
00:17:50,870 --> 00:17:50,880
 

971
00:17:50,880 --> 00:17:52,629
because the harbor can't actually

972
00:17:52,629 --> 00:17:52,639
 

973
00:17:52,639 --> 00:17:54,919
accurately represent these

974
00:17:54,919 --> 00:17:54,929
 

975
00:17:54,929 --> 00:17:57,259
floating-point numbers so this would be

976
00:17:57,259 --> 00:17:57,269
 

977
00:17:57,269 --> 00:17:59,659
really fast to do but if you have your

978
00:17:59,659 --> 00:17:59,669
 

979
00:17:59,669 --> 00:18:01,430
if your database is maintaining things

980
00:18:01,430 --> 00:18:01,440
 

981
00:18:01,440 --> 00:18:04,519
like money or measurements from

982
00:18:04,519 --> 00:18:04,529
 

983
00:18:04,529 --> 00:18:06,799
scientific instruments right this would

984
00:18:06,799 --> 00:18:06,809
 

985
00:18:06,809 --> 00:18:07,970
be problematic because now you can have

986
00:18:07,970 --> 00:18:07,980
 

987
00:18:07,980 --> 00:18:09,919
weird rounding errors which would be

988
00:18:09,919 --> 00:18:09,929

989
00:18:09,929 --> 00:18:13,820
inaccurate so the way to solve this is

990
00:18:13,820 --> 00:18:13,830
 

991
00:18:13,830 --> 00:18:15,549
to use fixed point precision numbers

992
00:18:15,549 --> 00:18:15,559
 

993
00:18:15,559 --> 00:18:18,889
alright so these are typically you have

994
00:18:18,889 --> 00:18:18,899
 

995
00:18:18,899 --> 00:18:22,190
a called numeric or decimal and so the

996
00:18:22,190 --> 00:18:22,200
 

997
00:18:22,200 --> 00:18:23,509
idea here is that we're going to store

998
00:18:23,509 --> 00:18:23,519
 

999
00:18:23,519 --> 00:18:28,070
some extra data in for the type in line

1000
00:18:28,070 --> 00:18:28,080
 

1001
00:18:28,080 --> 00:18:30,680
in the tuple that's going to tell us all

1002
00:18:30,680 --> 00:18:30,690
 

1003
00:18:30,690 --> 00:18:32,570
the things we need to know to actually

1004
00:18:32,570 --> 00:18:32,580
 

1005
00:18:32,580 --> 00:18:35,509
represent one of these decimals and in

1006
00:18:35,509 --> 00:18:35,519
 

1007
00:18:35,519 --> 00:18:37,129
some cases some systems like Oracle as

1008
00:18:37,129 --> 00:18:37,139
 

1009
00:18:37,139 --> 00:18:39,740
far as I know you can declare that you

1010
00:18:39,740 --> 00:18:39,750
 

1011
00:18:39,750 --> 00:18:42,680
want a float or even an integer but it's

1012
00:18:42,680 --> 00:18:42,690
 

1013
00:18:42,690 --> 00:18:43,730
always going to end up getting mapped

1014
00:18:43,730 --> 00:18:43,740
 

1015
00:18:43,740 --> 00:18:46,330
back to one of these sort of managed

1016
00:18:46,330 --> 00:18:46,340
 

1017
00:18:46,340 --> 00:18:49,730
values because they want to guarantee

1018
00:18:49,730 --> 00:18:49,740
 

1019
00:18:49,740 --> 00:18:51,230
that your accuracy in your calculations

1020
00:18:51,230 --> 00:18:51,240
 

1021
00:18:51,240 --> 00:18:52,909
again you pay performance penalty but

1022
00:18:52,909 --> 00:18:52,919
 

1023
00:18:52,919 --> 00:18:56,060
for a lot of cases this is okay and so

1024
00:18:56,060 --> 00:18:56,070
 

1025
00:18:56,070 --> 00:18:57,320
we'll see in a second how we actually

1026
00:18:57,320 --> 00:18:57,330
 

1027
00:18:57,330 --> 00:19:00,049
can represent this but at a high level

1028
00:19:00,049 --> 00:19:00,059

1029
00:19:00,059 --> 00:19:01,850
the way to think about it is you're

1030
00:19:01,850 --> 00:19:01,860
 

1031
00:19:01,860 --> 00:19:04,190
basically gonna store the the actual

1032
00:19:04,190 --> 00:19:04,200
 

1033
00:19:04,200 --> 00:19:07,279
number almost like a string and then

1034
00:19:07,279 --> 00:19:07,289

1035
00:19:07,289 --> 00:19:08,960
you're have some extra metadata but you

1036
00:19:08,960 --> 00:19:08,970
 

1037
00:19:08,970 --> 00:19:10,759
store in line with the tuple that'll

1038
00:19:10,759 --> 00:19:10,769
 

1039
00:19:10,769 --> 00:19:12,409
tell you you know where the decimal

1040
00:19:12,409 --> 00:19:12,419

1041
00:19:12,419 --> 00:19:15,049
point should be you know what is the

1042
00:19:15,049 --> 00:19:15,059
 

1043
00:19:15,059 --> 00:19:17,299
scope and things like that all right so

1044
00:19:17,299 --> 00:19:17,309
 

1045
00:19:17,309 --> 00:19:20,360
I'm gonna do a quick quick example in

1046
00:19:20,360 --> 00:19:20,370
 

1047
00:19:20,370 --> 00:19:23,409
Postgres give you show you sort of how

1048
00:19:23,409 --> 00:19:23,419
 

1049
00:19:23,419 --> 00:19:25,940
how expensive what the performance

1050
00:19:25,940 --> 00:19:25,950
 

1051
00:19:25,950 --> 00:19:27,110
differences between these different two

1052
00:19:27,110 --> 00:19:27,120
 

1053
00:19:27,120 --> 00:19:31,850
different types alright so let me do

1054
00:19:31,850 --> 00:19:31,860
 

1055
00:19:31,860 --> 00:19:39,010
this

1056
00:19:39,010 --> 00:19:39,020


1057
00:19:39,020 --> 00:19:43,040
remove that my secret to the bottom all

1058
00:19:43,040 --> 00:19:43,050
 

1059
00:19:43,050 --> 00:19:46,220
right so what I'm gonna do is well this

1060
00:19:46,220 --> 00:19:46,230
 

1061
00:19:46,230 --> 00:19:47,480
is post rest ten so I'm gonna turn off

1062
00:19:47,480 --> 00:19:47,490
 

1063
00:19:47,490 --> 00:19:50,090
they have a new parallel query execution

1064
00:19:50,090 --> 00:19:50,100
 

1065
00:19:50,100 --> 00:19:52,490
engine I'm turning that off just to see

1066
00:19:52,490 --> 00:19:52,500
 

1067
00:19:52,500 --> 00:19:54,590
that it'll make the performance

1068
00:19:54,590 --> 00:19:54,600
 

1069
00:19:54,600 --> 00:19:57,170
difference much greater so I'm gonna

1070
00:19:57,170 --> 00:19:57,180
 

1071
00:19:57,180 --> 00:20:04,670
create two tables one of real values so

1072
00:20:04,670 --> 00:20:04,680
 

1073
00:20:04,680 --> 00:20:06,640
that the the floating-point numbers

1074
00:20:06,640 --> 00:20:06,650
 

1075
00:20:06,650 --> 00:20:10,250
right and one of decimals right the

1076
00:20:10,250 --> 00:20:10,260
 

1077
00:20:10,260 --> 00:20:12,830
built in this sort of a custom Postgres

1078
00:20:12,830 --> 00:20:12,840
 

1079
00:20:12,840 --> 00:20:14,480
datatype that's doing fixed point

1080
00:20:14,480 --> 00:20:14,490
 

1081
00:20:14,490 --> 00:20:16,549
precision numbers and then what I've

1082
00:20:16,549 --> 00:20:16,559
 

1083
00:20:16,559 --> 00:20:18,260
done is I've ran a simple Python script

1084
00:20:18,260 --> 00:20:18,270
 

1085
00:20:18,270 --> 00:20:23,570
that generated a a simple CSV that has

1086
00:20:23,570 --> 00:20:23,580
 

1087
00:20:23,580 --> 00:20:24,970
ten million

1088
00:20:24,970 --> 00:20:24,980
 

1089
00:20:24,980 --> 00:20:28,010
numbers two columns with ten ten million

1090
00:20:28,010 --> 00:20:28,020
 

1091
00:20:28,020 --> 00:20:31,460
ten million rows of two random decimal

1092
00:20:31,460 --> 00:20:31,470
 

1093
00:20:31,470 --> 00:20:34,549
values and then I can load this into my

1094
00:20:34,549 --> 00:20:34,559
 

1095
00:20:34,559 --> 00:20:38,810
two tables in the CSV file by using the

1096
00:20:38,810 --> 00:20:38,820
 

1097
00:20:38,820 --> 00:20:40,430
copy command alright because a copy

1098
00:20:40,430 --> 00:20:40,440
 

1099
00:20:40,440 --> 00:20:42,320
basically is a command you can tell the

1100
00:20:42,320 --> 00:20:42,330
 

1101
00:20:42,330 --> 00:20:44,690
Davis system hey go local on your local

1102
00:20:44,690 --> 00:20:44,700
 

1103
00:20:44,700 --> 00:20:47,570
file system get this file and it's a CSV

1104
00:20:47,570 --> 00:20:47,580
 

1105
00:20:47,580 --> 00:20:49,160
file or whatever it's it's whatever file

1106
00:20:49,160 --> 00:20:49,170
 

1107
00:20:49,170 --> 00:20:51,230
and there's a departs parse it and load

1108
00:20:51,230 --> 00:20:51,240
 

1109
00:20:51,240 --> 00:20:55,220
it into the in the table right so now if

1110
00:20:55,220 --> 00:20:55,230
 

1111
00:20:55,230 --> 00:20:59,690
I do select star from test decimals just

1112
00:20:59,690 --> 00:20:59,700

1113
00:20:59,700 --> 00:21:01,640
to show you what it looks like right

1114
00:21:01,640 --> 00:21:01,650
 

1115
00:21:01,650 --> 00:21:04,580
baby two numbers like this right again

1116
00:21:04,580 --> 00:21:04,590
 

1117
00:21:04,590 --> 00:21:06,290
we have one table starting them as

1118
00:21:06,290 --> 00:21:06,300
 

1119
00:21:06,300 --> 00:21:08,120
decimal it's a fixed point precision one

1120
00:21:08,120 --> 00:21:08,130
 

1121
00:21:08,130 --> 00:21:10,190
table storing them as a floating point

1122
00:21:10,190 --> 00:21:10,200
 

1123
00:21:10,200 --> 00:21:12,710
position so now what I'm gonna do is I'm

1124
00:21:12,710 --> 00:21:12,720
 

1125
00:21:12,720 --> 00:21:17,570
gonna add together every single every

1126
00:21:17,570 --> 00:21:17,580
 

1127
00:21:17,580 --> 00:21:19,549
single for every single row I'm going to

1128
00:21:19,549 --> 00:21:19,559
 

1129
00:21:19,559 --> 00:21:21,890
add together the the first column with

1130
00:21:21,890 --> 00:21:21,900
 

1131
00:21:21,900 --> 00:21:22,970
the second column and computer

1132
00:21:22,970 --> 00:21:22,980
 

1133
00:21:22,980 --> 00:21:26,510
aggregation computer some for that so

1134
00:21:26,510 --> 00:21:26,520
 

1135
00:21:26,520 --> 00:21:27,980
I'm putting two keywords in front of

1136
00:21:27,980 --> 00:21:27,990
 

1137
00:21:27,990 --> 00:21:28,910
this query if you've never seen this

1138
00:21:28,910 --> 00:21:28,920
 

1139
00:21:28,920 --> 00:21:29,410
before

1140
00:21:29,410 --> 00:21:29,420
 

1141
00:21:29,420 --> 00:21:32,690
explain is a command that tells the

1142
00:21:32,690 --> 00:21:32,700
 

1143
00:21:32,700 --> 00:21:34,850
database system to return back the query

1144
00:21:34,850 --> 00:21:34,860
 

1145
00:21:34,860 --> 00:21:37,340
plan that the optimized are generated

1146
00:21:37,340 --> 00:21:37,350

1147
00:21:37,350 --> 00:21:38,990
and we'll discuss what query plans look

1148
00:21:38,990 --> 00:21:39,000
 

1149
00:21:39,000 --> 00:21:41,210
like later in the semester but you

1150
00:21:41,210 --> 00:21:41,220
 

1151
00:21:41,220 --> 00:21:42,160
essentially get something like this

1152
00:21:42,160 --> 00:21:42,170
 

1153
00:21:42,170 --> 00:21:44,780
right it's a tree that says do a

1154
00:21:44,780 --> 00:21:44,790
 

1155
00:21:44,790 --> 00:21:46,930
symmetric an on the table and then

1156
00:21:46,930 --> 00:21:46,940
 

1157
00:21:46,940 --> 00:21:48,730
computer and aggregation and you can see

1158
00:21:48,730 --> 00:21:48,740
 

1159
00:21:48,740 --> 00:21:50,530
what will cover this later on but it

1160
00:21:50,530 --> 00:21:50,540
 

1161
00:21:50,540 --> 00:21:52,450
shows you things like here's the number

1162
00:21:52,450 --> 00:21:52,460
 

1163
00:21:52,460 --> 00:21:53,620
of rows I think I'm gonna read and

1164
00:21:53,620 --> 00:21:53,630
 

1165
00:21:53,630 --> 00:21:56,340
here's how long it's gonna take me right

1166
00:21:56,340 --> 00:21:56,350
 

1167
00:21:56,350 --> 00:21:59,620
but if I add if I add analyze in front

1168
00:21:59,620 --> 00:21:59,630

1169
00:21:59,630 --> 00:21:59,950
of it

1170
00:21:59,950 --> 00:21:59,960

1171
00:21:59,960 --> 00:22:01,960
this tells to be hit to actually run the

1172
00:22:01,960 --> 00:22:01,970
 

1173
00:22:01,970 --> 00:22:04,570
query explained just does just spits out

1174
00:22:04,570 --> 00:22:04,580
 

1175
00:22:04,580 --> 00:22:05,740
the query plant doesn't actually run the

1176
00:22:05,740 --> 00:22:05,750
 

1177
00:22:05,750 --> 00:22:07,780
query he had analyzed it actually runs

1178
00:22:07,780 --> 00:22:07,790
 

1179
00:22:07,790 --> 00:22:10,180
the query and show you shows you the

1180
00:22:10,180 --> 00:22:10,190
 

1181
00:22:10,190 --> 00:22:13,840
query plan right so for this I run out

1182
00:22:13,840 --> 00:22:13,850
 

1183
00:22:13,850 --> 00:22:16,120
like that get a run for a bit and then

1184
00:22:16,120 --> 00:22:16,130
 

1185
00:22:16,130 --> 00:22:18,700
tells me what execution time is one

1186
00:22:18,700 --> 00:22:18,710
 

1187
00:22:18,710 --> 00:22:21,280
point four seconds right so it planned

1188
00:22:21,280 --> 00:22:21,290
 

1189
00:22:21,290 --> 00:22:23,980
for for a fraction of a millisecond and

1190
00:22:23,980 --> 00:22:23,990
 

1191
00:22:23,990 --> 00:22:29,050
then it ran for 1,400 milliseconds so

1192
00:22:29,050 --> 00:22:29,060
 

1193
00:22:29,060 --> 00:22:30,940
that's the one with real so that's using

1194
00:22:30,940 --> 00:22:30,950
 

1195
00:22:30,950 --> 00:22:32,890
the floating-point precision so now

1196
00:22:32,890 --> 00:22:32,900
 

1197
00:22:32,900 --> 00:22:34,600
let's use the fixed point precision same

1198
00:22:34,600 --> 00:22:34,610
 

1199
00:22:34,610 --> 00:22:37,060
query same data different table

1200
00:22:37,060 --> 00:22:37,070
 

1201
00:22:37,070 --> 00:22:40,000
representation and now it took 2800

1202
00:22:40,000 --> 00:22:40,010
 

1203
00:22:40,010 --> 00:22:44,980
right took twice as long right and just

1204
00:22:44,980 --> 00:22:44,990
 

1205
00:22:44,990 --> 00:22:46,210
to show you that it doesn't matter if

1206
00:22:46,210 --> 00:22:46,220
 

1207
00:22:46,220 --> 00:22:47,820
it's cash I can run the same query again

1208
00:22:47,820 --> 00:22:47,830
 

1209
00:22:47,830 --> 00:22:58,780
shouldn't be turn on timing right I got

1210
00:22:58,780 --> 00:22:58,790
 

1211
00:22:58,790 --> 00:22:59,980
a little bit faster but if I keep

1212
00:22:59,980 --> 00:22:59,990
 

1213
00:22:59,990 --> 00:23:01,390
running it again over and over again it

1214
00:23:01,390 --> 00:23:01,400
 

1215
00:23:01,400 --> 00:23:03,580
should roughly be the same right because

1216
00:23:03,580 --> 00:23:03,590
 

1217
00:23:03,590 --> 00:23:05,950
now everything's in memory and it's just

1218
00:23:05,950 --> 00:23:05,960
 

1219
00:23:05,960 --> 00:23:07,480
reading as fast as it can and doing

1220
00:23:07,480 --> 00:23:07,490
 

1221
00:23:07,490 --> 00:23:09,610
these calculations same thing for the

1222
00:23:09,610 --> 00:23:09,620
 

1223
00:23:09,620 --> 00:23:13,020
reals

1224
00:23:13,020 --> 00:23:13,030


1225
00:23:13,030 --> 00:23:15,400
right and so what all right so what now

1226
00:23:15,400 --> 00:23:15,410
 

1227
00:23:15,410 --> 00:23:19,060
the next thing to point out is we notice

1228
00:23:19,060 --> 00:23:19,070
 

1229
00:23:19,070 --> 00:23:21,130
at the when we've run out of decimals we

1230
00:23:21,130 --> 00:23:21,140
 

1231
00:23:21,140 --> 00:23:23,410
get something starts two nine nine nine

1232
00:23:23,410 --> 00:23:23,420
 

1233
00:23:23,420 --> 00:23:26,620
eight but then we run it with the reals

1234
00:23:26,620 --> 00:23:26,630
 

1235
00:23:26,630 --> 00:23:29,290
we get one point zero 1 4 and then

1236
00:23:29,290 --> 00:23:29,300
 

1237
00:23:29,300 --> 00:23:31,570
scientific notation so we can actually

1238
00:23:31,570 --> 00:23:31,580
 

1239
00:23:31,580 --> 00:23:33,790
see what that value is either so we can

1240
00:23:33,790 --> 00:23:33,800
 

1241
00:23:33,800 --> 00:23:42,030
cast it as a decimal

1242
00:23:42,030 --> 00:23:42,040


1243
00:23:42,040 --> 00:23:46,920
right so with with the decimals at the

1244
00:23:46,920 --> 00:23:46,930
 

1245
00:23:46,930 --> 00:23:49,770
top we got nine and eight with reals we

1246
00:23:49,770 --> 00:23:49,780
 

1247
00:23:49,780 --> 00:23:52,710
got 101 or one zero zero one right so

1248
00:23:52,710 --> 00:23:52,720
 

1249
00:23:52,720 --> 00:23:54,840
same data technically the same

1250
00:23:54,840 --> 00:23:54,850
 

1251
00:23:54,850 --> 00:23:56,340
calculation two different data type

1252
00:23:56,340 --> 00:23:56,350
 

1253
00:23:56,350 --> 00:23:57,900
representations we're getting two

1254
00:23:57,900 --> 00:23:57,910
 

1255
00:23:57,910 --> 00:24:01,260
different results so let's see let's try

1256
00:24:01,260 --> 00:24:01,270
 

1257
00:24:01,270 --> 00:24:02,490
to figure out what the actual correct

1258
00:24:02,490 --> 00:24:02,500
 

1259
00:24:02,500 --> 00:24:05,760
value is so we can run a really simple

1260
00:24:05,760 --> 00:24:05,770
 

1261
00:24:05,770 --> 00:24:12,770
python script so i'm gonna import the

1262
00:24:12,770 --> 00:24:12,780


1263
00:24:12,780 --> 00:24:15,210
load it loading the same data set that I

1264
00:24:15,210 --> 00:24:15,220
 

1265
00:24:15,220 --> 00:24:18,540
load it into Postgres and and just you

1266
00:24:18,540 --> 00:24:18,550
 

1267
00:24:18,550 --> 00:24:20,280
know add the two numbers together

1268
00:24:20,280 --> 00:24:20,290
 

1269
00:24:20,290 --> 00:24:22,560
casting the values as float and then we

1270
00:24:22,560 --> 00:24:22,570
 

1271
00:24:22,570 --> 00:24:30,080
can print out what the total is 9 9 9 8

1272
00:24:30,080 --> 00:24:30,090
 

1273
00:24:30,090 --> 00:24:32,280
so in this case here python is doing

1274
00:24:32,280 --> 00:24:32,290
 

1275
00:24:32,290 --> 00:24:33,120
something to make sure that it has

1276
00:24:33,120 --> 00:24:33,130
 

1277
00:24:33,130 --> 00:24:34,980
accurate calculations just like Postgres

1278
00:24:34,980 --> 00:24:34,990
 

1279
00:24:34,990 --> 00:24:37,530
is right so that would tell you the

1280
00:24:37,530 --> 00:24:37,540

1281
00:24:37,540 --> 00:24:40,650
correct value is what what we're getting

1282
00:24:40,650 --> 00:24:40,660
 

1283
00:24:40,660 --> 00:24:43,110
at the top here what you can you you

1284
00:24:43,110 --> 00:24:43,120
 

1285
00:24:43,120 --> 00:24:45,890
can't see me high like that right so

1286
00:24:45,890 --> 00:24:45,900
 

1287
00:24:45,900 --> 00:24:49,440
again we we use the built in primitive

1288
00:24:49,440 --> 00:24:49,450
 

1289
00:24:49,450 --> 00:24:52,530
types of the hardware and and and c++

1290
00:24:52,530 --> 00:24:52,540
 

1291
00:24:52,540 --> 00:24:53,940
then we're getting much better

1292
00:24:53,940 --> 00:24:53,950
 

1293
00:24:53,950 --> 00:24:55,610
performance but we're gonna have

1294
00:24:55,610 --> 00:24:55,620
 

1295
00:24:55,620 --> 00:24:57,540
inaccurate calculations because of

1296
00:24:57,540 --> 00:24:57,550
 

1297
00:24:57,550 --> 00:25:00,090
rounding errors if we want if we care

1298
00:25:00,090 --> 00:25:00,100
 

1299
00:25:00,100 --> 00:25:01,440
about these things then we then we want

1300
00:25:01,440 --> 00:25:01,450
 

1301
00:25:01,450 --> 00:25:03,000
to use fixed point precision or fix

1302
00:25:03,000 --> 00:25:03,010
 

1303
00:25:03,010 --> 00:25:04,620
point decimals but are going to be much

1304
00:25:04,620 --> 00:25:04,630
 

1305
00:25:04,630 --> 00:25:10,770
slower okay okay so let's understand

1306
00:25:10,770 --> 00:25:10,780
 

1307
00:25:10,780 --> 00:25:12,210
what's actually going on how this

1308
00:25:12,210 --> 00:25:12,220
 

1309
00:25:12,220 --> 00:25:14,730
process is actually implementing this so

1310
00:25:14,730 --> 00:25:14,740
 

1311
00:25:14,740 --> 00:25:16,800
this is actually from the real Postgres

1312
00:25:16,800 --> 00:25:16,810
 

1313
00:25:16,810 --> 00:25:18,870
code this is the internal type

1314
00:25:18,870 --> 00:25:18,880
 

1315
00:25:18,880 --> 00:25:20,880
representation that they define to

1316
00:25:20,880 --> 00:25:20,890

1317
00:25:20,890 --> 00:25:25,530
represent a decimal or numeric right so

1318
00:25:25,530 --> 00:25:25,540
 

1319
00:25:25,540 --> 00:25:27,060
you can see what I was saying before

1320
00:25:27,060 --> 00:25:27,070
 

1321
00:25:27,070 --> 00:25:31,790
where at the bottom we're gonna have a

1322
00:25:31,790 --> 00:25:31,800
 

1323
00:25:31,800 --> 00:25:38,250
string sorry the bottom here in numeric

1324
00:25:38,250 --> 00:25:38,260

1325
00:25:38,260 --> 00:25:40,410
digit this is essentially the most like

1326
00:25:40,410 --> 00:25:40,420
 

1327
00:25:40,420 --> 00:25:44,460
at the varchar' of the of the actual

1328
00:25:44,460 --> 00:25:44,470
 

1329
00:25:44,470 --> 00:25:47,370
string representation of the the of the

1330
00:25:47,370 --> 00:25:47,380
 

1331
00:25:47,380 --> 00:25:49,530
value and then there's all this extra

1332
00:25:49,530 --> 00:25:49,540
 

1333
00:25:49,540 --> 00:25:52,500
stuff we're storing to say what the

1334
00:25:52,500 --> 00:25:52,510
 

1335
00:25:52,510 --> 00:25:54,000
weight is the scale factor whether it's

1336
00:25:54,000 --> 00:25:54,010
 

1337
00:25:54,010 --> 00:25:55,730
positive negative or not a number

1338
00:25:55,730 --> 00:25:55,740
 

1339
00:25:55,740 --> 00:25:58,700
right the where the the you know where

1340
00:25:58,700 --> 00:25:58,710
 

1341
00:25:58,710 --> 00:26:01,220
the decimal point is things like that so

1342
00:26:01,220 --> 00:26:01,230
 

1343
00:26:01,230 --> 00:26:03,530
what what we could have stored as a

1344
00:26:03,530 --> 00:26:03,540
 

1345
00:26:03,540 --> 00:26:05,780
32-bit integer is now storing this as

1346
00:26:05,780 --> 00:26:05,790
 

1347
00:26:05,790 --> 00:26:11,030
what 4 8 16 20 and then whatever the

1348
00:26:11,030 --> 00:26:11,040
 

1349
00:26:11,040 --> 00:26:14,090
arbitrary saying is so went from 4 bytes

1350
00:26:14,090 --> 00:26:14,100
 

1351
00:26:14,100 --> 00:26:18,590
to you know possibly 30 or more just

1352
00:26:18,590 --> 00:26:18,600
 

1353
00:26:18,600 --> 00:26:21,020
store the same value and then when we

1354
00:26:21,020 --> 00:26:21,030

1355
00:26:21,030 --> 00:26:22,580
actually look at the code now see how

1356
00:26:22,580 --> 00:26:22,590
 

1357
00:26:22,590 --> 00:26:23,870
you they actually add two of these

1358
00:26:23,870 --> 00:26:23,880
 

1359
00:26:23,880 --> 00:26:26,360
decimals or numerix together right it's

1360
00:26:26,360 --> 00:26:26,370
 

1361
00:26:26,370 --> 00:26:28,549
way more complicated then then just

1362
00:26:28,549 --> 00:26:28,559
 

1363
00:26:28,559 --> 00:26:29,660
taking two numbers and adding together

1364
00:26:29,660 --> 00:26:29,670
 

1365
00:26:29,670 --> 00:26:31,840
which is a single instruction on the CPU

1366
00:26:31,840 --> 00:26:31,850
 

1367
00:26:31,850 --> 00:26:34,790
right you again this is from the real

1368
00:26:34,790 --> 00:26:34,800
 

1369
00:26:34,800 --> 00:26:36,830
Postgres code I think it's nine six or

1370
00:26:36,830 --> 00:26:36,840
 

1371
00:26:36,840 --> 00:26:39,110
nine five right this is just the add

1372
00:26:39,110 --> 00:26:39,120
 

1373
00:26:39,120 --> 00:26:41,270
function right just to add to these

1374
00:26:41,270 --> 00:26:41,280
 

1375
00:26:41,280 --> 00:26:42,830
numbers together that there's all these

1376
00:26:42,830 --> 00:26:42,840
 

1377
00:26:42,840 --> 00:26:43,970
cases you're checking to see whether

1378
00:26:43,970 --> 00:26:43,980
 

1379
00:26:43,980 --> 00:26:46,150
it's negative or not a number right and

1380
00:26:46,150 --> 00:26:46,160
 

1381
00:26:46,160 --> 00:26:48,500
then at the very end you end up just

1382
00:26:48,500 --> 00:26:48,510
 

1383
00:26:48,510 --> 00:26:50,210
actually being just you know adding to

1384
00:26:50,210 --> 00:26:50,220
 

1385
00:26:50,220 --> 00:26:53,510
these two numbers together so again in

1386
00:26:53,510 --> 00:26:53,520
 

1387
00:26:53,520 --> 00:26:55,460
my example for this is all the code

1388
00:26:55,460 --> 00:26:55,470
 

1389
00:26:55,470 --> 00:26:57,950
we're running when I was using decimals

1390
00:26:57,950 --> 00:26:57,960

1391
00:26:57,960 --> 00:27:01,750
just to add the two numbers together and

1392
00:27:01,750 --> 00:27:01,760


1393
00:27:01,760 --> 00:27:04,640
then in the obviously the same kind of

1394
00:27:04,640 --> 00:27:04,650
 

1395
00:27:04,650 --> 00:27:05,980
calculations for you know for

1396
00:27:05,980 --> 00:27:05,990

1397
00:27:05,990 --> 00:27:08,600
multiplication subtraction and other

1398
00:27:08,600 --> 00:27:08,610
 

1399
00:27:08,610 --> 00:27:12,440
aggregations as well okay again so the

1400
00:27:12,440 --> 00:27:12,450
 

1401
00:27:12,450 --> 00:27:14,540
main takeaway is you want to use fixed

1402
00:27:14,540 --> 00:27:14,550
 

1403
00:27:14,550 --> 00:27:15,890
point precision when you care about

1404
00:27:15,890 --> 00:27:15,900
 

1405
00:27:15,900 --> 00:27:18,710
accuracy anything with financial data

1406
00:27:18,710 --> 00:27:18,720
 

1407
00:27:18,720 --> 00:27:21,919
anything with scientific data if you

1408
00:27:21,919 --> 00:27:21,929
 

1409
00:27:21,929 --> 00:27:24,260
don't care about these things then using

1410
00:27:24,260 --> 00:27:24,270
 

1411
00:27:24,270 --> 00:27:27,169
the floating-point numbers or is the way

1412
00:27:27,169 --> 00:27:27,179
 

1413
00:27:27,179 --> 00:27:28,910
to go and you sort of start to see this

1414
00:27:28,910 --> 00:27:28,920
 

1415
00:27:28,920 --> 00:27:32,540
the same kind of ideas in in in machine

1416
00:27:32,540 --> 00:27:32,550
 

1417
00:27:32,550 --> 00:27:34,370
learning right instead of using 32-bit

1418
00:27:34,370 --> 00:27:34,380
 

1419
00:27:34,380 --> 00:27:36,140
floats for all your weights and your

1420
00:27:36,140 --> 00:27:36,150
 

1421
00:27:36,150 --> 00:27:37,310
neural networks maybe you drop down to

1422
00:27:37,310 --> 00:27:37,320
 

1423
00:27:37,320 --> 00:27:40,220
sixteen sixteen bits and that's that's

1424
00:27:40,220 --> 00:27:40,230
 

1425
00:27:40,230 --> 00:27:42,260
you still give good results cuz accuracy

1426
00:27:42,260 --> 00:27:42,270
 

1427
00:27:42,270 --> 00:27:43,220
doesn't actually matter in that

1428
00:27:43,220 --> 00:27:43,230
 

1429
00:27:43,230 --> 00:27:46,790
environment that much alright so now we

1430
00:27:46,790 --> 00:27:46,800
 

1431
00:27:46,800 --> 00:27:47,900
want to talk about how we actually store

1432
00:27:47,900 --> 00:27:47,910
 

1433
00:27:47,910 --> 00:27:50,690
so we know how to store integers we know

1434
00:27:50,690 --> 00:27:50,700
 

1435
00:27:50,700 --> 00:27:52,490
how to store a dates we're usually in

1436
00:27:52,490 --> 00:27:52,500
 

1437
00:27:52,500 --> 00:27:56,180
just integers and decimals and and

1438
00:27:56,180 --> 00:27:56,190
 

1439
00:27:56,190 --> 00:27:57,340
varchars

1440
00:27:57,340 --> 00:27:57,350

1441
00:27:57,350 --> 00:27:59,960
for this we're all assuming that we all

1442
00:27:59,960 --> 00:27:59,970
 

1443
00:27:59,970 --> 00:28:01,730
of these things can just fit in our in

1444
00:28:01,730 --> 00:28:01,740
 

1445
00:28:01,740 --> 00:28:03,200
our slot at pages where our tuple lives

1446
00:28:03,200 --> 00:28:03,210

1447
00:28:03,210 --> 00:28:06,049
right typically most database systems

1448
00:28:06,049 --> 00:28:06,059
 

1449
00:28:06,059 --> 00:28:09,440
don't let you have a the size of a tuple

1450
00:28:09,440 --> 00:28:09,450
 

1451
00:28:09,450 --> 00:28:14,420
exceed a single-page right but that

1452
00:28:14,420 --> 00:28:14,430
 

1453
00:28:14,430 --> 00:28:15,650
would be problematic when you have

1454
00:28:15,650 --> 00:28:15,660
 

1455
00:28:15,660 --> 00:28:18,140
really large values like a var binary or

1456
00:28:18,140 --> 00:28:18,150
 

1457
00:28:18,150 --> 00:28:20,990
blog because they can often be larger

1458
00:28:20,990 --> 00:28:21,000
 

1459
00:28:21,000 --> 00:28:23,630
than than a single page so to handle

1460
00:28:23,630 --> 00:28:23,640
 

1461
00:28:23,640 --> 00:28:25,910
this we would use what's usually called

1462
00:28:25,910 --> 00:28:25,920
 

1463
00:28:25,920 --> 00:28:28,430
overflow storage pages so basically a

1464
00:28:28,430 --> 00:28:28,440

1465
00:28:28,440 --> 00:28:30,860
place where you can store large values

1466
00:28:30,860 --> 00:28:30,870

1467
00:28:30,870 --> 00:28:32,420
that aren't no longer going to be in

1468
00:28:32,420 --> 00:28:32,430
 

1469
00:28:32,430 --> 00:28:35,600
line with the tuple itself right so in

1470
00:28:35,600 --> 00:28:35,610
 

1471
00:28:35,610 --> 00:28:37,850
this case here inside of our tuple say I

1472
00:28:37,850 --> 00:28:37,860
 

1473
00:28:37,860 --> 00:28:41,660
have this attribute C it's a var binary

1474
00:28:41,660 --> 00:28:41,670
 

1475
00:28:41,670 --> 00:28:44,450
and it's more than than the size of a

1476
00:28:44,450 --> 00:28:44,460
 

1477
00:28:44,460 --> 00:28:46,580
single page instead of actually storing

1478
00:28:46,580 --> 00:28:46,590
 

1479
00:28:46,590 --> 00:28:48,110
the value inside my page with my two

1480
00:28:48,110 --> 00:28:48,120
 

1481
00:28:48,120 --> 00:28:50,990
pool I'll just have a pointer page ID

1482
00:28:50,990 --> 00:28:51,000

1483
00:28:51,000 --> 00:28:53,300
and an offset to a overflow storage page

1484
00:28:53,300 --> 00:28:53,310
 

1485
00:28:53,310 --> 00:28:55,690
that tells me where my actual value is

1486
00:28:55,690 --> 00:28:55,700
 

1487
00:28:55,700 --> 00:29:00,290
all right so in Postgres they do this if

1488
00:29:00,290 --> 00:29:00,300
 

1489
00:29:00,300 --> 00:29:02,810
the value trying to store is larger than

1490
00:29:02,810 --> 00:29:02,820

1491
00:29:02,820 --> 00:29:05,390
two kilobytes and my sequel they do this

1492
00:29:05,390 --> 00:29:05,400
 

1493
00:29:05,400 --> 00:29:08,300
if the value trying to store is larger

1494
00:29:08,300 --> 00:29:08,310
 

1495
00:29:08,310 --> 00:29:11,020
than half size the page there's actually

1496
00:29:11,020 --> 00:29:11,030

1497
00:29:11,030 --> 00:29:12,950
we're not I'm to cover this but is

1498
00:29:12,950 --> 00:29:12,960
 

1499
00:29:12,960 --> 00:29:14,300
actually a bunch of other optimizations

1500
00:29:14,300 --> 00:29:14,310
 

1501
00:29:14,310 --> 00:29:16,760
you can do for these overflow storage

1502
00:29:16,760 --> 00:29:16,770
 

1503
00:29:16,770 --> 00:29:18,850
pages that you can't actually do in the

1504
00:29:18,850 --> 00:29:18,860
 

1505
00:29:18,860 --> 00:29:22,010
regular tuple pages right so in the case

1506
00:29:22,010 --> 00:29:22,020
 

1507
00:29:22,020 --> 00:29:23,450
of Postgres and we've had this thing

1508
00:29:23,450 --> 00:29:23,460
 

1509
00:29:23,460 --> 00:29:25,430
called toast I figure what it stands for

1510
00:29:25,430 --> 00:29:25,440
 

1511
00:29:25,440 --> 00:29:26,930
but that's where they store these large

1512
00:29:26,930 --> 00:29:26,940
 

1513
00:29:26,940 --> 00:29:28,580
values they can actually compress these

1514
00:29:28,580 --> 00:29:28,590
 

1515
00:29:28,590 --> 00:29:32,450
pages on disk because you know for these

1516
00:29:32,450 --> 00:29:32,460
 

1517
00:29:32,460 --> 00:29:33,500
things it's not like you're trying to

1518
00:29:33,500 --> 00:29:33,510
 

1519
00:29:33,510 --> 00:29:34,760
insert update things all the time right

1520
00:29:34,760 --> 00:29:34,770
 

1521
00:29:34,770 --> 00:29:36,020
I write a tuple I write a large value

1522
00:29:36,020 --> 00:29:36,030
 

1523
00:29:36,030 --> 00:29:38,480
I'm usually not going back and updating

1524
00:29:38,480 --> 00:29:38,490
 

1525
00:29:38,490 --> 00:29:40,610
that large value over and over again

1526
00:29:40,610 --> 00:29:40,620

1527
00:29:40,620 --> 00:29:42,200
because that's actually not what a

1528
00:29:42,200 --> 00:29:42,210
 

1529
00:29:42,210 --> 00:29:44,620
database system would be good for

1530
00:29:44,620 --> 00:29:44,630
 

1531
00:29:44,630 --> 00:29:48,800
there's also a way to do well covering

1532
00:29:48,800 --> 00:29:48,810
 

1533
00:29:48,810 --> 00:29:50,480
this when we talk about logging but all

1534
00:29:50,480 --> 00:29:50,490
 

1535
00:29:50,490 --> 00:29:52,250
the protections you would have for your

1536
00:29:52,250 --> 00:29:52,260
 

1537
00:29:52,260 --> 00:29:53,510
regular data that fits in the regular

1538
00:29:53,510 --> 00:29:53,520
 

1539
00:29:53,520 --> 00:29:55,810
tubule pages you have to have for these

1540
00:29:55,810 --> 00:29:55,820
 

1541
00:29:55,820 --> 00:29:58,520
overflow pages as well because because

1542
00:29:58,520 --> 00:29:58,530
 

1543
00:29:58,530 --> 00:30:01,130
in from the outside point of view from

1544
00:30:01,130 --> 00:30:01,140
 

1545
00:30:01,140 --> 00:30:02,510
from the application standpoint you

1546
00:30:02,510 --> 00:30:02,520
 

1547
00:30:02,520 --> 00:30:04,190
don't know whether your app your tuples

1548
00:30:04,190 --> 00:30:04,200
 

1549
00:30:04,200 --> 00:30:06,050
stored across two pages you just know if

1550
00:30:06,050 --> 00:30:06,060
 

1551
00:30:06,060 --> 00:30:07,340
you crash you come back you want to make

1552
00:30:07,340 --> 00:30:07,350
 

1553
00:30:07,350 --> 00:30:10,220
sure everything's still there so in some

1554
00:30:10,220 --> 00:30:10,230

1555
00:30:10,230 --> 00:30:11,420
cases you actually don't want to store

1556
00:30:11,420 --> 00:30:11,430
 

1557
00:30:11,430 --> 00:30:13,040
large files entirely in your database

1558
00:30:13,040 --> 00:30:13,050
 

1559
00:30:13,050 --> 00:30:16,460
because it's expensive to do instead you

1560
00:30:16,460 --> 00:30:16,470
 

1561
00:30:16,470 --> 00:30:17,750
have what's called an internal value

1562
00:30:17,750 --> 00:30:17,760
 

1563
00:30:17,760 --> 00:30:20,210
storage and it almost looks exactly the

1564
00:30:20,210 --> 00:30:20,220
 

1565
00:30:20,220 --> 00:30:23,120
same as as the

1566
00:30:23,120 --> 00:30:23,130
 

1567
00:30:23,130 --> 00:30:24,920
large value storage in the last slide

1568
00:30:24,920 --> 00:30:24,930
 

1569
00:30:24,930 --> 00:30:28,160
the difference is that the pointer from

1570
00:30:28,160 --> 00:30:28,170

1571
00:30:28,170 --> 00:30:30,560
the attribute for the regular tuple is

1572
00:30:30,560 --> 00:30:30,570
 

1573
00:30:30,570 --> 00:30:32,060
not going to another page managed by the

1574
00:30:32,060 --> 00:30:32,070

1575
00:30:32,070 --> 00:30:34,040
dating system it literally is just a

1576
00:30:34,040 --> 00:30:34,050
 

1577
00:30:34,050 --> 00:30:36,470
file path to somewhere on that's

1578
00:30:36,470 --> 00:30:36,480
 

1579
00:30:36,480 --> 00:30:38,630
accessible to the database system where

1580
00:30:38,630 --> 00:30:38,640
 

1581
00:30:38,640 --> 00:30:40,510
the data is actually being stored

1582
00:30:40,510 --> 00:30:40,520
 

1583
00:30:40,520 --> 00:30:42,950
alright so think of this say I have a

1584
00:30:42,950 --> 00:30:42,960
 

1585
00:30:42,960 --> 00:30:45,470
photo application right and my database

1586
00:30:45,470 --> 00:30:45,480
 

1587
00:30:45,480 --> 00:30:47,900
is storing photo information instead of

1588
00:30:47,900 --> 00:30:47,910
 

1589
00:30:47,910 --> 00:30:49,310
storing the really large photo files

1590
00:30:49,310 --> 00:30:49,320
 

1591
00:30:49,320 --> 00:30:51,170
inside of my database I can just have

1592
00:30:51,170 --> 00:30:51,180
 

1593
00:30:51,180 --> 00:30:54,440
them strewn across a directory and then

1594
00:30:54,440 --> 00:30:54,450
 

1595
00:30:54,450 --> 00:30:55,790
inside my data system it just has a

1596
00:30:55,790 --> 00:30:55,800
 

1597
00:30:55,800 --> 00:30:58,310
pointer to to where that file is that it

1598
00:30:58,310 --> 00:30:58,320
 

1599
00:30:58,320 --> 00:31:04,220
wants to store right so from the query

1600
00:31:04,220 --> 00:31:04,230
 

1601
00:31:04,230 --> 00:31:06,680
execution standpoint these external

1602
00:31:06,680 --> 00:31:06,690
 

1603
00:31:06,690 --> 00:31:08,150
files are essentially gonna be treated

1604
00:31:08,150 --> 00:31:08,160
 

1605
00:31:08,160 --> 00:31:09,740
the same thing as a bar binary or blob

1606
00:31:09,740 --> 00:31:09,750
 

1607
00:31:09,750 --> 00:31:11,690
right the upper levels of the system

1608
00:31:11,690 --> 00:31:11,700
 

1609
00:31:11,700 --> 00:31:13,760
don't know that you read this data from

1610
00:31:13,760 --> 00:31:13,770
 

1611
00:31:13,770 --> 00:31:16,640
the file system right does it need to

1612
00:31:16,640 --> 00:31:16,650
 

1613
00:31:16,650 --> 00:31:18,710
know just knows that if you need to read

1614
00:31:18,710 --> 00:31:18,720
 

1615
00:31:18,720 --> 00:31:20,390
it here you know internally I know how

1616
00:31:20,390 --> 00:31:20,400
 

1617
00:31:20,400 --> 00:31:22,040
to jump to that file and then and stream

1618
00:31:22,040 --> 00:31:22,050
 

1619
00:31:22,050 --> 00:31:23,990
it in stream the bytes in then hand it

1620
00:31:23,990 --> 00:31:24,000
 

1621
00:31:24,000 --> 00:31:26,210
off to whatever what other part of the

1622
00:31:26,210 --> 00:31:26,220
 

1623
00:31:26,220 --> 00:31:28,730
system it actually needs it so in Oracle

1624
00:31:28,730 --> 00:31:28,740
 

1625
00:31:28,740 --> 00:31:30,470
they have a special type called B file

1626
00:31:30,470 --> 00:31:30,480

1627
00:31:30,480 --> 00:31:32,300
in Microsoft they have a file type

1628
00:31:32,300 --> 00:31:32,310

1629
00:31:32,310 --> 00:31:34,190
called file stream I spent some time

1630
00:31:34,190 --> 00:31:34,200
 

1631
00:31:34,200 --> 00:31:35,930
looking at other major systems and as

1632
00:31:35,930 --> 00:31:35,940
 

1633
00:31:35,940 --> 00:31:38,600
far as I can tell they they they all

1634
00:31:38,600 --> 00:31:38,610
 

1635
00:31:38,610 --> 00:31:40,640
sort of have something similar to these

1636
00:31:40,640 --> 00:31:40,650
 

1637
00:31:40,650 --> 00:31:42,320
but these are the two main ones that I

1638
00:31:42,320 --> 00:31:42,330
 

1639
00:31:42,330 --> 00:31:45,500
that I can I know about so now the thing

1640
00:31:45,500 --> 00:31:45,510
 

1641
00:31:45,510 --> 00:31:47,840
to point out though is unlike in the

1642
00:31:47,840 --> 00:31:47,850
 

1643
00:31:47,850 --> 00:31:50,210
last slide with the overflow

1644
00:31:50,210 --> 00:31:50,220

1645
00:31:50,220 --> 00:31:54,200
values the database systems not be able

1646
00:31:54,200 --> 00:31:54,210

1647
00:31:54,210 --> 00:31:55,580
to protect or do anything with these

1648
00:31:55,580 --> 00:31:55,590
 

1649
00:31:55,590 --> 00:31:57,710
external files other than just reading

1650
00:31:57,710 --> 00:31:57,720
 

1651
00:31:57,720 --> 00:32:01,190
it okay so in the case of Oracle they

1652
00:32:01,190 --> 00:32:01,200
 

1653
00:32:01,200 --> 00:32:02,930
don't let you actually manipulate or

1654
00:32:02,930 --> 00:32:02,940
 

1655
00:32:02,940 --> 00:32:05,630
dude updates to these these files but

1656
00:32:05,630 --> 00:32:05,640
 

1657
00:32:05,640 --> 00:32:07,490
has to be managed all outside of the

1658
00:32:07,490 --> 00:32:07,500
 

1659
00:32:07,500 --> 00:32:11,000
database system right and then we'll

1660
00:32:11,000 --> 00:32:11,010
 

1661
00:32:11,010 --> 00:32:12,050
also see the case and that means you

1662
00:32:12,050 --> 00:32:12,060
 

1663
00:32:12,060 --> 00:32:13,430
also don't get protect transaction

1664
00:32:13,430 --> 00:32:13,440
 

1665
00:32:13,440 --> 00:32:15,620
protections meaning if I try to

1666
00:32:15,620 --> 00:32:15,630
 

1667
00:32:15,630 --> 00:32:16,940
manipulate this thing inside the

1668
00:32:16,940 --> 00:32:16,950
 

1669
00:32:16,950 --> 00:32:20,000
database system and I in some concept of

1670
00:32:20,000 --> 00:32:20,010
 

1671
00:32:20,010 --> 00:32:21,620
transaction and I crash and I come back

1672
00:32:21,620 --> 00:32:21,630

1673
00:32:21,630 --> 00:32:24,140
Davis is not gonna know how to replay

1674
00:32:24,140 --> 00:32:24,150
 

1675
00:32:24,150 --> 00:32:26,810
the log to recreate the the changes that

1676
00:32:26,810 --> 00:32:26,820

1677
00:32:26,820 --> 00:32:28,970
you made right these are Sitter

1678
00:32:28,970 --> 00:32:28,980
 

1679
00:32:28,980 --> 00:32:31,520
considered external so you see this a

1680
00:32:31,520 --> 00:32:31,530
 

1681
00:32:31,530 --> 00:32:35,990
lot of times where we're database

1682
00:32:35,990 --> 00:32:36,000
 

1683
00:32:36,000 --> 00:32:36,720
systems are really

1684
00:32:36,720 --> 00:32:36,730
 

1685
00:32:36,730 --> 00:32:38,159
are really expensive and storage is

1686
00:32:38,159 --> 00:32:38,169
 

1687
00:32:38,169 --> 00:32:40,740
expensive and you can store these

1688
00:32:40,740 --> 00:32:40,750
 

1689
00:32:40,750 --> 00:32:42,390
external files on like a distributed

1690
00:32:42,390 --> 00:32:42,400
 

1691
00:32:42,400 --> 00:32:44,340
file system or ass and that's external

1692
00:32:44,340 --> 00:32:44,350
 

1693
00:32:44,350 --> 00:32:45,690
to the data system that's actually much

1694
00:32:45,690 --> 00:32:45,700
 

1695
00:32:45,700 --> 00:32:47,490
cheaper to do right a lot of times you

1696
00:32:47,490 --> 00:32:47,500
 

1697
00:32:47,500 --> 00:32:49,799
see this and like you know if you if

1698
00:32:49,799 --> 00:32:49,809
 

1699
00:32:49,809 --> 00:32:51,990
you're paying per gigabyte on your

1700
00:32:51,990 --> 00:32:52,000
 

1701
00:32:52,000 --> 00:32:53,250
database system some vendors actually

1702
00:32:53,250 --> 00:32:53,260
 

1703
00:32:53,260 --> 00:32:55,110
charge this way instead of storing all

1704
00:32:55,110 --> 00:32:55,120
 

1705
00:32:55,120 --> 00:32:56,280
your large files in the database you

1706
00:32:56,280 --> 00:32:56,290
 

1707
00:32:56,290 --> 00:32:58,380
just have it point to the these external

1708
00:32:58,380 --> 00:32:58,390
 

1709
00:32:58,390 --> 00:33:00,810
files and then you don't pay extra to

1710
00:33:00,810 --> 00:33:00,820
 

1711
00:33:00,820 --> 00:33:05,220
store them right again inside the tuple

1712
00:33:05,220 --> 00:33:05,230
 

1713
00:33:05,230 --> 00:33:06,659
we're just storing now the file path

1714
00:33:06,659 --> 00:33:06,669
 

1715
00:33:06,669 --> 00:33:13,650
question yes her question is for the

1716
00:33:13,650 --> 00:33:13,660
 

1717
00:33:13,660 --> 00:33:15,539
overflow page will there's always be a

1718
00:33:15,539 --> 00:33:15,549
 

1719
00:33:15,549 --> 00:33:20,490
fixed sized page sorry is the overflow

1720
00:33:20,490 --> 00:33:20,500
 

1721
00:33:20,500 --> 00:33:23,760
page is each overflow place gonna be the

1722
00:33:23,760 --> 00:33:23,770
 

1723
00:33:23,770 --> 00:33:26,789
same size yes so typically in a database

1724
00:33:26,789 --> 00:33:26,799

1725
00:33:26,799 --> 00:33:29,700
system there wasn't clear from last

1726
00:33:29,700 --> 00:33:29,710
 

1727
00:33:29,710 --> 00:33:33,539
class if my if I say my page size is is

1728
00:33:33,539 --> 00:33:33,549
 

1729
00:33:33,549 --> 00:33:36,780
8 kilobytes every page is a key light

1730
00:33:36,780 --> 00:33:36,790
 

1731
00:33:36,790 --> 00:33:38,250
regardless whether it's a logging page

1732
00:33:38,250 --> 00:33:38,260
 

1733
00:33:38,260 --> 00:33:39,570
regardless of whether it's a one of the

1734
00:33:39,570 --> 00:33:39,580
 

1735
00:33:39,580 --> 00:33:41,100
overflow pages they're always gonna be

1736
00:33:41,100 --> 00:33:41,110
 

1737
00:33:41,110 --> 00:33:43,110
the same size and the reason is because

1738
00:33:43,110 --> 00:33:43,120
 

1739
00:33:43,120 --> 00:33:44,909
when we saw that buffer pool manager I

1740
00:33:44,909 --> 00:33:44,919
 

1741
00:33:44,919 --> 00:33:46,740
had those slots where I wanted to put my

1742
00:33:46,740 --> 00:33:46,750
 

1743
00:33:46,750 --> 00:33:49,049
pages in I don't want to have variable

1744
00:33:49,049 --> 00:33:49,059
 

1745
00:33:49,059 --> 00:33:52,260
length slots now some systems I think

1746
00:33:52,260 --> 00:33:52,270
 

1747
00:33:52,270 --> 00:33:55,049
db2 you maybe it'll tune this to change

1748
00:33:55,049 --> 00:33:55,059
 

1749
00:33:55,059 --> 00:33:57,090
the page size / buffer pool but in

1750
00:33:57,090 --> 00:33:57,100
 

1751
00:33:57,100 --> 00:33:58,169
general it's always gonna be the same

1752
00:33:58,169 --> 00:33:58,179
 

1753
00:33:58,179 --> 00:34:00,240
size so now the next question might be

1754
00:34:00,240 --> 00:34:00,250
 

1755
00:34:00,250 --> 00:34:03,240
asking is if if my database system has 4

1756
00:34:03,240 --> 00:34:03,250
 

1757
00:34:03,250 --> 00:34:05,760
kilobyte pages and the value I want to

1758
00:34:05,760 --> 00:34:05,770
 

1759
00:34:05,770 --> 00:34:07,530
store is larger than 4 kilobytes so what

1760
00:34:07,530 --> 00:34:07,540
 

1761
00:34:07,540 --> 00:34:07,919
do I do

1762
00:34:07,919 --> 00:34:07,929

1763
00:34:07,929 --> 00:34:10,139
we just have now a pointer inside of

1764
00:34:10,139 --> 00:34:10,149

1765
00:34:10,149 --> 00:34:12,629
this thing to say I can only store 4

1766
00:34:12,629 --> 00:34:12,639
 

1767
00:34:12,639 --> 00:34:13,950
kilobytes but here's the point into the

1768
00:34:13,950 --> 00:34:13,960
 

1769
00:34:13,960 --> 00:34:15,659
next page where you can continue reading

1770
00:34:15,659 --> 00:34:15,669
 

1771
00:34:15,669 --> 00:34:18,690
these things right and now we get into

1772
00:34:18,690 --> 00:34:18,700
 

1773
00:34:18,700 --> 00:34:20,399
so what are the optimizations you can do

1774
00:34:20,399 --> 00:34:20,409

1775
00:34:20,409 --> 00:34:22,409
to make streaming this data in very

1776
00:34:22,409 --> 00:34:22,419
 

1777
00:34:22,419 --> 00:34:25,530
efficient well if I know I'm gonna store

1778
00:34:25,530 --> 00:34:25,540
 

1779
00:34:25,540 --> 00:34:29,460
a 1 megabyte value in one of these

1780
00:34:29,460 --> 00:34:29,470
 

1781
00:34:29,470 --> 00:34:32,070
verbling fields I want to be allocate a

1782
00:34:32,070 --> 00:34:32,080
 

1783
00:34:32,080 --> 00:34:33,570
bunch of for kalaiy pages all

1784
00:34:33,570 --> 00:34:33,580
 

1785
00:34:33,580 --> 00:34:37,500
contiguously on disk so that you know

1786
00:34:37,500 --> 00:34:37,510
 

1787
00:34:37,510 --> 00:34:38,700
yes there's a pointer to go to the next

1788
00:34:38,700 --> 00:34:38,710
 

1789
00:34:38,710 --> 00:34:40,980
one but it's you know it's it's not I

1790
00:34:40,980 --> 00:34:40,990
 

1791
00:34:40,990 --> 00:34:42,270
know I can jump ahead and read

1792
00:34:42,270 --> 00:34:42,280
 

1793
00:34:42,280 --> 00:34:43,290
everything ahead of time without having

1794
00:34:43,290 --> 00:34:43,300
 

1795
00:34:43,300 --> 00:34:44,550
to jump around to different locations

1796
00:34:44,550 --> 00:34:44,560
 

1797
00:34:44,560 --> 00:34:48,240
right I wish I had numbers for this but

1798
00:34:48,240 --> 00:34:48,250
 

1799
00:34:48,250 --> 00:34:50,470
there was a

1800
00:34:50,470 --> 00:34:50,480
 

1801
00:34:50,480 --> 00:34:52,720
there is a paper from it from a few

1802
00:34:52,720 --> 00:34:52,730
 

1803
00:34:52,730 --> 00:34:54,280
years ago actually 10 years ago now

1804
00:34:54,280 --> 00:34:54,290
 

1805
00:34:54,290 --> 00:34:56,290
where basically they try to figure out

1806
00:34:56,290 --> 00:34:56,300
 

1807
00:34:56,300 --> 00:34:58,240
at Microsoft what was the right cut off

1808
00:34:58,240 --> 00:34:58,250
 

1809
00:34:58,250 --> 00:35:00,040
point of making decision and when to

1810
00:35:00,040 --> 00:35:00,050
 

1811
00:35:00,050 --> 00:35:02,980
store things as large values inside the

1812
00:35:02,980 --> 00:35:02,990
 

1813
00:35:02,990 --> 00:35:04,359
database and when to store things in

1814
00:35:04,359 --> 00:35:04,369
 

1815
00:35:04,369 --> 00:35:06,880
external storage and I think the number

1816
00:35:06,880 --> 00:35:06,890
 

1817
00:35:06,890 --> 00:35:08,080
they came up with it was like really

1818
00:35:08,080 --> 00:35:08,090
 

1819
00:35:08,090 --> 00:35:14,320
small like 256 kilobytes that seems too

1820
00:35:14,320 --> 00:35:14,330
 

1821
00:35:14,330 --> 00:35:16,690
small when they had the sequel like guy

1822
00:35:16,690 --> 00:35:16,700
 

1823
00:35:16,700 --> 00:35:19,060
come here here a few years ago they were

1824
00:35:19,060 --> 00:35:19,070
 

1825
00:35:19,070 --> 00:35:20,830
actually they did experiments they were

1826
00:35:20,830 --> 00:35:20,840
 

1827
00:35:20,840 --> 00:35:22,060
showing that it's better off to store

1828
00:35:22,060 --> 00:35:22,070
 

1829
00:35:22,070 --> 00:35:25,090
like in like phone apps he were storing

1830
00:35:25,090 --> 00:35:25,100
 

1831
00:35:25,100 --> 00:35:26,890
like 1 megabyte thumbnails you were

1832
00:35:26,890 --> 00:35:26,900
 

1833
00:35:26,900 --> 00:35:27,910
actually better off storing the

1834
00:35:27,910 --> 00:35:27,920
 

1835
00:35:27,920 --> 00:35:29,320
thumbnails inside the database system

1836
00:35:29,320 --> 00:35:29,330
 

1837
00:35:29,330 --> 00:35:31,510
because it was super fast to read these

1838
00:35:31,510 --> 00:35:31,520
 

1839
00:35:31,520 --> 00:35:33,040
files to write you know from from disk

1840
00:35:33,040 --> 00:35:33,050
 

1841
00:35:33,050 --> 00:35:34,150
because you already had the file handle

1842
00:35:34,150 --> 00:35:34,160
 

1843
00:35:34,160 --> 00:35:37,120
open right so there's no there's no

1844
00:35:37,120 --> 00:35:37,130
 

1845
00:35:37,130 --> 00:35:38,710
conventional ways from a hard fast rule

1846
00:35:38,710 --> 00:35:38,720
 

1847
00:35:38,720 --> 00:35:40,840
to say when you store things like this

1848
00:35:40,840 --> 00:35:40,850
 

1849
00:35:40,850 --> 00:35:42,130
so when you store things in an external

1850
00:35:42,130 --> 00:35:42,140
 

1851
00:35:42,140 --> 00:35:44,020
file different people say different

1852
00:35:44,020 --> 00:35:44,030
 

1853
00:35:44,030 --> 00:35:46,390
things I would say the from it from a

1854
00:35:46,390 --> 00:35:46,400
 

1855
00:35:46,400 --> 00:35:49,120
management standpoint if you stored

1856
00:35:49,120 --> 00:35:49,130
 

1857
00:35:49,130 --> 00:35:50,800
inside the database if I do a dump now

1858
00:35:50,800 --> 00:35:50,810
 

1859
00:35:50,810 --> 00:35:52,480
of the database everything's always

1860
00:35:52,480 --> 00:35:52,490
 

1861
00:35:52,490 --> 00:35:54,700
there if I have these external files I

1862
00:35:54,700 --> 00:35:54,710
 

1863
00:35:54,710 --> 00:35:56,260
maybe copy the data from one machine to

1864
00:35:56,260 --> 00:35:56,270
 

1865
00:35:56,270 --> 00:35:57,880
another I got to make sure I copied the

1866
00:35:57,880 --> 00:35:57,890
 

1867
00:35:57,890 --> 00:35:59,290
database plus the files make sure the

1868
00:35:59,290 --> 00:35:59,300

1869
00:35:59,300 --> 00:36:01,240
file paths are all point correctly right

1870
00:36:01,240 --> 00:36:01,250
 

1871
00:36:01,250 --> 00:36:02,890
so there's different trade-offs for each

1872
00:36:02,890 --> 00:36:02,900
 

1873
00:36:02,900 --> 00:36:05,400
of these from a performance standpoint

1874
00:36:05,400 --> 00:36:05,410

1875
00:36:05,410 --> 00:36:07,990
you know don't store one gigabyte files

1876
00:36:07,990 --> 00:36:08,000
 

1877
00:36:08,000 --> 00:36:09,640
in a database you can some systems will

1878
00:36:09,640 --> 00:36:09,650
 

1879
00:36:09,650 --> 00:36:12,160
let you do this I think Tara data was

1880
00:36:12,160 --> 00:36:12,170
 

1881
00:36:12,170 --> 00:36:14,590
like gee do there's like 2 terabytes for

1882
00:36:14,590 --> 00:36:14,600
 

1883
00:36:14,600 --> 00:36:17,460
a single value don't do that

1884
00:36:17,460 --> 00:36:17,470
 

1885
00:36:17,470 --> 00:36:20,740
ok so see your question these pages are

1886
00:36:20,740 --> 00:36:20,750
 

1887
00:36:20,750 --> 00:36:22,990
always being the same size and then for

1888
00:36:22,990 --> 00:36:23,000
 

1889
00:36:23,000 --> 00:36:24,070
external files it's whatever the

1890
00:36:24,070 --> 00:36:24,080
 

1891
00:36:24,080 --> 00:36:25,300
operating system or the file system

1892
00:36:25,300 --> 00:36:25,310
 

1893
00:36:25,310 --> 00:36:26,920
actually uses right we don't care we

1894
00:36:26,920 --> 00:36:26,930
 

1895
00:36:26,930 --> 00:36:31,230
just know how to stream things alright

1896
00:36:31,230 --> 00:36:31,240
 

1897
00:36:31,240 --> 00:36:35,740
so as I said in beginning the tuples are

1898
00:36:35,740 --> 00:36:35,750
 

1899
00:36:35,750 --> 00:36:38,650
just byte strings or byte arrays there's

1900
00:36:38,650 --> 00:36:38,660

1901
00:36:38,660 --> 00:36:41,080
no meaning to them other than what the

1902
00:36:41,080 --> 00:36:41,090
 

1903
00:36:41,090 --> 00:36:43,030
database system you know in parts on it

1904
00:36:43,030 --> 00:36:43,040
 

1905
00:36:43,040 --> 00:36:45,700
from interpreting those bytes and the

1906
00:36:45,700 --> 00:36:45,710
 

1907
00:36:45,710 --> 00:36:47,020
way it's going to be able to do this is

1908
00:36:47,020 --> 00:36:47,030
 

1909
00:36:47,030 --> 00:36:49,660
through its system catalogs so the

1910
00:36:49,660 --> 00:36:49,670
 

1911
00:36:49,670 --> 00:36:51,970
system catalog is the internal metadata

1912
00:36:51,970 --> 00:36:51,980

1913
00:36:51,980 --> 00:36:54,130
about the data right tells you what

1914
00:36:54,130 --> 00:36:54,140
 

1915
00:36:54,140 --> 00:36:55,540
tables you have what comes they have

1916
00:36:55,540 --> 00:36:55,550
 

1917
00:36:55,550 --> 00:36:57,640
what types they are what their names are

1918
00:36:57,640 --> 00:36:57,650
 

1919
00:36:57,650 --> 00:36:59,740
what the ordering is everything about

1920
00:36:59,740 --> 00:36:59,750

1921
00:36:59,750 --> 00:37:02,140
indexes and views alright we need all

1922
00:37:02,140 --> 00:37:02,150
 

1923
00:37:02,150 --> 00:37:03,940
this for for query planning because we

1924
00:37:03,940 --> 00:37:03,950
 

1925
00:37:03,950 --> 00:37:04,329
didn't

1926
00:37:04,329 --> 00:37:04,339
 

1927
00:37:04,339 --> 00:37:05,709
whether you know if you do a read on a

1928
00:37:05,709 --> 00:37:05,719
 

1929
00:37:05,719 --> 00:37:07,269
table does that table actually exist and

1930
00:37:07,269 --> 00:37:07,279
 

1931
00:37:07,279 --> 00:37:08,979
we need to know when we actually read

1932
00:37:08,979 --> 00:37:08,989
 

1933
00:37:08,989 --> 00:37:11,529
tuples inside that table how to actually

1934
00:37:11,529 --> 00:37:11,539
 

1935
00:37:11,539 --> 00:37:13,599
find the data that we need interpret it

1936
00:37:13,599 --> 00:37:13,609
 

1937
00:37:13,609 --> 00:37:16,450
correctly so in general almost every

1938
00:37:16,450 --> 00:37:16,460
 

1939
00:37:16,460 --> 00:37:18,209
single database minute system

1940
00:37:18,209 --> 00:37:18,219

1941
00:37:18,219 --> 00:37:21,160
essentially stores the catalog

1942
00:37:21,160 --> 00:37:21,170

1943
00:37:21,170 --> 00:37:24,249
in its own database format so it stores

1944
00:37:24,249 --> 00:37:24,259
 

1945
00:37:24,259 --> 00:37:25,660
information about tables inside of

1946
00:37:25,660 --> 00:37:25,670
 

1947
00:37:25,670 --> 00:37:28,509
tables and we'll see it in a second it

1948
00:37:28,509 --> 00:37:28,519
 

1949
00:37:28,519 --> 00:37:29,620
actually makes it really easy they can

1950
00:37:29,620 --> 00:37:29,630
 

1951
00:37:29,630 --> 00:37:32,709
then find information about these tables

1952
00:37:32,709 --> 00:37:32,719

1953
00:37:32,719 --> 00:37:33,759
because there's there's sort of a

1954
00:37:33,759 --> 00:37:33,769
 

1955
00:37:33,769 --> 00:37:36,039
standard location or standard view if

1956
00:37:36,039 --> 00:37:36,049
 

1957
00:37:36,049 --> 00:37:37,390
you want to call it that where you can

1958
00:37:37,390 --> 00:37:37,400

1959
00:37:37,400 --> 00:37:40,120
see all this metadata but internally

1960
00:37:40,120 --> 00:37:40,130
 

1961
00:37:40,130 --> 00:37:41,349
what's gonna happen to the data systems

1962
00:37:41,349 --> 00:37:41,359
 

1963
00:37:41,359 --> 00:37:43,150
gonna know when they call create table

1964
00:37:43,150 --> 00:37:43,160

1965
00:37:43,160 --> 00:37:45,400
and define four fields right and these

1966
00:37:45,400 --> 00:37:45,410
 

1967
00:37:45,410 --> 00:37:47,049
fields have these different types so

1968
00:37:47,049 --> 00:37:47,059
 

1969
00:37:47,059 --> 00:37:48,969
when I read a tuple I know what those

1970
00:37:48,969 --> 00:37:48,979

1971
00:37:48,979 --> 00:37:54,789
those types are all right so the the

1972
00:37:54,789 --> 00:37:54,799
 

1973
00:37:54,799 --> 00:37:57,670
ANSI standard I think is in the single

1974
00:37:57,670 --> 00:37:57,680
 

1975
00:37:57,680 --> 00:38:00,880
standard now says that the everyday

1976
00:38:00,880 --> 00:38:00,890
 

1977
00:38:00,890 --> 00:38:02,019
there's no system has gonna have

1978
00:38:02,019 --> 00:38:02,029
 

1979
00:38:02,029 --> 00:38:04,569
catalogs you won't expose this through

1980
00:38:04,569 --> 00:38:04,579
 

1981
00:38:04,579 --> 00:38:06,279
the user through what's called the

1982
00:38:06,279 --> 00:38:06,289
 

1983
00:38:06,289 --> 00:38:08,259
information schema catalog information

1984
00:38:08,259 --> 00:38:08,269
 

1985
00:38:08,269 --> 00:38:10,479
schema view right again this is

1986
00:38:10,479 --> 00:38:10,489

1987
00:38:10,489 --> 00:38:12,279
basically all the information about

1988
00:38:12,279 --> 00:38:12,289
 

1989
00:38:12,289 --> 00:38:13,809
tables and columns and everything that

1990
00:38:13,809 --> 00:38:13,819
 

1991
00:38:13,819 --> 00:38:15,579
the theaters could use internally this

1992
00:38:15,579 --> 00:38:15,589
 

1993
00:38:15,589 --> 00:38:17,859
is just a way to get to it as you're as

1994
00:38:17,859 --> 00:38:17,869
 

1995
00:38:17,869 --> 00:38:20,829
in your application code so as well see

1996
00:38:20,829 --> 00:38:20,839
 

1997
00:38:20,839 --> 00:38:23,079
in a second although there is a standard

1998
00:38:23,079 --> 00:38:23,089
 

1999
00:38:23,089 --> 00:38:25,180
way to get this information or every

2000
00:38:25,180 --> 00:38:25,190
 

2001
00:38:25,190 --> 00:38:26,680
single database system that I'm aware of

2002
00:38:26,680 --> 00:38:26,690
 

2003
00:38:26,690 --> 00:38:29,019
has their own little shortcuts to to

2004
00:38:29,019 --> 00:38:29,029
 

2005
00:38:29,029 --> 00:38:31,150
make it easier to do this because you

2006
00:38:31,150 --> 00:38:31,160
 

2007
00:38:31,160 --> 00:38:32,559
know writing queries against information

2008
00:38:32,559 --> 00:38:32,569
 

2009
00:38:32,569 --> 00:38:35,069
schema can is kind of cumbersome in law

2010
00:38:35,069 --> 00:38:35,079
 

2011
00:38:35,079 --> 00:38:37,059
so let's say that you want to real

2012
00:38:37,059 --> 00:38:37,069
 

2013
00:38:37,069 --> 00:38:40,269
simple get the all the tables inside

2014
00:38:40,269 --> 00:38:40,279

2015
00:38:40,279 --> 00:38:42,339
your database the sequel standards say

2016
00:38:42,339 --> 00:38:42,349
 

2017
00:38:42,349 --> 00:38:43,660
that you do select star from a from

2018
00:38:43,660 --> 00:38:43,670
 

2019
00:38:43,670 --> 00:38:45,130
information schema dot table and then

2020
00:38:45,130 --> 00:38:45,140
 

2021
00:38:45,140 --> 00:38:47,709
you pass along table catalog is the name

2022
00:38:47,709 --> 00:38:47,719
 

2023
00:38:47,719 --> 00:38:49,839
of the database but in Postgres of my

2024
00:38:49,839 --> 00:38:49,849
 

2025
00:38:49,849 --> 00:38:51,969
sequel and sequel light they have their

2026
00:38:51,969 --> 00:38:51,979
 

2027
00:38:51,979 --> 00:38:53,799
own idioms to get this information real

2028
00:38:53,799 --> 00:38:53,809
 

2029
00:38:53,809 --> 00:38:56,950
quickly right /d four-post grass or /d

2030
00:38:56,950 --> 00:38:56,960
 

2031
00:38:56,960 --> 00:38:58,239
plus gives you more information

2032
00:38:58,239 --> 00:38:58,249
 

2033
00:38:58,249 --> 00:39:00,279
show tables for my sequel and dot tables

2034
00:39:00,279 --> 00:39:00,289

2035
00:39:00,289 --> 00:39:03,430
in sequel Lite so say now we want to get

2036
00:39:03,430 --> 00:39:03,440
 

2037
00:39:03,440 --> 00:39:06,459
all of the tables were started all to be

2038
00:39:06,459 --> 00:39:06,469
 

2039
00:39:06,469 --> 00:39:09,180
all the tables in the student database

2040
00:39:09,180 --> 00:39:09,190
 

2041
00:39:09,190 --> 00:39:13,089
in Postgres you use /d student my sequel

2042
00:39:13,089 --> 00:39:13,099
 

2043
00:39:13,099 --> 00:39:14,410
with describe student and dot schema

2044
00:39:14,410 --> 00:39:14,420
 

2045
00:39:14,420 --> 00:39:16,959
student in sickle life so again the main

2046
00:39:16,959 --> 00:39:16,969
 

2047
00:39:16,969 --> 00:39:18,170
takeaway I don't

2048
00:39:18,170 --> 00:39:18,180

2049
00:39:18,180 --> 00:39:21,020
is that when we call create table we

2050
00:39:21,020 --> 00:39:21,030
 

2051
00:39:21,030 --> 00:39:22,340
stir all this information in our

2052
00:39:22,340 --> 00:39:22,350
 

2053
00:39:22,350 --> 00:39:25,300
catalogs that is then propagated to the

2054
00:39:25,300 --> 00:39:25,310
 

2055
00:39:25,310 --> 00:39:27,530
execution engine part that was it sort

2056
00:39:27,530 --> 00:39:27,540
 

2057
00:39:27,540 --> 00:39:29,210
of in the cloud that I was showing my

2058
00:39:29,210 --> 00:39:29,220
 

2059
00:39:29,220 --> 00:39:31,040
diagram that says all right you're

2060
00:39:31,040 --> 00:39:31,050
 

2061
00:39:31,050 --> 00:39:32,900
reading this page is from this table

2062
00:39:32,900 --> 00:39:32,910
 

2063
00:39:32,910 --> 00:39:35,060
here and here's here's how to find the

2064
00:39:35,060 --> 00:39:35,070
 

2065
00:39:35,070 --> 00:39:36,800
offset for an attribute they may be

2066
00:39:36,800 --> 00:39:36,810
 

2067
00:39:36,810 --> 00:39:40,400
looking for right so we'll cover I think

2068
00:39:40,400 --> 00:39:40,410
 

2069
00:39:40,410 --> 00:39:42,290
if you have try to cover more about this

2070
00:39:42,290 --> 00:39:42,300
 

2071
00:39:42,300 --> 00:39:43,960
in the in the later in the semester

2072
00:39:43,960 --> 00:39:43,970
 

2073
00:39:43,970 --> 00:39:46,460
but I find catalogs are actually very

2074
00:39:46,460 --> 00:39:46,470
 

2075
00:39:46,470 --> 00:39:48,830
interesting because they vary widely in

2076
00:39:48,830 --> 00:39:48,840
 

2077
00:39:48,840 --> 00:39:52,850
implementation and the this is something

2078
00:39:52,850 --> 00:39:52,860
 

2079
00:39:52,860 --> 00:39:53,870
that actually the research doesn't

2080
00:39:53,870 --> 00:39:53,880
 

2081
00:39:53,880 --> 00:39:57,140
really cover because it's not sexy right

2082
00:39:57,140 --> 00:39:57,150
 

2083
00:39:57,150 --> 00:39:58,910
like writing a catalogue with the da

2084
00:39:58,910 --> 00:39:58,920
 

2085
00:39:58,920 --> 00:40:01,370
system you need to have it but there's

2086
00:40:01,370 --> 00:40:01,380
 

2087
00:40:01,380 --> 00:40:04,780
no nobody actually doesn't really well

2088
00:40:04,780 --> 00:40:04,790
 

2089
00:40:04,790 --> 00:40:07,250
my sequel you should actually just store

2090
00:40:07,250 --> 00:40:07,260
 

2091
00:40:07,260 --> 00:40:10,850
files on and on disk and that was the

2092
00:40:10,850 --> 00:40:10,860
 

2093
00:40:10,860 --> 00:40:13,460
way that you could figure out what more

2094
00:40:13,460 --> 00:40:13,470
 

2095
00:40:13,470 --> 00:40:15,380
tables you actually have actually we can

2096
00:40:15,380 --> 00:40:15,390

2097
00:40:15,390 --> 00:40:16,430
give a little demo of that we want to

2098
00:40:16,430 --> 00:40:16,440
 

2099
00:40:16,440 --> 00:40:24,710
see that all right so this is Postgres

2100
00:40:24,710 --> 00:40:24,720
 

2101
00:40:24,720 --> 00:40:38,290
at the top I'm at the Kinect again

2102
00:40:38,290 --> 00:40:38,300


2103
00:40:38,300 --> 00:40:41,540
alright so as I said I can do select

2104
00:40:41,540 --> 00:40:41,550
 

2105
00:40:41,550 --> 00:40:46,970
star from information schema that tables

2106
00:40:46,970 --> 00:40:46,980
 

2107
00:40:46,980 --> 00:40:52,220
and you get a bunch of stuff right so I

2108
00:40:52,220 --> 00:40:52,230
 

2109
00:40:52,230 --> 00:41:00,010
can do where table catalog equals Pablo

2110
00:41:00,010 --> 00:41:00,020
 

2111
00:41:00,020 --> 00:41:02,510
right and this tells me all the internal

2112
00:41:02,510 --> 00:41:02,520
 

2113
00:41:02,520 --> 00:41:05,990
tables that I have right these anything

2114
00:41:05,990 --> 00:41:06,000
 

2115
00:41:06,000 --> 00:41:07,670
with PG underscores is an internal thing

2116
00:41:07,670 --> 00:41:07,680
 

2117
00:41:07,680 --> 00:41:10,700
that Postgres sets up for you I can also

2118
00:41:10,700 --> 00:41:10,710
 

2119
00:41:10,710 --> 00:41:13,760
do like this your /t and it shows me all

2120
00:41:13,760 --> 00:41:13,770
 

2121
00:41:13,770 --> 00:41:16,910
of the tables that have /gx sx then it

2122
00:41:16,910 --> 00:41:16,920
 

2123
00:41:16,920 --> 00:41:25,400
shows you what the schema is there we go

2124
00:41:25,400 --> 00:41:25,410
 

2125
00:41:25,410 --> 00:41:27,740
alright so my sequel the same thing I

2126
00:41:27,740 --> 00:41:27,750
 

2127
00:41:27,750 --> 00:41:33,109
can use select star from

2128
00:41:33,109 --> 00:41:33,119


2129
00:41:33,119 --> 00:41:43,680
information schema top tables well it's

2130
00:41:43,680 --> 00:41:43,690
 

2131
00:41:43,690 --> 00:41:50,789
a bunch of stuff it's hard to see I said

2132
00:41:50,789 --> 00:41:50,799
 

2133
00:41:50,799 --> 00:41:52,739
so in case here they're showing every

2134
00:41:52,739 --> 00:41:52,749
 

2135
00:41:52,749 --> 00:41:54,749
possible thing every possible table

2136
00:41:54,749 --> 00:41:54,759

2137
00:41:54,759 --> 00:41:56,969
that's in type of entire system right

2138
00:41:56,969 --> 00:41:56,979
 

2139
00:41:56,979 --> 00:41:59,910
alright so there are shortcuts to show

2140
00:41:59,910 --> 00:41:59,920
 

2141
00:41:59,920 --> 00:42:04,319
tables right or show databases here I

2142
00:42:04,319 --> 00:42:04,329
 

2143
00:42:04,329 --> 00:42:07,559
want to do a database as a hat right so

2144
00:42:07,559 --> 00:42:07,569
 

2145
00:42:07,569 --> 00:42:12,960
the this is post this is my sequel 5,7

2146
00:42:12,960 --> 00:42:12,970
 

2147
00:42:12,970 --> 00:42:14,460
post goes my sequel 8 they've actually

2148
00:42:14,460 --> 00:42:14,470
 

2149
00:42:14,470 --> 00:42:16,829
fixed this and they actually now store

2150
00:42:16,829 --> 00:42:16,839
 

2151
00:42:16,839 --> 00:42:18,450
all the stars could tell all the catalog

2152
00:42:18,450 --> 00:42:18,460
 

2153
00:42:18,460 --> 00:42:20,910
information in tables themselves in this

2154
00:42:20,910 --> 00:42:20,920
 

2155
00:42:20,920 --> 00:42:22,529
earlier version they would actually

2156
00:42:22,529 --> 00:42:22,539

2157
00:42:22,539 --> 00:42:30,509
store this in they would actually store

2158
00:42:30,509 --> 00:42:30,519

2159
00:42:30,519 --> 00:42:37,499
this in in the file system so if I go to

2160
00:42:37,499 --> 00:42:37,509

2161
00:42:37,509 --> 00:42:45,719
VAR live my sequel right I see a bunch I

2162
00:42:45,719 --> 00:42:45,729
 

2163
00:42:45,729 --> 00:42:47,549
see a bunch of directories here and and

2164
00:42:47,549 --> 00:42:47,559
 

2165
00:42:47,559 --> 00:42:49,289
it matches up with what tables or

2166
00:42:49,289 --> 00:42:49,299
 

2167
00:42:49,299 --> 00:42:51,059
databases that have so it says I have a

2168
00:42:51,059 --> 00:42:51,069
 

2169
00:42:51,069 --> 00:42:53,160
dangerous caught information schema our

2170
00:42:53,160 --> 00:42:53,170
 

2171
00:42:53,170 --> 00:42:54,690
performance schema and there's a there's

2172
00:42:54,690 --> 00:42:54,700
 

2173
00:42:54,700 --> 00:42:57,509
a directory up above or it says you know

2174
00:42:57,509 --> 00:42:57,519
 

2175
00:42:57,519 --> 00:42:59,339
performing schema that I have a data is

2176
00:42:59,339 --> 00:42:59,349
 

2177
00:42:59,349 --> 00:43:00,690
called test insist

2178
00:43:00,690 --> 00:43:00,700
 

2179
00:43:00,700 --> 00:43:01,709
and there's directories called system

2180
00:43:01,709 --> 00:43:01,719
 

2181
00:43:01,719 --> 00:43:03,779
test so what my segal basically does is

2182
00:43:03,779 --> 00:43:03,789
 

2183
00:43:03,789 --> 00:43:05,670
when you say show me the Davises you

2184
00:43:05,670 --> 00:43:05,680
 

2185
00:43:05,680 --> 00:43:08,309
have it looks in this directory and any

2186
00:43:08,309 --> 00:43:08,319
 

2187
00:43:08,319 --> 00:43:09,719
directory it sees it assumes that it's

2188
00:43:09,719 --> 00:43:09,729

2189
00:43:09,729 --> 00:43:12,589
the database right so we can fake it out

2190
00:43:12,589 --> 00:43:12,599
 

2191
00:43:12,599 --> 00:43:15,059
by saying let's make a directory called

2192
00:43:15,059 --> 00:43:15,069
 

2193
00:43:15,069 --> 00:43:18,059
xxx and down below and I show show do it

2194
00:43:18,059 --> 00:43:18,069
 

2195
00:43:18,069 --> 00:43:20,519
show up call show databases and voila

2196
00:43:20,519 --> 00:43:20,529
 

2197
00:43:20,529 --> 00:43:24,270
xxx alright

2198
00:43:24,270 --> 00:43:24,280
 

2199
00:43:24,280 --> 00:43:25,380
I'll see what happens if I try to ask

2200
00:43:25,380 --> 00:43:25,390
 

2201
00:43:25,390 --> 00:43:30,540
what's inside of it or use it let me use

2202
00:43:30,540 --> 00:43:30,550
 

2203
00:43:30,550 --> 00:43:32,660
it

2204
00:43:32,660 --> 00:43:32,670


2205
00:43:32,670 --> 00:43:34,830
nothing's in there so let's go see in

2206
00:43:34,830 --> 00:43:34,840
 

2207
00:43:34,840 --> 00:43:37,710
here there's nothing there's no files in

2208
00:43:37,710 --> 00:43:37,720
 

2209
00:43:37,720 --> 00:43:40,830
there let's see what happens I call it

2210
00:43:40,830 --> 00:43:40,840
 

2211
00:43:40,840 --> 00:43:41,520
table

2212
00:43:41,520 --> 00:43:41,530

2213
00:43:41,530 --> 00:43:46,849
I don't know what's gonna happen here

2214
00:43:46,849 --> 00:43:46,859


2215
00:43:46,859 --> 00:43:49,020
yeah didn't like it cuz there's nothing

2216
00:43:49,020 --> 00:43:49,030
 

2217
00:43:49,030 --> 00:43:51,320
there

2218
00:43:51,320 --> 00:43:51,330


2219
00:43:51,330 --> 00:43:56,460
anyway so so show databases xxx is there

2220
00:43:56,460 --> 00:43:56,470
 

2221
00:43:56,470 --> 00:44:02,099
come back here we'll delete X X X X X

2222
00:44:02,099 --> 00:44:02,109
 

2223
00:44:02,109 --> 00:44:02,760
it's gone

2224
00:44:02,760 --> 00:44:02,770
 

2225
00:44:02,770 --> 00:44:05,339
alright so the main takeaway here is

2226
00:44:05,339 --> 00:44:05,349
 

2227
00:44:05,349 --> 00:44:06,330
gonna say post curse does a much better

2228
00:44:06,330 --> 00:44:06,340
 

2229
00:44:06,340 --> 00:44:08,550
job most data systems do a much better

2230
00:44:08,550 --> 00:44:08,560
 

2231
00:44:08,560 --> 00:44:10,640
job of actually storing all the

2232
00:44:10,640 --> 00:44:10,650
 

2233
00:44:10,650 --> 00:44:12,900
catalogue information that we use to

2234
00:44:12,900 --> 00:44:12,910
 

2235
00:44:12,910 --> 00:44:14,130
understand what the data looks like

2236
00:44:14,130 --> 00:44:14,140
 

2237
00:44:14,140 --> 00:44:16,890
inside of tables themselves my sequel

2238
00:44:16,890 --> 00:44:16,900
 

2239
00:44:16,900 --> 00:44:21,359
got better in this in version 8 there's

2240
00:44:21,359 --> 00:44:21,369
 

2241
00:44:21,369 --> 00:44:23,040
a bunch of weird stuff though that they

2242
00:44:23,040 --> 00:44:23,050
 

2243
00:44:23,050 --> 00:44:25,080
don't do correctly which we'll talk

2244
00:44:25,080 --> 00:44:25,090
 

2245
00:44:25,090 --> 00:44:26,339
about when we do transactions where

2246
00:44:26,339 --> 00:44:26,349
 

2247
00:44:26,349 --> 00:44:28,640
although it looks like a regular table

2248
00:44:28,640 --> 00:44:28,650
 

2249
00:44:28,650 --> 00:44:30,660
and you would think what had the same

2250
00:44:30,660 --> 00:44:30,670
 

2251
00:44:30,670 --> 00:44:32,490
transaction semantics the regular data

2252
00:44:32,490 --> 00:44:32,500
 

2253
00:44:32,500 --> 00:44:34,700
has in some cases it actually doesn't

2254
00:44:34,700 --> 00:44:34,710
 

2255
00:44:34,710 --> 00:44:37,170
write because these catalogs are sort of

2256
00:44:37,170 --> 00:44:37,180
 

2257
00:44:37,180 --> 00:44:38,609
special cased in the system and they

2258
00:44:38,609 --> 00:44:38,619

2259
00:44:38,619 --> 00:44:40,339
don't they don't always get it right

2260
00:44:40,339 --> 00:44:40,349
 

2261
00:44:40,349 --> 00:44:42,690
again I am extremely interested in

2262
00:44:42,690 --> 00:44:42,700
 

2263
00:44:42,700 --> 00:44:43,890
catalogs I just find it really

2264
00:44:43,890 --> 00:44:43,900
 

2265
00:44:43,900 --> 00:44:47,849
fascinating just sort of a you know my

2266
00:44:47,849 --> 00:44:47,859
 

2267
00:44:47,859 --> 00:44:48,780
stupid thing okay

2268
00:44:48,780 --> 00:44:48,790
 

2269
00:44:48,790 --> 00:44:51,900
so now I want to talk about storage

2270
00:44:51,900 --> 00:44:51,910
 

2271
00:44:51,910 --> 00:44:55,020
models and I think this is a really

2272
00:44:55,020 --> 00:44:55,030

2273
00:44:55,030 --> 00:44:57,020
important concept and in some ways like

2274
00:44:57,020 --> 00:44:57,030
 

2275
00:44:57,030 --> 00:45:00,150
this is probably one of the things that

2276
00:45:00,150 --> 00:45:00,160
 

2277
00:45:00,160 --> 00:45:02,730
you were a design decision you have to

2278
00:45:02,730 --> 00:45:02,740
 

2279
00:45:02,740 --> 00:45:04,410
consider when you go out in the real

2280
00:45:04,410 --> 00:45:04,420
 

2281
00:45:04,420 --> 00:45:06,240
world and you and you say maybe you're

2282
00:45:06,240 --> 00:45:06,250
 

2283
00:45:06,250 --> 00:45:07,380
not building a database system from

2284
00:45:07,380 --> 00:45:07,390
 

2285
00:45:07,390 --> 00:45:09,720
scratch but you need to pick one all

2286
00:45:09,720 --> 00:45:09,730
 

2287
00:45:09,730 --> 00:45:10,650
right the thing we're talk about here it

2288
00:45:10,650 --> 00:45:10,660
 

2289
00:45:10,660 --> 00:45:12,859
actually can make a big difference right

2290
00:45:12,859 --> 00:45:12,869
 

2291
00:45:12,869 --> 00:45:16,950
so remember that there in the relational

2292
00:45:16,950 --> 00:45:16,960
 

2293
00:45:16,960 --> 00:45:20,760
model that there's nothing about it that

2294
00:45:20,760 --> 00:45:20,770
 

2295
00:45:20,770 --> 00:45:23,880
said the defined how we actually had to

2296
00:45:23,880 --> 00:45:23,890
 

2297
00:45:23,890 --> 00:45:26,820
store the the tuples inside of our data

2298
00:45:26,820 --> 00:45:26,830
 

2299
00:45:26,830 --> 00:45:29,760
inside of our pages right and that means

2300
00:45:29,760 --> 00:45:29,770
 

2301
00:45:29,770 --> 00:45:31,349
that what I mean by that is in all my

2302
00:45:31,349 --> 00:45:31,359
 

2303
00:45:31,359 --> 00:45:33,420
examples so far when I said let's store

2304
00:45:33,420 --> 00:45:33,430
 

2305
00:45:33,430 --> 00:45:35,700
tuple I showed like this array with

2306
00:45:35,700 --> 00:45:35,710
 

2307
00:45:35,710 --> 00:45:37,170
these attributes contiguous to each

2308
00:45:37,170 --> 00:45:37,180
 

2309
00:45:37,180 --> 00:45:37,950
other

2310
00:45:37,950 --> 00:45:37,960

2311
00:45:37,960 --> 00:45:39,990
right and when the middle see what think

2312
00:45:39,990 --> 00:45:40,000
 

2313
00:45:40,000 --> 00:45:41,370
about a database and think about like a

2314
00:45:41,370 --> 00:45:41,380
 

2315
00:45:41,380 --> 00:45:43,319
row or a two point of data is they

2316
00:45:43,319 --> 00:45:43,329
 

2317
00:45:43,329 --> 00:45:44,309
always start to think about like that

2318
00:45:44,309 --> 00:45:44,319
 

2319
00:45:44,319 --> 00:45:46,020
you have one attribute after after

2320
00:45:46,020 --> 00:45:46,030
 

2321
00:45:46,030 --> 00:45:48,120
another but again the relational model

2322
00:45:48,120 --> 00:45:48,130

2323
00:45:48,130 --> 00:45:49,470
doesn't say anything about this because

2324
00:45:49,470 --> 00:45:49,480
 

2325
00:45:49,480 --> 00:45:51,270
a relational model is a is a high-level

2326
00:45:51,270 --> 00:45:51,280
 

2327
00:45:51,280 --> 00:45:53,819
logical concept which means we can store

2328
00:45:53,819 --> 00:45:53,829

2329
00:45:53,829 --> 00:45:55,650
it anything you know sort of data in any

2330
00:45:55,650 --> 00:45:55,660
 

2331
00:45:55,660 --> 00:45:58,799
physical way that you want as long as we

2332
00:45:58,799 --> 00:45:58,809
 

2333
00:45:58,809 --> 00:46:00,990
expose it to the user as you know as you

2334
00:46:00,990 --> 00:46:01,000
 

2335
00:46:01,000 --> 00:46:02,549
know tuple has these these values these

2336
00:46:02,549 --> 00:46:02,559
 

2337
00:46:02,559 --> 00:46:04,650
attributes so the reason why this

2338
00:46:04,650 --> 00:46:04,660

2339
00:46:04,660 --> 00:46:07,020
matters because storing it the way we

2340
00:46:07,020 --> 00:46:07,030
 

2341
00:46:07,030 --> 00:46:08,880
took that so far storing everything as

2342
00:46:08,880 --> 00:46:08,890
 

2343
00:46:08,890 --> 00:46:10,980
rows with Katti keys batteries may

2344
00:46:10,980 --> 00:46:10,990
 

2345
00:46:10,990 --> 00:46:12,690
actually not be the right thing for some

2346
00:46:12,690 --> 00:46:12,700
 

2347
00:46:12,700 --> 00:46:15,390
workloads so to understand this bit

2348
00:46:15,390 --> 00:46:15,400

2349
00:46:15,400 --> 00:46:17,400
better I'm going to use this sample

2350
00:46:17,400 --> 00:46:17,410
 

2351
00:46:17,410 --> 00:46:19,829
schema it's actually derived from the

2352
00:46:19,829 --> 00:46:19,839
 

2353
00:46:19,839 --> 00:46:21,569
real application the real software that

2354
00:46:21,569 --> 00:46:21,579
 

2355
00:46:21,579 --> 00:46:23,490
runs Wikipedia right you can download

2356
00:46:23,490 --> 00:46:23,500
 

2357
00:46:23,500 --> 00:46:24,809
this thing called MediaWiki it's written

2358
00:46:24,809 --> 00:46:24,819
 

2359
00:46:24,819 --> 00:46:26,940
in PHP uses my sequel if you look at

2360
00:46:26,940 --> 00:46:26,950
 

2361
00:46:26,950 --> 00:46:28,230
their DDL files you'll see something

2362
00:46:28,230 --> 00:46:28,240
 

2363
00:46:28,240 --> 00:46:30,510
that roughly looks like this we've I've

2364
00:46:30,510 --> 00:46:30,520
 

2365
00:46:30,520 --> 00:46:31,980
modified it slightly to make it more

2366
00:46:31,980 --> 00:46:31,990
 

2367
00:46:31,990 --> 00:46:33,900
simple so when have two tables we have

2368
00:46:33,900 --> 00:46:33,910
 

2369
00:46:33,910 --> 00:46:35,930
user account pages and revisions

2370
00:46:35,930 --> 00:46:35,940
 

2371
00:46:35,940 --> 00:46:38,839
revisions have a foreign key reference

2372
00:46:38,839 --> 00:46:38,849
 

2373
00:46:38,849 --> 00:46:41,790
to the user account table and the pages

2374
00:46:41,790 --> 00:46:41,800
 

2375
00:46:41,800 --> 00:46:43,920
table and then the pages table has a

2376
00:46:43,920 --> 00:46:43,930

2377
00:46:43,930 --> 00:46:46,200
foreign key reference to the revisions

2378
00:46:46,200 --> 00:46:46,210
 

2379
00:46:46,210 --> 00:46:49,230
table so users have accounts users make

2380
00:46:49,230 --> 00:46:49,240

2381
00:46:49,240 --> 00:46:51,510
pages or you just have accounts there

2382
00:46:51,510 --> 00:46:51,520
 

2383
00:46:51,520 --> 00:46:53,460
are pages like articles on Wikipedia and

2384
00:46:53,460 --> 00:46:53,470
 

2385
00:46:53,470 --> 00:46:56,160
those pages can have revisions right and

2386
00:46:56,160 --> 00:46:56,170
 

2387
00:46:56,170 --> 00:46:57,660
there's religions are created by users

2388
00:46:57,660 --> 00:46:57,670
 

2389
00:46:57,670 --> 00:47:00,870
that's the basic schema so the two

2390
00:47:00,870 --> 00:47:00,880
 

2391
00:47:00,880 --> 00:47:02,670
classes of workloads that we're going

2392
00:47:02,670 --> 00:47:02,680
 

2393
00:47:02,680 --> 00:47:06,049
talk about our OLTP and Ola ap or OLAP

2394
00:47:06,049 --> 00:47:06,059
 

2395
00:47:06,059 --> 00:47:08,910
so LLC OLTP stands for online

2396
00:47:08,910 --> 00:47:08,920
 

2397
00:47:08,920 --> 00:47:11,400
transaction processing right think of

2398
00:47:11,400 --> 00:47:11,410
 

2399
00:47:11,410 --> 00:47:13,859
this as the applicant application where

2400
00:47:13,859 --> 00:47:13,869
 

2401
00:47:13,869 --> 00:47:15,900
you have people interacting with a

2402
00:47:15,900 --> 00:47:15,910
 

2403
00:47:15,910 --> 00:47:18,240
website and you're you're making you

2404
00:47:18,240 --> 00:47:18,250
 

2405
00:47:18,250 --> 00:47:19,770
know filling out forms and submitting

2406
00:47:19,770 --> 00:47:19,780
 

2407
00:47:19,780 --> 00:47:21,980
things and you're recording new data

2408
00:47:21,980 --> 00:47:21,990
 

2409
00:47:21,990 --> 00:47:24,000
right so think of like in like on

2410
00:47:24,000 --> 00:47:24,010
 

2411
00:47:24,010 --> 00:47:26,190
Wikipedia I can go and create an account

2412
00:47:26,190 --> 00:47:26,200
 

2413
00:47:26,200 --> 00:47:27,450
right

2414
00:47:27,450 --> 00:47:27,460
 

2415
00:47:27,460 --> 00:47:29,700
I go felt the form and click Submit then

2416
00:47:29,700 --> 00:47:29,710
 

2417
00:47:29,710 --> 00:47:31,140
the data system takes that data and

2418
00:47:31,140 --> 00:47:31,150
 

2419
00:47:31,150 --> 00:47:32,970
stores it as a new record inside the

2420
00:47:32,970 --> 00:47:32,980
 

2421
00:47:32,980 --> 00:47:36,180
database alright so and these workloads

2422
00:47:36,180 --> 00:47:36,190
 

2423
00:47:36,190 --> 00:47:38,490
the the queries can actually going to be

2424
00:47:38,490 --> 00:47:38,500

2425
00:47:38,500 --> 00:47:40,589
usually pretty simple right they're not

2426
00:47:40,589 --> 00:47:40,599
 

2427
00:47:40,599 --> 00:47:42,030
talking about you know very complex

2428
00:47:42,030 --> 00:47:42,040
 

2429
00:47:42,040 --> 00:47:43,530
joins very complex aggregations

2430
00:47:43,530 --> 00:47:43,540

2431
00:47:43,540 --> 00:47:46,260
because because your your the queries

2432
00:47:46,260 --> 00:47:46,270
 

2433
00:47:46,270 --> 00:47:49,260
gonna be operating on a single entity at

2434
00:47:49,260 --> 00:47:49,270
 

2435
00:47:49,270 --> 00:47:51,390
a time in the database again

2436
00:47:51,390 --> 00:47:51,400
 

2437
00:47:51,400 --> 00:47:53,370
think of like going to Amazon I have my

2438
00:47:53,370 --> 00:47:53,380
 

2439
00:47:53,380 --> 00:47:55,230
Amazon account I can add things to my

2440
00:47:55,230 --> 00:47:55,240
 

2441
00:47:55,240 --> 00:47:57,809
cart I can make purchases I can I can I

2442
00:47:57,809 --> 00:47:57,819
 

2443
00:47:57,819 --> 00:48:00,239
can make payments I'm the the actions

2444
00:48:00,239 --> 00:48:00,249
 

2445
00:48:00,249 --> 00:48:03,019
I'm doing only affect my account right

2446
00:48:03,019 --> 00:48:03,029
 

2447
00:48:03,029 --> 00:48:05,670
so the transactions the queries that are

2448
00:48:05,670 --> 00:48:05,680
 

2449
00:48:05,680 --> 00:48:08,309
executing um based on my invocations of

2450
00:48:08,309 --> 00:48:08,319
 

2451
00:48:08,319 --> 00:48:11,940
the the website only touch my data from

2452
00:48:11,940 --> 00:48:11,950
 

2453
00:48:11,950 --> 00:48:15,180
you know my entity so this is typically

2454
00:48:15,180 --> 00:48:15,190
 

2455
00:48:15,190 --> 00:48:16,559
what people usually build first like if

2456
00:48:16,559 --> 00:48:16,569
 

2457
00:48:16,569 --> 00:48:18,329
you're gonna be a start-up and you say

2458
00:48:18,329 --> 00:48:18,339
 

2459
00:48:18,339 --> 00:48:19,739
I'm gonna build something that you know

2460
00:48:19,739 --> 00:48:19,749
 

2461
00:48:19,749 --> 00:48:21,509
wants to do machine learning analytics

2462
00:48:21,509 --> 00:48:21,519

2463
00:48:21,519 --> 00:48:24,359
you need to get data first this is how

2464
00:48:24,359 --> 00:48:24,369
 

2465
00:48:24,369 --> 00:48:25,529
you're simply collecting that data or

2466
00:48:25,529 --> 00:48:25,539
 

2467
00:48:25,539 --> 00:48:27,749
you set up a website people use it and

2468
00:48:27,749 --> 00:48:27,759
 

2469
00:48:27,759 --> 00:48:29,789
then you know installs new data in the

2470
00:48:29,789 --> 00:48:29,799
 

2471
00:48:29,799 --> 00:48:32,069
database so in the case of our Wikipedia

2472
00:48:32,069 --> 00:48:32,079
 

2473
00:48:32,079 --> 00:48:34,259
example the queries that would fall

2474
00:48:34,259 --> 00:48:34,269
 

2475
00:48:34,269 --> 00:48:35,460
under this category would be simple

2476
00:48:35,460 --> 00:48:35,470
 

2477
00:48:35,470 --> 00:48:38,339
things like click get all the revisions

2478
00:48:38,339 --> 00:48:38,349
 

2479
00:48:38,349 --> 00:48:41,309
for a page by doing a join update my

2480
00:48:41,309 --> 00:48:41,319
 

2481
00:48:41,319 --> 00:48:42,930
user account by saying the last time I

2482
00:48:42,930 --> 00:48:42,940
 

2483
00:48:42,940 --> 00:48:44,819
walked in with the current time and then

2484
00:48:44,819 --> 00:48:44,829
 

2485
00:48:44,829 --> 00:48:46,319
inserting new things into revisions

2486
00:48:46,319 --> 00:48:46,329
 

2487
00:48:46,329 --> 00:48:48,420
right and these are simple operations

2488
00:48:48,420 --> 00:48:48,430
 

2489
00:48:48,430 --> 00:48:50,609
doing that only touching a small amount

2490
00:48:50,609 --> 00:48:50,619
 

2491
00:48:50,619 --> 00:48:52,940
of data and operating on a single entity

2492
00:48:52,940 --> 00:48:52,950
 

2493
00:48:52,950 --> 00:48:55,440
now contrast this with OLAP or online

2494
00:48:55,440 --> 00:48:55,450
 

2495
00:48:55,450 --> 00:48:59,160
analytical processing these are more

2496
00:48:59,160 --> 00:48:59,170

2497
00:48:59,170 --> 00:49:02,099
complex queries that will be reading

2498
00:49:02,099 --> 00:49:02,109
 

2499
00:49:02,109 --> 00:49:04,499
large segments of the database or tables

2500
00:49:04,499 --> 00:49:04,509
 

2501
00:49:04,509 --> 00:49:08,220
that go across multiple entities so

2502
00:49:08,220 --> 00:49:08,230
 

2503
00:49:08,230 --> 00:49:11,160
again using Amazon an example under LTP

2504
00:49:11,160 --> 00:49:11,170
 

2505
00:49:11,170 --> 00:49:14,309
I make purchases I buy items right I'm

2506
00:49:14,309 --> 00:49:14,319
 

2507
00:49:14,319 --> 00:49:16,650
only operating on my account under OLAP

2508
00:49:16,650 --> 00:49:16,660

2509
00:49:16,660 --> 00:49:19,049
I'm doing calculations like you know

2510
00:49:19,049 --> 00:49:19,059
 

2511
00:49:19,059 --> 00:49:21,269
compute the the the five most bought

2512
00:49:21,269 --> 00:49:21,279

2513
00:49:21,279 --> 00:49:23,249
items over a one-month period for these

2514
00:49:23,249 --> 00:49:23,259
 

2515
00:49:23,259 --> 00:49:26,249
these these geographical regions right

2516
00:49:26,249 --> 00:49:26,259
 

2517
00:49:26,259 --> 00:49:27,660
now I'm reading large sections of data

2518
00:49:27,660 --> 00:49:27,670
 

2519
00:49:27,670 --> 00:49:29,880
to compute some kind of aggregation I'm

2520
00:49:29,880 --> 00:49:29,890

2521
00:49:29,890 --> 00:49:31,499
deriving new data from the data I've

2522
00:49:31,499 --> 00:49:31,509
 

2523
00:49:31,509 --> 00:49:34,529
collected from the OTP side alright so

2524
00:49:34,529 --> 00:49:34,539
 

2525
00:49:34,539 --> 00:49:36,299
you typically do this after you've built

2526
00:49:36,299 --> 00:49:36,309
 

2527
00:49:36,309 --> 00:49:38,460
the OTP side and you collected your data

2528
00:49:38,460 --> 00:49:38,470
 

2529
00:49:38,470 --> 00:49:40,410
and now you want to infer some meaning

2530
00:49:40,410 --> 00:49:40,420
 

2531
00:49:40,420 --> 00:49:42,900
or derive new knowledge from it so in

2532
00:49:42,900 --> 00:49:42,910
 

2533
00:49:42,910 --> 00:49:44,700
the case of our Wikipedia example the

2534
00:49:44,700 --> 00:49:44,710
 

2535
00:49:44,710 --> 00:49:46,739
sample o that like query that I'm

2536
00:49:46,739 --> 00:49:46,749
 

2537
00:49:46,749 --> 00:49:48,470
showing here is that we're going to a

2538
00:49:48,470 --> 00:49:48,480
 

2539
00:49:48,480 --> 00:49:52,079
sequential scan over every single user

2540
00:49:52,079 --> 00:49:52,089
 

2541
00:49:52,089 --> 00:49:54,180
account record look at the hostname the

2542
00:49:54,180 --> 00:49:54,190
 

2543
00:49:54,190 --> 00:49:56,279
C's well see whether they ends with the

2544
00:49:56,279 --> 00:49:56,289
 

2545
00:49:56,289 --> 00:49:57,120
dot-gov

2546
00:49:57,120 --> 00:49:57,130
 

2547
00:49:57,130 --> 00:50:00,450
donate no name domain name suffix and

2548
00:50:00,450 --> 00:50:00,460
 

2549
00:50:00,460 --> 00:50:02,729
then compute the number of times they

2550
00:50:02,729 --> 00:50:02,739
 

2551
00:50:02,739 --> 00:50:04,979
logged in for each month all right is

2552
00:50:04,979 --> 00:50:04,989
 

2553
00:50:04,989 --> 00:50:05,130
that

2554
00:50:05,130 --> 00:50:05,140
 

2555
00:50:05,140 --> 00:50:06,809
real query you can do you can see you

2556
00:50:06,809 --> 00:50:06,819
 

2557
00:50:06,819 --> 00:50:08,519
know you can see which government

2558
00:50:08,519 --> 00:50:08,529
 

2559
00:50:08,529 --> 00:50:10,410
employees are going on to Wikipedia and

2560
00:50:10,410 --> 00:50:10,420
 

2561
00:50:10,420 --> 00:50:12,539
modifying things a few years ago there's

2562
00:50:12,539 --> 00:50:12,549
 

2563
00:50:12,549 --> 00:50:13,470
much of Congressman where they have

2564
00:50:13,470 --> 00:50:13,480
 

2565
00:50:13,480 --> 00:50:15,269
their and their assistants go modify the

2566
00:50:15,269 --> 00:50:15,279
 

2567
00:50:15,279 --> 00:50:16,799
Wikipedia page to make a more flattering

2568
00:50:16,799 --> 00:50:16,809
 

2569
00:50:16,809 --> 00:50:18,569
writing so this query could could find

2570
00:50:18,569 --> 00:50:18,579
 

2571
00:50:18,579 --> 00:50:20,910
people like this why is this sort of

2572
00:50:20,910 --> 00:50:20,920
 

2573
00:50:20,920 --> 00:50:23,309
clear the LTP is for transactions and

2574
00:50:23,309 --> 00:50:23,319

2575
00:50:23,319 --> 00:50:25,319
updating new data and just in new data

2576
00:50:25,319 --> 00:50:25,329
 

2577
00:50:25,329 --> 00:50:27,990
in you're modifying the database the

2578
00:50:27,990 --> 00:50:28,000
 

2579
00:50:28,000 --> 00:50:31,319
OLAP is more analytical queries so a

2580
00:50:31,319 --> 00:50:31,329
 

2581
00:50:31,329 --> 00:50:34,170
high level diagram it's sort of a really

2582
00:50:34,170 --> 00:50:34,180

2583
00:50:34,180 --> 00:50:35,700
simplistic view of what the differences

2584
00:50:35,700 --> 00:50:35,710
 

2585
00:50:35,710 --> 00:50:37,259
are would look something like this and

2586
00:50:37,259 --> 00:50:37,269
 

2587
00:50:37,269 --> 00:50:38,609
this is from article written by Mike

2588
00:50:38,609 --> 00:50:38,619
 

2589
00:50:38,619 --> 00:50:40,620
Stormbreaker from a few years ago so

2590
00:50:40,620 --> 00:50:40,630
 

2591
00:50:40,630 --> 00:50:42,509
long the y-axis we have the operation

2592
00:50:42,509 --> 00:50:42,519
 

2593
00:50:42,519 --> 00:50:44,309
complexity how complex of the queries

2594
00:50:44,309 --> 00:50:44,319

2595
00:50:44,319 --> 00:50:47,069
and then on the x axis is its whether

2596
00:50:47,069 --> 00:50:47,079
 

2597
00:50:47,079 --> 00:50:48,900
the workload is you more rights or some

2598
00:50:48,900 --> 00:50:48,910

2599
00:50:48,910 --> 00:50:51,450
more reads so in the bottom corner you

2600
00:50:51,450 --> 00:50:51,460
 

2601
00:50:51,460 --> 00:50:52,829
have OLTP where you're doing simple

2602
00:50:52,829 --> 00:50:52,839
 

2603
00:50:52,839 --> 00:50:54,990
operations that write data and then in

2604
00:50:54,990 --> 00:50:55,000

2605
00:50:55,000 --> 00:50:57,299
the top corner you have complex

2606
00:50:57,299 --> 00:50:57,309
 

2607
00:50:57,309 --> 00:50:59,220
operations and OLAP queries that are

2608
00:50:59,220 --> 00:50:59,230

2609
00:50:59,230 --> 00:51:01,890
that are typically read-only now social

2610
00:51:01,890 --> 00:51:01,900
 

2611
00:51:01,900 --> 00:51:03,480
networking is sort of this weird thing

2612
00:51:03,480 --> 00:51:03,490
 

2613
00:51:03,490 --> 00:51:04,920
in the middle because it's a mixture of

2614
00:51:04,920 --> 00:51:04,930
 

2615
00:51:04,930 --> 00:51:05,250
both

2616
00:51:05,250 --> 00:51:05,260

2617
00:51:05,260 --> 00:51:07,589
right you're updating your your timeline

2618
00:51:07,589 --> 00:51:07,599
 

2619
00:51:07,599 --> 00:51:09,509
you're making posts on Twitter but

2620
00:51:09,509 --> 00:51:09,519
 

2621
00:51:09,519 --> 00:51:10,980
they're still doing calculations to

2622
00:51:10,980 --> 00:51:10,990
 

2623
00:51:10,990 --> 00:51:12,059
figure out you know who you should be

2624
00:51:12,059 --> 00:51:12,069
 

2625
00:51:12,069 --> 00:51:14,819
friends with and things like that but

2626
00:51:14,819 --> 00:51:14,829
 

2627
00:51:14,829 --> 00:51:16,890
for now our purposes we just focus on

2628
00:51:16,890 --> 00:51:16,900
 

2629
00:51:16,900 --> 00:51:20,279
all it to be an OLAP so now the storage

2630
00:51:20,279 --> 00:51:20,289
 

2631
00:51:20,289 --> 00:51:22,440
model is we're going to talk about is

2632
00:51:22,440 --> 00:51:22,450
 

2633
00:51:22,450 --> 00:51:25,130
the way we're going to represent tuples

2634
00:51:25,130 --> 00:51:25,140
 

2635
00:51:25,140 --> 00:51:28,980
across our pages and how we want to deal

2636
00:51:28,980 --> 00:51:28,990
 

2637
00:51:28,990 --> 00:51:30,329
for OTP is actually gonna be different

2638
00:51:30,329 --> 00:51:30,339
 

2639
00:51:30,339 --> 00:51:32,789
how we're going to do it for OLAP and as

2640
00:51:32,789 --> 00:51:32,799
 

2641
00:51:32,799 --> 00:51:35,430
I said so far we've assumed about tuples

2642
00:51:35,430 --> 00:51:35,440
 

2643
00:51:35,440 --> 00:51:38,759
are stored as contiguous rows and the

2644
00:51:38,759 --> 00:51:38,769
 

2645
00:51:38,769 --> 00:51:40,650
mathematical term for this is called NRI

2646
00:51:40,650 --> 00:51:40,660
 

2647
00:51:40,660 --> 00:51:43,829
storage storage model so the an airy

2648
00:51:43,829 --> 00:51:43,839
 

2649
00:51:43,839 --> 00:51:46,740
storage model is where you store all the

2650
00:51:46,740 --> 00:51:46,750
 

2651
00:51:46,750 --> 00:51:49,700
values for the attributes contiguously

2652
00:51:49,700 --> 00:51:49,710
 

2653
00:51:49,710 --> 00:51:52,349
inside of a single page now again you

2654
00:51:52,349 --> 00:51:52,359
 

2655
00:51:52,359 --> 00:51:53,819
can have the overflow pages or the

2656
00:51:53,819 --> 00:51:53,829
 

2657
00:51:53,829 --> 00:51:55,920
external files for our purposes that

2658
00:51:55,920 --> 00:51:55,930
 

2659
00:51:55,930 --> 00:51:57,210
doesn't actually matter at this point

2660
00:51:57,210 --> 00:51:57,220
 

2661
00:51:57,220 --> 00:51:59,160
it's just if I have a tuple I have five

2662
00:51:59,160 --> 00:51:59,170
 

2663
00:51:59,170 --> 00:52:01,410
attributes I'm gonna have some location

2664
00:52:01,410 --> 00:52:01,420
 

2665
00:52:01,420 --> 00:52:02,880
inside of a page where I have my header

2666
00:52:02,880 --> 00:52:02,890
 

2667
00:52:02,890 --> 00:52:04,289
for that tuple and then I'm gonna have

2668
00:52:04,289 --> 00:52:04,299
 

2669
00:52:04,299 --> 00:52:05,910
all those five attributes in line with

2670
00:52:05,910 --> 00:52:05,920
 

2671
00:52:05,920 --> 00:52:10,079
each other right and so this is ideal

2672
00:52:10,079 --> 00:52:10,089
 

2673
00:52:10,089 --> 00:52:13,049
for o2b workloads because as I said most

2674
00:52:13,049 --> 00:52:13,059
 

2675
00:52:13,059 --> 00:52:14,700
of the queries operate on a single

2676
00:52:14,700 --> 00:52:14,710
 

2677
00:52:14,710 --> 00:52:18,029
entity so and you typically you're going

2678
00:52:18,029 --> 00:52:18,039
 

2679
00:52:18,039 --> 00:52:18,720
to try to read all

2680
00:52:18,720 --> 00:52:18,730
 

2681
00:52:18,730 --> 00:52:20,880
the attributes for that single entity so

2682
00:52:20,880 --> 00:52:20,890
 

2683
00:52:20,890 --> 00:52:22,280
if I want to get my account information

2684
00:52:22,280 --> 00:52:22,290
 

2685
00:52:22,290 --> 00:52:24,540
right I want to do a select star query

2686
00:52:24,540 --> 00:52:24,550
 

2687
00:52:24,550 --> 00:52:26,730
wit from account where username equals

2688
00:52:26,730 --> 00:52:26,740
 

2689
00:52:26,740 --> 00:52:31,470
no Andy I want all my attributes so when

2690
00:52:31,470 --> 00:52:31,480
 

2691
00:52:31,480 --> 00:52:33,240
things are in things are in mind this is

2692
00:52:33,240 --> 00:52:33,250
 

2693
00:52:33,250 --> 00:52:35,070
ideal because it's one fetch to go get

2694
00:52:35,070 --> 00:52:35,080

2695
00:52:35,080 --> 00:52:36,720
the page we need and then one read to

2696
00:52:36,720 --> 00:52:36,730
 

2697
00:52:36,730 --> 00:52:38,130
get you know across again everything we

2698
00:52:38,130 --> 00:52:38,140
 

2699
00:52:38,140 --> 00:52:41,370
need right so it looked like this so say

2700
00:52:41,370 --> 00:52:41,380
 

2701
00:52:41,380 --> 00:52:43,740
that we have a page with four tuples

2702
00:52:43,740 --> 00:52:43,750
 

2703
00:52:43,750 --> 00:52:47,160
right we can divide it up where the the

2704
00:52:47,160 --> 00:52:47,170
 

2705
00:52:47,170 --> 00:52:49,560
the first of all starts followed by the

2706
00:52:49,560 --> 00:52:49,570

2707
00:52:49,570 --> 00:52:51,030
second tuple and third tuple right

2708
00:52:51,030 --> 00:52:51,040
 

2709
00:52:51,040 --> 00:52:52,650
there's no data for the first tuple

2710
00:52:52,650 --> 00:52:52,660
 

2711
00:52:52,660 --> 00:52:54,690
intermix with the second tuple only when

2712
00:52:54,690 --> 00:52:54,700
 

2713
00:52:54,700 --> 00:52:56,700
it ends does does the the second start

2714
00:52:56,700 --> 00:52:56,710

2715
00:52:56,710 --> 00:52:58,770
and this is the architecture of the

2716
00:52:58,770 --> 00:52:58,780
 

2717
00:52:58,780 --> 00:53:01,670
slotted page design that we saw before

2718
00:53:01,670 --> 00:53:01,680
 

2719
00:53:01,680 --> 00:53:04,890
so now I can represent this in a single

2720
00:53:04,890 --> 00:53:04,900
 

2721
00:53:04,900 --> 00:53:06,960
page that's stored in my database with a

2722
00:53:06,960 --> 00:53:06,970
 

2723
00:53:06,970 --> 00:53:08,460
bunch of other pages so say these are

2724
00:53:08,460 --> 00:53:08,470
 

2725
00:53:08,470 --> 00:53:10,890
all the pages for this user account

2726
00:53:10,890 --> 00:53:10,900
 

2727
00:53:10,900 --> 00:53:14,040
table right for every single page

2728
00:53:14,040 --> 00:53:14,050
 

2729
00:53:14,050 --> 00:53:15,570
they'll have all the values for just one

2730
00:53:15,570 --> 00:53:15,580
 

2731
00:53:15,580 --> 00:53:17,460
entity so if I gonna need to go get that

2732
00:53:17,460 --> 00:53:17,470
 

2733
00:53:17,470 --> 00:53:19,500
entity or get the data for that single

2734
00:53:19,500 --> 00:53:19,510
 

2735
00:53:19,510 --> 00:53:21,920
entity it's one fetch to go get it let's

2736
00:53:21,920 --> 00:53:21,930
 

2737
00:53:21,930 --> 00:53:24,359
see how we'd actually write queries on

2738
00:53:24,359 --> 00:53:24,369
 

2739
00:53:24,369 --> 00:53:26,130
this so let's say we didn't want to do a

2740
00:53:26,130 --> 00:53:26,140
 

2741
00:53:26,140 --> 00:53:27,420
select star from user account where

2742
00:53:27,420 --> 00:53:27,430
 

2743
00:53:27,430 --> 00:53:28,740
username equals something and patent

2744
00:53:28,740 --> 00:53:28,750
 

2745
00:53:28,750 --> 00:53:31,380
user password equals something right so

2746
00:53:31,380 --> 00:53:31,390
 

2747
00:53:31,390 --> 00:53:33,930
there's some index we're going to use to

2748
00:53:33,930 --> 00:53:33,940

2749
00:53:33,940 --> 00:53:37,070
say to map a user account to the actual

2750
00:53:37,070 --> 00:53:37,080
 

2751
00:53:37,080 --> 00:53:39,930
tuple ID or page ID and offset that we

2752
00:53:39,930 --> 00:53:39,940
 

2753
00:53:39,940 --> 00:53:42,180
want for our purposes we don't care

2754
00:53:42,180 --> 00:53:42,190
 

2755
00:53:42,190 --> 00:53:44,040
about what the index looks like at this

2756
00:53:44,040 --> 00:53:44,050
 

2757
00:53:44,050 --> 00:53:45,359
point you can just think of it as a hash

2758
00:53:45,359 --> 00:53:45,369
 

2759
00:53:45,369 --> 00:53:47,190
table or tree we'll cover this in

2760
00:53:47,190 --> 00:53:47,200
 

2761
00:53:47,200 --> 00:53:49,620
lecture seven but this is gonna tell us

2762
00:53:49,620 --> 00:53:49,630
 

2763
00:53:49,630 --> 00:53:52,290
for this query for this user account

2764
00:53:52,290 --> 00:53:52,300
 

2765
00:53:52,300 --> 00:53:53,970
here's the one page you need to go get

2766
00:53:53,970 --> 00:53:53,980
 

2767
00:53:53,980 --> 00:53:56,280
get and then we know how to jump to the

2768
00:53:56,280 --> 00:53:56,290
 

2769
00:53:56,290 --> 00:53:58,830
offset inside that page to jump to the

2770
00:53:58,830 --> 00:53:58,840
 

2771
00:53:58,840 --> 00:53:59,970
starting point and then it's readable

2772
00:53:59,970 --> 00:53:59,980
 

2773
00:53:59,980 --> 00:54:02,550
data right across right it's really

2774
00:54:02,550 --> 00:54:02,560
 

2775
00:54:02,560 --> 00:54:04,770
simple if you want to do an insert well

2776
00:54:04,770 --> 00:54:04,780
 

2777
00:54:04,780 --> 00:54:06,690
that's easy too again we just find a

2778
00:54:06,690 --> 00:54:06,700
 

2779
00:54:06,700 --> 00:54:08,550
free page using our page directory and

2780
00:54:08,550 --> 00:54:08,560
 

2781
00:54:08,560 --> 00:54:10,620
then we just jump to inside inside of

2782
00:54:10,620 --> 00:54:10,630
 

2783
00:54:10,630 --> 00:54:12,330
that page we dump some offset and we

2784
00:54:12,330 --> 00:54:12,340
 

2785
00:54:12,340 --> 00:54:14,640
write all the data one after another

2786
00:54:14,640 --> 00:54:14,650

2787
00:54:14,650 --> 00:54:16,620
right in this case it's really simple

2788
00:54:16,620 --> 00:54:16,630
 

2789
00:54:16,630 --> 00:54:18,120
cuz it's sort of we assume we have a

2790
00:54:18,120 --> 00:54:18,130
 

2791
00:54:18,130 --> 00:54:20,220
byte buffer of the byte array sorry we

2792
00:54:20,220 --> 00:54:20,230
 

2793
00:54:20,230 --> 00:54:21,570
have a bite buffer of the values we want

2794
00:54:21,570 --> 00:54:21,580

2795
00:54:21,580 --> 00:54:23,250
to insert from the insert statement and

2796
00:54:23,250 --> 00:54:23,260
 

2797
00:54:23,260 --> 00:54:25,470
we just write them continuously with a

2798
00:54:25,470 --> 00:54:25,480

2799
00:54:25,480 --> 00:54:27,090
single write operation or mem copy into

2800
00:54:27,090 --> 00:54:27,100
 

2801
00:54:27,100 --> 00:54:30,420
our page right so again for all the TP

2802
00:54:30,420 --> 00:54:30,430
 

2803
00:54:30,430 --> 00:54:31,920
this works out great

2804
00:54:31,920 --> 00:54:31,930
 

2805
00:54:31,930 --> 00:54:34,559
for OLAP though not so much let's take

2806
00:54:34,559 --> 00:54:34,569
 

2807
00:54:34,569 --> 00:54:36,059
that query we had before we want to do

2808
00:54:36,059 --> 00:54:36,069

2809
00:54:36,069 --> 00:54:38,010
the scan across the user account table

2810
00:54:38,010 --> 00:54:38,020
 

2811
00:54:38,020 --> 00:54:39,809
and trying to find all the records with

2812
00:54:39,809 --> 00:54:39,819
 

2813
00:54:39,819 --> 00:54:41,750
someone logged in with the the gov

2814
00:54:41,750 --> 00:54:41,760
 

2815
00:54:41,760 --> 00:54:45,779
hostname so for this

2816
00:54:45,779 --> 00:54:45,789
 

2817
00:54:45,789 --> 00:54:48,450
it's a sequential scan there's no index

2818
00:54:48,450 --> 00:54:48,460
 

2819
00:54:48,460 --> 00:54:49,440
is going to help us because we want to

2820
00:54:49,440 --> 00:54:49,450
 

2821
00:54:49,450 --> 00:54:50,760
look at every single user account record

2822
00:54:50,760 --> 00:54:50,770
 

2823
00:54:50,770 --> 00:54:52,470
so that means we have to touch every

2824
00:54:52,470 --> 00:54:52,480
 

2825
00:54:52,480 --> 00:54:53,910
single page we're gonna look at every

2826
00:54:53,910 --> 00:54:53,920
 

2827
00:54:53,920 --> 00:54:56,579
single page so let's say that we go grab

2828
00:54:56,579 --> 00:54:56,589
 

2829
00:54:56,589 --> 00:54:58,829
the first page we fetch it bring it into

2830
00:54:58,829 --> 00:54:58,839
 

2831
00:54:58,839 --> 00:55:02,130
memory write what are we gonna do well

2832
00:55:02,130 --> 00:55:02,140
 

2833
00:55:02,140 --> 00:55:04,109
we will next do this query basically we

2834
00:55:04,109 --> 00:55:04,119

2835
00:55:04,119 --> 00:55:05,490
want to just look at our where clause

2836
00:55:05,490 --> 00:55:05,500
 

2837
00:55:05,500 --> 00:55:07,019
and figure out what what attributes do

2838
00:55:07,019 --> 00:55:07,029
 

2839
00:55:07,029 --> 00:55:08,760
we actually want to read we care about

2840
00:55:08,760 --> 00:55:08,770
 

2841
00:55:08,770 --> 00:55:12,569
the host name so that's stored here so

2842
00:55:12,569 --> 00:55:12,579
 

2843
00:55:12,579 --> 00:55:13,650
what's going to happen is we're gonna

2844
00:55:13,650 --> 00:55:13,660
 

2845
00:55:13,660 --> 00:55:15,450
fetch this page in and then we're gonna

2846
00:55:15,450 --> 00:55:15,460
 

2847
00:55:15,460 --> 00:55:18,240
scan through and jump to the offset as

2848
00:55:18,240 --> 00:55:18,250
 

2849
00:55:18,250 --> 00:55:20,130
defined by our catalog to where the host

2850
00:55:20,130 --> 00:55:20,140
 

2851
00:55:20,140 --> 00:55:22,019
name is and then check to see whether

2852
00:55:22,019 --> 00:55:22,029
 

2853
00:55:22,029 --> 00:55:23,819
that matches the query or the the

2854
00:55:23,819 --> 00:55:23,829
 

2855
00:55:23,829 --> 00:55:26,849
predicate and our where clause and if it

2856
00:55:26,849 --> 00:55:26,859
 

2857
00:55:26,859 --> 00:55:28,559
does match what do we need next well we

2858
00:55:28,559 --> 00:55:28,569
 

2859
00:55:28,569 --> 00:55:30,870
need the login right because we want to

2860
00:55:30,870 --> 00:55:30,880
 

2861
00:55:30,880 --> 00:55:33,029
do the group line it's the same thing as

2862
00:55:33,029 --> 00:55:33,039

2863
00:55:33,039 --> 00:55:34,529
we're going long as we check the host

2864
00:55:34,529 --> 00:55:34,539
 

2865
00:55:34,539 --> 00:55:36,450
name if it matches then we want to go

2866
00:55:36,450 --> 00:55:36,460
 

2867
00:55:36,460 --> 00:55:38,970
also then read the last login to then

2868
00:55:38,970 --> 00:55:38,980
 

2869
00:55:38,980 --> 00:55:41,819
build out our hash table or if we're

2870
00:55:41,819 --> 00:55:41,829
 

2871
00:55:41,829 --> 00:55:44,039
doing sorting aggregation to fill out

2872
00:55:44,039 --> 00:55:44,049

2873
00:55:44,049 --> 00:55:47,549
some intermediate heap or byte array to

2874
00:55:47,549 --> 00:55:47,559
 

2875
00:55:47,559 --> 00:55:48,539
say here's the values we're actually

2876
00:55:48,539 --> 00:55:48,549

2877
00:55:48,549 --> 00:55:50,549
back to pass our predicate and we can

2878
00:55:50,549 --> 00:55:50,559
 

2879
00:55:50,559 --> 00:55:52,279
use them for the aggregation later one

2880
00:55:52,279 --> 00:55:52,289

2881
00:55:52,289 --> 00:55:56,130
so what's the problem with this what's

2882
00:55:56,130 --> 00:55:56,140
 

2883
00:55:56,140 --> 00:55:57,900
the problem for this query but I've

2884
00:55:57,900 --> 00:55:57,910
 

2885
00:55:57,910 --> 00:56:05,490
talked about so far what data did itdid

2886
00:56:05,490 --> 00:56:05,500
 

2887
00:56:05,500 --> 00:56:08,700
I have to read for this query I only

2888
00:56:08,700 --> 00:56:08,710
 

2889
00:56:08,710 --> 00:56:11,400
access two attributes right last login

2890
00:56:11,400 --> 00:56:11,410
 

2891
00:56:11,410 --> 00:56:19,920
and hostname yes exactly I only need two

2892
00:56:19,920 --> 00:56:19,930
 

2893
00:56:19,930 --> 00:56:22,559
columns but I had this huge chunk here

2894
00:56:22,559 --> 00:56:22,569
 

2895
00:56:22,569 --> 00:56:25,140
that I had to fetch in because they're

2896
00:56:25,140 --> 00:56:25,150

2897
00:56:25,150 --> 00:56:27,960
stored together with the tuple all right

2898
00:56:27,960 --> 00:56:27,970
 

2899
00:56:27,970 --> 00:56:29,519
it's unavoidable so even though my query

2900
00:56:29,519 --> 00:56:29,529
 

2901
00:56:29,529 --> 00:56:31,829
doesn't need this it comes along for the

2902
00:56:31,829 --> 00:56:31,839
 

2903
00:56:31,839 --> 00:56:34,079
ride when I go fetch the page so this is

2904
00:56:34,079 --> 00:56:34,089
 

2905
00:56:34,089 --> 00:56:39,000
all now uses data so for you can sort of

2906
00:56:39,000 --> 00:56:39,010
 

2907
00:56:39,010 --> 00:56:41,160
think about as the the the data that I

2908
00:56:41,160 --> 00:56:41,170
 

2909
00:56:41,170 --> 00:56:42,809
actually I need to read it to actually

2910
00:56:42,809 --> 00:56:42,819
 

2911
00:56:42,819 --> 00:56:45,240
process this query I produced the result

2912
00:56:45,240 --> 00:56:45,250
 

2913
00:56:45,250 --> 00:56:46,980
I also have to read other useless data

2914
00:56:46,980 --> 00:56:46,990
 

2915
00:56:46,990 --> 00:56:48,870
just because they're they're tucked in

2916
00:56:48,870 --> 00:56:48,880
 

2917
00:56:48,880 --> 00:56:51,570
the page with them right and that's the

2918
00:56:51,570 --> 00:56:51,580
 

2919
00:56:51,580 --> 00:56:54,260
problem with the the row storage of the

2920
00:56:54,260 --> 00:56:54,270
 

2921
00:56:54,270 --> 00:56:57,810
NSM storage model for for its peak

2922
00:56:57,810 --> 00:56:57,820
 

2923
00:56:57,820 --> 00:56:59,730
queries so what the advantages are that

2924
00:56:59,730 --> 00:56:59,740
 

2925
00:56:59,740 --> 00:57:01,710
it's really fast for inserts updating

2926
00:57:01,710 --> 00:57:01,720
 

2927
00:57:01,720 --> 00:57:03,840
deletes because all the data that I need

2928
00:57:03,840 --> 00:57:03,850
 

2929
00:57:03,850 --> 00:57:05,190
is gonna be right there I can just do

2930
00:57:05,190 --> 00:57:05,200
 

2931
00:57:05,200 --> 00:57:06,360
whatever I need to it without having to

2932
00:57:06,360 --> 00:57:06,370
 

2933
00:57:06,370 --> 00:57:08,970
go fetch other pages and it's good for

2934
00:57:08,970 --> 00:57:08,980
 

2935
00:57:08,980 --> 00:57:10,170
queries are doing select star because

2936
00:57:10,170 --> 00:57:10,180
 

2937
00:57:10,180 --> 00:57:12,300
again everything's always there but as I

2938
00:57:12,300 --> 00:57:12,310
 

2939
00:57:12,310 --> 00:57:14,700
said it's bad for doing OLAP queries

2940
00:57:14,700 --> 00:57:14,710
 

2941
00:57:14,710 --> 00:57:17,010
that typically only scan a portion of

2942
00:57:17,010 --> 00:57:17,020
 

2943
00:57:17,020 --> 00:57:18,210
the total number of columns and have to

2944
00:57:18,210 --> 00:57:18,220
 

2945
00:57:18,220 --> 00:57:21,600
look at the entire table so this is the

2946
00:57:21,600 --> 00:57:21,610
 

2947
00:57:21,610 --> 00:57:23,070
alternative is called the decomposition

2948
00:57:23,070 --> 00:57:23,080
 

2949
00:57:23,080 --> 00:57:25,650
storage model or more closely known as

2950
00:57:25,650 --> 00:57:25,660
 

2951
00:57:25,660 --> 00:57:28,260
column stores so column storage and the

2952
00:57:28,260 --> 00:57:28,270

2953
00:57:28,270 --> 00:57:30,810
idea here is that instead of storing for

2954
00:57:30,810 --> 00:57:30,820
 

2955
00:57:30,820 --> 00:57:33,000
a single tuple all its attributes and

2956
00:57:33,000 --> 00:57:33,010
 

2957
00:57:33,010 --> 00:57:34,350
then go to the next tuple strong strong

2958
00:57:34,350 --> 00:57:34,360
 

2959
00:57:34,360 --> 00:57:36,450
its attributes we're gonna take a single

2960
00:57:36,450 --> 00:57:36,460
 

2961
00:57:36,460 --> 00:57:39,630
attribute or column and store all the

2962
00:57:39,630 --> 00:57:39,640
 

2963
00:57:39,640 --> 00:57:42,360
values continuously for all the tuples

2964
00:57:42,360 --> 00:57:42,370

2965
00:57:42,370 --> 00:57:44,670
for that single attribute together in

2966
00:57:44,670 --> 00:57:44,680
 

2967
00:57:44,680 --> 00:57:48,390
our pages so then what happens is when

2968
00:57:48,390 --> 00:57:48,400
 

2969
00:57:48,400 --> 00:57:50,280
we have to go then read that data and

2970
00:57:50,280 --> 00:57:50,290
 

2971
00:57:50,290 --> 00:57:52,860
our query we only end up going to read

2972
00:57:52,860 --> 00:57:52,870
 

2973
00:57:52,870 --> 00:57:54,390
the data we actually need we don't read

2974
00:57:54,390 --> 00:57:54,400
 

2975
00:57:54,400 --> 00:57:57,540
stuff that we don't need so to go back

2976
00:57:57,540 --> 00:57:57,550
 

2977
00:57:57,550 --> 00:57:59,340
to our example before again this is when

2978
00:57:59,340 --> 00:57:59,350
 

2979
00:57:59,350 --> 00:58:01,140
we were storing as a row store or the

2980
00:58:01,140 --> 00:58:01,150

2981
00:58:01,150 --> 00:58:05,790
NSM if we break up now all the

2982
00:58:05,790 --> 00:58:05,800
 

2983
00:58:05,800 --> 00:58:08,250
attributes in two columns and now store

2984
00:58:08,250 --> 00:58:08,260
 

2985
00:58:08,260 --> 00:58:10,530
them all within a single page right sort

2986
00:58:10,530 --> 00:58:10,540
 

2987
00:58:10,540 --> 00:58:12,090
of think of the row stores like this the

2988
00:58:12,090 --> 00:58:12,100
 

2989
00:58:12,100 --> 00:58:13,520
column store is storing things like that

2990
00:58:13,520 --> 00:58:13,530
 

2991
00:58:13,530 --> 00:58:16,320
so I'll take the I'll take the host name

2992
00:58:16,320 --> 00:58:16,330
 

2993
00:58:16,330 --> 00:58:19,290
column and I'll make a page it only has

2994
00:58:19,290 --> 00:58:19,300
 

2995
00:58:19,300 --> 00:58:21,540
the host name so this is the host name

2996
00:58:21,540 --> 00:58:21,550
 

2997
00:58:21,550 --> 00:58:22,800
for the first two bullet and then host

2998
00:58:22,800 --> 00:58:22,810
 

2999
00:58:22,810 --> 00:58:24,060
name for the second tuple and so forth

3000
00:58:24,060 --> 00:58:24,070
 

3001
00:58:24,070 --> 00:58:26,220
all my single page and I'm not going to

3002
00:58:26,220 --> 00:58:26,230
 

3003
00:58:26,230 --> 00:58:28,500
mix up data from other attributes if I

3004
00:58:28,500 --> 00:58:28,510
 

3005
00:58:28,510 --> 00:58:30,120
have space right we say this page only

3006
00:58:30,120 --> 00:58:30,130

3007
00:58:30,130 --> 00:58:34,110
stores data for this column and so I'll

3008
00:58:34,110 --> 00:58:34,120
 

3009
00:58:34,120 --> 00:58:35,640
do this I'll have you know different

3010
00:58:35,640 --> 00:58:35,650
 

3011
00:58:35,650 --> 00:58:38,460
pages for for all the attributes so now

3012
00:58:38,460 --> 00:58:38,470
 

3013
00:58:38,470 --> 00:58:41,010
if we go back to our query that we have

3014
00:58:41,010 --> 00:58:41,020
 

3015
00:58:41,020 --> 00:58:43,560
problems with in the row store now to

3016
00:58:43,560 --> 00:58:43,570
 

3017
00:58:43,570 --> 00:58:45,720
execute the the scan with the where

3018
00:58:45,720 --> 00:58:45,730
 

3019
00:58:45,730 --> 00:58:48,540
clause on hostname all I need to do is

3020
00:58:48,540 --> 00:58:48,550
 

3021
00:58:48,550 --> 00:58:50,220
actually really only get these two pages

3022
00:58:50,220 --> 00:58:50,230
 

3023
00:58:50,230 --> 00:58:52,080
right the first page will have the host

3024
00:58:52,080 --> 00:58:52,090
 

3025
00:58:52,090 --> 00:58:53,790
name and I've is ripped through this

3026
00:58:53,790 --> 00:58:53,800
 

3027
00:58:53,800 --> 00:58:56,850
really quickly and just check to see

3028
00:58:56,850 --> 00:58:56,860
 

3029
00:58:56,860 --> 00:58:59,079
what chuckles actually match and then

3030
00:58:59,079 --> 00:58:59,089
 

3031
00:58:59,089 --> 00:59:01,120
for the ones that do match then I can go

3032
00:59:01,120 --> 00:59:01,130
 

3033
00:59:01,130 --> 00:59:03,609
back to the hostname I started the the

3034
00:59:03,609 --> 00:59:03,619
 

3035
00:59:03,619 --> 00:59:06,819
the last login page and just go get the

3036
00:59:06,819 --> 00:59:06,829
 

3037
00:59:06,829 --> 00:59:10,479
values I need right in the case of the

3038
00:59:10,479 --> 00:59:10,489
 

3039
00:59:10,489 --> 00:59:11,229
row store

3040
00:59:11,229 --> 00:59:11,239
 

3041
00:59:11,239 --> 00:59:12,999
I didn't know what two poles actually

3042
00:59:12,999 --> 00:59:13,009
 

3043
00:59:13,009 --> 00:59:14,440
match until I actually looked at the

3044
00:59:14,440 --> 00:59:14,450
 

3045
00:59:14,450 --> 00:59:17,349
hostname so you end up reading not only

3046
00:59:17,349 --> 00:59:17,359
 

3047
00:59:17,359 --> 00:59:18,579
that the columns you know only actually

3048
00:59:18,579 --> 00:59:18,589
 

3049
00:59:18,589 --> 00:59:21,160
need you end up reading the the last log

3050
00:59:21,160 --> 00:59:21,170
 

3051
00:59:21,170 --> 00:59:23,410
and attribute for some people as you may

3052
00:59:23,410 --> 00:59:23,420
 

3053
00:59:23,420 --> 00:59:25,359
not need either as well in this case

3054
00:59:25,359 --> 00:59:25,369

3055
00:59:25,369 --> 00:59:26,769
here I'm only need to get the data that

3056
00:59:26,769 --> 00:59:26,779
 

3057
00:59:26,779 --> 00:59:29,109
I actually need that satisfy the first

3058
00:59:29,109 --> 00:59:29,119
 

3059
00:59:29,119 --> 00:59:33,700
predicate so is this clear right and

3060
00:59:33,700 --> 00:59:33,710
 

3061
00:59:33,710 --> 00:59:34,809
then you can do this sort of same

3062
00:59:34,809 --> 00:59:34,819
 

3063
00:59:34,819 --> 00:59:36,400
architecture as the slot is designed

3064
00:59:36,400 --> 00:59:36,410
 

3065
00:59:36,410 --> 00:59:37,479
that we talked about before it's just

3066
00:59:37,479 --> 00:59:37,489
 

3067
00:59:37,489 --> 00:59:39,640
now the slots are pointing to where you

3068
00:59:39,640 --> 00:59:39,650
 

3069
00:59:39,650 --> 00:59:42,910
can put the next value in so what's the

3070
00:59:42,910 --> 00:59:42,920
 

3071
00:59:42,920 --> 00:59:48,809
sort of big problem with this then yes

3072
00:59:48,809 --> 00:59:48,819


3073
00:59:48,819 --> 00:59:50,859
right so he says he won't do a select

3074
00:59:50,859 --> 00:59:50,869
 

3075
00:59:50,869 --> 00:59:52,059
star you got to go bunch of pages and

3076
00:59:52,059 --> 00:59:52,069
 

3077
00:59:52,069 --> 00:59:53,200
stitch things back together

3078
00:59:53,200 --> 00:59:53,210
 

3079
00:59:53,210 --> 00:59:54,640
you go over verse two if I went to an

3080
00:59:54,640 --> 00:59:54,650
 

3081
00:59:54,650 --> 00:59:56,559
update or an insert I gotta take it

3082
00:59:56,559 --> 00:59:56,569
 

3083
00:59:56,569 --> 00:59:58,029
split it back apart and write up read

3084
00:59:58,029 --> 00:59:58,039
 

3085
00:59:58,039 --> 01:00:00,849
this all out absolutely yes anything

3086
01:00:00,849 --> 01:00:00,859
 

3087
01:00:00,859 --> 01:00:06,700
else so I said here right as I'm as I'm

3088
01:00:06,700 --> 01:00:06,710
 

3089
01:00:06,710 --> 01:00:08,529
ripping through my host name some of

3090
01:00:08,529 --> 01:00:08,539
 

3091
01:00:08,539 --> 01:00:09,489
these will match some of these won't

3092
01:00:09,489 --> 01:00:09,499
 

3093
01:00:09,499 --> 01:00:12,729
match now I need to go back to the last

3094
01:00:12,729 --> 01:00:12,739
 

3095
01:00:12,739 --> 01:00:14,709
login page and find out find the tuples

3096
01:00:14,709 --> 01:00:14,719
 

3097
01:00:14,719 --> 01:00:16,299
that that that correspond the ones that

3098
01:00:16,299 --> 01:00:16,309

3099
01:00:16,309 --> 01:00:21,549
matched yes exactly

3100
01:00:21,549 --> 01:00:21,559

3101
01:00:21,559 --> 01:00:24,219
so your question is and then what I was

3102
01:00:24,219 --> 01:00:24,229
 

3103
01:00:24,229 --> 01:00:25,359
alluding to is how do you reconstruct

3104
01:00:25,359 --> 01:00:25,369
 

3105
01:00:25,369 --> 01:00:27,849
the tuple absolutely right so there's

3106
01:00:27,849 --> 01:00:27,859
 

3107
01:00:27,859 --> 01:00:30,729
two ways to do this the first you can

3108
01:00:30,729 --> 01:00:30,739
 

3109
01:00:30,739 --> 01:00:31,930
use all sets the other one you can use

3110
01:00:31,930 --> 01:00:31,940
 

3111
01:00:31,940 --> 01:00:32,880
the bedded IDs

3112
01:00:32,880 --> 01:00:32,890
 

3113
01:00:32,890 --> 01:00:35,829
so with all sets the way it works is

3114
01:00:35,829 --> 01:00:35,839

3115
01:00:35,839 --> 01:00:39,339
that you assume the attributes are all

3116
01:00:39,339 --> 01:00:39,349
 

3117
01:00:39,349 --> 01:00:42,069
fixed length right you know say column

3118
01:00:42,069 --> 01:00:42,079
 

3119
01:00:42,079 --> 01:00:43,900
is an integer they're always gonna be 32

3120
01:00:43,900 --> 01:00:43,910
 

3121
01:00:43,910 --> 01:00:47,140
bit or 32 bit integers so now what'll

3122
01:00:47,140 --> 01:00:47,150
 

3123
01:00:47,150 --> 01:00:49,120
happen to say if I'm if I'm ripping

3124
01:00:49,120 --> 01:00:49,130
 

3125
01:00:49,130 --> 01:00:50,589
through the host name field assuming

3126
01:00:50,589 --> 01:00:50,599
 

3127
01:00:50,599 --> 01:00:53,559
it's fixed length and they say v tuple

3128
01:00:53,559 --> 01:00:53,569
 

3129
01:00:53,569 --> 01:00:56,049
matches now when I want to go get its

3130
01:00:56,049 --> 01:00:56,059
 

3131
01:00:56,059 --> 01:00:58,539
corresponding attributes from values for

3132
01:00:58,539 --> 01:00:58,549
 

3133
01:00:58,549 --> 01:01:00,700
the last login column I just know how to

3134
01:01:00,700 --> 01:01:00,710
 

3135
01:01:00,710 --> 01:01:03,670
jump to the to the fifth one right when

3136
01:01:03,670 --> 01:01:03,680
 

3137
01:01:03,680 --> 01:01:04,749
you have variable length fields this

3138
01:01:04,749 --> 01:01:04,759
 

3139
01:01:04,759 --> 01:01:06,969
gets tricky you either have to pad them

3140
01:01:06,969 --> 01:01:06,979
 

3141
01:01:06,979 --> 01:01:09,599
out so they're always the max size of

3142
01:01:09,599 --> 01:01:09,609
 

3143
01:01:09,609 --> 01:01:12,130
what they'd actually could ever be or

3144
01:01:12,130 --> 01:01:12,140
 

3145
01:01:12,140 --> 01:01:13,360
you can use diction

3146
01:01:13,360 --> 01:01:13,370
 

3147
01:01:13,370 --> 01:01:15,310
encoding where you destroy things as

3148
01:01:15,310 --> 01:01:15,320
 

3149
01:01:15,320 --> 01:01:16,930
fixed-point fixed with integers and then

3150
01:01:16,930 --> 01:01:16,940
 

3151
01:01:16,940 --> 01:01:18,070
you have a mapping table to map those

3152
01:01:18,070 --> 01:01:18,080
 

3153
01:01:18,080 --> 01:01:19,990
integers to the original values alright

3154
01:01:19,990 --> 01:01:20,000
 

3155
01:01:20,000 --> 01:01:22,870
different systems do different things so

3156
01:01:22,870 --> 01:01:22,880
 

3157
01:01:22,880 --> 01:01:24,340
you can use offsets the alternative

3158
01:01:24,340 --> 01:01:24,350
 

3159
01:01:24,350 --> 01:01:26,440
which I think this shows up in some of

3160
01:01:26,440 --> 01:01:26,450
 

3161
01:01:26,450 --> 01:01:27,610
the literature but I don't think anybody

3162
01:01:27,610 --> 01:01:27,620
 

3163
01:01:27,620 --> 01:01:29,860
actually does this is to actually embed

3164
01:01:29,860 --> 01:01:29,870
 

3165
01:01:29,870 --> 01:01:32,470
the values of the tuples or the tuple ID

3166
01:01:32,470 --> 01:01:32,480
 

3167
01:01:32,480 --> 01:01:34,960
inside the every single value inside the

3168
01:01:34,960 --> 01:01:34,970
 

3169
01:01:34,970 --> 01:01:37,900
column itself right so for 2 plus 0 and

3170
01:01:37,900 --> 01:01:37,910
 

3171
01:01:37,910 --> 01:01:39,280
column a I've to store it and same

3172
01:01:39,280 --> 01:01:39,290

3173
01:01:39,290 --> 01:01:41,110
fourth same as for all the all the other

3174
01:01:41,110 --> 01:01:41,120
 

3175
01:01:41,120 --> 01:01:43,330
columns I don't think I'm actually does

3176
01:01:43,330 --> 01:01:43,340
 

3177
01:01:43,340 --> 01:01:45,610
this because you still need an index to

3178
01:01:45,610 --> 01:01:45,620
 

3179
01:01:45,620 --> 01:01:48,340
say if I want you know offset 5 or 2 yd

3180
01:01:48,340 --> 01:01:48,350
 

3181
01:01:48,350 --> 01:01:51,790
5 how to jump into that as far as I know

3182
01:01:51,790 --> 01:01:51,800
 

3183
01:01:51,800 --> 01:01:53,470
all the column stores actually use the

3184
01:01:53,470 --> 01:01:53,480
 

3185
01:01:53,480 --> 01:01:59,580
offset approach alright alright so the

3186
01:01:59,580 --> 01:01:59,590
 

3187
01:01:59,590 --> 01:02:04,090
the advantages of the DSM is that for

3188
01:02:04,090 --> 01:02:04,100
 

3189
01:02:04,100 --> 01:02:05,620
OLAP queries we only uh know how many

3190
01:02:05,620 --> 01:02:05,630
 

3191
01:02:05,630 --> 01:02:08,200
read the data that we actually need and

3192
01:02:08,200 --> 01:02:08,210
 

3193
01:02:08,210 --> 01:02:10,420
this is to make things be much much

3194
01:02:10,420 --> 01:02:10,430
 

3195
01:02:10,430 --> 01:02:13,270
faster we'll see this later on when we

3196
01:02:13,270 --> 01:02:13,280
 

3197
01:02:13,280 --> 01:02:14,530
talk about query processing there are

3198
01:02:14,530 --> 01:02:14,540
 

3199
01:02:14,540 --> 01:02:16,930
some additional optimizations we can do

3200
01:02:16,930 --> 01:02:16,940

3201
01:02:16,940 --> 01:02:19,780
where if we know that we're just

3202
01:02:19,780 --> 01:02:19,790
 

3203
01:02:19,790 --> 01:02:23,020
operating on on on all sets the columns

3204
01:02:23,020 --> 01:02:23,030

3205
01:02:23,030 --> 01:02:24,820
maybe we don't actually retrieve the

3206
01:02:24,820 --> 01:02:24,830
 

3207
01:02:24,830 --> 01:02:26,380
data until the very last moment we

3208
01:02:26,380 --> 01:02:26,390
 

3209
01:02:26,390 --> 01:02:28,120
actually need it right we just

3210
01:02:28,120 --> 01:02:28,130
 

3211
01:02:28,130 --> 01:02:29,740
manipulate these offsets as far as we

3212
01:02:29,740 --> 01:02:29,750

3213
01:02:29,750 --> 01:02:30,970
can up the query plan and then only go

3214
01:02:30,970 --> 01:02:30,980
 

3215
01:02:30,980 --> 01:02:32,350
back and get the data when we as you

3216
01:02:32,350 --> 01:02:32,360
 

3217
01:02:32,360 --> 01:02:33,820
have to finally show an answer to a

3218
01:02:33,820 --> 01:02:33,830
 

3219
01:02:33,830 --> 01:02:38,410
human the for compression there's some

3220
01:02:38,410 --> 01:02:38,420
 

3221
01:02:38,420 --> 01:02:40,000
optimizations we can do because we now

3222
01:02:40,000 --> 01:02:40,010
 

3223
01:02:40,010 --> 01:02:41,260
we know all the values are going to be

3224
01:02:41,260 --> 01:02:41,270
 

3225
01:02:41,270 --> 01:02:43,960
sorted in the same domain so we can do

3226
01:02:43,960 --> 01:02:43,970
 

3227
01:02:43,970 --> 01:02:46,420
want more more sophisticated encoding

3228
01:02:46,420 --> 01:02:46,430
 

3229
01:02:46,430 --> 01:02:48,460
schemes beyond to sort of you know gzip

3230
01:02:48,460 --> 01:02:48,470
 

3231
01:02:48,470 --> 01:02:50,920
or dictionary compression so for example

3232
01:02:50,920 --> 01:02:50,930
 

3233
01:02:50,930 --> 01:02:53,380
if I know that I'm throwing a sex field

3234
01:02:53,380 --> 01:02:53,390
 

3235
01:02:53,390 --> 01:02:55,420
and to say that's just either male or

3236
01:02:55,420 --> 01:02:55,430
 

3237
01:02:55,430 --> 01:02:58,210
female it's only be either one or two

3238
01:02:58,210 --> 01:02:58,220
 

3239
01:02:58,220 --> 01:02:59,890
values so now maybe I can run length

3240
01:02:59,890 --> 01:02:59,900
 

3241
01:02:59,900 --> 01:03:02,260
encoding or other ways to compress that

3242
01:03:02,260 --> 01:03:02,270

3243
01:03:02,270 --> 01:03:05,470
down further and then the disadvantage

3244
01:03:05,470 --> 01:03:05,480
 

3245
01:03:05,480 --> 01:03:07,840
is what he pointed out was now anytime I

3246
01:03:07,840 --> 01:03:07,850
 

3247
01:03:07,850 --> 01:03:10,150
want to do an insert or I do a select

3248
01:03:10,150 --> 01:03:10,160
 

3249
01:03:10,160 --> 01:03:12,610
star I had to break everything apart

3250
01:03:12,610 --> 01:03:12,620
 

3251
01:03:12,620 --> 01:03:14,590
across the columns to store things or

3252
01:03:14,590 --> 01:03:14,600
 

3253
01:03:14,600 --> 01:03:16,000
put it back together to produce our

3254
01:03:16,000 --> 01:03:16,010

3255
01:03:16,010 --> 01:03:18,940
final result all right now there are

3256
01:03:18,940 --> 01:03:18,950
 

3257
01:03:18,950 --> 01:03:19,990
some optimizations we can talk about

3258
01:03:19,990 --> 01:03:20,000

3259
01:03:20,000 --> 01:03:22,030
later on of how to make inserts and

3260
01:03:22,030 --> 01:03:22,040
 

3261
01:03:22,040 --> 01:03:23,980
updates really fast by sort of having a

3262
01:03:23,980 --> 01:03:23,990

3263
01:03:23,990 --> 01:03:25,750
roast or in front of a column store and

3264
01:03:25,750 --> 01:03:25,760
 

3265
01:03:25,760 --> 01:03:27,310
this is the general approach that most

3266
01:03:27,310 --> 01:03:27,320
 

3267
01:03:27,320 --> 01:03:30,040
people use but if you have a sort of

3268
01:03:30,040 --> 01:03:30,050
 

3269
01:03:30,050 --> 01:03:31,630
pure columnstore you would have to split

3270
01:03:31,630 --> 01:03:31,640
 

3271
01:03:31,640 --> 01:03:35,770
up each time alright so any high-level

3272
01:03:35,770 --> 01:03:35,780
 

3273
01:03:35,780 --> 01:03:46,090
questions about this yes alright so his

3274
01:03:46,090 --> 01:03:46,100
 

3275
01:03:46,100 --> 01:03:48,250
question is how do you support native

3276
01:03:48,250 --> 01:03:48,260
 

3277
01:03:48,260 --> 01:03:49,990
how do databases that need to support

3278
01:03:49,990 --> 01:03:50,000
 

3279
01:03:50,000 --> 01:03:52,030
both types of workloads actually do this

3280
01:03:52,030 --> 01:03:52,040
 

3281
01:03:52,040 --> 01:03:54,070
that's a whole nother lecture actually

3282
01:03:54,070 --> 01:03:54,080
 

3283
01:03:54,080 --> 01:03:59,020
we could do so the there's a couple

3284
01:03:59,020 --> 01:03:59,030
 

3285
01:03:59,030 --> 01:04:02,200
different ways one is that you said we

3286
01:04:02,200 --> 01:04:02,210
 

3287
01:04:02,210 --> 01:04:04,540
have two storage engines or two two

3288
01:04:04,540 --> 01:04:04,550
 

3289
01:04:04,550 --> 01:04:06,190
executions inside the same database

3290
01:04:06,190 --> 01:04:06,200
 

3291
01:04:06,200 --> 01:04:08,350
system so mem sequel does this mem

3292
01:04:08,350 --> 01:04:08,360
 

3293
01:04:08,360 --> 01:04:09,700
sequel you can declare you have a row

3294
01:04:09,700 --> 01:04:09,710
 

3295
01:04:09,710 --> 01:04:11,740
store and then you can also declare you

3296
01:04:11,740 --> 01:04:11,750
 

3297
01:04:11,750 --> 01:04:13,990
have a column store in that in their

3298
01:04:13,990 --> 01:04:14,000
 

3299
01:04:14,000 --> 01:04:15,490
case as far as I know in that system you

3300
01:04:15,490 --> 01:04:15,500
 

3301
01:04:15,500 --> 01:04:17,050
have them you can't sort of

3302
01:04:17,050 --> 01:04:17,060
 

3303
01:04:17,060 --> 01:04:18,940
automatically migrate data from one to

3304
01:04:18,940 --> 01:04:18,950
 

3305
01:04:18,950 --> 01:04:20,680
the next you have to sort of dump out

3306
01:04:20,680 --> 01:04:20,690
 

3307
01:04:20,690 --> 01:04:21,940
the data from the row store and then

3308
01:04:21,940 --> 01:04:21,950
 

3309
01:04:21,950 --> 01:04:23,860
reinsert it into the column store now

3310
01:04:23,860 --> 01:04:23,870

3311
01:04:23,870 --> 01:04:25,150
there's some systems that try to be

3312
01:04:25,150 --> 01:04:25,160
 

3313
01:04:25,160 --> 01:04:27,250
clever and underneath the covers do that

3314
01:04:27,250 --> 01:04:27,260
 

3315
01:04:27,260 --> 01:04:29,620
migration transparently we're originally

3316
01:04:29,620 --> 01:04:29,630
 

3317
01:04:29,630 --> 01:04:31,390
doing this for our system at CMU we end

3318
01:04:31,390 --> 01:04:31,400
 

3319
01:04:31,400 --> 01:04:33,460
up banning it because it was too much

3320
01:04:33,460 --> 01:04:33,470
 

3321
01:04:33,470 --> 01:04:37,600
engineering overhead the other approach

3322
01:04:37,600 --> 01:04:37,610
 

3323
01:04:37,610 --> 01:04:40,900
is to actually have a you basically

3324
01:04:40,900 --> 01:04:40,910
 

3325
01:04:40,910 --> 01:04:45,130
maintain a Arena link copy of the

3326
01:04:45,130 --> 01:04:45,140
 

3327
01:04:45,140 --> 01:04:47,230
database in a column store format this

3328
01:04:47,230 --> 01:04:47,240
 

3329
01:04:47,240 --> 01:04:48,580
is called fracturing mirrors this is

3330
01:04:48,580 --> 01:04:48,590
 

3331
01:04:48,590 --> 01:04:50,620
what Oracle does so I insert everything

3332
01:04:50,620 --> 01:04:50,630
 

3333
01:04:50,630 --> 01:04:52,960
as my row store and then in the

3334
01:04:52,960 --> 01:04:52,970
 

3335
01:04:52,970 --> 01:04:54,580
background I'll make a I'll make a copy

3336
01:04:54,580 --> 01:04:54,590
 

3337
01:04:54,590 --> 01:04:56,440
of it as a column store and any

3338
01:04:56,440 --> 01:04:56,450
 

3339
01:04:56,450 --> 01:04:58,870
analytical query that could use it is

3340
01:04:58,870 --> 01:04:58,880
 

3341
01:04:58,880 --> 01:05:01,870
then redirected to that thing all right

3342
01:05:01,870 --> 01:05:01,880
 

3343
01:05:01,880 --> 01:05:03,690
so there's a bunch of approaches leave

3344
01:05:03,690 --> 01:05:03,700
 

3345
01:05:03,700 --> 01:05:05,740
the most of this way to think about is

3346
01:05:05,740 --> 01:05:05,750
 

3347
01:05:05,750 --> 01:05:07,030
do you have a little mini roast or that

3348
01:05:07,030 --> 01:05:07,040
 

3349
01:05:07,040 --> 01:05:08,890
you just append changes to and then

3350
01:05:08,890 --> 01:05:08,900
 

3351
01:05:08,900 --> 01:05:10,630
every so often there's a background

3352
01:05:10,630 --> 01:05:10,640
 

3353
01:05:10,640 --> 01:05:12,100
process that merges it into the column

3354
01:05:12,100 --> 01:05:12,110
 

3355
01:05:12,110 --> 01:05:13,510
store but that case you have to be

3356
01:05:13,510 --> 01:05:13,520
 

3357
01:05:13,520 --> 01:05:15,430
careful about making sure that like you

3358
01:05:15,430 --> 01:05:15,440
 

3359
01:05:15,440 --> 01:05:18,310
know if images a read in one side you

3360
01:05:18,310 --> 01:05:18,320
 

3361
01:05:18,320 --> 01:05:19,780
know if they're reading something that

3362
01:05:19,780 --> 01:05:19,790
 

3363
01:05:19,790 --> 01:05:21,730
hasn't made it to the column store yet

3364
01:05:21,730 --> 01:05:21,740
 

3365
01:05:21,740 --> 01:05:22,840
that you don't miss it because it's an

3366
01:05:22,840 --> 01:05:22,850
 

3367
01:05:22,850 --> 01:05:29,050
it's in the the deltal store so this

3368
01:05:29,050 --> 01:05:29,060
 

3369
01:05:29,060 --> 01:05:30,280
question is do you always use twice

3370
01:05:30,280 --> 01:05:30,290
 

3371
01:05:30,290 --> 01:05:32,290
twice amount of storage if you're doing

3372
01:05:32,290 --> 01:05:32,300
 

3373
01:05:32,300 --> 01:05:33,610
the fraction mirror approach if you're

3374
01:05:33,610 --> 01:05:33,620

3375
01:05:33,620 --> 01:05:36,520
making the copy you have to yes it's not

3376
01:05:36,520 --> 01:05:36,530
 

3377
01:05:36,530 --> 01:05:38,260
always gonna be exactly - twice as much

3378
01:05:38,260 --> 01:05:38,270
 

3379
01:05:38,270 --> 01:05:39,730
because again on a column store you can

3380
01:05:39,730 --> 01:05:39,740
 

3381
01:05:39,740 --> 01:05:40,900
compress it much better

3382
01:05:40,900 --> 01:05:40,910
 

3383
01:05:40,910 --> 01:05:44,050
roast or but in general if you're not

3384
01:05:44,050 --> 01:05:44,060
 

3385
01:05:44,060 --> 01:05:45,850
compressing then in that case yes if

3386
01:05:45,850 --> 01:05:45,860
 

3387
01:05:45,860 --> 01:05:46,960
we're doing the Delta store know the

3388
01:05:46,960 --> 01:05:46,970
 

3389
01:05:46,970 --> 01:05:48,490
Delta stores usually much smaller and

3390
01:05:48,490 --> 01:05:48,500
 

3391
01:05:48,500 --> 01:05:50,080
then you migrate things to the column

3392
01:05:50,080 --> 01:05:50,090

3393
01:05:50,090 --> 01:05:51,940
store where it exists permanently

3394
01:05:51,940 --> 01:05:51,950

3395
01:05:51,950 --> 01:05:56,380
I mean I'll check the schedule maybe we

3396
01:05:56,380 --> 01:05:56,390

3397
01:05:56,390 --> 01:05:57,670
should talk about this a bit more too as

3398
01:05:57,670 --> 01:05:57,680
 

3399
01:05:57,680 --> 01:06:02,020
later on alright so comm stores are hot

3400
01:06:02,020 --> 01:06:02,030
 

3401
01:06:02,030 --> 01:06:04,060
now open which every newer database

3402
01:06:04,060 --> 01:06:04,070
 

3403
01:06:04,070 --> 01:06:05,080
system that's doing analytics that's

3404
01:06:05,080 --> 01:06:05,090
 

3405
01:06:05,090 --> 01:06:07,510
been developed in the last eight or ten

3406
01:06:07,510 --> 01:06:07,520
 

3407
01:06:07,520 --> 01:06:10,450
years is a column store but the core

3408
01:06:10,450 --> 01:06:10,460
 

3409
01:06:10,460 --> 01:06:12,700
idea is not new it actually goes back to

3410
01:06:12,700 --> 01:06:12,710
 

3411
01:06:12,710 --> 01:06:15,550
the 1970s so there's a early system

3412
01:06:15,550 --> 01:06:15,560
 

3413
01:06:15,560 --> 01:06:17,310
called cantor from the Swedish military

3414
01:06:17,310 --> 01:06:17,320
 

3415
01:06:17,320 --> 01:06:19,290
and this would never released publicly

3416
01:06:19,290 --> 01:06:19,300
 

3417
01:06:19,300 --> 01:06:22,120
there's only like one or two papers that

3418
01:06:22,120 --> 01:06:22,130
 

3419
01:06:22,130 --> 01:06:25,780
describe it they're in English and they

3420
01:06:25,780 --> 01:06:25,790
 

3421
01:06:25,790 --> 01:06:26,890
don't really describe it as being a

3422
01:06:26,890 --> 01:06:26,900
 

3423
01:06:26,900 --> 01:06:29,170
database system because back then you

3424
01:06:29,170 --> 01:06:29,180
 

3425
01:06:29,180 --> 01:06:31,480
know that that term wasn't wasn't you

3426
01:06:31,480 --> 01:06:31,490
 

3427
01:06:31,490 --> 01:06:33,280
know wasn't common as it is now and they

3428
01:06:33,280 --> 01:06:33,290
 

3429
01:06:33,290 --> 01:06:34,750
were mostly manipulating files but they

3430
01:06:34,750 --> 01:06:34,760
 

3431
01:06:34,760 --> 01:06:37,060
talk about these files being as a calm

3432
01:06:37,060 --> 01:06:37,070
 

3433
01:06:37,070 --> 01:06:40,510
oriented format then the 1990s there was

3434
01:06:40,510 --> 01:06:40,520
 

3435
01:06:40,520 --> 01:06:41,950
sort of the first academic paper that

3436
01:06:41,950 --> 01:06:41,960
 

3437
01:06:41,960 --> 01:06:43,810
describes what the decomposition storage

3438
01:06:43,810 --> 01:06:43,820

3439
01:06:43,820 --> 01:06:45,400
model looks like from a theoretical

3440
01:06:45,400 --> 01:06:45,410
 

3441
01:06:45,410 --> 01:06:48,280
standpoint but it was until the 1990s

3442
01:06:48,280 --> 01:06:48,290
 

3443
01:06:48,290 --> 01:06:50,200
when somebody actually actually

3444
01:06:50,200 --> 01:06:50,210
 

3445
01:06:50,210 --> 01:06:52,240
implemented what we now understand to be

3446
01:06:52,240 --> 01:06:52,250
 

3447
01:06:52,250 --> 01:06:55,440
a column store a DSM system so sybase IQ

3448
01:06:55,440 --> 01:06:55,450
 

3449
01:06:55,450 --> 01:06:59,740
was a in-memory query accelerator it's a

3450
01:06:59,740 --> 01:06:59,750
 

3451
01:06:59,750 --> 01:07:01,690
sort of big example I said before where

3452
01:07:01,690 --> 01:07:01,700
 

3453
01:07:01,700 --> 01:07:02,830
you have your roast or your doing

3454
01:07:02,830 --> 01:07:02,840
 

3455
01:07:02,840 --> 01:07:05,170
updates and then you could use sybase IQ

3456
01:07:05,170 --> 01:07:05,180
 

3457
01:07:05,180 --> 01:07:08,380
to make a in-memory columnar

3458
01:07:08,380 --> 01:07:08,390
 

3459
01:07:08,390 --> 01:07:09,940
representation or copy of the database

3460
01:07:09,940 --> 01:07:09,950

3461
01:07:09,950 --> 01:07:13,090
to make those queries go faster sybase

3462
01:07:13,090 --> 01:07:13,100
 

3463
01:07:13,100 --> 01:07:15,400
IQ actually still exists Sybase was

3464
01:07:15,400 --> 01:07:15,410
 

3465
01:07:15,410 --> 01:07:17,350
bought was a database start up in the

3466
01:07:17,350 --> 01:07:17,360
 

3467
01:07:17,360 --> 01:07:21,880
1980s got bought by sa p and the as far

3468
01:07:21,880 --> 01:07:21,890
 

3469
01:07:21,890 --> 01:07:22,930
as you know that the system is still

3470
01:07:22,930 --> 01:07:22,940
 

3471
01:07:22,940 --> 01:07:24,400
peoples to actually still use this in

3472
01:07:24,400 --> 01:07:24,410
 

3473
01:07:24,410 --> 01:07:27,610
the 2000s when the concerts really took

3474
01:07:27,610 --> 01:07:27,620
 

3475
01:07:27,620 --> 01:07:30,040
off there was a big movement a bunch of

3476
01:07:30,040 --> 01:07:30,050
 

3477
01:07:30,050 --> 01:07:31,180
newer systems that were built from

3478
01:07:31,180 --> 01:07:31,190
 

3479
01:07:31,190 --> 01:07:33,640
scratch not to be quit accelerators or

3480
01:07:33,640 --> 01:07:33,650
 

3481
01:07:33,650 --> 01:07:35,050
copies of the database actually to be

3482
01:07:35,050 --> 01:07:35,060
 

3483
01:07:35,060 --> 01:07:36,820
the primary storage location in the

3484
01:07:36,820 --> 01:07:36,830
 

3485
01:07:36,830 --> 01:07:39,190
database Vertica is probably most famous

3486
01:07:39,190 --> 01:07:39,200
 

3487
01:07:39,200 --> 01:07:42,460
one in full disclosure Vertica was was a

3488
01:07:42,460 --> 01:07:42,470
 

3489
01:07:42,470 --> 01:07:44,770
startup founded by my two advisers

3490
01:07:44,770 --> 01:07:44,780
 

3491
01:07:44,780 --> 01:07:47,200
before i started grad school got bought

3492
01:07:47,200 --> 01:07:47,210
 

3493
01:07:47,210 --> 01:07:50,080
by HP and then they got sold off again

3494
01:07:50,080 --> 01:07:50,090
 

3495
01:07:50,090 --> 01:07:52,780
to a holding company actually Vertica

3496
01:07:52,780 --> 01:07:52,790
 

3497
01:07:52,790 --> 01:07:53,980
has an office here in Pittsburgh and

3498
01:07:53,980 --> 01:07:53,990
 

3499
01:07:53,990 --> 01:07:55,240
there

3500
01:07:55,240 --> 01:07:55,250
 

3501
01:07:55,250 --> 01:07:57,500
if you wanna go talk to them

3502
01:07:57,500 --> 01:07:57,510
 

3503
01:07:57,510 --> 01:08:00,140
dr. wise and monie to be our two systems

3504
01:08:00,140 --> 01:08:00,150
 

3505
01:08:00,150 --> 01:08:03,740
that came out of Europe but in the two

3506
01:08:03,740 --> 01:08:03,750
 

3507
01:08:03,750 --> 01:08:05,450
thousand is when people should recognize

3508
01:08:05,450 --> 01:08:05,460
 

3509
01:08:05,460 --> 01:08:06,769
that for if you're doing any little

3510
01:08:06,769 --> 01:08:06,779
 

3511
01:08:06,779 --> 01:08:09,230
queries column stores are the way to go

3512
01:08:09,230 --> 01:08:09,240
 

3513
01:08:09,240 --> 01:08:12,319
and part of the reason why bees took off

3514
01:08:12,319 --> 01:08:12,329
 

3515
01:08:12,329 --> 01:08:13,849
in the 2000s because this is when the

3516
01:08:13,849 --> 01:08:13,859
 

3517
01:08:13,859 --> 01:08:15,140
internet was sort of starting to take

3518
01:08:15,140 --> 01:08:15,150
 

3519
01:08:15,150 --> 01:08:18,200
off and now a lot of people had a lot of

3520
01:08:18,200 --> 01:08:18,210
 

3521
01:08:18,210 --> 01:08:20,720
data right back in the 1980s 1990s only

3522
01:08:20,720 --> 01:08:20,730
 

3523
01:08:20,730 --> 01:08:22,370
really a small number like the fortune

3524
01:08:22,370 --> 01:08:22,380
 

3525
01:08:22,380 --> 01:08:24,680
ten companies have big data sets right

3526
01:08:24,680 --> 01:08:24,690
 

3527
01:08:24,690 --> 01:08:26,180
maybe some the big banks some of the big

3528
01:08:26,180 --> 01:08:26,190
 

3529
01:08:26,190 --> 01:08:28,430
retailers but now you know you can go

3530
01:08:28,430 --> 01:08:28,440
 

3531
01:08:28,440 --> 01:08:30,050
whip out a you know a Twitter app pretty

3532
01:08:30,050 --> 01:08:30,060
 

3533
01:08:30,060 --> 01:08:32,360
easily I start collecting a lot of data

3534
01:08:32,360 --> 01:08:32,370
 

3535
01:08:32,370 --> 01:08:33,800
so people are hitting these problems

3536
01:08:33,800 --> 01:08:33,810
 

3537
01:08:33,810 --> 01:08:35,899
with existing systems and this one comm

3538
01:08:35,899 --> 01:08:35,909
 

3539
01:08:35,909 --> 01:08:37,879
stores really took off then as I said

3540
01:08:37,879 --> 01:08:37,889
 

3541
01:08:37,889 --> 01:08:39,289
now in the 2010s

3542
01:08:39,289 --> 01:08:39,299
 

3543
01:08:39,299 --> 01:08:41,240
like if anybody is building a new

3544
01:08:41,240 --> 01:08:41,250
 

3545
01:08:41,250 --> 01:08:42,860
analytical database system and it's not

3546
01:08:42,860 --> 01:08:42,870
 

3547
01:08:42,870 --> 01:08:45,249
a column store it's it's a non-starter

3548
01:08:45,249 --> 01:08:45,259
 

3549
01:08:45,259 --> 01:08:47,599
right cuz users not gonna get the same

3550
01:08:47,599 --> 01:08:47,609
 

3551
01:08:47,609 --> 01:08:50,329
performance benefits you can get using

3552
01:08:50,329 --> 01:08:50,339
 

3553
01:08:50,339 --> 01:08:52,459
the DSM storage model versus the row

3554
01:08:52,459 --> 01:08:52,469
 

3555
01:08:52,469 --> 01:08:54,439
store and then this is just sort of a

3556
01:08:54,439 --> 01:08:54,449
 

3557
01:08:54,449 --> 01:08:57,890
smattering of a bunch of of a bunch of

3558
01:08:57,890 --> 01:08:57,900
 

3559
01:08:57,900 --> 01:09:00,050
column store databases that or that that

3560
01:09:00,050 --> 01:09:00,060
 

3561
01:09:00,060 --> 01:09:01,490
I'm aware of there's way more than this

3562
01:09:01,490 --> 01:09:01,500
 

3563
01:09:01,500 --> 01:09:03,499
but that just I quickly put up a bunch

3564
01:09:03,499 --> 01:09:03,509
 

3565
01:09:03,509 --> 01:09:07,910
of them okay all right any questions

3566
01:09:07,910 --> 01:09:07,920
 

3567
01:09:07,920 --> 01:09:11,390
about this column starts are hot you'll

3568
01:09:11,390 --> 01:09:11,400
 

3569
01:09:11,400 --> 01:09:12,470
see this all the time but it's good to

3570
01:09:12,470 --> 01:09:12,480
 

3571
01:09:12,480 --> 01:09:15,740
understand what's actually going on okay

3572
01:09:15,740 --> 01:09:15,750
 

3573
01:09:15,750 --> 01:09:19,459
so the main takeaway at this point

3574
01:09:19,459 --> 01:09:19,469
 

3575
01:09:19,469 --> 01:09:21,169
before we start moving now into memory

3576
01:09:21,169 --> 01:09:21,179
 

3577
01:09:21,179 --> 01:09:23,329
so the memory side of the database

3578
01:09:23,329 --> 01:09:23,339
 

3579
01:09:23,339 --> 01:09:26,479
system is that the storage manager

3580
01:09:26,479 --> 01:09:26,489
 

3581
01:09:26,489 --> 01:09:28,849
ideally would be independent to the rest

3582
01:09:28,849 --> 01:09:28,859
 

3583
01:09:28,859 --> 01:09:31,099
of the system but in actuality in some

3584
01:09:31,099 --> 01:09:31,109
 

3585
01:09:31,109 --> 01:09:32,840
ways it's not always the case

3586
01:09:32,840 --> 01:09:32,850
 

3587
01:09:32,850 --> 01:09:35,749
right because we'll help expose some

3588
01:09:35,749 --> 01:09:35,759
 

3589
01:09:35,759 --> 01:09:37,370
information about you know what the

3590
01:09:37,370 --> 01:09:37,380
 

3591
01:09:37,380 --> 01:09:39,019
layout is or how we're actually storing

3592
01:09:39,019 --> 01:09:39,029
 

3593
01:09:39,029 --> 01:09:40,910
these pages to the upper level parts of

3594
01:09:40,910 --> 01:09:40,920
 

3595
01:09:40,920 --> 01:09:42,700
the system that we can then use for

3596
01:09:42,700 --> 01:09:42,710
 

3597
01:09:42,710 --> 01:09:44,840
optimizing our queries or doing other

3598
01:09:44,840 --> 01:09:44,850
 

3599
01:09:44,850 --> 01:09:47,450
more sophisticated operations on the

3600
01:09:47,450 --> 01:09:47,460
 

3601
01:09:47,460 --> 01:09:49,220
data other than is treating as you know

3602
01:09:49,220 --> 01:09:49,230
 

3603
01:09:49,230 --> 01:09:52,129
black box on the file system and then as

3604
01:09:52,129 --> 01:09:52,139
 

3605
01:09:52,139 --> 01:09:54,200
I said choosing the right storage model

3606
01:09:54,200 --> 01:09:54,210
 

3607
01:09:54,210 --> 01:09:56,149
for your database system is really

3608
01:09:56,149 --> 01:09:56,159
 

3609
01:09:56,159 --> 01:09:59,600
important at the very beginning because

3610
01:09:59,600 --> 01:09:59,610
 

3611
01:09:59,610 --> 01:10:00,860
you want to make sure that you can get

3612
01:10:00,860 --> 01:10:00,870
 

3613
01:10:00,870 --> 01:10:02,629
all the optimizations are targeted right

3614
01:10:02,629 --> 01:10:02,639
 

3615
01:10:02,639 --> 01:10:04,850
sort of workload based on what you think

3616
01:10:04,850 --> 01:10:04,860
 

3617
01:10:04,860 --> 01:10:06,890
you need to do and so what I mean by

3618
01:10:06,890 --> 01:10:06,900
 

3619
01:10:06,900 --> 01:10:08,060
this is that it's

3620
01:10:08,060 --> 01:10:08,070
 

3621
01:10:08,070 --> 01:10:10,760
be very difficult to take a row storage

3622
01:10:10,760 --> 01:10:10,770
 

3623
01:10:10,770 --> 01:10:13,970
system and then build that out and then

3624
01:10:13,970 --> 01:10:13,980
 

3625
01:10:13,980 --> 01:10:17,410
come back okay I want to be calm store

3626
01:10:17,410 --> 01:10:17,420
 

3627
01:10:17,420 --> 01:10:19,910
it's not just you know just changing the

3628
01:10:19,910 --> 01:10:19,920
 

3629
01:10:19,920 --> 01:10:21,319
actual the to how you storing tuples in

3630
01:10:21,319 --> 01:10:21,329
 

3631
01:10:21,329 --> 01:10:22,790
the pages there's a whole bunch of other

3632
01:10:22,790 --> 01:10:22,800
 

3633
01:10:22,800 --> 01:10:26,359
see later on that if you that is

3634
01:10:26,359 --> 01:10:26,369
 

3635
01:10:26,369 --> 01:10:27,890
predicated on knowing whether you're a

3636
01:10:27,890 --> 01:10:27,900
 

3637
01:10:27,900 --> 01:10:30,260
pro store versus a column store so some

3638
01:10:30,260 --> 01:10:30,270

3639
01:10:30,270 --> 01:10:31,669
people try to do this with Postgres

3640
01:10:31,669 --> 01:10:31,679
 

3641
01:10:31,679 --> 01:10:33,050
right there's there's some people that

3642
01:10:33,050 --> 01:10:33,060

3643
01:10:33,060 --> 01:10:35,450
have extensions for Postgres to actually

3644
01:10:35,450 --> 01:10:35,460
 

3645
01:10:35,460 --> 01:10:37,280
store data as as a column store inside a

3646
01:10:37,280 --> 01:10:37,290
 

3647
01:10:37,290 --> 01:10:39,169
row store but the actual execution

3648
01:10:39,169 --> 01:10:39,179
 

3649
01:10:39,179 --> 01:10:41,359
engine itself is still a row oriented

3650
01:10:41,359 --> 01:10:41,369
 

3651
01:10:41,369 --> 01:10:43,250
storage engine whereas something like

3652
01:10:43,250 --> 01:10:43,260
 

3653
01:10:43,260 --> 01:10:45,680
Vertica which was based on Postgres they

3654
01:10:45,680 --> 01:10:45,690
 

3655
01:10:45,690 --> 01:10:47,089
actually ripped out all the execution

3656
01:10:47,089 --> 01:10:47,099
 

3657
01:10:47,099 --> 01:10:48,410
engine stuff and the store stuff and

3658
01:10:48,410 --> 01:10:48,420
 

3659
01:10:48,420 --> 01:10:50,030
built it from the ground up to be

3660
01:10:50,030 --> 01:10:50,040
 

3661
01:10:50,040 --> 01:10:52,189
explicitly a column store and you get

3662
01:10:52,189 --> 01:10:52,199
 

3663
01:10:52,199 --> 01:10:54,439
much much better performance all right

3664
01:10:54,439 --> 01:10:54,449
 

3665
01:10:54,449 --> 01:10:55,910
so it's sort of goes beyond just the

3666
01:10:55,910 --> 01:10:55,920
 

3667
01:10:55,920 --> 01:10:57,290
storage model stop but the main takeaway

3668
01:10:57,290 --> 01:10:57,300

3669
01:10:57,300 --> 01:10:58,669
here is again you have to know this

3670
01:10:58,669 --> 01:10:58,679
 

3671
01:10:58,679 --> 01:10:59,899
ahead of time because there's a bunch of

3672
01:10:59,899 --> 01:10:59,909
 

3673
01:10:59,909 --> 01:11:01,310
design decisions we're gonna make later

3674
01:11:01,310 --> 01:11:01,320
 

3675
01:11:01,320 --> 01:11:02,300
on

3676
01:11:02,300 --> 01:11:02,310

3677
01:11:02,310 --> 01:11:04,250
that'll be predicated on this you know

3678
01:11:04,250 --> 01:11:04,260
 

3679
01:11:04,260 --> 01:11:09,350
on this decision okay all right so next

3680
01:11:09,350 --> 01:11:09,360
 

3681
01:11:09,360 --> 01:11:12,020
class as I said in for data storage

3682
01:11:12,020 --> 01:11:12,030
 

3683
01:11:12,030 --> 01:11:14,510
there's these two parts right we've

3684
01:11:14,510 --> 01:11:14,520
 

3685
01:11:14,520 --> 01:11:16,850
covered the first one now we know how

3686
01:11:16,850 --> 01:11:16,860
 

3687
01:11:16,860 --> 01:11:18,260
the David says was gonna represent files

3688
01:11:18,260 --> 01:11:18,270
 

3689
01:11:18,270 --> 01:11:19,010
on disk

3690
01:11:19,010 --> 01:11:19,020

3691
01:11:19,020 --> 01:11:21,560
alright the actual data itself and now

3692
01:11:21,560 --> 01:11:21,570
 

3693
01:11:21,570 --> 01:11:22,640
we want start talking about how do we

3694
01:11:22,640 --> 01:11:22,650
 

3695
01:11:22,650 --> 01:11:24,140
actually bring this into memory in our

3696
01:11:24,140 --> 01:11:24,150
 

3697
01:11:24,150 --> 01:11:27,100
buffer pool and move data back and forth

3698
01:11:27,100 --> 01:11:27,110
 

3699
01:11:27,110 --> 01:11:34,280
okay any questions hi guys enjoy the

3700
01:11:34,280 --> 01:11:34,290
 

3701
01:11:34,290 --> 01:11:42,780
rain and I'll see you on Wednesday

3702
01:11:42,780 --> 01:11:42,790


3703
01:11:42,790 --> 01:11:48,040
yes it's the SD cricket IDE pests I make

3704
01:11:48,040 --> 01:11:48,050
 

3705
01:11:48,050 --> 01:11:50,530
them less unless I can do it like a Geo

3706
01:11:50,530 --> 01:11:50,540
 

3707
01:11:50,540 --> 01:11:53,770
are you with the G to the e to the T

3708
01:11:53,770 --> 01:11:53,780
 

3709
01:11:53,780 --> 01:11:56,379
comes dope I play the game with no rules

3710
01:11:56,379 --> 01:11:56,389
 

3711
01:11:56,389 --> 01:11:58,629
homies on the truck so yah was because I

3712
01:11:58,629 --> 01:11:58,639
 

3713
01:11:58,639 --> 01:11:59,379
drink bro

3714
01:11:59,379 --> 01:11:59,389

3715
01:11:59,389 --> 01:12:02,680
put the bus a cap on the road on the

3716
01:12:02,680 --> 01:12:02,690
 

3717
01:12:02,690 --> 01:12:14,649
with a party by the 12-pack case of a

3718
01:12:14,649 --> 01:12:14,659
 

3719
01:12:14,659 --> 01:12:16,839
bar six-pack for the act against the

3720
01:12:16,839 --> 01:12:16,849
 

3721
01:12:16,849 --> 01:12:19,810
Real ID replete with your drinking

3722
01:12:19,810 --> 01:12:19,820
 

3723
01:12:19,820 --> 01:12:22,270
proper 12 ow they say bill makes your

3724
01:12:22,270 --> 01:12:22,280
 

3725
01:12:22,280 --> 01:12:24,790
flat out what's a nice is straight so it

3726
01:12:24,790 --> 01:12:24,800
 

3727
01:12:24,800 --> 01:12:27,489
really don't matter

