1
00:00:00,740 --> 00:00:10,650
[Music]

2
00:00:10,650 --> 00:00:10,660

3
00:00:10,660 --> 00:00:14,499
they'd be on the Jill's neck so real

4
00:00:14,499 --> 00:00:14,509
 

5
00:00:14,509 --> 00:00:17,740
quick - quick announcement I want to

6
00:00:17,740 --> 00:00:17,750
 

7
00:00:17,750 --> 00:00:20,650
mention two things the first is that

8
00:00:20,650 --> 00:00:20,660
 

9
00:00:20,660 --> 00:00:22,029
everyone should be aware that that

10
00:00:22,029 --> 00:00:22,039
 

11
00:00:22,039 --> 00:00:26,200
homework one is due next week on Monday

12
00:00:26,200 --> 00:00:26,210
 

13
00:00:26,210 --> 00:00:27,910
at midnight some of you've already

14
00:00:27,910 --> 00:00:27,920
 

15
00:00:27,920 --> 00:00:30,669
started people that work try to get role

16
00:00:30,669 --> 00:00:30,679
 

17
00:00:30,679 --> 00:00:31,509
in the course they've already finished

18
00:00:31,509 --> 00:00:31,519

19
00:00:31,519 --> 00:00:33,820
obviously actually whoever got it first

20
00:00:33,820 --> 00:00:33,830
 

21
00:00:33,830 --> 00:00:34,869
I don't know who it is dad they weren't

22
00:00:34,869 --> 00:00:34,879
 

23
00:00:34,879 --> 00:00:35,979
even they weren't even the wait list

24
00:00:35,979 --> 00:00:35,989
 

25
00:00:35,989 --> 00:00:37,270
they were already enrolled in the course

26
00:00:37,270 --> 00:00:37,280
 

27
00:00:37,280 --> 00:00:39,850
and they beat all of you right so

28
00:00:39,850 --> 00:00:39,860
 

29
00:00:39,860 --> 00:00:43,360
whoever did that was congrats and then

30
00:00:43,360 --> 00:00:43,370
 

31
00:00:43,370 --> 00:00:45,310
the the other thing else is next week we

32
00:00:45,310 --> 00:00:45,320
 

33
00:00:45,320 --> 00:00:47,259
will be releasing the first programming

34
00:00:47,259 --> 00:00:47,269
 

35
00:00:47,269 --> 00:00:50,950
project so that'll be I think you'll be

36
00:00:50,950 --> 00:00:50,960
 

37
00:00:50,960 --> 00:00:53,410
doing two weeks after this so I'll send

38
00:00:53,410 --> 00:00:53,420
 

39
00:00:53,420 --> 00:00:54,969
out a notice about this but we've

40
00:00:54,969 --> 00:00:54,979
 

41
00:00:54,979 --> 00:00:57,160
adjusted the deadlines slightly for

42
00:00:57,160 --> 00:00:57,170
 

43
00:00:57,170 --> 00:00:58,689
these projects because last year the

44
00:00:58,689 --> 00:00:58,699
 

45
00:00:58,699 --> 00:01:00,700
feedback we got was the first project

46
00:01:00,700 --> 00:01:00,710

47
00:01:00,710 --> 00:01:02,799
was considered too easy and the second

48
00:01:02,799 --> 00:01:02,809
 

49
00:01:02,809 --> 00:01:04,240
project was considered really hard

50
00:01:04,240 --> 00:01:04,250

51
00:01:04,250 --> 00:01:05,679
except everyone thought the second

52
00:01:05,679 --> 00:01:05,689
 

53
00:01:05,689 --> 00:01:06,910
project would be like the first project

54
00:01:06,910 --> 00:01:06,920
 

55
00:01:06,920 --> 00:01:08,710
and so a lot of people end up failing

56
00:01:08,710 --> 00:01:08,720
 

57
00:01:08,720 --> 00:01:10,060
because they didn't a lot themselves

58
00:01:10,060 --> 00:01:10,070
 

59
00:01:10,070 --> 00:01:11,530
enough time so we're giving you less

60
00:01:11,530 --> 00:01:11,540
 

61
00:01:11,540 --> 00:01:13,270
time for project one more time on

62
00:01:13,270 --> 00:01:13,280
 

63
00:01:13,280 --> 00:01:17,710
project - okay the other thing to

64
00:01:17,710 --> 00:01:17,720
 

65
00:01:17,720 --> 00:01:18,700
announce is also there's a bunch of

66
00:01:18,700 --> 00:01:18,710
 

67
00:01:18,710 --> 00:01:21,190
database talks coming up in the next

68
00:01:21,190 --> 00:01:21,200
 

69
00:01:21,200 --> 00:01:25,810
week so tomorrow in CIC on the fourth

70
00:01:25,810 --> 00:01:25,820
 

71
00:01:25,820 --> 00:01:27,700
floor while having the cofounders of

72
00:01:27,700 --> 00:01:27,710
 

73
00:01:27,710 --> 00:01:29,700
Connecticut which is the gpu-accelerated

74
00:01:29,700 --> 00:01:29,710
 

75
00:01:29,710 --> 00:01:32,260
database system out of Virginia they'll

76
00:01:32,260 --> 00:01:32,270
 

77
00:01:32,270 --> 00:01:34,090
be coming giving a talk at noon again

78
00:01:34,090 --> 00:01:34,100
 

79
00:01:34,100 --> 00:01:35,440
that's open to everyone you don't have

80
00:01:35,440 --> 00:01:35,450
 

81
00:01:35,450 --> 00:01:37,300
to register for this and there will be

82
00:01:37,300 --> 00:01:37,310
 

83
00:01:37,310 --> 00:01:39,220
pizza available for that for that one

84
00:01:39,220 --> 00:01:39,230
 

85
00:01:39,230 --> 00:01:42,550
and then on Friday we'll have a talk

86
00:01:42,550 --> 00:01:42,560
 

87
00:01:42,560 --> 00:01:46,930
from Pat Helen from Salesforce Pat is a

88
00:01:46,930 --> 00:01:46,940
 

89
00:01:46,940 --> 00:01:49,570
sort of a legend in the database

90
00:01:49,570 --> 00:01:49,580
 

91
00:01:49,580 --> 00:01:52,270
research community he's not academic

92
00:01:52,270 --> 00:01:52,280
 

93
00:01:52,280 --> 00:01:53,140
he's a sort of somebody that's been

94
00:01:53,140 --> 00:01:53,150
 

95
00:01:53,150 --> 00:01:54,790
around working on databases for a long

96
00:01:54,790 --> 00:01:54,800
 

97
00:01:54,800 --> 00:01:57,670
time since the 1980s so he's gonna come

98
00:01:57,670 --> 00:01:57,680
 

99
00:01:57,680 --> 00:02:00,670
give a talk also at noon in the CIC for

100
00:02:00,670 --> 00:02:00,680
 

101
00:02:00,680 --> 00:02:01,990
four that should be Pisa this one as

102
00:02:01,990 --> 00:02:02,000
 

103
00:02:02,000 --> 00:02:04,780
well so I encourage you to come to

104
00:02:04,780 --> 00:02:04,790
 

105
00:02:04,790 --> 00:02:06,160
either one of those the first one the

106
00:02:06,160 --> 00:02:06,170
 

107
00:02:06,170 --> 00:02:07,570
Connecticut talk would be very technical

108
00:02:07,570 --> 00:02:07,580
 

109
00:02:07,580 --> 00:02:08,949
but they're gonna talk about more about

110
00:02:08,949 --> 00:02:08,959
 

111
00:02:08,959 --> 00:02:10,809
the engineering side of making database

112
00:02:10,809 --> 00:02:10,819
 

113
00:02:10,819 --> 00:02:13,270
systems run on GPUs and this is going

114
00:02:13,270 --> 00:02:13,280

115
00:02:13,280 --> 00:02:14,800
well beyond anything we'll talk about in

116
00:02:14,800 --> 00:02:14,810
 

117
00:02:14,810 --> 00:02:16,780
this course and then the Salesforce talk

118
00:02:16,780 --> 00:02:16,790
 

119
00:02:16,790 --> 00:02:17,710
should be a bit more lofty

120
00:02:17,710 --> 00:02:17,720
 

121
00:02:17,720 --> 00:02:19,840
or higher-level I guess Pat's much more

122
00:02:19,840 --> 00:02:19,850
 

123
00:02:19,850 --> 00:02:21,550
senior it's about you're thinking big

124
00:02:21,550 --> 00:02:21,560
 

125
00:02:21,560 --> 00:02:22,810
about distributed systems distributed

126
00:02:22,810 --> 00:02:22,820
 

127
00:02:22,820 --> 00:02:25,870
databases and then on Wednesday next

128
00:02:25,870 --> 00:02:25,880

129
00:02:25,880 --> 00:02:29,200
week at 4 p.m. will be having the

130
00:02:29,200 --> 00:02:29,210
 

131
00:02:29,210 --> 00:02:31,510
co-founder of relational AI come give a

132
00:02:31,510 --> 00:02:31,520

133
00:02:31,520 --> 00:02:33,850
talk so I don't know this person this is

134
00:02:33,850 --> 00:02:33,860
 

135
00:02:33,860 --> 00:02:35,050
actually being organized by somebody

136
00:02:35,050 --> 00:02:35,060
 

137
00:02:35,060 --> 00:02:37,900
else in Tepper but the the co-planner of

138
00:02:37,900 --> 00:02:37,910
 

139
00:02:37,910 --> 00:02:39,490
relational AI had a previous database

140
00:02:39,490 --> 00:02:39,500
 

141
00:02:39,500 --> 00:02:41,650
system startup called logic blocks which

142
00:02:41,650 --> 00:02:41,660

143
00:02:41,660 --> 00:02:44,110
is a bit of an esoteric system doesn't

144
00:02:44,110 --> 00:02:44,120
 

145
00:02:44,120 --> 00:02:45,880
look like didn't operate the same way

146
00:02:45,880 --> 00:02:45,890
 

147
00:02:45,890 --> 00:02:47,650
that the data systems that we're talking

148
00:02:47,650 --> 00:02:47,660
 

149
00:02:47,660 --> 00:02:50,380
on here operate but so he's sort of a

150
00:02:50,380 --> 00:02:50,390
 

151
00:02:50,390 --> 00:02:52,150
semi-famous guys he'll also be giving a

152
00:02:52,150 --> 00:02:52,160
 

153
00:02:52,160 --> 00:02:54,699
talk at at 4 p.m. so the first one will

154
00:02:54,699 --> 00:02:54,709
 

155
00:02:54,709 --> 00:02:56,380
be on YouTube the other two will not be

156
00:02:56,380 --> 00:02:56,390
 

157
00:02:56,390 --> 00:02:59,260
ok so the first two will have pizza the

158
00:02:59,260 --> 00:02:59,270
 

159
00:02:59,270 --> 00:03:00,699
second one I don't know because I'm not

160
00:03:00,699 --> 00:03:00,709
 

161
00:03:00,709 --> 00:03:02,830
I'm not running it you can plan your

162
00:03:02,830 --> 00:03:02,840
 

163
00:03:02,840 --> 00:03:05,260
meals accordingly all right any

164
00:03:05,260 --> 00:03:05,270
 

165
00:03:05,270 --> 00:03:10,650
questions any questions at homework one

166
00:03:10,650 --> 00:03:10,660


167
00:03:10,660 --> 00:03:16,330
ok let's jump right into it ok so where

168
00:03:16,330 --> 00:03:16,340
 

169
00:03:16,340 --> 00:03:18,100
we're at now is that we spent the first

170
00:03:18,100 --> 00:03:18,110
 

171
00:03:18,110 --> 00:03:20,230
two lectures talking about sort of

172
00:03:20,230 --> 00:03:20,240
 

173
00:03:20,240 --> 00:03:23,470
higher level things like how what the

174
00:03:23,470 --> 00:03:23,480
 

175
00:03:23,480 --> 00:03:25,630
relational model is and how you would

176
00:03:25,630 --> 00:03:25,640
 

177
00:03:25,640 --> 00:03:28,000
write queries against data stored it

178
00:03:28,000 --> 00:03:28,010
 

179
00:03:28,010 --> 00:03:30,820
stored like that and that was all sort

180
00:03:30,820 --> 00:03:30,830
 

181
00:03:30,830 --> 00:03:33,070
of lofty in in terms of high-level and

182
00:03:33,070 --> 00:03:33,080
 

183
00:03:33,080 --> 00:03:34,240
abstract right we didn't describe

184
00:03:34,240 --> 00:03:34,250
 

185
00:03:34,250 --> 00:03:35,650
anything about how we actually would

186
00:03:35,650 --> 00:03:35,660
 

187
00:03:35,660 --> 00:03:38,229
implement code that could do those

188
00:03:38,229 --> 00:03:38,239

189
00:03:38,239 --> 00:03:40,330
particular things so at this point of

190
00:03:40,330 --> 00:03:40,340
 

191
00:03:40,340 --> 00:03:41,470
course this is where we sort of start

192
00:03:41,470 --> 00:03:41,480
 

193
00:03:41,480 --> 00:03:43,509
jumping to now describing how you would

194
00:03:43,509 --> 00:03:43,519
 

195
00:03:43,519 --> 00:03:46,539
actually build software to execute

196
00:03:46,539 --> 00:03:46,549
 

197
00:03:46,549 --> 00:03:48,630
queries on a relational database system

198
00:03:48,630 --> 00:03:48,640
 

199
00:03:48,640 --> 00:03:50,590
and so that's really what the next

200
00:03:50,590 --> 00:03:50,600
 

201
00:03:50,600 --> 00:03:53,020
pretty much from now until Thanksgiving

202
00:03:53,020 --> 00:03:53,030

203
00:03:53,030 --> 00:03:54,940
the things that we were talking about

204
00:03:54,940 --> 00:03:54,950
 

205
00:03:54,950 --> 00:03:57,340
and so if you go back to the course

206
00:03:57,340 --> 00:03:57,350
 

207
00:03:57,350 --> 00:04:00,130
outline that I showed at the first class

208
00:04:00,130 --> 00:04:00,140
 

209
00:04:00,140 --> 00:04:01,750
where we sort of already covered the

210
00:04:01,750 --> 00:04:01,760
 

211
00:04:01,760 --> 00:04:03,100
first part we already covered relational

212
00:04:03,100 --> 00:04:03,110
 

213
00:04:03,110 --> 00:04:05,259
databases and now we're getting into all

214
00:04:05,259 --> 00:04:05,269
 

215
00:04:05,269 --> 00:04:07,570
the implementation details and so the

216
00:04:07,570 --> 00:04:07,580
 

217
00:04:07,580 --> 00:04:09,250
way to sort of think about this as we're

218
00:04:09,250 --> 00:04:09,260
 

219
00:04:09,260 --> 00:04:11,470
going along at a high level is that

220
00:04:11,470 --> 00:04:11,480
 

221
00:04:11,480 --> 00:04:13,240
we're essentially going to be describing

222
00:04:13,240 --> 00:04:13,250
 

223
00:04:13,250 --> 00:04:15,880
different layers of the database

224
00:04:15,880 --> 00:04:15,890
 

225
00:04:15,890 --> 00:04:17,770
management system software that we're

226
00:04:17,770 --> 00:04:17,780
 

227
00:04:17,780 --> 00:04:19,960
going to build on top of do do more

228
00:04:19,960 --> 00:04:19,970
 

229
00:04:19,970 --> 00:04:21,280
complicated things or get more

230
00:04:21,280 --> 00:04:21,290
 

231
00:04:21,290 --> 00:04:23,890
functionality out of it right so at the

232
00:04:23,890 --> 00:04:23,900
 

233
00:04:23,900 --> 00:04:25,510
storage level we're sort of starting at

234
00:04:25,510 --> 00:04:25,520
 

235
00:04:25,520 --> 00:04:26,860
the bottom right we're talking about how

236
00:04:26,860 --> 00:04:26,870
 

237
00:04:26,870 --> 00:04:28,150
we're actually going to read and write

238
00:04:28,150 --> 00:04:28,160
 

239
00:04:28,160 --> 00:04:31,230
data and what that data looks like on

240
00:04:31,230 --> 00:04:31,240
 

241
00:04:31,240 --> 00:04:34,980
and then we define an API in our disk

242
00:04:34,980 --> 00:04:34,990
 

243
00:04:34,990 --> 00:04:36,870
manager or a storage manager to say

244
00:04:36,870 --> 00:04:36,880
 

245
00:04:36,880 --> 00:04:38,580
here's how to interact with the data

246
00:04:38,580 --> 00:04:38,590
 

247
00:04:38,590 --> 00:04:40,439
that I can manage and then on top of

248
00:04:40,439 --> 00:04:40,449
 

249
00:04:40,449 --> 00:04:41,879
that we can then build our buffer pool

250
00:04:41,879 --> 00:04:41,889
 

251
00:04:41,889 --> 00:04:43,320
then on top of that we can start

252
00:04:43,320 --> 00:04:43,330
 

253
00:04:43,330 --> 00:04:44,700
building our execution engines or access

254
00:04:44,700 --> 00:04:44,710
 

255
00:04:44,710 --> 00:04:47,339
methods right so sort of going up by one

256
00:04:47,339 --> 00:04:47,349
 

257
00:04:47,349 --> 00:04:48,960
by one and to describe how you would

258
00:04:48,960 --> 00:04:48,970
 

259
00:04:48,970 --> 00:04:51,300
build each different layer what are the

260
00:04:51,300 --> 00:04:51,310
 

261
00:04:51,310 --> 00:04:53,040
trade-offs or different design decisions

262
00:04:53,040 --> 00:04:53,050
 

263
00:04:53,050 --> 00:04:55,469
you have to think about for each layer

264
00:04:55,469 --> 00:04:55,479
 

265
00:04:55,479 --> 00:04:57,450
and then once that's sort of done we can

266
00:04:57,450 --> 00:04:57,460
 

267
00:04:57,460 --> 00:04:59,730
assume that we're good to go right along

268
00:04:59,730 --> 00:04:59,740
 

269
00:04:59,740 --> 00:05:01,499
as we implement whatever that layer once

270
00:05:01,499 --> 00:05:01,509
 

271
00:05:01,509 --> 00:05:03,540
or we define what an API is we can build

272
00:05:03,540 --> 00:05:03,550
 

273
00:05:03,550 --> 00:05:05,850
other stuff on top of that so we'll see

274
00:05:05,850 --> 00:05:05,860
 

275
00:05:05,860 --> 00:05:07,710
it in a couple cases today where I'm

276
00:05:07,710 --> 00:05:07,720
 

277
00:05:07,720 --> 00:05:09,480
going to describe different ways to

278
00:05:09,480 --> 00:05:09,490
 

279
00:05:09,490 --> 00:05:11,820
organize pages or organized data in

280
00:05:11,820 --> 00:05:11,830
 

281
00:05:11,830 --> 00:05:14,790
pages and what happens above that

282
00:05:14,790 --> 00:05:14,800

283
00:05:14,800 --> 00:05:16,350
actually doesn't matter in some ways

284
00:05:16,350 --> 00:05:16,360
 

285
00:05:16,360 --> 00:05:17,909
right we can still use maybe the same

286
00:05:17,909 --> 00:05:17,919
 

287
00:05:17,919 --> 00:05:19,950
control schemes or the same indexing

288
00:05:19,950 --> 00:05:19,960
 

289
00:05:19,960 --> 00:05:21,810
schemes on top of this because we had

290
00:05:21,810 --> 00:05:21,820
 

291
00:05:21,820 --> 00:05:24,600
this sort of abstraction down below and

292
00:05:24,600 --> 00:05:24,610
 

293
00:05:24,610 --> 00:05:26,070
this is this is not new to databases

294
00:05:26,070 --> 00:05:26,080
 

295
00:05:26,080 --> 00:05:27,450
they're not unique to databases this is

296
00:05:27,450 --> 00:05:27,460
 

297
00:05:27,460 --> 00:05:29,760
the standard practice in putting any

298
00:05:29,760 --> 00:05:29,770
 

299
00:05:29,770 --> 00:05:33,240
large software system so again so

300
00:05:33,240 --> 00:05:33,250
 

301
00:05:33,250 --> 00:05:36,210
today's class and next class we're

302
00:05:36,210 --> 00:05:36,220
 

303
00:05:36,220 --> 00:05:37,680
focusing on the disk manager and again

304
00:05:37,680 --> 00:05:37,690

305
00:05:37,690 --> 00:05:38,909
this is just how we're gonna actually

306
00:05:38,909 --> 00:05:38,919
 

307
00:05:38,919 --> 00:05:42,510
the store data on disk so for the the

308
00:05:42,510 --> 00:05:42,520
 

309
00:05:42,520 --> 00:05:44,219
course I sort of mentioned this in the

310
00:05:44,219 --> 00:05:44,229
 

311
00:05:44,229 --> 00:05:45,300
beginning but I didn't really define

312
00:05:45,300 --> 00:05:45,310
 

313
00:05:45,310 --> 00:05:48,480
what I meant so I want to say that this

314
00:05:48,480 --> 00:05:48,490
 

315
00:05:48,490 --> 00:05:49,770
course is focusing on what I would call

316
00:05:49,770 --> 00:05:49,780
 

317
00:05:49,780 --> 00:05:51,990
a disk oriented database management

318
00:05:51,990 --> 00:05:52,000
 

319
00:05:52,000 --> 00:05:54,270
system architecture and so what I mean

320
00:05:54,270 --> 00:05:54,280
 

321
00:05:54,280 --> 00:05:56,640
by that is that the database management

322
00:05:56,640 --> 00:05:56,650
 

323
00:05:56,650 --> 00:05:59,219
system is designed such that it's oons

324
00:05:59,219 --> 00:05:59,229
 

325
00:05:59,229 --> 00:06:01,680
that it assumes the primary storage

326
00:06:01,680 --> 00:06:01,690
 

327
00:06:01,690 --> 00:06:03,930
location of the database is on some

328
00:06:03,930 --> 00:06:03,940

329
00:06:03,940 --> 00:06:06,180
non-volatile disk and I'll define what I

330
00:06:06,180 --> 00:06:06,190
 

331
00:06:06,190 --> 00:06:07,499
mean by non-volatile disk in the next

332
00:06:07,499 --> 00:06:07,509
 

333
00:06:07,509 --> 00:06:10,890
slide and therefore the the components

334
00:06:10,890 --> 00:06:10,900
 

335
00:06:10,900 --> 00:06:13,230
of the system are responsible for

336
00:06:13,230 --> 00:06:13,240
 

337
00:06:13,240 --> 00:06:15,300
figuring out how to move data back and

338
00:06:15,300 --> 00:06:15,310
 

339
00:06:15,310 --> 00:06:17,520
forth between the non-volatile disk and

340
00:06:17,520 --> 00:06:17,530
 

341
00:06:17,530 --> 00:06:20,459
and volatile memory right because you

342
00:06:20,459 --> 00:06:20,469
 

343
00:06:20,469 --> 00:06:22,080
can't operate the Devi system can't

344
00:06:22,080 --> 00:06:22,090
 

345
00:06:22,090 --> 00:06:23,939
operate data directly on disk right

346
00:06:23,939 --> 00:06:23,949
 

347
00:06:23,949 --> 00:06:26,520
there are some newer disks that can do

348
00:06:26,520 --> 00:06:26,530
 

349
00:06:26,530 --> 00:06:27,779
these kind of things because their CPUs

350
00:06:27,779 --> 00:06:27,789
 

351
00:06:27,789 --> 00:06:29,490
down there but in practice like a

352
00:06:29,490 --> 00:06:29,500
 

353
00:06:29,500 --> 00:06:31,620
commodity disk you would buy or on

354
00:06:31,620 --> 00:06:31,630

355
00:06:31,630 --> 00:06:33,629
Amazon or Newegg you're not gonna be

356
00:06:33,629 --> 00:06:33,639
 

357
00:06:33,639 --> 00:06:35,100
able to write run code down on there

358
00:06:35,100 --> 00:06:35,110
 

359
00:06:35,110 --> 00:06:36,659
right so you always have to bring the

360
00:06:36,659 --> 00:06:36,669
 

361
00:06:36,669 --> 00:06:38,490
data you need to operate on either read

362
00:06:38,490 --> 00:06:38,500
 

363
00:06:38,500 --> 00:06:40,560
and write into memory and then do

364
00:06:40,560 --> 00:06:40,570
 

365
00:06:40,570 --> 00:06:42,120
whatever it is that you need to do so

366
00:06:42,120 --> 00:06:42,130
 

367
00:06:42,130 --> 00:06:43,589
the database manner system is all about

368
00:06:43,589 --> 00:06:43,599
 

369
00:06:43,599 --> 00:06:44,220
managing

370
00:06:44,220 --> 00:06:44,230

371
00:06:44,230 --> 00:06:45,660
that movement back and forth at this

372
00:06:45,660 --> 00:06:45,670
 

373
00:06:45,670 --> 00:06:49,200
level of the architecture and this is

374
00:06:49,200 --> 00:06:49,210
 

375
00:06:49,210 --> 00:06:50,340
this is the classic von Neumann

376
00:06:50,340 --> 00:06:50,350
 

377
00:06:50,350 --> 00:06:53,250
architecture from from the 1950s so in

378
00:06:53,250 --> 00:06:53,260
 

379
00:06:53,260 --> 00:06:55,650
order to understand the implications of

380
00:06:55,650 --> 00:06:55,660
 

381
00:06:55,660 --> 00:06:57,630
this movement of data back and forth we

382
00:06:57,630 --> 00:06:57,640
 

383
00:06:57,640 --> 00:06:58,500
will first to understand what the

384
00:06:58,500 --> 00:06:58,510
 

385
00:06:58,510 --> 00:06:59,940
storage hierarchy looks like what are we

386
00:06:59,940 --> 00:06:59,950
 

387
00:06:59,950 --> 00:07:01,320
actually dealing with in our real

388
00:07:01,320 --> 00:07:01,330
 

389
00:07:01,330 --> 00:07:05,400
systems so the the way to start to think

390
00:07:05,400 --> 00:07:05,410
 

391
00:07:05,410 --> 00:07:07,680
about it is is this this sort of tree

392
00:07:07,680 --> 00:07:07,690
 

393
00:07:07,690 --> 00:07:10,770
structure like this right and and every

394
00:07:10,770 --> 00:07:10,780
 

395
00:07:10,780 --> 00:07:11,910
single layer is a different kind of

396
00:07:11,910 --> 00:07:11,920
 

397
00:07:11,920 --> 00:07:14,640
storage class device and the you can

398
00:07:14,640 --> 00:07:14,650

399
00:07:14,650 --> 00:07:16,680
only move data directly from one layer

400
00:07:16,680 --> 00:07:16,690
 

401
00:07:16,690 --> 00:07:19,110
to another right you can only take data

402
00:07:19,110 --> 00:07:19,120
 

403
00:07:19,120 --> 00:07:20,610
out from well that's not exactly true

404
00:07:20,610 --> 00:07:20,620
 

405
00:07:20,620 --> 00:07:21,030
buddy

406
00:07:21,030 --> 00:07:21,040
 

407
00:07:21,040 --> 00:07:22,860
you only take data out from an SSD and

408
00:07:22,860 --> 00:07:22,870
 

409
00:07:22,870 --> 00:07:24,210
put into DRAM before you can put it into

410
00:07:24,210 --> 00:07:24,220
 

411
00:07:24,220 --> 00:07:27,270
your CPU caches all right again that's

412
00:07:27,270 --> 00:07:27,280
 

413
00:07:27,280 --> 00:07:28,560
not entirely true in those cases but for

414
00:07:28,560 --> 00:07:28,570
 

415
00:07:28,570 --> 00:07:30,870
our purposes let's go with that so in a

416
00:07:30,870 --> 00:07:30,880
 

417
00:07:30,880 --> 00:07:32,610
way to sort of think about this is in

418
00:07:32,610 --> 00:07:32,620
 

419
00:07:32,620 --> 00:07:36,420
this hierarchy is the storage devices at

420
00:07:36,420 --> 00:07:36,430
 

421
00:07:36,430 --> 00:07:38,070
the top are really fast

422
00:07:38,070 --> 00:07:38,080
 

423
00:07:38,080 --> 00:07:40,440
but they have much smaller capacity and

424
00:07:40,440 --> 00:07:40,450
 

425
00:07:40,450 --> 00:07:42,840
they're also much more expensive right

426
00:07:42,840 --> 00:07:42,850

427
00:07:42,850 --> 00:07:44,790
and at the bottom you have larger

428
00:07:44,790 --> 00:07:44,800
 

429
00:07:44,800 --> 00:07:46,500
storage devices that have larger

430
00:07:46,500 --> 00:07:46,510
 

431
00:07:46,510 --> 00:07:48,660
capacities that are cheaper per gigabyte

432
00:07:48,660 --> 00:07:48,670
 

433
00:07:48,670 --> 00:07:50,730
or per megabyte but they're gonna be

434
00:07:50,730 --> 00:07:50,740
 

435
00:07:50,740 --> 00:07:53,310
went much much slower if you go looking

436
00:07:53,310 --> 00:07:53,320
 

437
00:07:53,320 --> 00:07:55,560
in the textbook they'll describe sort of

438
00:07:55,560 --> 00:07:55,570
 

439
00:07:55,570 --> 00:07:57,300
as hierarchy as well the one thing I'll

440
00:07:57,300 --> 00:07:57,310
 

441
00:07:57,310 --> 00:07:59,310
point out is they don't put network

442
00:07:59,310 --> 00:07:59,320

443
00:07:59,320 --> 00:08:00,720
storage at the bottom network store

444
00:08:00,720 --> 00:08:00,730
 

445
00:08:00,730 --> 00:08:02,550
never stored to be something like EBS or

446
00:08:02,550 --> 00:08:02,560
 

447
00:08:02,560 --> 00:08:04,950
HDFS like I just distributed file system

448
00:08:04,950 --> 00:08:04,960
 

449
00:08:04,960 --> 00:08:07,530
below this would be like tape archives I

450
00:08:07,530 --> 00:08:07,540
 

451
00:08:07,540 --> 00:08:10,050
mean I mean that's really only used for

452
00:08:10,050 --> 00:08:10,060
 

453
00:08:10,060 --> 00:08:11,880
the disaster recovery you can get that

454
00:08:11,880 --> 00:08:11,890

455
00:08:11,890 --> 00:08:13,650
from Amazon Amazon has the thing called

456
00:08:13,650 --> 00:08:13,660

457
00:08:13,660 --> 00:08:15,510
flag Amazon glacier right that's like

458
00:08:15,510 --> 00:08:15,520
 

459
00:08:15,520 --> 00:08:17,730
super super slow we're not even gonna

460
00:08:17,730 --> 00:08:17,740
 

461
00:08:17,740 --> 00:08:23,610
worry about that here so the foot in our

462
00:08:23,610 --> 00:08:23,620
 

463
00:08:23,620 --> 00:08:25,140
course the way we're going to

464
00:08:25,140 --> 00:08:25,150
 

465
00:08:25,150 --> 00:08:26,670
differentiate between these different

466
00:08:26,670 --> 00:08:26,680
 

467
00:08:26,680 --> 00:08:28,620
layers is not so much between SSDs and

468
00:08:28,620 --> 00:08:28,630
 

469
00:08:28,630 --> 00:08:31,530
nacd's it's really is it volatile or

470
00:08:31,530 --> 00:08:31,540
 

471
00:08:31,540 --> 00:08:34,080
versus non-volatile so anything above

472
00:08:34,080 --> 00:08:34,090
 

473
00:08:34,090 --> 00:08:36,780
the line is considered volatile right it

474
00:08:36,780 --> 00:08:36,790
 

475
00:08:36,790 --> 00:08:38,820
means like you if you remove power on

476
00:08:38,820 --> 00:08:38,830
 

477
00:08:38,830 --> 00:08:40,260
the machine like you pull the power cord

478
00:08:40,260 --> 00:08:40,270
 

479
00:08:40,270 --> 00:08:42,770
and then every all your data is gone

480
00:08:42,770 --> 00:08:42,780
 

481
00:08:42,780 --> 00:08:45,570
right DRAM needs power every so often or

482
00:08:45,570 --> 00:08:45,580

483
00:08:45,580 --> 00:08:47,670
the Refresh it sells and maintain the

484
00:08:47,670 --> 00:08:47,680
 

485
00:08:47,680 --> 00:08:50,810
charge same thing for CPU caches and CP

486
00:08:50,810 --> 00:08:50,820
 

487
00:08:50,820 --> 00:08:54,630
and so they the the way we're gonna

488
00:08:54,630 --> 00:08:54,640
 

489
00:08:54,640 --> 00:08:56,640
access the volatile data has been

490
00:08:56,640 --> 00:08:56,650
 

491
00:08:56,650 --> 00:08:58,110
different however we're gonna access it

492
00:08:58,110 --> 00:08:58,120
 

493
00:08:58,120 --> 00:09:00,870
non-volatile data so in Volvo data

494
00:09:00,870 --> 00:09:00,880
 

495
00:09:00,880 --> 00:09:02,820
support what's called a random access

496
00:09:02,820 --> 00:09:02,830
 

497
00:09:02,830 --> 00:09:05,360
API meaning we can jump to any single

498
00:09:05,360 --> 00:09:05,370
 

499
00:09:05,370 --> 00:09:08,370
byte address and get the actual data

500
00:09:08,370 --> 00:09:08,380
 

501
00:09:08,380 --> 00:09:11,040
that's there and it can be able to

502
00:09:11,040 --> 00:09:11,050
 

503
00:09:11,050 --> 00:09:12,870
support this fast random access right we

504
00:09:12,870 --> 00:09:12,880
 

505
00:09:12,880 --> 00:09:14,490
can jump around anywhere in in our

506
00:09:14,490 --> 00:09:14,500

507
00:09:14,500 --> 00:09:16,980
memory space and it's gonna be roughly

508
00:09:16,980 --> 00:09:16,990

509
00:09:16,990 --> 00:09:19,519
the same speed no matter where we go

510
00:09:19,519 --> 00:09:19,529
 

511
00:09:19,529 --> 00:09:22,230
non-volatile memory is going to be

512
00:09:22,230 --> 00:09:22,240

513
00:09:22,240 --> 00:09:23,640
better off for doing what's called

514
00:09:23,640 --> 00:09:23,650
 

515
00:09:23,650 --> 00:09:25,620
sequential access so that's trying to

516
00:09:25,620 --> 00:09:25,630

517
00:09:25,630 --> 00:09:27,930
read a lot of data that's sort of

518
00:09:27,930 --> 00:09:27,940
 

519
00:09:27,940 --> 00:09:29,760
contiguous to each other in in storage

520
00:09:29,760 --> 00:09:29,770
 

521
00:09:29,770 --> 00:09:32,340
right so you just sort of read all the

522
00:09:32,340 --> 00:09:32,350
 

523
00:09:32,350 --> 00:09:34,260
data at once you can still jump around

524
00:09:34,260 --> 00:09:34,270
 

525
00:09:34,270 --> 00:09:36,810
but it's gonna be slower and instead of

526
00:09:36,810 --> 00:09:36,820
 

527
00:09:36,820 --> 00:09:39,390
accessing a single address address line

528
00:09:39,390 --> 00:09:39,400
 

529
00:09:39,400 --> 00:09:41,030
or cache line to go get the data we need

530
00:09:41,030 --> 00:09:41,040
 

531
00:09:41,040 --> 00:09:43,710
we're gonna access the data in what are

532
00:09:43,710 --> 00:09:43,720
 

533
00:09:43,720 --> 00:09:45,510
called blocks or pages which are

534
00:09:45,510 --> 00:09:45,520
 

535
00:09:45,520 --> 00:09:47,850
typically about four kilobytes right so

536
00:09:47,850 --> 00:09:47,860
 

537
00:09:47,860 --> 00:09:49,500
in volatile storage I can say go get me

538
00:09:49,500 --> 00:09:49,510
 

539
00:09:49,510 --> 00:09:52,019
this single 64-bit memory location and

540
00:09:52,019 --> 00:09:52,029
 

541
00:09:52,029 --> 00:09:54,690
we'll read the value in a non-volatile

542
00:09:54,690 --> 00:09:54,700
 

543
00:09:54,700 --> 00:09:56,790
storage that's block addressable I have

544
00:09:56,790 --> 00:09:56,800
 

545
00:09:56,800 --> 00:09:58,380
to go get the four kilobyte block that

546
00:09:58,380 --> 00:09:58,390

547
00:09:58,390 --> 00:09:59,760
has the data I need and then inside of

548
00:09:59,760 --> 00:09:59,770
 

549
00:09:59,770 --> 00:10:02,220
that I can get the 64 bit value that I

550
00:10:02,220 --> 00:10:02,230
 

551
00:10:02,230 --> 00:10:06,540
want all right so the again the way to

552
00:10:06,540 --> 00:10:06,550
 

553
00:10:06,550 --> 00:10:08,280
sort of think about this is that when I

554
00:10:08,280 --> 00:10:08,290
 

555
00:10:08,290 --> 00:10:09,269
talk throughout the course

556
00:10:09,269 --> 00:10:09,279
 

557
00:10:09,279 --> 00:10:10,949
I'm not going to differentiate between

558
00:10:10,949 --> 00:10:10,959
 

559
00:10:10,959 --> 00:10:12,930
SSDs and HTTP or network storage I'm

560
00:10:12,930 --> 00:10:12,940
 

561
00:10:12,940 --> 00:10:16,470
really gonna say that anything above SSD

562
00:10:16,470 --> 00:10:16,480
 

563
00:10:16,480 --> 00:10:18,750
that's memory there started dear M that

564
00:10:18,750 --> 00:10:18,760
 

565
00:10:18,760 --> 00:10:20,699
will be considered memory and then

566
00:10:20,699 --> 00:10:20,709
 

567
00:10:20,709 --> 00:10:21,930
anything below that will be dis

568
00:10:21,930 --> 00:10:21,940
 

569
00:10:21,940 --> 00:10:24,300
considered disk right because at a high

570
00:10:24,300 --> 00:10:24,310
 

571
00:10:24,310 --> 00:10:25,890
level the algorithms we're going to use

572
00:10:25,890 --> 00:10:25,900
 

573
00:10:25,900 --> 00:10:28,050
to accessing what I'll call disk are

574
00:10:28,050 --> 00:10:28,060
 

575
00:10:28,060 --> 00:10:30,150
roughly the same whether it's an SSD a

576
00:10:30,150 --> 00:10:30,160
 

577
00:10:30,160 --> 00:10:34,560
CD or EBS so the other thing else is a

578
00:10:34,560 --> 00:10:34,570

579
00:10:34,570 --> 00:10:36,180
two isn't in this course we're not gonna

580
00:10:36,180 --> 00:10:36,190
 

581
00:10:36,190 --> 00:10:39,030
care about anything above DRAM right so

582
00:10:39,030 --> 00:10:39,040
 

583
00:10:39,040 --> 00:10:42,690
CPU caches like l1 l2 l3 or anything

584
00:10:42,690 --> 00:10:42,700
 

585
00:10:42,700 --> 00:10:45,540
like CPU registers because in our world

586
00:10:45,540 --> 00:10:45,550
 

587
00:10:45,550 --> 00:10:48,060
with it with a disk the disk is so slow

588
00:10:48,060 --> 00:10:48,070
 

589
00:10:48,070 --> 00:10:50,970
that all our focus is really about how

590
00:10:50,970 --> 00:10:50,980
 

591
00:10:50,980 --> 00:10:52,980
can we speed up or hide the latency of

592
00:10:52,980 --> 00:10:52,990
 

593
00:10:52,990 --> 00:10:56,190
these storage devices down here and you

594
00:10:56,190 --> 00:10:56,200
 

595
00:10:56,200 --> 00:10:57,570
know once it's in memory that's good

596
00:10:57,570 --> 00:10:57,580
 

597
00:10:57,580 --> 00:11:00,150
enough so if you take the advanced class

598
00:11:00,150 --> 00:11:00,160
 

599
00:11:00,160 --> 00:11:04,230
in the spring 15 7:21 we're gonna not

600
00:11:04,230 --> 00:11:04,240
 

601
00:11:04,240 --> 00:11:05,820
going to do disk or David systems we're

602
00:11:05,820 --> 00:11:05,830
 

603
00:11:05,830 --> 00:11:07,230
actually do memory origin or any memory

604
00:11:07,230 --> 00:11:07,240
 

605
00:11:07,240 --> 00:11:09,090
database systems so this now the disk

606
00:11:09,090 --> 00:11:09,100
 

607
00:11:09,100 --> 00:11:11,610
goes away except for logging and now it

608
00:11:11,610 --> 00:11:11,620
 

609
00:11:11,620 --> 00:11:12,269
since everything

610
00:11:12,269 --> 00:11:12,279
 

611
00:11:12,279 --> 00:11:13,739
memory now we care about the stuff at

612
00:11:13,739 --> 00:11:13,749
 

613
00:11:13,749 --> 00:11:15,629
the top right and you can actually get

614
00:11:15,629 --> 00:11:15,639
 

615
00:11:15,639 --> 00:11:16,889
pretty good speed up if you start

616
00:11:16,889 --> 00:11:16,899
 

617
00:11:16,899 --> 00:11:19,800
aligning things to the cache lines or

618
00:11:19,800 --> 00:11:19,810
 

619
00:11:19,810 --> 00:11:21,960
try to maintain as much data in CPU

620
00:11:21,960 --> 00:11:21,970
 

621
00:11:21,970 --> 00:11:23,309
registers and actual individual

622
00:11:23,309 --> 00:11:23,319

623
00:11:23,319 --> 00:11:25,920
registers for as long as possible but

624
00:11:25,920 --> 00:11:25,930
 

625
00:11:25,930 --> 00:11:28,160
again for our purpose here we don't care

626
00:11:28,160 --> 00:11:28,170
 

627
00:11:28,170 --> 00:11:30,119
the other thing I want to bring up too

628
00:11:30,119 --> 00:11:30,129
 

629
00:11:30,129 --> 00:11:32,280
is also there is actually a new storage

630
00:11:32,280 --> 00:11:32,290
 

631
00:11:32,290 --> 00:11:35,129
technology that that's coming out called

632
00:11:35,129 --> 00:11:35,139
 

633
00:11:35,139 --> 00:11:37,739
non-volatile memory that sort of sits in

634
00:11:37,739 --> 00:11:37,749
 

635
00:11:37,749 --> 00:11:39,689
in the in the middle here right between

636
00:11:39,689 --> 00:11:39,699
 

637
00:11:39,699 --> 00:11:42,960
SSDs and in DRAM right so this is

638
00:11:42,960 --> 00:11:42,970
 

639
00:11:42,970 --> 00:11:44,579
sometimes called persistent memory or

640
00:11:44,579 --> 00:11:44,589
 

641
00:11:44,589 --> 00:11:46,829
storage class memory the way to sort of

642
00:11:46,829 --> 00:11:46,839
 

643
00:11:46,839 --> 00:11:49,170
think about it is it's like DRAM in that

644
00:11:49,170 --> 00:11:49,180
 

645
00:11:49,180 --> 00:11:51,420
it's fast sports random access and

646
00:11:51,420 --> 00:11:51,430

647
00:11:51,430 --> 00:11:53,850
things are byte addressable but it's

648
00:11:53,850 --> 00:11:53,860
 

649
00:11:53,860 --> 00:11:56,639
persistent like an SSD right so meaning

650
00:11:56,639 --> 00:11:56,649
 

651
00:11:56,649 --> 00:11:58,499
if I write to non-volatile memory and I

652
00:11:58,499 --> 00:11:58,509

653
00:11:58,509 --> 00:12:00,480
pull the plug all my data is still there

654
00:12:00,480 --> 00:12:00,490
 

655
00:12:00,490 --> 00:12:03,239
when I come back so the last couple

656
00:12:03,239 --> 00:12:03,249
 

657
00:12:03,249 --> 00:12:04,530
years as I've been teaching this course

658
00:12:04,530 --> 00:12:04,540
 

659
00:12:04,540 --> 00:12:06,299
I always keep saying like oh yeah

660
00:12:06,299 --> 00:12:06,309
 

661
00:12:06,309 --> 00:12:08,670
non-volatile memory it exists in the lab

662
00:12:08,670 --> 00:12:08,680
 

663
00:12:08,680 --> 00:12:10,170
so you actually can't get it yet so

664
00:12:10,170 --> 00:12:10,180
 

665
00:12:10,180 --> 00:12:10,920
we're not we're looking to worry about

666
00:12:10,920 --> 00:12:10,930
 

667
00:12:10,930 --> 00:12:13,769
it here that's actually not true as of

668
00:12:13,769 --> 00:12:13,779
 

669
00:12:13,779 --> 00:12:15,869
this year so Intel announced that they

670
00:12:15,869 --> 00:12:15,879
 

671
00:12:15,879 --> 00:12:17,429
have actually non-volatile memory in

672
00:12:17,429 --> 00:12:17,439
 

673
00:12:17,439 --> 00:12:20,069
production we actually have access

674
00:12:20,069 --> 00:12:20,079
 

675
00:12:20,079 --> 00:12:23,309
access to it here at CMU my PhD student

676
00:12:23,309 --> 00:12:23,319
 

677
00:12:23,319 --> 00:12:25,350
that just graduated he's now at Georgia

678
00:12:25,350 --> 00:12:25,360
 

679
00:12:25,360 --> 00:12:26,999
Tech he his whole thesis was on

680
00:12:26,999 --> 00:12:27,009
 

681
00:12:27,009 --> 00:12:29,759
non-volatile memory databases so we're

682
00:12:29,759 --> 00:12:29,769

683
00:12:29,769 --> 00:12:31,230
not ready yet to throw away the entire

684
00:12:31,230 --> 00:12:31,240
 

685
00:12:31,240 --> 00:12:33,540
textbook but I think a lot of things

686
00:12:33,540 --> 00:12:33,550
 

687
00:12:33,550 --> 00:12:34,799
that we'll talk about during the

688
00:12:34,799 --> 00:12:34,809
 

689
00:12:34,809 --> 00:12:36,389
semester some of these things will go

690
00:12:36,389 --> 00:12:36,399
 

691
00:12:36,399 --> 00:12:37,799
away some of these things we get tweet

692
00:12:37,799 --> 00:12:37,809
 

693
00:12:37,809 --> 00:12:39,269
because now you're gonna have

694
00:12:39,269 --> 00:12:39,279
 

695
00:12:39,279 --> 00:12:41,670
non-volatile memory so I think Intel's

696
00:12:41,670 --> 00:12:41,680
 

697
00:12:41,680 --> 00:12:43,309
announcing it's going to come out in

698
00:12:43,309 --> 00:12:43,319
 

699
00:12:43,319 --> 00:12:47,009
later later this year supposedly I think

700
00:12:47,009 --> 00:12:47,019
 

701
00:12:47,019 --> 00:12:49,319
they're calling it 3d crosspoint or

702
00:12:49,319 --> 00:12:49,329
 

703
00:12:49,329 --> 00:12:50,519
octane memory there's a bunch of

704
00:12:50,519 --> 00:12:50,529

705
00:12:50,529 --> 00:12:52,439
marketing terms for it right now but the

706
00:12:52,439 --> 00:12:52,449
 

707
00:12:52,449 --> 00:12:53,910
high level it works like this it looks

708
00:12:53,910 --> 00:12:53,920
 

709
00:12:53,920 --> 00:12:55,559
like DRAM but it's persistent like an

710
00:12:55,559 --> 00:12:55,569
 

711
00:12:55,569 --> 00:13:00,240
SSD all right so to give an idea of why

712
00:13:00,240 --> 00:13:00,250
 

713
00:13:00,250 --> 00:13:03,240
we're gonna spend a lot of work to move

714
00:13:03,240 --> 00:13:03,250
 

715
00:13:03,250 --> 00:13:05,519
data back and forth between DRAM and

716
00:13:05,519 --> 00:13:05,529
 

717
00:13:05,529 --> 00:13:06,990
disk we have to understand what it takes

718
00:13:06,990 --> 00:13:07,000
 

719
00:13:07,000 --> 00:13:09,030
to actually get data at a disk and bring

720
00:13:09,030 --> 00:13:09,040
 

721
00:13:09,040 --> 00:13:11,220
it into memory so there's a bunch of

722
00:13:11,220 --> 00:13:11,230
 

723
00:13:11,230 --> 00:13:12,660
different tables on the internet that

724
00:13:12,660 --> 00:13:12,670

725
00:13:12,670 --> 00:13:14,069
roughly had the same information this

726
00:13:14,069 --> 00:13:14,079
 

727
00:13:14,079 --> 00:13:15,780
were like this so the exact numbers

728
00:13:15,780 --> 00:13:15,790
 

729
00:13:15,790 --> 00:13:17,210
might be slightly different but the

730
00:13:17,210 --> 00:13:17,220
 

731
00:13:17,220 --> 00:13:20,249
magnitude of the differences are roughly

732
00:13:20,249 --> 00:13:20,259
 

733
00:13:20,259 --> 00:13:23,850
the same so to read data from a single

734
00:13:23,850 --> 00:13:23,860
 

735
00:13:23,860 --> 00:13:25,210
cache line

736
00:13:25,210 --> 00:13:25,220

737
00:13:25,220 --> 00:13:28,180
in l1 which is the the closest cash you

738
00:13:28,180 --> 00:13:28,190
 

739
00:13:28,190 --> 00:13:31,180
can have to write about CP registers it

740
00:13:31,180 --> 00:13:31,190
 

741
00:13:31,190 --> 00:13:33,310
takes about half a nanosecond you got to

742
00:13:33,310 --> 00:13:33,320
 

743
00:13:33,320 --> 00:13:35,980
read from l2 it's seven nanoseconds DRAM

744
00:13:35,980 --> 00:13:35,990
 

745
00:13:35,990 --> 00:13:37,660
is 100 nanoseconds and so forth and so

746
00:13:37,660 --> 00:13:37,670
 

747
00:13:37,670 --> 00:13:41,770
forth right so when you show numbers

748
00:13:41,770 --> 00:13:41,780
 

749
00:13:41,780 --> 00:13:43,180
like this with nanoseconds people don't

750
00:13:43,180 --> 00:13:43,190
 

751
00:13:43,190 --> 00:13:44,560
really know how to like put that in

752
00:13:44,560 --> 00:13:44,570
 

753
00:13:44,570 --> 00:13:46,030
perspective of like real world clock

754
00:13:46,030 --> 00:13:46,040

755
00:13:46,040 --> 00:13:49,150
time so instead of saying that maybe for

756
00:13:49,150 --> 00:13:49,160
 

757
00:13:49,160 --> 00:13:50,980
this case here that l1 cache reference

758
00:13:50,980 --> 00:13:50,990
 

759
00:13:50,990 --> 00:13:53,050
takes half a nanosecond well we say if

760
00:13:53,050 --> 00:13:53,060
 

761
00:13:53,060 --> 00:13:56,170
it takes a second right now you can I

762
00:13:56,170 --> 00:13:56,180

763
00:13:56,180 --> 00:13:57,820
can see why reading from these these

764
00:13:57,820 --> 00:13:57,830
 

765
00:13:57,830 --> 00:13:59,650
slower devices is so bad right

766
00:13:59,650 --> 00:13:59,660
 

767
00:13:59,660 --> 00:14:02,920
so we say l1 cache is this cache miss as

768
00:14:02,920 --> 00:14:02,930

769
00:14:02,930 --> 00:14:05,740
a as a second half a second then reading

770
00:14:05,740 --> 00:14:05,750
 

771
00:14:05,750 --> 00:14:08,530
from l2 cache seven seconds DRAM is 100

772
00:14:08,530 --> 00:14:08,540
 

773
00:14:08,540 --> 00:14:11,140
seconds reading from an SSD is one point

774
00:14:11,140 --> 00:14:11,150
 

775
00:14:11,150 --> 00:14:13,300
seven days reading from a spinning disk

776
00:14:13,300 --> 00:14:13,310
 

777
00:14:13,310 --> 00:14:16,080
magnetic hard drive is sixteen weeks

778
00:14:16,080 --> 00:14:16,090
 

779
00:14:16,090 --> 00:14:18,610
reading from network stores a TBS is a

780
00:14:18,610 --> 00:14:18,620
 

781
00:14:18,620 --> 00:14:20,260
months and then reading from a tape

782
00:14:20,260 --> 00:14:20,270
 

783
00:14:20,270 --> 00:14:24,400
drive is 31 years the other certain

784
00:14:24,400 --> 00:14:24,410

785
00:14:24,410 --> 00:14:26,170
metaphor people like to use is say I

786
00:14:26,170 --> 00:14:26,180
 

787
00:14:26,180 --> 00:14:28,060
want to read a book I want to read a

788
00:14:28,060 --> 00:14:28,070
 

789
00:14:28,070 --> 00:14:30,580
page in a book right reading from my CTO

790
00:14:30,580 --> 00:14:30,590
 

791
00:14:30,590 --> 00:14:31,840
caches it's like the book is right in

792
00:14:31,840 --> 00:14:31,850
 

793
00:14:31,850 --> 00:14:33,880
front of me reading it from maybe DRAM

794
00:14:33,880 --> 00:14:33,890
 

795
00:14:33,890 --> 00:14:35,170
is like walking across the room to get

796
00:14:35,170 --> 00:14:35,180
 

797
00:14:35,180 --> 00:14:37,750
it meeting from SSDs are walking down to

798
00:14:37,750 --> 00:14:37,760
 

799
00:14:37,760 --> 00:14:39,070
the library and getting it but like

800
00:14:39,070 --> 00:14:39,080
 

801
00:14:39,080 --> 00:14:40,150
reading it from a tape drive is like

802
00:14:40,150 --> 00:14:40,160
 

803
00:14:40,160 --> 00:14:42,340
flying to Pluto to read the book and

804
00:14:42,340 --> 00:14:42,350
 

805
00:14:42,350 --> 00:14:45,130
then flying back right I say these are

806
00:14:45,130 --> 00:14:45,140
 

807
00:14:45,140 --> 00:14:46,930
orders of magnitude slower and again

808
00:14:46,930 --> 00:14:46,940
 

809
00:14:46,940 --> 00:14:48,310
this is why we're gonna be tough to be

810
00:14:48,310 --> 00:14:48,320
 

811
00:14:48,320 --> 00:14:50,830
smart about how we keep our data in DRAM

812
00:14:50,830 --> 00:14:50,840
 

813
00:14:50,840 --> 00:14:53,590
as much as possible to avoid ever having

814
00:14:53,590 --> 00:14:53,600
 

815
00:14:53,600 --> 00:14:55,840
to go to disk now in some cases we can't

816
00:14:55,840 --> 00:14:55,850
 

817
00:14:55,850 --> 00:14:57,340
avoid this right we have to actually

818
00:14:57,340 --> 00:14:57,350
 

819
00:14:57,350 --> 00:14:59,500
write data to disk to make sure things

820
00:14:59,500 --> 00:14:59,510
 

821
00:14:59,510 --> 00:15:01,600
are durable but we can be smart about

822
00:15:01,600 --> 00:15:01,610
 

823
00:15:01,610 --> 00:15:04,930
how we actually want to do this so our

824
00:15:04,930 --> 00:15:04,940
 

825
00:15:04,940 --> 00:15:06,280
system design goals for actually how

826
00:15:06,280 --> 00:15:06,290
 

827
00:15:06,290 --> 00:15:08,230
we're gonna build a data system is at a

828
00:15:08,230 --> 00:15:08,240
 

829
00:15:08,240 --> 00:15:09,760
higher level what we essentially want to

830
00:15:09,760 --> 00:15:09,770
 

831
00:15:09,770 --> 00:15:11,530
do is we want to have the provide a

832
00:15:11,530 --> 00:15:11,540
 

833
00:15:11,540 --> 00:15:14,200
software system that has the illusion

834
00:15:14,200 --> 00:15:14,210
 

835
00:15:14,210 --> 00:15:16,660
that the entire database fits in DRAM

836
00:15:16,660 --> 00:15:16,670
 

837
00:15:16,670 --> 00:15:20,170
even though it doesn't right and we're

838
00:15:20,170 --> 00:15:20,180
 

839
00:15:20,180 --> 00:15:21,430
to be careful about how we move data

840
00:15:21,430 --> 00:15:21,440
 

841
00:15:21,440 --> 00:15:23,230
back and forth and we want to do it in

842
00:15:23,230 --> 00:15:23,240
 

843
00:15:23,240 --> 00:15:25,540
such a way that we avoid large stalls

844
00:15:25,540 --> 00:15:25,550
 

845
00:15:25,550 --> 00:15:27,310
because we have to fetch something from

846
00:15:27,310 --> 00:15:27,320
 

847
00:15:27,320 --> 00:15:30,040
disk and we don't want to have have that

848
00:15:30,040 --> 00:15:30,050
 

849
00:15:30,050 --> 00:15:31,810
slowed down everything else again it's

850
00:15:31,810 --> 00:15:31,820
 

851
00:15:31,820 --> 00:15:33,190
unavoidable the data is not in memory

852
00:15:33,190 --> 00:15:33,200
 

853
00:15:33,200 --> 00:15:34,420
you've got to go get a disk and get it

854
00:15:34,420 --> 00:15:34,430
 

855
00:15:34,430 --> 00:15:36,010
but ideally you want to have the data

856
00:15:36,010 --> 00:15:36,020
 

857
00:15:36,020 --> 00:15:38,200
system be able to do other things

858
00:15:38,200 --> 00:15:38,210
 

859
00:15:38,210 --> 00:15:40,580
while you're going fetching that data

860
00:15:40,580 --> 00:15:40,590
 

861
00:15:40,590 --> 00:15:43,640
let me be up processing other queries of

862
00:15:43,640 --> 00:15:43,650
 

863
00:15:43,650 --> 00:15:45,050
course now we'll see this later on when

864
00:15:45,050 --> 00:15:45,060
 

865
00:15:45,060 --> 00:15:46,040
we talk about transactions and

866
00:15:46,040 --> 00:15:46,050
 

867
00:15:46,050 --> 00:15:47,630
concurrency control but if you have

868
00:15:47,630 --> 00:15:47,640
 

869
00:15:47,640 --> 00:15:48,920
multiple threads doing multiple things

870
00:15:48,920 --> 00:15:48,930

871
00:15:48,930 --> 00:15:50,570
at the same time because maybe one

872
00:15:50,570 --> 00:15:50,580
 

873
00:15:50,580 --> 00:15:52,580
thread stalled to go out there disk now

874
00:15:52,580 --> 00:15:52,590

875
00:15:52,590 --> 00:15:53,960
you make sure that you order their

876
00:15:53,960 --> 00:15:53,970
 

877
00:15:53,970 --> 00:15:56,420
operations correctly so they don't you

878
00:15:56,420 --> 00:15:56,430
 

879
00:15:56,430 --> 00:15:57,470
know read data that they shouldn't be

880
00:15:57,470 --> 00:15:57,480
 

881
00:15:57,480 --> 00:15:59,390
reading ok we'll worry about that later

882
00:15:59,390 --> 00:15:59,400
 

883
00:15:59,400 --> 00:16:00,560
for our purpose here we're just trying

884
00:16:00,560 --> 00:16:00,570
 

885
00:16:00,570 --> 00:16:02,600
to say how can we deal with reading

886
00:16:02,600 --> 00:16:02,610
 

887
00:16:02,610 --> 00:16:03,830
writing dated from disk and how we're

888
00:16:03,830 --> 00:16:03,840
 

889
00:16:03,840 --> 00:16:08,600
gonna organize things so the I mentioned

890
00:16:08,600 --> 00:16:08,610
 

891
00:16:08,610 --> 00:16:10,610
this before when we talked about the the

892
00:16:10,610 --> 00:16:10,620
 

893
00:16:10,620 --> 00:16:12,230
difference between non vult on volatile

894
00:16:12,230 --> 00:16:12,240
 

895
00:16:12,240 --> 00:16:14,590
memory because just to bring it up again

896
00:16:14,590 --> 00:16:14,600
 

897
00:16:14,600 --> 00:16:16,820
the big also difference we're gonna see

898
00:16:16,820 --> 00:16:16,830
 

899
00:16:16,830 --> 00:16:18,590
is and how we design these components is

900
00:16:18,590 --> 00:16:18,600
 

901
00:16:18,600 --> 00:16:20,450
dealing with the fact that sequential

902
00:16:20,450 --> 00:16:20,460
 

903
00:16:20,460 --> 00:16:23,840
access on non-volatile storage is much

904
00:16:23,840 --> 00:16:23,850
 

905
00:16:23,850 --> 00:16:26,450
faster than random access so that means

906
00:16:26,450 --> 00:16:26,460
 

907
00:16:26,460 --> 00:16:29,570
that we're gonna try to maximize our

908
00:16:29,570 --> 00:16:29,580
 

909
00:16:29,580 --> 00:16:30,860
ability to read and write data

910
00:16:30,860 --> 00:16:30,870
 

911
00:16:30,870 --> 00:16:33,140
sequentially meaning reading large

912
00:16:33,140 --> 00:16:33,150
 

913
00:16:33,150 --> 00:16:35,390
blocks of data at a time to get things

914
00:16:35,390 --> 00:16:35,400
 

915
00:16:35,400 --> 00:16:37,100
that we need all right if you have to go

916
00:16:37,100 --> 00:16:37,110
 

917
00:16:37,110 --> 00:16:38,510
jump around say you have a spinning disk

918
00:16:38,510 --> 00:16:38,520
 

919
00:16:38,520 --> 00:16:40,100
hard drive it has a mechanical arm that

920
00:16:40,100 --> 00:16:40,110
 

921
00:16:40,110 --> 00:16:42,110
jumps around on the platter right you

922
00:16:42,110 --> 00:16:42,120
 

923
00:16:42,120 --> 00:16:44,240
have to jump it around for every single

924
00:16:44,240 --> 00:16:44,250
 

925
00:16:44,250 --> 00:16:45,230
time you want to read a single tuple

926
00:16:45,230 --> 00:16:45,240
 

927
00:16:45,240 --> 00:16:48,440
then that's gonna be really slow but if

928
00:16:48,440 --> 00:16:48,450
 

929
00:16:48,450 --> 00:16:50,090
you can read you know plop the arm down

930
00:16:50,090 --> 00:16:50,100
 

931
00:16:50,100 --> 00:16:52,030
and let it read a large segment of data

932
00:16:52,030 --> 00:16:52,040
 

933
00:16:52,040 --> 00:16:54,290
then bring that in memory then that's me

934
00:16:54,290 --> 00:16:54,300
 

935
00:16:54,300 --> 00:16:55,790
much faster because again there's this

936
00:16:55,790 --> 00:16:55,800
 

937
00:16:55,800 --> 00:16:57,950
fewer fewer movements of the physical

938
00:16:57,950 --> 00:16:57,960
 

939
00:16:57,960 --> 00:17:01,250
arm so the operating systems usually

940
00:17:01,250 --> 00:17:01,260

941
00:17:01,260 --> 00:17:03,200
support the ability to allocate multiple

942
00:17:03,200 --> 00:17:03,210
 

943
00:17:03,210 --> 00:17:05,449
pages or blocks in a row right these are

944
00:17:05,449 --> 00:17:05,459
 

945
00:17:05,459 --> 00:17:07,550
calls at extents I said you can say I

946
00:17:07,550 --> 00:17:07,560
 

947
00:17:07,560 --> 00:17:10,610
want to allocate one megabyte extent or

948
00:17:10,610 --> 00:17:10,620
 

949
00:17:10,620 --> 00:17:12,350
one gigabyte extent and then the OS will

950
00:17:12,350 --> 00:17:12,360
 

951
00:17:12,360 --> 00:17:13,850
try to

952
00:17:13,850 --> 00:17:13,860
 

953
00:17:13,860 --> 00:17:16,280
contiguous in the in the actual storage

954
00:17:16,280 --> 00:17:16,290
 

955
00:17:16,290 --> 00:17:21,079
device itself so as I said like in my

956
00:17:21,079 --> 00:17:21,089
 

957
00:17:21,089 --> 00:17:23,000
design goals we try to want to make we

958
00:17:23,000 --> 00:17:23,010

959
00:17:23,010 --> 00:17:24,800
want to have our database system provide

960
00:17:24,800 --> 00:17:24,810
 

961
00:17:24,810 --> 00:17:27,679
the illusion that it has more memory

962
00:17:27,679 --> 00:17:27,689
 

963
00:17:27,689 --> 00:17:28,370
than it actually has

964
00:17:28,370 --> 00:17:28,380
 

965
00:17:28,380 --> 00:17:30,380
right if we have one gigabyte of RAM and

966
00:17:30,380 --> 00:17:30,390
 

967
00:17:30,390 --> 00:17:32,420
we have a 10 gigabyte database we want

968
00:17:32,420 --> 00:17:32,430
 

969
00:17:32,430 --> 00:17:33,650
to make it appear that the entire

970
00:17:33,650 --> 00:17:33,660

971
00:17:33,660 --> 00:17:37,160
database fits in fits in memory so what

972
00:17:37,160 --> 00:17:37,170
 

973
00:17:37,170 --> 00:17:41,100
does that sound like

974
00:17:41,100 --> 00:17:41,110


975
00:17:41,110 --> 00:17:43,060
who here is taken operating system

976
00:17:43,060 --> 00:17:43,070
 

977
00:17:43,070 --> 00:17:47,260
course what's that I heard it virtual

978
00:17:47,260 --> 00:17:47,270
 

979
00:17:47,270 --> 00:17:49,030
memory exactly right so this is

980
00:17:49,030 --> 00:17:49,040
 

981
00:17:49,040 --> 00:17:50,490
essential what virtual memory does right

982
00:17:50,490 --> 00:17:50,500
 

983
00:17:50,500 --> 00:17:52,630
virtual memory set the operating system

984
00:17:52,630 --> 00:17:52,640
 

985
00:17:52,640 --> 00:17:54,730
says all right here's my address space

986
00:17:54,730 --> 00:17:54,740
 

987
00:17:54,740 --> 00:17:56,470
but then I have this little swap section

988
00:17:56,470 --> 00:17:56,480
 

989
00:17:56,480 --> 00:17:59,050
where I can write out pages when I run

990
00:17:59,050 --> 00:17:59,060
 

991
00:17:59,060 --> 00:18:01,420
out of space in memory and it looks to

992
00:18:01,420 --> 00:18:01,430
 

993
00:18:01,430 --> 00:18:03,220
the application it looks like

994
00:18:03,220 --> 00:18:03,230

995
00:18:03,230 --> 00:18:04,420
everything's actually a memory when it's

996
00:18:04,420 --> 00:18:04,430
 

997
00:18:04,430 --> 00:18:06,340
not you don't the right change your code

998
00:18:06,340 --> 00:18:06,350
 

999
00:18:06,350 --> 00:18:08,740
in any way to deal with the fact that

1000
00:18:08,740 --> 00:18:08,750
 

1001
00:18:08,750 --> 00:18:11,020
the page you want to read is that is the

1002
00:18:11,020 --> 00:18:11,030
 

1003
00:18:11,030 --> 00:18:14,050
operative hides all that for you so now

1004
00:18:14,050 --> 00:18:14,060
 

1005
00:18:14,060 --> 00:18:15,880
really saying well if I this is what I

1006
00:18:15,880 --> 00:18:15,890
 

1007
00:18:15,890 --> 00:18:17,530
want in my database system I want the

1008
00:18:17,530 --> 00:18:17,540
 

1009
00:18:17,540 --> 00:18:19,960
ability to have it appear that I have

1010
00:18:19,960 --> 00:18:19,970
 

1011
00:18:19,970 --> 00:18:22,120
more memory than I actually have and the

1012
00:18:22,120 --> 00:18:22,130
 

1013
00:18:22,130 --> 00:18:23,320
operating system already can do this in

1014
00:18:23,320 --> 00:18:23,330
 

1015
00:18:23,330 --> 00:18:25,180
virtual memory why not just use the

1016
00:18:25,180 --> 00:18:25,190
 

1017
00:18:25,190 --> 00:18:27,820
operating system for this so the way you

1018
00:18:27,820 --> 00:18:27,830
 

1019
00:18:27,830 --> 00:18:30,190
would actually write this is through a

1020
00:18:30,190 --> 00:18:30,200
 

1021
00:18:30,200 --> 00:18:32,080
syscall called M map who here has heard

1022
00:18:32,080 --> 00:18:32,090
 

1023
00:18:32,090 --> 00:18:36,220
of M map to in the back okay three right

1024
00:18:36,220 --> 00:18:36,230
 

1025
00:18:36,230 --> 00:18:38,280
so M map means memory map file and

1026
00:18:38,280 --> 00:18:38,290
 

1027
00:18:38,290 --> 00:18:40,240
debated way to basically think about

1028
00:18:40,240 --> 00:18:40,250
 

1029
00:18:40,250 --> 00:18:41,800
this is like you have a file on disk and

1030
00:18:41,800 --> 00:18:41,810
 

1031
00:18:41,810 --> 00:18:43,810
you tell the operating system um map it

1032
00:18:43,810 --> 00:18:43,820

1033
00:18:43,820 --> 00:18:45,790
you load it in and it's basically going

1034
00:18:45,790 --> 00:18:45,800
 

1035
00:18:45,800 --> 00:18:48,820
to map the the physical pages of the of

1036
00:18:48,820 --> 00:18:48,830
 

1037
00:18:48,830 --> 00:18:51,520
the file on disk into virtual memory

1038
00:18:51,520 --> 00:18:51,530
 

1039
00:18:51,530 --> 00:18:54,370
addresses in inside of you know the OS

1040
00:18:54,370 --> 00:18:54,380
 

1041
00:18:54,380 --> 00:18:56,710
and then from your application

1042
00:18:56,710 --> 00:18:56,720
 

1043
00:18:56,720 --> 00:18:58,270
standpoint you can jump to any location

1044
00:18:58,270 --> 00:18:58,280
 

1045
00:18:58,280 --> 00:19:00,630
in that file in your memory address and

1046
00:19:00,630 --> 00:19:00,640
 

1047
00:19:00,640 --> 00:19:02,530
underneath the coverage the operating

1048
00:19:02,530 --> 00:19:02,540
 

1049
00:19:02,540 --> 00:19:04,030
system will page things in and out as

1050
00:19:04,030 --> 00:19:04,040
 

1051
00:19:04,040 --> 00:19:04,540
needed

1052
00:19:04,540 --> 00:19:04,550
 

1053
00:19:04,550 --> 00:19:06,580
right so the L the operation is

1054
00:19:06,580 --> 00:19:06,590
 

1055
00:19:06,590 --> 00:19:07,900
essentially responsible moving data in

1056
00:19:07,900 --> 00:19:07,910

1057
00:19:07,910 --> 00:19:09,850
and out so just to give a quick example

1058
00:19:09,850 --> 00:19:09,860
 

1059
00:19:09,860 --> 00:19:12,010
looks like this say this is our this is

1060
00:19:12,010 --> 00:19:12,020
 

1061
00:19:12,020 --> 00:19:13,930
our file on disk and it has four pages

1062
00:19:13,930 --> 00:19:13,940
 

1063
00:19:13,940 --> 00:19:16,750
right one two three four and then in

1064
00:19:16,750 --> 00:19:16,760
 

1065
00:19:16,760 --> 00:19:18,250
memory and the operating system we're

1066
00:19:18,250 --> 00:19:18,260
 

1067
00:19:18,260 --> 00:19:19,660
gonna have our virtual memory so we a

1068
00:19:19,660 --> 00:19:19,670
 

1069
00:19:19,670 --> 00:19:22,090
map it in so we have the four pages in

1070
00:19:22,090 --> 00:19:22,100
 

1071
00:19:22,100 --> 00:19:23,320
memory but at this point at the very

1072
00:19:23,320 --> 00:19:23,330
 

1073
00:19:23,330 --> 00:19:25,180
beginning there's no there's nothing in

1074
00:19:25,180 --> 00:19:25,190
 

1075
00:19:25,190 --> 00:19:26,230
there eight empty because we haven't

1076
00:19:26,230 --> 00:19:26,240
 

1077
00:19:26,240 --> 00:19:28,360
gone to disk to get anything and then we

1078
00:19:28,360 --> 00:19:28,370
 

1079
00:19:28,370 --> 00:19:30,160
only have actually two pages of space in

1080
00:19:30,160 --> 00:19:30,170
 

1081
00:19:30,170 --> 00:19:32,590
physical memory so now if my process

1082
00:19:32,590 --> 00:19:32,600
 

1083
00:19:32,600 --> 00:19:33,940
comes along and it wants to read the

1084
00:19:33,940 --> 00:19:33,950
 

1085
00:19:33,950 --> 00:19:36,280
first page I'll get a page fault which

1086
00:19:36,280 --> 00:19:36,290
 

1087
00:19:36,290 --> 00:19:38,170
is it interrupts the operating system

1088
00:19:38,170 --> 00:19:38,180
 

1089
00:19:38,180 --> 00:19:42,100
stalls my process wall goes down to the

1090
00:19:42,100 --> 00:19:42,110
 

1091
00:19:42,110 --> 00:19:44,230
disk fetches the the page that I want

1092
00:19:44,230 --> 00:19:44,240

1093
00:19:44,240 --> 00:19:46,990
puts it in physical memory and then maps

1094
00:19:46,990 --> 00:19:47,000
 

1095
00:19:47,000 --> 00:19:48,250
the virtual memory to point to that

1096
00:19:48,250 --> 00:19:48,260
 

1097
00:19:48,260 --> 00:19:51,190
physical page right again if I access

1098
00:19:51,190 --> 00:19:51,200
 

1099
00:19:51,200 --> 00:19:54,970
page three same thing I get a page fault

1100
00:19:54,970 --> 00:19:54,980
 

1101
00:19:54,980 --> 00:19:56,979
the OS stalls my process and then it

1102
00:19:56,979 --> 00:19:56,989
 

1103
00:19:56,989 --> 00:19:59,200
goes fetches that what I need right the

1104
00:19:59,200 --> 00:19:59,210
 

1105
00:19:59,210 --> 00:20:00,460
stalling the process actually means that

1106
00:20:00,460 --> 00:20:00,470
 

1107
00:20:00,470 --> 00:20:02,529
you're blocking your thread because

1108
00:20:02,529 --> 00:20:02,539
 

1109
00:20:02,539 --> 00:20:03,729
you're now you're down in the kernel and

1110
00:20:03,729 --> 00:20:03,739
 

1111
00:20:03,739 --> 00:20:05,830
the operating system knows not to have

1112
00:20:05,830 --> 00:20:05,840
 

1113
00:20:05,840 --> 00:20:07,779
its schedule schedule scared of you for

1114
00:20:07,779 --> 00:20:07,789
 

1115
00:20:07,789 --> 00:20:09,279
a quantum to actually run because you

1116
00:20:09,279 --> 00:20:09,289

1117
00:20:09,289 --> 00:20:10,749
can't do anything because you're blocked

1118
00:20:10,749 --> 00:20:10,759
 

1119
00:20:10,759 --> 00:20:13,419
waiting for for this page all right

1120
00:20:13,419 --> 00:20:13,429
 

1121
00:20:13,429 --> 00:20:15,430
of course now we have this problem of

1122
00:20:15,430 --> 00:20:15,440
 

1123
00:20:15,440 --> 00:20:17,560
well we want to access this page here

1124
00:20:17,560 --> 00:20:17,570
 

1125
00:20:17,570 --> 00:20:20,169
it's not memory we don't have any more

1126
00:20:20,169 --> 00:20:20,179
 

1127
00:20:20,179 --> 00:20:22,539
free space in physical memory so what do

1128
00:20:22,539 --> 00:20:22,549
 

1129
00:20:22,549 --> 00:20:25,180
we actually do right we need to evict

1130
00:20:25,180 --> 00:20:25,190
 

1131
00:20:25,190 --> 00:20:28,029
one and and make space for it but now

1132
00:20:28,029 --> 00:20:28,039
 

1133
00:20:28,039 --> 00:20:29,349
there might be other threads or other

1134
00:20:29,349 --> 00:20:29,359
 

1135
00:20:29,359 --> 00:20:31,720
processes doing the same thing so we may

1136
00:20:31,720 --> 00:20:31,730
 

1137
00:20:31,730 --> 00:20:34,629
have a long stall right so this is bad

1138
00:20:34,629 --> 00:20:34,639
 

1139
00:20:34,639 --> 00:20:35,769
from our point of view member I said

1140
00:20:35,769 --> 00:20:35,779
 

1141
00:20:35,779 --> 00:20:38,590
earlier that ideally when we ever have

1142
00:20:38,590 --> 00:20:38,600
 

1143
00:20:38,600 --> 00:20:40,539
to go to disks and get something we

1144
00:20:40,539 --> 00:20:40,549
 

1145
00:20:40,549 --> 00:20:41,889
don't want to stall the entire database

1146
00:20:41,889 --> 00:20:41,899
 

1147
00:20:41,899 --> 00:20:43,599
system we want to have something else

1148
00:20:43,599 --> 00:20:43,609
 

1149
00:20:43,609 --> 00:20:45,729
keep running and maybe make for progress

1150
00:20:45,729 --> 00:20:45,739

1151
00:20:45,739 --> 00:20:48,070
on their queries while we go fetch the

1152
00:20:48,070 --> 00:20:48,080
 

1153
00:20:48,080 --> 00:20:50,470
thing that we need but in in in this

1154
00:20:50,470 --> 00:20:50,480

1155
00:20:50,480 --> 00:20:51,700
case here at the operating system using

1156
00:20:51,700 --> 00:20:51,710
 

1157
00:20:51,710 --> 00:20:53,680
M map it doesn't do that because the the

1158
00:20:53,680 --> 00:20:53,690
 

1159
00:20:53,690 --> 00:20:56,200
operation prop stalls our thread now if

1160
00:20:56,200 --> 00:20:56,210
 

1161
00:20:56,210 --> 00:20:57,399
we have other threads they can do other

1162
00:20:57,399 --> 00:20:57,409
 

1163
00:20:57,409 --> 00:20:59,609
things but that's gonna cause problems

1164
00:20:59,609 --> 00:20:59,619
 

1165
00:20:59,619 --> 00:21:01,810
right so we have multiple threads to

1166
00:21:01,810 --> 00:21:01,820
 

1167
00:21:01,820 --> 00:21:03,759
access the same and that file the same

1168
00:21:03,759 --> 00:21:03,769
 

1169
00:21:03,769 --> 00:21:07,389
time to hide these page fault stalls now

1170
00:21:07,389 --> 00:21:07,399
 

1171
00:21:07,399 --> 00:21:08,649
we got to deal with problems of what

1172
00:21:08,649 --> 00:21:08,659
 

1173
00:21:08,659 --> 00:21:09,519
happens if they're reading and writing

1174
00:21:09,519 --> 00:21:09,529
 

1175
00:21:09,529 --> 00:21:12,190
to different pages and how to make sure

1176
00:21:12,190 --> 00:21:12,200
 

1177
00:21:12,200 --> 00:21:13,479
things get you get written out just

1178
00:21:13,479 --> 00:21:13,489
 

1179
00:21:13,489 --> 00:21:15,639
correctly so I want to go to the details

1180
00:21:15,639 --> 00:21:15,649
 

1181
00:21:15,649 --> 00:21:19,330
of how a map sucks this has been a

1182
00:21:19,330 --> 00:21:19,340
 

1183
00:21:19,340 --> 00:21:22,269
long-standing beef that I have with end

1184
00:21:22,269 --> 00:21:22,279
 

1185
00:21:22,279 --> 00:21:23,979
map if you want to call it that I will

1186
00:21:23,979 --> 00:21:23,989
 

1187
00:21:23,989 --> 00:21:25,389
say also underneath the covers I mean

1188
00:21:25,389 --> 00:21:25,399
 

1189
00:21:25,399 --> 00:21:27,129
for if you call malloc it's essentially

1190
00:21:27,129 --> 00:21:27,139
 

1191
00:21:27,139 --> 00:21:30,009
doing a map right but it's not actually

1192
00:21:30,009 --> 00:21:30,019
 

1193
00:21:30,019 --> 00:21:31,869
being backed by disk writes is backed by

1194
00:21:31,869 --> 00:21:31,879
 

1195
00:21:31,879 --> 00:21:34,599
just physical memory that's always there

1196
00:21:34,599 --> 00:21:34,609
 

1197
00:21:34,609 --> 00:21:36,099
it could get swapped out but that's

1198
00:21:36,099 --> 00:21:36,109
 

1199
00:21:36,109 --> 00:21:38,739
that's the virtual memory in the OS so

1200
00:21:38,739 --> 00:21:38,749
 

1201
00:21:38,749 --> 00:21:39,879
and that works really great or

1202
00:21:39,879 --> 00:21:39,889
 

1203
00:21:39,889 --> 00:21:42,909
reasonably great for read-only workloads

1204
00:21:42,909 --> 00:21:42,919

1205
00:21:42,919 --> 00:21:44,619
but when you have writers then you have

1206
00:21:44,619 --> 00:21:44,629
 

1207
00:21:44,629 --> 00:21:47,229
problems so the way it started handle

1208
00:21:47,229 --> 00:21:47,239
 

1209
00:21:47,239 --> 00:21:49,149
this is that you the OS does provide you

1210
00:21:49,149 --> 00:21:49,159
 

1211
00:21:49,159 --> 00:21:51,639
some hints to overcome this right these

1212
00:21:51,639 --> 00:21:51,649
 

1213
00:21:51,649 --> 00:21:53,649
3 cysts calls em advise and the lock and

1214
00:21:53,649 --> 00:21:53,659
 

1215
00:21:53,659 --> 00:21:55,599
sink and these are basically telling the

1216
00:21:55,599 --> 00:21:55,609
 

1217
00:21:55,609 --> 00:21:57,369
operating system how you how that your

1218
00:21:57,369 --> 00:21:57,379
 

1219
00:21:57,379 --> 00:21:58,599
process your database system is actually

1220
00:21:58,599 --> 00:21:58,609
 

1221
00:21:58,609 --> 00:22:00,849
going to access the pages that um mapped

1222
00:22:00,849 --> 00:22:00,859
 

1223
00:22:00,859 --> 00:22:03,700
right so em advise can say that like I

1224
00:22:03,700 --> 00:22:03,710
 

1225
00:22:03,710 --> 00:22:05,109
plan on reading these certain pages now

1226
00:22:05,109 --> 00:22:05,119
 

1227
00:22:05,119 --> 00:22:07,359
or how how I plan on reading them and

1228
00:22:07,359 --> 00:22:07,369

1229
00:22:07,369 --> 00:22:08,830
block and tell the operating

1230
00:22:08,830 --> 00:22:08,840
 

1231
00:22:08,840 --> 00:22:10,539
whatever you do don't swap this out to

1232
00:22:10,539 --> 00:22:10,549

1233
00:22:10,549 --> 00:22:11,590
disk because I'm always gonna do

1234
00:22:11,590 --> 00:22:11,600
 

1235
00:22:11,600 --> 00:22:13,330
something to it and then NSYNC allows

1236
00:22:13,330 --> 00:22:13,340
 

1237
00:22:13,340 --> 00:22:17,259
you to it to flush things so there are

1238
00:22:17,259 --> 00:22:17,269

1239
00:22:17,269 --> 00:22:20,200
some systems actually use em map the

1240
00:22:20,200 --> 00:22:20,210
 

1241
00:22:20,210 --> 00:22:22,659
ones I'm aware of in terms of full usage

1242
00:22:22,659 --> 00:22:22,669
 

1243
00:22:22,669 --> 00:22:25,779
would be mone DB and OLM DB the LM DB

1244
00:22:25,779 --> 00:22:25,789
 

1245
00:22:25,789 --> 00:22:27,129
doesn't like me because I don't like em

1246
00:22:27,129 --> 00:22:27,139
 

1247
00:22:27,139 --> 00:22:28,950
map that's another story

1248
00:22:28,950 --> 00:22:28,960
 

1249
00:22:28,960 --> 00:22:32,259
mo DB Mon a DB is a analytical system

1250
00:22:32,259 --> 00:22:32,269
 

1251
00:22:32,269 --> 00:22:33,789
that's highly read-only so this is like

1252
00:22:33,789 --> 00:22:33,799

1253
00:22:33,799 --> 00:22:34,930
fine but when you actually wanted to

1254
00:22:34,930 --> 00:22:34,940
 

1255
00:22:34,940 --> 00:22:36,580
start doing writes that's when you have

1256
00:22:36,580 --> 00:22:36,590
 

1257
00:22:36,590 --> 00:22:38,529
problems and map now there are some

1258
00:22:38,529 --> 00:22:38,539
 

1259
00:22:38,539 --> 00:22:41,340
systems that also also use partial use

1260
00:22:41,340 --> 00:22:41,350
 

1261
00:22:41,350 --> 00:22:44,739
and map so MongoDB the original engine

1262
00:22:44,739 --> 00:22:44,749

1263
00:22:44,749 --> 00:22:46,480
that actually it actually uses was based

1264
00:22:46,480 --> 00:22:46,490
 

1265
00:22:46,490 --> 00:22:48,580
on a map it was so bad that they threw

1266
00:22:48,580 --> 00:22:48,590
 

1267
00:22:48,590 --> 00:22:51,070
it away and actually built a sort of

1268
00:22:51,070 --> 00:22:51,080
 

1269
00:22:51,080 --> 00:22:52,690
what I'll call correct storage manager

1270
00:22:52,690 --> 00:22:52,700
 

1271
00:22:52,700 --> 00:22:54,580
called wired Tiger that does the things

1272
00:22:54,580 --> 00:22:54,590
 

1273
00:22:54,590 --> 00:22:56,279
that we're talking about in this class

1274
00:22:56,279 --> 00:22:56,289
 

1275
00:22:56,289 --> 00:23:00,519
mem sequel uses Men map for the column

1276
00:23:00,519 --> 00:23:00,529
 

1277
00:23:00,529 --> 00:23:02,830
store for sort of read-only things same

1278
00:23:02,830 --> 00:23:02,840
 

1279
00:23:02,840 --> 00:23:04,269
with the influx DB and then sequel light

1280
00:23:04,269 --> 00:23:04,279
 

1281
00:23:04,279 --> 00:23:05,560
has different engines you can use and

1282
00:23:05,560 --> 00:23:05,570
 

1283
00:23:05,570 --> 00:23:08,710
what I think one of them is ml so the

1284
00:23:08,710 --> 00:23:08,720
 

1285
00:23:08,720 --> 00:23:10,060
bottom line I want to get out of this

1286
00:23:10,060 --> 00:23:10,070
 

1287
00:23:10,070 --> 00:23:11,889
and we'll see this later on we talked

1288
00:23:11,889 --> 00:23:11,899
 

1289
00:23:11,899 --> 00:23:13,570
about the buffer pool stuff the buffer

1290
00:23:13,570 --> 00:23:13,580
 

1291
00:23:13,580 --> 00:23:17,019
pool manager in two lectures but the

1292
00:23:17,019 --> 00:23:17,029
 

1293
00:23:17,029 --> 00:23:18,519
reoccurring theme throughout this course

1294
00:23:18,519 --> 00:23:18,529
 

1295
00:23:18,529 --> 00:23:20,080
also will be that the database managed

1296
00:23:20,080 --> 00:23:20,090
 

1297
00:23:20,090 --> 00:23:21,669
system can always do a better job than

1298
00:23:21,669 --> 00:23:21,679
 

1299
00:23:21,679 --> 00:23:23,830
the operating system because it knows

1300
00:23:23,830 --> 00:23:23,840
 

1301
00:23:23,840 --> 00:23:26,109
exactly what's happening right it knows

1302
00:23:26,109 --> 00:23:26,119
 

1303
00:23:26,119 --> 00:23:27,580
what the queries is executing it knows

1304
00:23:27,580 --> 00:23:27,590
 

1305
00:23:27,590 --> 00:23:28,960
what the data looks like it knows how

1306
00:23:28,960 --> 00:23:28,970
 

1307
00:23:28,970 --> 00:23:31,690
it's going to access that data so

1308
00:23:31,690 --> 00:23:31,700
 

1309
00:23:31,700 --> 00:23:32,649
therefore it can always do a much better

1310
00:23:32,649 --> 00:23:32,659
 

1311
00:23:32,659 --> 00:23:34,600
job at scheduling these things then then

1312
00:23:34,600 --> 00:23:34,610
 

1313
00:23:34,610 --> 00:23:37,960
the operating system right and there's

1314
00:23:37,960 --> 00:23:37,970
 

1315
00:23:37,970 --> 00:23:39,340
certain precautions you have to take to

1316
00:23:39,340 --> 00:23:39,350
 

1317
00:23:39,350 --> 00:23:40,509
make sure that you write things out in

1318
00:23:40,509 --> 00:23:40,519
 

1319
00:23:40,519 --> 00:23:41,710
the correct order which are actually

1320
00:23:41,710 --> 00:23:41,720
 

1321
00:23:41,720 --> 00:23:43,330
difficult to do and not really portable

1322
00:23:43,330 --> 00:23:43,340
 

1323
00:23:43,340 --> 00:23:48,609
with the nmap syscall so if I die you

1324
00:23:48,609 --> 00:23:48,619
 

1325
00:23:48,619 --> 00:23:49,749
put two things my tombstone

1326
00:23:49,749 --> 00:23:49,759
 

1327
00:23:49,759 --> 00:23:51,190
one is the operating system is not your

1328
00:23:51,190 --> 00:23:51,200
 

1329
00:23:51,200 --> 00:23:53,320
friend it's like a frenemy right you

1330
00:23:53,320 --> 00:23:53,330
 

1331
00:23:53,330 --> 00:23:55,060
need it to survive but like it kind of

1332
00:23:55,060 --> 00:23:55,070
 

1333
00:23:55,070 --> 00:23:57,669
gets in the way and the second one is

1334
00:23:57,669 --> 00:23:57,679
 

1335
00:23:57,679 --> 00:23:58,869
never use a map but your database

1336
00:23:58,869 --> 00:23:58,879

1337
00:23:58,879 --> 00:24:01,960
management system right now I'll send

1338
00:24:01,960 --> 00:24:01,970
 

1339
00:24:01,970 --> 00:24:03,100
one else out this but this has been a

1340
00:24:03,100 --> 00:24:03,110
 

1341
00:24:03,110 --> 00:24:05,950
long-standing beef the there's a some

1342
00:24:05,950 --> 00:24:05,960
 

1343
00:24:05,960 --> 00:24:07,509
really good researchers in Germany that

1344
00:24:07,509 --> 00:24:07,519
 

1345
00:24:07,519 --> 00:24:08,889
try to use mmm for their database system

1346
00:24:08,889 --> 00:24:08,899
 

1347
00:24:08,899 --> 00:24:10,419
they gave up on it and we want to write

1348
00:24:10,419 --> 00:24:10,429
 

1349
00:24:10,429 --> 00:24:12,489
a paper to prove that finally a map is a

1350
00:24:12,489 --> 00:24:12,499
 

1351
00:24:12,499 --> 00:24:14,350
bad idea from a database system so if

1352
00:24:14,350 --> 00:24:14,360
 

1353
00:24:14,360 --> 00:24:15,940
you're interested in this and you want

1354
00:24:15,940 --> 00:24:15,950
 

1355
00:24:15,950 --> 00:24:18,609
you know ruffle some feathers email me

1356
00:24:18,609 --> 00:24:18,619
 

1357
00:24:18,619 --> 00:24:19,950
and we can talk about it

1358
00:24:19,950 --> 00:24:19,960
 

1359
00:24:19,960 --> 00:24:22,330
alright so again we'll see is a couple

1360
00:24:22,330 --> 00:24:22,340
 

1361
00:24:22,340 --> 00:24:22,630
of times

1362
00:24:22,630 --> 00:24:22,640
 

1363
00:24:22,640 --> 00:24:24,940
the semester where it seems like what

1364
00:24:24,940 --> 00:24:24,950
 

1365
00:24:24,950 --> 00:24:27,340
I'm describing to you is functionality

1366
00:24:27,340 --> 00:24:27,350
 

1367
00:24:27,350 --> 00:24:28,810
that the database system our ticket or

1368
00:24:28,810 --> 00:24:28,820
 

1369
00:24:28,820 --> 00:24:29,890
sorry the operating system can already

1370
00:24:29,890 --> 00:24:29,900
 

1371
00:24:29,900 --> 00:24:31,870
provide over having implemented

1372
00:24:31,870 --> 00:24:31,880
 

1373
00:24:31,880 --> 00:24:34,090
ourselves and every major commercial

1374
00:24:34,090 --> 00:24:34,100
 

1375
00:24:34,100 --> 00:24:36,040
database system does this right because

1376
00:24:36,040 --> 00:24:36,050
 

1377
00:24:36,050 --> 00:24:37,210
they can always get much better

1378
00:24:37,210 --> 00:24:37,220
 

1379
00:24:37,220 --> 00:24:38,560
performance and have much better control

1380
00:24:38,560 --> 00:24:38,570
 

1381
00:24:38,570 --> 00:24:41,170
and guarantee correctness and safety of

1382
00:24:41,170 --> 00:24:41,180

1383
00:24:41,180 --> 00:24:44,260
data in ways that it may not always be

1384
00:24:44,260 --> 00:24:44,270

1385
00:24:44,270 --> 00:24:46,900
possible with the operating system right

1386
00:24:46,900 --> 00:24:46,910
 

1387
00:24:46,910 --> 00:24:49,900
so again what I'm describing for this

1388
00:24:49,900 --> 00:24:49,910
 

1389
00:24:49,910 --> 00:24:51,070
class will seem like a lot of ways like

1390
00:24:51,070 --> 00:24:51,080
 

1391
00:24:51,080 --> 00:24:53,170
oh we're betting a little mini operating

1392
00:24:53,170 --> 00:24:53,180
 

1393
00:24:53,180 --> 00:24:55,480
system yes that's because we can we want

1394
00:24:55,480 --> 00:24:55,490
 

1395
00:24:55,490 --> 00:24:57,370
to do things ourselves and then you know

1396
00:24:57,370 --> 00:24:57,380
 

1397
00:24:57,380 --> 00:24:58,960
what if we go do this at a company they

1398
00:24:58,960 --> 00:24:58,970
 

1399
00:24:58,970 --> 00:25:00,130
pay us a lot to do it cuz it's hard

1400
00:25:00,130 --> 00:25:00,140
 

1401
00:25:00,140 --> 00:25:03,790
alright there's always a good thing all

1402
00:25:03,790 --> 00:25:03,800
 

1403
00:25:03,800 --> 00:25:05,500
right so what are the do problems

1404
00:25:05,500 --> 00:25:05,510
 

1405
00:25:05,510 --> 00:25:07,630
empathy with Davis storage so the first

1406
00:25:07,630 --> 00:25:07,640
 

1407
00:25:07,640 --> 00:25:09,250
is that how we're gonna actually

1408
00:25:09,250 --> 00:25:09,260
 

1409
00:25:09,260 --> 00:25:11,790
represent the data in files on disk

1410
00:25:11,790 --> 00:25:11,800
 

1411
00:25:11,800 --> 00:25:14,410
right and the second one is how we

1412
00:25:14,410 --> 00:25:14,420
 

1413
00:25:14,420 --> 00:25:15,820
actually to manage this movement of

1414
00:25:15,820 --> 00:25:15,830
 

1415
00:25:15,830 --> 00:25:17,890
memory back and forth pages between the

1416
00:25:17,890 --> 00:25:17,900
 

1417
00:25:17,900 --> 00:25:20,470
disk and memory back and forth so for

1418
00:25:20,470 --> 00:25:20,480
 

1419
00:25:20,480 --> 00:25:22,090
this class and the next class we're

1420
00:25:22,090 --> 00:25:22,100
 

1421
00:25:22,100 --> 00:25:24,580
gonna focus on this problem here right

1422
00:25:24,580 --> 00:25:24,590
 

1423
00:25:24,590 --> 00:25:26,200
so we're not gonna worry about however

1424
00:25:26,200 --> 00:25:26,210
 

1425
00:25:26,210 --> 00:25:27,640
actually you know if we have these pages

1426
00:25:27,640 --> 00:25:27,650
 

1427
00:25:27,650 --> 00:25:29,560
when we copy the memory what do we how

1428
00:25:29,560 --> 00:25:29,570
 

1429
00:25:29,570 --> 00:25:31,090
do we actually manage that we'll cover

1430
00:25:31,090 --> 00:25:31,100
 

1431
00:25:31,100 --> 00:25:32,350
that when we talk about the buffer pool

1432
00:25:32,350 --> 00:25:32,360
 

1433
00:25:32,360 --> 00:25:34,840
stuff and then that that's what you'll

1434
00:25:34,840 --> 00:25:34,850
 

1435
00:25:34,850 --> 00:25:36,610
do in the first project we're really

1436
00:25:36,610 --> 00:25:36,620
 

1437
00:25:36,620 --> 00:25:38,680
focused on this problem here of like we

1438
00:25:38,680 --> 00:25:38,690
 

1439
00:25:38,690 --> 00:25:40,060
have these files on disk how do we

1440
00:25:40,060 --> 00:25:40,070
 

1441
00:25:40,070 --> 00:25:41,530
actually do have you actually represent

1442
00:25:41,530 --> 00:25:41,540
 

1443
00:25:41,540 --> 00:25:44,560
the data that's stored in them so for

1444
00:25:44,560 --> 00:25:44,570
 

1445
00:25:44,570 --> 00:25:45,760
today's agenda we talked about three

1446
00:25:45,760 --> 00:25:45,770
 

1447
00:25:45,770 --> 00:25:48,400
parts and you sort of see again what I

1448
00:25:48,400 --> 00:25:48,410
 

1449
00:25:48,410 --> 00:25:49,540
said before how we're going to build

1450
00:25:49,540 --> 00:25:49,550
 

1451
00:25:49,550 --> 00:25:51,130
these layers up and do something more

1452
00:25:51,130 --> 00:25:51,140

1453
00:25:51,140 --> 00:25:52,870
complicated things so we're gonna start

1454
00:25:52,870 --> 00:25:52,880
 

1455
00:25:52,880 --> 00:25:54,640
with how we actually gonna maintain

1456
00:25:54,640 --> 00:25:54,650
 

1457
00:25:54,650 --> 00:25:57,160
these files on disk and then we'll build

1458
00:25:57,160 --> 00:25:57,170
 

1459
00:25:57,170 --> 00:25:58,330
up from that talk about how we actually

1460
00:25:58,330 --> 00:25:58,340
 

1461
00:25:58,340 --> 00:26:00,730
organized the pages in those files and

1462
00:26:00,730 --> 00:26:00,740
 

1463
00:26:00,740 --> 00:26:02,380
then from that we can then talk about

1464
00:26:02,380 --> 00:26:02,390
 

1465
00:26:02,390 --> 00:26:03,520
how we actually organize the tuples

1466
00:26:03,520 --> 00:26:03,530
 

1467
00:26:03,530 --> 00:26:06,520
inside of those pages right so again

1468
00:26:06,520 --> 00:26:06,530
 

1469
00:26:06,530 --> 00:26:08,110
well both these one-by-one sort of see

1470
00:26:08,110 --> 00:26:08,120
 

1471
00:26:08,120 --> 00:26:09,790
how these things build on top of each

1472
00:26:09,790 --> 00:26:09,800
 

1473
00:26:09,800 --> 00:26:14,320
other so in the most basic form the

1474
00:26:14,320 --> 00:26:14,330
 

1475
00:26:14,330 --> 00:26:16,180
database minute system is essentially

1476
00:26:16,180 --> 00:26:16,190
 

1477
00:26:16,190 --> 00:26:19,020
just going to store the database as

1478
00:26:19,020 --> 00:26:19,030
 

1479
00:26:19,030 --> 00:26:22,510
files on disk right there's no magic to

1480
00:26:22,510 --> 00:26:22,520
 

1481
00:26:22,520 --> 00:26:24,070
it I just went to files you in your file

1482
00:26:24,070 --> 00:26:24,080
 

1483
00:26:24,080 --> 00:26:26,860
system right there they are some systems

1484
00:26:26,860 --> 00:26:26,870
 

1485
00:26:26,870 --> 00:26:29,440
will store a single file sequel light

1486
00:26:29,440 --> 00:26:29,450
 

1487
00:26:29,450 --> 00:26:30,850
does this right if you if you create a

1488
00:26:30,850 --> 00:26:30,860
 

1489
00:26:30,860 --> 00:26:32,260
database a sequel light it creates a

1490
00:26:32,260 --> 00:26:32,270
 

1491
00:26:32,270 --> 00:26:34,570
single dot DB file for you which is nice

1492
00:26:34,570 --> 00:26:34,580
 

1493
00:26:34,580 --> 00:26:36,330
because it's portable you can move it

1494
00:26:36,330 --> 00:26:36,340
 

1495
00:26:36,340 --> 00:26:39,210
anywhere but typically the the the

1496
00:26:39,210 --> 00:26:39,220
 

1497
00:26:39,220 --> 00:26:41,039
bigger systems actually store multiple

1498
00:26:41,039 --> 00:26:41,049
 

1499
00:26:41,049 --> 00:26:44,430
files in embarrass hierarchies but I see

1500
00:26:44,430 --> 00:26:44,440
 

1501
00:26:44,440 --> 00:26:45,690
if you have Postgres installed in your

1502
00:26:45,690 --> 00:26:45,700
 

1503
00:26:45,700 --> 00:26:48,390
system go in its UNIX go look at slash

1504
00:26:48,390 --> 00:26:48,400
 

1505
00:26:48,400 --> 00:26:51,750
var slash / quest QL they're gonna have

1506
00:26:51,750 --> 00:26:51,760
 

1507
00:26:51,760 --> 00:26:53,159
them in all these directories where

1508
00:26:53,159 --> 00:26:53,169

1509
00:26:53,169 --> 00:26:54,570
they'll have different directors for

1510
00:26:54,570 --> 00:26:54,580
 

1511
00:26:54,580 --> 00:26:56,070
tables different directories for indexes

1512
00:26:56,070 --> 00:26:56,080
 

1513
00:26:56,080 --> 00:26:57,180
different directories for it for

1514
00:26:57,180 --> 00:26:57,190
 

1515
00:26:57,190 --> 00:26:59,519
metadata and each is inside of those

1516
00:26:59,519 --> 00:26:59,529
 

1517
00:26:59,529 --> 00:27:01,399
will be these different database files

1518
00:27:01,399 --> 00:27:01,409
 

1519
00:27:01,409 --> 00:27:04,140
so these files typically are in a

1520
00:27:04,140 --> 00:27:04,150
 

1521
00:27:04,150 --> 00:27:06,180
proprietary format that is specific to

1522
00:27:06,180 --> 00:27:06,190
 

1523
00:27:06,190 --> 00:27:08,370
the database minute system so it's not

1524
00:27:08,370 --> 00:27:08,380

1525
00:27:08,380 --> 00:27:09,750
like you can open up a text editor and

1526
00:27:09,750 --> 00:27:09,760
 

1527
00:27:09,760 --> 00:27:11,070
actually see any data right it's gonna

1528
00:27:11,070 --> 00:27:11,080
 

1529
00:27:11,080 --> 00:27:12,870
be some binary form that only that

1530
00:27:12,870 --> 00:27:12,880
 

1531
00:27:12,880 --> 00:27:15,269
database management system can read and

1532
00:27:15,269 --> 00:27:15,279
 

1533
00:27:15,279 --> 00:27:17,159
write to now we'll see this one and the

1534
00:27:17,159 --> 00:27:17,169
 

1535
00:27:17,169 --> 00:27:18,779
cloud systems later on but there are

1536
00:27:18,779 --> 00:27:18,789
 

1537
00:27:18,789 --> 00:27:21,090
sort of now these sort of universal file

1538
00:27:21,090 --> 00:27:21,100
 

1539
00:27:21,100 --> 00:27:23,310
database file formats things like or

1540
00:27:23,310 --> 00:27:23,320
 

1541
00:27:23,320 --> 00:27:26,039
Corp RK or Aereo right these are things

1542
00:27:26,039 --> 00:27:26,049
 

1543
00:27:26,049 --> 00:27:27,960
that are designed to be usable orange

1544
00:27:27,960 --> 00:27:27,970
 

1545
00:27:27,970 --> 00:27:29,370
estable by different database systems

1546
00:27:29,370 --> 00:27:29,380

1547
00:27:29,380 --> 00:27:32,610
but in general usually the actual raw

1548
00:27:32,610 --> 00:27:32,620
 

1549
00:27:32,620 --> 00:27:34,919
files and cells are what can only on be

1550
00:27:34,919 --> 00:27:34,929
 

1551
00:27:34,929 --> 00:27:36,480
understood by that the davis isn't that

1552
00:27:36,480 --> 00:27:36,490
 

1553
00:27:36,490 --> 00:27:40,019
made it so because they're just files on

1554
00:27:40,019 --> 00:27:40,029
 

1555
00:27:40,029 --> 00:27:41,820
disk the operating system doesn't know

1556
00:27:41,820 --> 00:27:41,830
 

1557
00:27:41,830 --> 00:27:43,139
anything about them right doesn't know

1558
00:27:43,139 --> 00:27:43,149
 

1559
00:27:43,149 --> 00:27:44,370
that they're special right there's no

1560
00:27:44,370 --> 00:27:44,380
 

1561
00:27:44,380 --> 00:27:46,350
that their database files so all sort of

1562
00:27:46,350 --> 00:27:46,360
 

1563
00:27:46,360 --> 00:27:48,060
the standard file protection mechanisms

1564
00:27:48,060 --> 00:27:48,070
 

1565
00:27:48,070 --> 00:27:50,460
that you get from from regular files in

1566
00:27:50,460 --> 00:27:50,470
 

1567
00:27:50,470 --> 00:27:52,019
the OS that's the always before that

1568
00:27:52,019 --> 00:27:52,029
 

1569
00:27:52,029 --> 00:27:53,399
provide that for you as well

1570
00:27:53,399 --> 00:27:53,409
 

1571
00:27:53,409 --> 00:27:54,810
right you can just run your database

1572
00:27:54,810 --> 00:27:54,820
 

1573
00:27:54,820 --> 00:27:57,269
system on top of ext4 txt three you know

1574
00:27:57,269 --> 00:27:57,279
 

1575
00:27:57,279 --> 00:27:59,610
whatever in Windows provides right and

1576
00:27:59,610 --> 00:27:59,620
 

1577
00:27:59,620 --> 00:28:01,500
the upper levels of the the system for

1578
00:28:01,500 --> 00:28:01,510
 

1579
00:28:01,510 --> 00:28:04,919
the most part maybe don't care I would

1580
00:28:04,919 --> 00:28:04,929
 

1581
00:28:04,929 --> 00:28:09,870
say in the early 1980s there was a sort

1582
00:28:09,870 --> 00:28:09,880
 

1583
00:28:09,880 --> 00:28:12,810
of a moment or a trend where the the

1584
00:28:12,810 --> 00:28:12,820
 

1585
00:28:12,820 --> 00:28:14,430
database vendors decided that all the

1586
00:28:14,430 --> 00:28:14,440

1587
00:28:14,440 --> 00:28:16,620
file systems were crap and that they

1588
00:28:16,620 --> 00:28:16,630
 

1589
00:28:16,630 --> 00:28:17,760
wanted to actually implement their own

1590
00:28:17,760 --> 00:28:17,770
 

1591
00:28:17,770 --> 00:28:19,760
database if ik says the duck file system

1592
00:28:19,760 --> 00:28:19,770
 

1593
00:28:19,770 --> 00:28:21,630
so what that means it's like you just

1594
00:28:21,630 --> 00:28:21,640
 

1595
00:28:21,640 --> 00:28:23,190
take the role blocks on the extra

1596
00:28:23,190 --> 00:28:23,200
 

1597
00:28:23,200 --> 00:28:25,169
storage device and then the data system

1598
00:28:25,169 --> 00:28:25,179
 

1599
00:28:25,179 --> 00:28:26,789
knew how to build a file system on top

1600
00:28:26,789 --> 00:28:26,799
 

1601
00:28:26,799 --> 00:28:28,260
of it and it's read and write to the

1602
00:28:28,260 --> 00:28:28,270
 

1603
00:28:28,270 --> 00:28:31,080
role blocks as far as I know nobody

1604
00:28:31,080 --> 00:28:31,090
 

1605
00:28:31,090 --> 00:28:32,250
actually does that anymore

1606
00:28:32,250 --> 00:28:32,260
 

1607
00:28:32,260 --> 00:28:33,899
I personally sorry you wouldn't build a

1608
00:28:33,899 --> 00:28:33,909
 

1609
00:28:33,909 --> 00:28:36,120
new system today and start doing that

1610
00:28:36,120 --> 00:28:36,130
 

1611
00:28:36,130 --> 00:28:37,919
there's conventional wisdom is that you

1612
00:28:37,919 --> 00:28:37,929
 

1613
00:28:37,929 --> 00:28:39,630
really only get maybe look at 10 or 15

1614
00:28:39,630 --> 00:28:39,640
 

1615
00:28:39,640 --> 00:28:42,090
set 15% speed-up in performance if

1616
00:28:42,090 --> 00:28:42,100
 

1617
00:28:42,100 --> 00:28:44,039
you've run your own file system over

1618
00:28:44,039 --> 00:28:44,049
 

1619
00:28:44,049 --> 00:28:46,980
something like ext4 and for that kind of

1620
00:28:46,980 --> 00:28:46,990
 

1621
00:28:46,990 --> 00:28:48,090
speed up it's just not worth the

1622
00:28:48,090 --> 00:28:48,100
 

1623
00:28:48,100 --> 00:28:50,100
engineering effort right and also makes

1624
00:28:50,100 --> 00:28:50,110
 

1625
00:28:50,110 --> 00:28:50,820
your

1626
00:28:50,820 --> 00:28:50,830

1627
00:28:50,830 --> 00:28:52,500
it makes her you know database isn't

1628
00:28:52,500 --> 00:28:52,510
 

1629
00:28:52,510 --> 00:28:56,820
less portable so in general the the most

1630
00:28:56,820 --> 00:28:56,830
 

1631
00:28:56,830 --> 00:28:58,290
major data systems are just gonna run on

1632
00:28:58,290 --> 00:28:58,300
 

1633
00:28:58,300 --> 00:28:59,730
existing file systems and that you know

1634
00:28:59,730 --> 00:28:59,740
 

1635
00:28:59,740 --> 00:29:01,110
and that's good enough for us it's not

1636
00:29:01,110 --> 00:29:01,120
 

1637
00:29:01,120 --> 00:29:05,820
great but it's good so now this the same

1638
00:29:05,820 --> 00:29:05,830
 

1639
00:29:05,830 --> 00:29:07,170
reverse first need to build is what

1640
00:29:07,170 --> 00:29:07,180
 

1641
00:29:07,180 --> 00:29:09,570
we'll call the Storage Manager and this

1642
00:29:09,570 --> 00:29:09,580
 

1643
00:29:09,580 --> 00:29:12,120
is essentially responsible for the the

1644
00:29:12,120 --> 00:29:12,130
 

1645
00:29:12,130 --> 00:29:13,710
maintaining the database files whether

1646
00:29:13,710 --> 00:29:13,720
 

1647
00:29:13,720 --> 00:29:15,450
it's one or multiple ones but the

1648
00:29:15,450 --> 00:29:15,460

1649
00:29:15,460 --> 00:29:16,920
storage manager is responsible we're

1650
00:29:16,920 --> 00:29:16,930
 

1651
00:29:16,930 --> 00:29:19,110
saying here's here's my files and I know

1652
00:29:19,110 --> 00:29:19,120
 

1653
00:29:19,120 --> 00:29:20,910
how to get pages in and out of them so

1654
00:29:20,910 --> 00:29:20,920
 

1655
00:29:20,920 --> 00:29:22,800
the files are going to be organized as a

1656
00:29:22,800 --> 00:29:22,810
 

1657
00:29:22,810 --> 00:29:25,170
collection of pages right you sort of

1658
00:29:25,170 --> 00:29:25,180
 

1659
00:29:25,180 --> 00:29:26,570
take the file and you split it up to

1660
00:29:26,570 --> 00:29:26,580
 

1661
00:29:26,580 --> 00:29:28,770
different chunks and each of these

1662
00:29:28,770 --> 00:29:28,780
 

1663
00:29:28,780 --> 00:29:31,890
chunks to be called a page and so the

1664
00:29:31,890 --> 00:29:31,900
 

1665
00:29:31,900 --> 00:29:33,540
storage manager to keep track of what

1666
00:29:33,540 --> 00:29:33,550
 

1667
00:29:33,550 --> 00:29:34,980
data needs to read and write to pages

1668
00:29:34,980 --> 00:29:34,990
 

1669
00:29:34,990 --> 00:29:37,920
how much free space are is in pages if

1670
00:29:37,920 --> 00:29:37,930
 

1671
00:29:37,930 --> 00:29:39,480
you want to do compaction maybe remove

1672
00:29:39,480 --> 00:29:39,490
 

1673
00:29:39,490 --> 00:29:41,280
empty empty pages that are being used

1674
00:29:41,280 --> 00:29:41,290
 

1675
00:29:41,290 --> 00:29:43,050
and used less space like this is what

1676
00:29:43,050 --> 00:29:43,060
 

1677
00:29:43,060 --> 00:29:45,960
the storage manager provides for you so

1678
00:29:45,960 --> 00:29:45,970
 

1679
00:29:45,970 --> 00:29:49,440
now a database case as I said is a fixed

1680
00:29:49,440 --> 00:29:49,450
 

1681
00:29:49,450 --> 00:29:52,230
size block of data and it can contain

1682
00:29:52,230 --> 00:29:52,240
 

1683
00:29:52,240 --> 00:29:53,550
anything that that relates to our

1684
00:29:53,550 --> 00:29:53,560
 

1685
00:29:53,560 --> 00:29:56,220
database right so it contains tuples

1686
00:29:56,220 --> 00:29:56,230
 

1687
00:29:56,230 --> 00:29:57,900
that contain a metadata about the tuples

1688
00:29:57,900 --> 00:29:57,910
 

1689
00:29:57,910 --> 00:30:00,810
it contain indexes and log records it

1690
00:30:00,810 --> 00:30:00,820
 

1691
00:30:00,820 --> 00:30:03,210
can contain intermediate results from a

1692
00:30:03,210 --> 00:30:03,220
 

1693
00:30:03,220 --> 00:30:04,380
query as we're running it because we

1694
00:30:04,380 --> 00:30:04,390
 

1695
00:30:04,390 --> 00:30:05,580
have to fill out the disk so we don't

1696
00:30:05,580 --> 00:30:05,590
 

1697
00:30:05,590 --> 00:30:07,350
have enough memory right for our

1698
00:30:07,350 --> 00:30:07,360
 

1699
00:30:07,360 --> 00:30:09,000
purposes in this class we'll just assume

1700
00:30:09,000 --> 00:30:09,010
 

1701
00:30:09,010 --> 00:30:10,620
that we're only dealing with pages that

1702
00:30:10,620 --> 00:30:10,630

1703
00:30:10,630 --> 00:30:13,740
contain tuples typically you also don't

1704
00:30:13,740 --> 00:30:13,750
 

1705
00:30:13,750 --> 00:30:15,720
mix the type of data you store it in a

1706
00:30:15,720 --> 00:30:15,730
 

1707
00:30:15,730 --> 00:30:17,460
page so you're not gonna have a single

1708
00:30:17,460 --> 00:30:17,470
 

1709
00:30:17,470 --> 00:30:18,900
page that'll have some you know to have

1710
00:30:18,900 --> 00:30:18,910
 

1711
00:30:18,910 --> 00:30:22,620
index data and tuple data right from us

1712
00:30:22,620 --> 00:30:22,630
 

1713
00:30:22,630 --> 00:30:24,240
this is done mostly for myself for

1714
00:30:24,240 --> 00:30:24,250
 

1715
00:30:24,250 --> 00:30:25,470
engineering standpoint you want to have

1716
00:30:25,470 --> 00:30:25,480
 

1717
00:30:25,480 --> 00:30:27,500
each page only stored data for a

1718
00:30:27,500 --> 00:30:27,510
 

1719
00:30:27,510 --> 00:30:31,350
specific class or specific type now some

1720
00:30:31,350 --> 00:30:31,360
 

1721
00:30:31,360 --> 00:30:32,610
systems actually required pages

1722
00:30:32,610 --> 00:30:32,620

1723
00:30:32,620 --> 00:30:34,890
activities self-contained and what I

1724
00:30:34,890 --> 00:30:34,900
 

1725
00:30:34,900 --> 00:30:37,530
mean by that is all the data you need to

1726
00:30:37,530 --> 00:30:37,540
 

1727
00:30:37,540 --> 00:30:40,560
know about how to read and interpret the

1728
00:30:40,560 --> 00:30:40,570
 

1729
00:30:40,570 --> 00:30:42,450
data that's stored inside that page has

1730
00:30:42,450 --> 00:30:42,460
 

1731
00:30:42,460 --> 00:30:45,600
to be stored in that page so an example

1732
00:30:45,600 --> 00:30:45,610
 

1733
00:30:45,610 --> 00:30:46,830
with this be let's say I'm doing like

1734
00:30:46,830 --> 00:30:46,840
 

1735
00:30:46,840 --> 00:30:48,750
dictionary compression right dictionary

1736
00:30:48,750 --> 00:30:48,760
 

1737
00:30:48,760 --> 00:30:50,250
compression is you take a string that

1738
00:30:50,250 --> 00:30:50,260
 

1739
00:30:50,260 --> 00:30:52,260
occurs a lot and instead of storing the

1740
00:30:52,260 --> 00:30:52,270
 

1741
00:30:52,270 --> 00:30:53,880
actual raw characters we just stored an

1742
00:30:53,880 --> 00:30:53,890
 

1743
00:30:53,890 --> 00:30:55,680
integer to say here's what here's the

1744
00:30:55,680 --> 00:30:55,690

1745
00:30:55,690 --> 00:30:58,140
placeholder for that original string so

1746
00:30:58,140 --> 00:30:58,150
 

1747
00:30:58,150 --> 00:30:59,550
you need a dictionary to say here's how

1748
00:30:59,550 --> 00:30:59,560
 

1749
00:30:59,560 --> 00:31:01,050
to map that integer to the actual

1750
00:31:01,050 --> 00:31:01,060
 

1751
00:31:01,060 --> 00:31:03,810
original string so if you store that

1752
00:31:03,810 --> 00:31:03,820
 

1753
00:31:03,820 --> 00:31:04,380
dictionary

1754
00:31:04,380 --> 00:31:04,390
 

1755
00:31:04,390 --> 00:31:06,240
one page and then store the database

1756
00:31:06,240 --> 00:31:06,250

1757
00:31:06,250 --> 00:31:07,650
that's encoded with that dictionary on

1758
00:31:07,650 --> 00:31:07,660
 

1759
00:31:07,660 --> 00:31:10,020
another page if that dictionary page

1760
00:31:10,020 --> 00:31:10,030
 

1761
00:31:10,030 --> 00:31:12,540
gets trashed right now you can't

1762
00:31:12,540 --> 00:31:12,550
 

1763
00:31:12,550 --> 00:31:15,930
unencoded the original page so some

1764
00:31:15,930 --> 00:31:15,940
 

1765
00:31:15,940 --> 00:31:18,180
systems like Oracle they they're worried

1766
00:31:18,180 --> 00:31:18,190
 

1767
00:31:18,190 --> 00:31:19,590
about disaster recovery they actually

1768
00:31:19,590 --> 00:31:19,600
 

1769
00:31:19,600 --> 00:31:21,270
say oh no they did everything you need

1770
00:31:21,270 --> 00:31:21,280
 

1771
00:31:21,280 --> 00:31:22,410
to know to actually interpret the data

1772
00:31:22,410 --> 00:31:22,420
 

1773
00:31:22,420 --> 00:31:24,690
has to be on stored on that page so that

1774
00:31:24,690 --> 00:31:24,700
 

1775
00:31:24,700 --> 00:31:26,850
way if for whatever reason that that

1776
00:31:26,850 --> 00:31:26,860
 

1777
00:31:26,860 --> 00:31:29,010
page gets trashed the damage is only

1778
00:31:29,010 --> 00:31:29,020
 

1779
00:31:29,020 --> 00:31:32,850
isolated to that single page right so

1780
00:31:32,850 --> 00:31:32,860
 

1781
00:31:32,860 --> 00:31:34,590
that is actually specific to Oracle I

1782
00:31:34,590 --> 00:31:34,600
 

1783
00:31:34,600 --> 00:31:35,760
don't think anybody else actually does

1784
00:31:35,760 --> 00:31:35,770
 

1785
00:31:35,770 --> 00:31:38,490
this but I think it's actually a really

1786
00:31:38,490 --> 00:31:38,500
 

1787
00:31:38,500 --> 00:31:40,710
good idea but and it if it causes them

1788
00:31:40,710 --> 00:31:40,720
 

1789
00:31:40,720 --> 00:31:42,150
to make certain other design decisions

1790
00:31:42,150 --> 00:31:42,160
 

1791
00:31:42,160 --> 00:31:44,520
that may be seen inefficient from a

1792
00:31:44,520 --> 00:31:44,530
 

1793
00:31:44,530 --> 00:31:46,080
performance standpoint but from a you

1794
00:31:46,080 --> 00:31:46,090

1795
00:31:46,090 --> 00:31:48,030
know never losing data I think it's a

1796
00:31:48,030 --> 00:31:48,040
 

1797
00:31:48,040 --> 00:31:51,300
good idea so now every page is going to

1798
00:31:51,300 --> 00:31:51,310
 

1799
00:31:51,310 --> 00:31:53,580
have a unique identifier we'll call it

1800
00:31:53,580 --> 00:31:53,590
 

1801
00:31:53,590 --> 00:31:58,230
the page ID B now the basin's gonna have

1802
00:31:58,230 --> 00:31:58,240
 

1803
00:31:58,240 --> 00:31:59,970
to maintain some kind of indirection map

1804
00:31:59,970 --> 00:31:59,980
 

1805
00:31:59,980 --> 00:32:02,010
that allows you to figure out how to

1806
00:32:02,010 --> 00:32:02,020
 

1807
00:32:02,020 --> 00:32:04,200
take a page ID because that's what a

1808
00:32:04,200 --> 00:32:04,210
 

1809
00:32:04,210 --> 00:32:05,430
that's what the upper levels of the

1810
00:32:05,430 --> 00:32:05,440
 

1811
00:32:05,440 --> 00:32:07,410
system are going to access or ask for it

1812
00:32:07,410 --> 00:32:07,420
 

1813
00:32:07,420 --> 00:32:08,670
are the upper levels of the system is

1814
00:32:08,670 --> 00:32:08,680
 

1815
00:32:08,680 --> 00:32:10,230
gonna say give me page one two three and

1816
00:32:10,230 --> 00:32:10,240
 

1817
00:32:10,240 --> 00:32:12,060
now the storage manager needs to have a

1818
00:32:12,060 --> 00:32:12,070
 

1819
00:32:12,070 --> 00:32:14,790
some kind of mapping layer to take that

1820
00:32:14,790 --> 00:32:14,800
 

1821
00:32:14,800 --> 00:32:17,010
page number and find the file and the

1822
00:32:17,010 --> 00:32:17,020
 

1823
00:32:17,020 --> 00:32:18,870
offset of where can go get that

1824
00:32:18,870 --> 00:32:18,880
 

1825
00:32:18,880 --> 00:32:21,180
particular page and then put give the

1826
00:32:21,180 --> 00:32:21,190
 

1827
00:32:21,190 --> 00:32:24,440
bytes back up to whoever asked for it so

1828
00:32:24,440 --> 00:32:24,450
 

1829
00:32:24,450 --> 00:32:26,490
they also - I think say the reason why

1830
00:32:26,490 --> 00:32:26,500
 

1831
00:32:26,500 --> 00:32:27,690
we want to keep it fixed size is that

1832
00:32:27,690 --> 00:32:27,700
 

1833
00:32:27,700 --> 00:32:30,840
that way in our file if we say oh we

1834
00:32:30,840 --> 00:32:30,850
 

1835
00:32:30,850 --> 00:32:32,790
want page one to three and we know it's

1836
00:32:32,790 --> 00:32:32,800
 

1837
00:32:32,800 --> 00:32:35,250
in this file at offset 100 we know

1838
00:32:35,250 --> 00:32:35,260
 

1839
00:32:35,260 --> 00:32:37,500
exactly how to calculate where to go in

1840
00:32:37,500 --> 00:32:37,510
 

1841
00:32:37,510 --> 00:32:38,820
that jump in that file to get the data

1842
00:32:38,820 --> 00:32:38,830
 

1843
00:32:38,830 --> 00:32:40,740
that we need if we have variable length

1844
00:32:40,740 --> 00:32:40,750
 

1845
00:32:40,750 --> 00:32:41,880
pages then when you have to have an

1846
00:32:41,880 --> 00:32:41,890

1847
00:32:41,890 --> 00:32:43,740
indirection layer at the top to say oh

1848
00:32:43,740 --> 00:32:43,750
 

1849
00:32:43,750 --> 00:32:46,350
you want page 100 it's at this all set

1850
00:32:46,350 --> 00:32:46,360

1851
00:32:46,360 --> 00:32:47,880
and now you've you maintain that thing

1852
00:32:47,880 --> 00:32:47,890
 

1853
00:32:47,890 --> 00:32:48,990
and now you're pro the problems if you

1854
00:32:48,990 --> 00:32:49,000
 

1855
00:32:49,000 --> 00:32:51,030
delete a page that may be variable size

1856
00:32:51,030 --> 00:32:51,040
 

1857
00:32:51,040 --> 00:32:52,350
now you have a hole that you maybe can't

1858
00:32:52,350 --> 00:32:52,360
 

1859
00:32:52,360 --> 00:32:54,630
fill back up so pages are always gonna

1860
00:32:54,630 --> 00:32:54,640

1861
00:32:54,640 --> 00:32:55,980
be fixed sized and just makes everything

1862
00:32:55,980 --> 00:32:55,990
 

1863
00:32:55,990 --> 00:32:58,350
much easier and we'll see how we do

1864
00:32:58,350 --> 00:32:58,360
 

1865
00:32:58,360 --> 00:32:59,640
handle this with tuples that can be

1866
00:32:59,640 --> 00:32:59,650
 

1867
00:32:59,650 --> 00:33:04,020
variable length within a page so one

1868
00:33:04,020 --> 00:33:04,030
 

1869
00:33:04,030 --> 00:33:06,060
thing I confess is that as I go along

1870
00:33:06,060 --> 00:33:06,070

1871
00:33:06,070 --> 00:33:07,980
sometimes I'll say page and sometimes

1872
00:33:07,980 --> 00:33:07,990
 

1873
00:33:07,990 --> 00:33:10,650
I'll say block right there the words are

1874
00:33:10,650 --> 00:33:10,660
 

1875
00:33:10,660 --> 00:33:12,360
in some ways inter interchangeable but

1876
00:33:12,360 --> 00:33:12,370
 

1877
00:33:12,370 --> 00:33:14,930
I'll try to use page as much as often

1878
00:33:14,930 --> 00:33:14,940
 

1879
00:33:14,940 --> 00:33:17,359
and there's different concepts of pages

1880
00:33:17,359 --> 00:33:17,369
 

1881
00:33:17,369 --> 00:33:18,739
in our system that we have to be mindful

1882
00:33:18,739 --> 00:33:18,749
 

1883
00:33:18,749 --> 00:33:21,589
as well so at the lowest point you have

1884
00:33:21,589 --> 00:33:21,599
 

1885
00:33:21,599 --> 00:33:23,719
what's called a harbor page this is what

1886
00:33:23,719 --> 00:33:23,729
 

1887
00:33:23,729 --> 00:33:25,070
the actual storage device itself

1888
00:33:25,070 --> 00:33:25,080
 

1889
00:33:25,080 --> 00:33:27,320
provides to you right into the operating

1890
00:33:27,320 --> 00:33:27,330
 

1891
00:33:27,330 --> 00:33:28,759
system when you ask to read and write a

1892
00:33:28,759 --> 00:33:28,769
 

1893
00:33:28,769 --> 00:33:31,009
particular block a particular page right

1894
00:33:31,009 --> 00:33:31,019
 

1895
00:33:31,019 --> 00:33:32,599
different storage devices have different

1896
00:33:32,599 --> 00:33:32,609
 

1897
00:33:32,609 --> 00:33:34,039
page sizes but in general they're

1898
00:33:34,039 --> 00:33:34,049
 

1899
00:33:34,049 --> 00:33:36,799
usually four kilobytes then now in the

1900
00:33:36,799 --> 00:33:36,809
 

1901
00:33:36,809 --> 00:33:38,869
operating system again it's going to be

1902
00:33:38,869 --> 00:33:38,879
 

1903
00:33:38,879 --> 00:33:40,580
providing this notion of pages as well

1904
00:33:40,580 --> 00:33:40,590

1905
00:33:40,590 --> 00:33:43,099
and these pages are usually four

1906
00:33:43,099 --> 00:33:43,109
 

1907
00:33:43,109 --> 00:33:45,200
kilobytes by default in Linux with Linux

1908
00:33:45,200 --> 00:33:45,210
 

1909
00:33:45,210 --> 00:33:46,969
and windows are four kilobytes but

1910
00:33:46,969 --> 00:33:46,979
 

1911
00:33:46,979 --> 00:33:48,469
there's ways to in turn turn on what's

1912
00:33:48,469 --> 00:33:48,479
 

1913
00:33:48,479 --> 00:33:50,479
called huge pages where you can have it

1914
00:33:50,479 --> 00:33:50,489
 

1915
00:33:50,489 --> 00:33:53,210
actually organize memory as in you know

1916
00:33:53,210 --> 00:33:53,220
 

1917
00:33:53,220 --> 00:33:56,419
up to one gigabyte pages I need you this

1918
00:33:56,419 --> 00:33:56,429
 

1919
00:33:56,429 --> 00:33:57,649
because this reduces the size of the

1920
00:33:57,649 --> 00:33:57,659
 

1921
00:33:57,659 --> 00:33:59,839
page directory of your TLB and that fits

1922
00:33:59,839 --> 00:33:59,849
 

1923
00:33:59,849 --> 00:34:01,009
more than the cache and you have fewer

1924
00:34:01,009 --> 00:34:01,019
 

1925
00:34:01,019 --> 00:34:04,219
cache misses on that but in our world

1926
00:34:04,219 --> 00:34:04,229
 

1927
00:34:04,229 --> 00:34:05,450
again we care about the database page

1928
00:34:05,450 --> 00:34:05,460
 

1929
00:34:05,460 --> 00:34:06,950
and is essentially the way to think

1930
00:34:06,950 --> 00:34:06,960
 

1931
00:34:06,960 --> 00:34:07,909
about this is like we're going to

1932
00:34:07,909 --> 00:34:07,919
 

1933
00:34:07,919 --> 00:34:10,460
organize in our database the you know

1934
00:34:10,460 --> 00:34:10,470
 

1935
00:34:10,470 --> 00:34:12,770
our own pages but in those pages one

1936
00:34:12,770 --> 00:34:12,780
 

1937
00:34:12,780 --> 00:34:14,720
should get mapped to OS sized pages and

1938
00:34:14,720 --> 00:34:14,730
 

1939
00:34:14,730 --> 00:34:16,490
the OSI pages get mapped to physical

1940
00:34:16,490 --> 00:34:16,500

1941
00:34:16,500 --> 00:34:18,619
pages right so you think would be always

1942
00:34:18,619 --> 00:34:18,629
 

1943
00:34:18,629 --> 00:34:20,119
four kilobytes because that's what the

1944
00:34:20,119 --> 00:34:20,129
 

1945
00:34:20,129 --> 00:34:22,309
harbor once and it's the OS one but in

1946
00:34:22,309 --> 00:34:22,319
 

1947
00:34:22,319 --> 00:34:26,210
practice it varies a lot right so at one

1948
00:34:26,210 --> 00:34:26,220
 

1949
00:34:26,220 --> 00:34:28,250
in the spectrum you have sequel Lite

1950
00:34:28,250 --> 00:34:28,260
 

1951
00:34:28,260 --> 00:34:30,379
that has one kilobyte pages and this

1952
00:34:30,379 --> 00:34:30,389

1953
00:34:30,389 --> 00:34:31,609
makes sense because they're you know

1954
00:34:31,609 --> 00:34:31,619
 

1955
00:34:31,619 --> 00:34:33,799
sequel is designed to run on really

1956
00:34:33,799 --> 00:34:33,809
 

1957
00:34:33,809 --> 00:34:35,990
small embedded devices that may not have

1958
00:34:35,990 --> 00:34:36,000
 

1959
00:34:36,000 --> 00:34:39,799
four kilobyte pages db2 and Oracle

1960
00:34:39,799 --> 00:34:39,809
 

1961
00:34:39,809 --> 00:34:41,599
support for Cabaye pages Post Crescent

1962
00:34:41,599 --> 00:34:41,609
 

1963
00:34:41,609 --> 00:34:43,970
sequel server or AQI pages and then my

1964
00:34:43,970 --> 00:34:43,980
 

1965
00:34:43,980 --> 00:34:46,399
sequel in uncompressed form is 16

1966
00:34:46,399 --> 00:34:46,409
 

1967
00:34:46,409 --> 00:34:48,769
kilobyte pages I actually don't know why

1968
00:34:48,769 --> 00:34:48,779
 

1969
00:34:48,779 --> 00:34:50,539
they do this I have a hunch because they

1970
00:34:50,539 --> 00:34:50,549
 

1971
00:34:50,549 --> 00:34:52,220
want to do ink that's organized tables

1972
00:34:52,220 --> 00:34:52,230
 

1973
00:34:52,230 --> 00:34:57,200
which we'll talk about later on but when

1974
00:34:57,200 --> 00:34:57,210
 

1975
00:34:57,210 --> 00:34:58,519
you do compression they also can store

1976
00:34:58,519 --> 00:34:58,529
 

1977
00:34:58,529 --> 00:35:00,400
pages and smaller sizes as well

1978
00:35:00,400 --> 00:35:00,410
 

1979
00:35:00,410 --> 00:35:03,460
well we're not gonna talk about it here

1980
00:35:03,460 --> 00:35:03,470
 

1981
00:35:03,470 --> 00:35:06,529
what I'll say though is that the harbor

1982
00:35:06,529 --> 00:35:06,539
 

1983
00:35:06,539 --> 00:35:08,000
page size is sort of what it can

1984
00:35:08,000 --> 00:35:08,010
 

1985
00:35:08,010 --> 00:35:09,559
guarantee as what I call a fail-safe

1986
00:35:09,559 --> 00:35:09,569
 

1987
00:35:09,569 --> 00:35:12,559
write meaning it can guarantee that if

1988
00:35:12,559 --> 00:35:12,569
 

1989
00:35:12,569 --> 00:35:13,730
you tell it to write for well kilobyte

1990
00:35:13,730 --> 00:35:13,740
 

1991
00:35:13,740 --> 00:35:15,410
pages and it says I wrote for clout

1992
00:35:15,410 --> 00:35:15,420
 

1993
00:35:15,420 --> 00:35:17,839
pages like that-like or you tell it to

1994
00:35:17,839 --> 00:35:17,849
 

1995
00:35:17,849 --> 00:35:19,490
write a page and that page size is 4

1996
00:35:19,490 --> 00:35:19,500
 

1997
00:35:19,500 --> 00:35:21,140
kilobytes on the hardware it'll

1998
00:35:21,140 --> 00:35:21,150
 

1999
00:35:21,150 --> 00:35:23,180
guarantee that it neither all 4

2000
00:35:23,180 --> 00:35:23,190
 

2001
00:35:23,190 --> 00:35:24,529
kilobytes get written or none of them

2002
00:35:24,529 --> 00:35:24,539
 

2003
00:35:24,539 --> 00:35:26,990
get written right so that means that if

2004
00:35:26,990 --> 00:35:27,000
 

2005
00:35:27,000 --> 00:35:28,700
you have larger database pages and you

2006
00:35:28,700 --> 00:35:28,710
 

2007
00:35:28,710 --> 00:35:30,620
flushed him out the disk you may have to

2008
00:35:30,620 --> 00:35:30,630
 

2009
00:35:30,630 --> 00:35:33,020
do extra extra work extra protection

2010
00:35:33,020 --> 00:35:33,030
 

2011
00:35:33,030 --> 00:35:35,839
mechanisms to make sure that you don't

2012
00:35:35,839 --> 00:35:35,849

2013
00:35:35,849 --> 00:35:37,310
have torn up dates right if you have a

2014
00:35:37,310 --> 00:35:37,320
 

2015
00:35:37,320 --> 00:35:39,829
16 kilobyte page on my sequel and the

2016
00:35:39,829 --> 00:35:39,839
 

2017
00:35:39,839 --> 00:35:41,240
harbor can only provide four kilobyte

2018
00:35:41,240 --> 00:35:41,250
 

2019
00:35:41,250 --> 00:35:43,130
atomic writes you don't want to write

2020
00:35:43,130 --> 00:35:43,140
 

2021
00:35:43,140 --> 00:35:44,599
the first you know eight kilobytes and

2022
00:35:44,599 --> 00:35:44,609
 

2023
00:35:44,609 --> 00:35:46,490
then crash and come back and have you

2024
00:35:46,490 --> 00:35:46,500
 

2025
00:35:46,500 --> 00:35:48,800
know in half of your update so we'll see

2026
00:35:48,800 --> 00:35:48,810
 

2027
00:35:48,810 --> 00:35:50,120
this when we talk about logging recovery

2028
00:35:50,120 --> 00:35:50,130
 

2029
00:35:50,130 --> 00:35:51,980
systems like my sequel have to do extra

2030
00:35:51,980 --> 00:35:51,990

2031
00:35:51,990 --> 00:35:53,720
work to make sure that you know they're

2032
00:35:53,720 --> 00:35:53,730
 

2033
00:35:53,730 --> 00:35:55,790
writing their data out safely and they

2034
00:35:55,790 --> 00:35:55,800
 

2035
00:35:55,800 --> 00:35:57,230
know it's been staged and all everything

2036
00:35:57,230 --> 00:35:57,240
 

2037
00:35:57,240 --> 00:36:01,220
is always there all right so now we need

2038
00:36:01,220 --> 00:36:01,230
 

2039
00:36:01,230 --> 00:36:04,310
every we have these pages and we know

2040
00:36:04,310 --> 00:36:04,320
 

2041
00:36:04,320 --> 00:36:05,930
where a bunch of files and they're going

2042
00:36:05,930 --> 00:36:05,940
 

2043
00:36:05,940 --> 00:36:07,550
split up into pages now we need a

2044
00:36:07,550 --> 00:36:07,560
 

2045
00:36:07,560 --> 00:36:08,750
mechanism to figure out how to actually

2046
00:36:08,750 --> 00:36:08,760
 

2047
00:36:08,760 --> 00:36:11,300
find where the page that we want right

2048
00:36:11,300 --> 00:36:11,310
 

2049
00:36:11,310 --> 00:36:12,589
can the upper levels of the system are

2050
00:36:12,589 --> 00:36:12,599
 

2051
00:36:12,599 --> 00:36:14,210
gonna say gimme page one two three and

2052
00:36:14,210 --> 00:36:14,220
 

2053
00:36:14,220 --> 00:36:15,740
now we need to go figure out where that

2054
00:36:15,740 --> 00:36:15,750
 

2055
00:36:15,750 --> 00:36:17,839
page one two three is or we want to

2056
00:36:17,839 --> 00:36:17,849
 

2057
00:36:17,849 --> 00:36:20,030
order the system could say hey I want to

2058
00:36:20,030 --> 00:36:20,040
 

2059
00:36:20,040 --> 00:36:22,670
write this amount of data gave me a page

2060
00:36:22,670 --> 00:36:22,680
 

2061
00:36:22,680 --> 00:36:25,550
that has a free slot and now our storage

2062
00:36:25,550 --> 00:36:25,560
 

2063
00:36:25,560 --> 00:36:26,570
layer has to figure out how to how to

2064
00:36:26,570 --> 00:36:26,580
 

2065
00:36:26,580 --> 00:36:29,599
find that so there's a couple different

2066
00:36:29,599 --> 00:36:29,609
 

2067
00:36:29,609 --> 00:36:31,310
ways to actually do this I'm gonna focus

2068
00:36:31,310 --> 00:36:31,320
 

2069
00:36:31,320 --> 00:36:33,339
on the first one

2070
00:36:33,339 --> 00:36:33,349
 

2071
00:36:33,349 --> 00:36:35,810
because this is the most common the

2072
00:36:35,810 --> 00:36:35,820
 

2073
00:36:35,820 --> 00:36:37,990
sequential and sort of file organization

2074
00:36:37,990 --> 00:36:38,000
 

2075
00:36:38,000 --> 00:36:39,800
we'll see this when we talk about

2076
00:36:39,800 --> 00:36:39,810
 

2077
00:36:39,810 --> 00:36:41,359
indexes this is typically how you

2078
00:36:41,359 --> 00:36:41,369
 

2079
00:36:41,369 --> 00:36:44,359
implement clustering indexes right well

2080
00:36:44,359 --> 00:36:44,369

2081
00:36:44,369 --> 00:36:46,359
basically the heap file is unsorted

2082
00:36:46,359 --> 00:36:46,369

2083
00:36:46,369 --> 00:36:48,800
sequential or sort of files are sorted

2084
00:36:48,800 --> 00:36:48,810
 

2085
00:36:48,810 --> 00:36:50,060
and you need index to make that happen

2086
00:36:50,060 --> 00:36:50,070
 

2087
00:36:50,070 --> 00:36:51,589
and we'll talk about that later

2088
00:36:51,589 --> 00:36:51,599
 

2089
00:36:51,599 --> 00:36:53,300
and then hashing file organization is

2090
00:36:53,300 --> 00:36:53,310

2091
00:36:53,310 --> 00:36:55,040
just an easy extension to the heap file

2092
00:36:55,040 --> 00:36:55,050
 

2093
00:36:55,050 --> 00:36:57,349
one so I'll focus on the first one the

2094
00:36:57,349 --> 00:36:57,359
 

2095
00:36:57,359 --> 00:36:58,730
other thing I'll say also at this point

2096
00:36:58,730 --> 00:36:58,740
 

2097
00:36:58,740 --> 00:37:00,829
is that we don't really care what's

2098
00:37:00,829 --> 00:37:00,839
 

2099
00:37:00,839 --> 00:37:03,020
inside of our pages at this point again

2100
00:37:03,020 --> 00:37:03,030
 

2101
00:37:03,030 --> 00:37:04,460
we're only trying to say give me a page

2102
00:37:04,460 --> 00:37:04,470
 

2103
00:37:04,470 --> 00:37:06,230
or give me a free slot within a page we

2104
00:37:06,230 --> 00:37:06,240
 

2105
00:37:06,240 --> 00:37:07,250
don't care what's actually stored in

2106
00:37:07,250 --> 00:37:07,260
 

2107
00:37:07,260 --> 00:37:09,710
that right and that makes this what our

2108
00:37:09,710 --> 00:37:09,720
 

2109
00:37:09,720 --> 00:37:11,030
job a bit more easier here because we

2110
00:37:11,030 --> 00:37:11,040
 

2111
00:37:11,040 --> 00:37:12,890
don't care about finding an exact you

2112
00:37:12,890 --> 00:37:12,900
 

2113
00:37:12,900 --> 00:37:14,750
know exact things we can let the upper

2114
00:37:14,750 --> 00:37:14,760

2115
00:37:14,760 --> 00:37:18,050
levels of the system do that for us so a

2116
00:37:18,050 --> 00:37:18,060
 

2117
00:37:18,060 --> 00:37:22,280
database heap or a heap file is a

2118
00:37:22,280 --> 00:37:22,290
 

2119
00:37:22,290 --> 00:37:25,220
unorganized collection of pages where

2120
00:37:25,220 --> 00:37:25,230
 

2121
00:37:25,230 --> 00:37:27,410
the two books can be stored in random

2122
00:37:27,410 --> 00:37:27,420

2123
00:37:27,420 --> 00:37:28,849
order or the data that were storing can

2124
00:37:28,849 --> 00:37:28,859
 

2125
00:37:28,859 --> 00:37:31,339
be sorted random border right we have a

2126
00:37:31,339 --> 00:37:31,349
 

2127
00:37:31,349 --> 00:37:32,810
chunk of data we want to write to a page

2128
00:37:32,810 --> 00:37:32,820
 

2129
00:37:32,820 --> 00:37:34,910
we don't care if it's we're using heat

2130
00:37:34,910 --> 00:37:34,920
 

2131
00:37:34,920 --> 00:37:36,140
Bob we don't care where that actually

2132
00:37:36,140 --> 00:37:36,150

2133
00:37:36,150 --> 00:37:38,140
goes as long as it goes somewhere

2134
00:37:38,140 --> 00:37:38,150
 

2135
00:37:38,150 --> 00:37:41,630
so the basic API we need to be a support

2136
00:37:41,630 --> 00:37:41,640

2137
00:37:41,640 --> 00:37:42,380
in a

2138
00:37:42,380 --> 00:37:42,390

2139
00:37:42,390 --> 00:37:45,620
file or a database heap a storage

2140
00:37:45,620 --> 00:37:45,630
 

2141
00:37:45,630 --> 00:37:47,779
manager is the ability to get and delete

2142
00:37:47,779 --> 00:37:47,789
 

2143
00:37:47,789 --> 00:37:51,380
a page as well as to iterate over every

2144
00:37:51,380 --> 00:37:51,390
 

2145
00:37:51,390 --> 00:37:53,779
possible page right so I if I have 100

2146
00:37:53,779 --> 00:37:53,789
 

2147
00:37:53,789 --> 00:37:56,180
pages I want a way to say here's you

2148
00:37:56,180 --> 00:37:56,190
 

2149
00:37:56,190 --> 00:37:58,670
know here's the the chunks of memory to

2150
00:37:58,670 --> 00:37:58,680
 

2151
00:37:58,680 --> 00:38:01,700
that for each of those 100 pages now

2152
00:38:01,700 --> 00:38:01,710
 

2153
00:38:01,710 --> 00:38:02,690
we're gonna need to maintain some

2154
00:38:02,690 --> 00:38:02,700
 

2155
00:38:02,700 --> 00:38:04,700
metadata to keep track of what pages

2156
00:38:04,700 --> 00:38:04,710
 

2157
00:38:04,710 --> 00:38:07,250
exist obviously and when you keep track

2158
00:38:07,250 --> 00:38:07,260
 

2159
00:38:07,260 --> 00:38:10,009
of where do we have free space because

2160
00:38:10,009 --> 00:38:10,019
 

2161
00:38:10,019 --> 00:38:11,539
again we may want to say get a page that

2162
00:38:11,539 --> 00:38:11,549
 

2163
00:38:11,549 --> 00:38:13,670
has a free space that we can store this

2164
00:38:13,670 --> 00:38:13,680
 

2165
00:38:13,680 --> 00:38:16,250
amount of data so now there's two ways

2166
00:38:16,250 --> 00:38:16,260
 

2167
00:38:16,260 --> 00:38:19,220
to organize this the first is a linked

2168
00:38:19,220 --> 00:38:19,230
 

2169
00:38:19,230 --> 00:38:20,599
list and the friend the second is a page

2170
00:38:20,599 --> 00:38:20,609
 

2171
00:38:20,609 --> 00:38:22,609
directory and sort of a spoiler is

2172
00:38:22,609 --> 00:38:22,619
 

2173
00:38:22,619 --> 00:38:25,099
everyone does the page rectory approach

2174
00:38:25,099 --> 00:38:25,109
 

2175
00:38:25,109 --> 00:38:26,630
but it's good to understand what the

2176
00:38:26,630 --> 00:38:26,640
 

2177
00:38:26,640 --> 00:38:28,579
link list one is because it's sort of

2178
00:38:28,579 --> 00:38:28,589
 

2179
00:38:28,589 --> 00:38:31,390
see why you need to use a page directory

2180
00:38:31,390 --> 00:38:31,400
 

2181
00:38:31,400 --> 00:38:34,700
so the linked list approach is you have

2182
00:38:34,700 --> 00:38:34,710
 

2183
00:38:34,710 --> 00:38:37,039
a single header page that only contains

2184
00:38:37,039 --> 00:38:37,049
 

2185
00:38:37,049 --> 00:38:39,829
two pointers and the pointer is going to

2186
00:38:39,829 --> 00:38:39,839
 

2187
00:38:39,839 --> 00:38:41,870
point to two different linked lists so

2188
00:38:41,870 --> 00:38:41,880
 

2189
00:38:41,880 --> 00:38:43,819
the first link list will be the free

2190
00:38:43,819 --> 00:38:43,829
 

2191
00:38:43,829 --> 00:38:46,039
page list so these are pages that have

2192
00:38:46,039 --> 00:38:46,049
 

2193
00:38:46,049 --> 00:38:47,990
at least some free space where you can

2194
00:38:47,990 --> 00:38:48,000
 

2195
00:38:48,000 --> 00:38:51,410
actually store data and then the second

2196
00:38:51,410 --> 00:38:51,420
 

2197
00:38:51,420 --> 00:38:53,029
linked list is the data page these are

2198
00:38:53,029 --> 00:38:53,039
 

2199
00:38:53,039 --> 00:38:54,890
pages there that there are there is no

2200
00:38:54,890 --> 00:38:54,900
 

2201
00:38:54,900 --> 00:38:58,579
more free space right so what will

2202
00:38:58,579 --> 00:38:58,589

2203
00:38:58,589 --> 00:39:00,740
happen is if you want to say get me page

2204
00:39:00,740 --> 00:39:00,750
 

2205
00:39:00,750 --> 00:39:02,749
one two three you actually have to

2206
00:39:02,749 --> 00:39:02,759
 

2207
00:39:02,759 --> 00:39:04,370
traverse these linked lists and figure

2208
00:39:04,370 --> 00:39:04,380
 

2209
00:39:04,380 --> 00:39:06,499
out where the page it is that you want

2210
00:39:06,499 --> 00:39:06,509
 

2211
00:39:06,509 --> 00:39:08,630
or if you need say I want to insert a

2212
00:39:08,630 --> 00:39:08,640
 

2213
00:39:08,640 --> 00:39:10,910
new record and I need to find space you

2214
00:39:10,910 --> 00:39:10,920
 

2215
00:39:10,920 --> 00:39:12,019
only have to you don't have to follow

2216
00:39:12,019 --> 00:39:12,029
 

2217
00:39:12,029 --> 00:39:15,559
along the the free page list all right

2218
00:39:15,559 --> 00:39:15,569
 

2219
00:39:15,569 --> 00:39:16,759
and this is because there's an

2220
00:39:16,759 --> 00:39:16,769
 

2221
00:39:16,769 --> 00:39:18,890
additional metadata that we need that

2222
00:39:18,890 --> 00:39:18,900
 

2223
00:39:18,900 --> 00:39:20,690
we're not actually going to track inside

2224
00:39:20,690 --> 00:39:20,700
 

2225
00:39:20,700 --> 00:39:23,509
of the the header page right about like

2226
00:39:23,509 --> 00:39:23,519
 

2227
00:39:23,519 --> 00:39:25,160
what free space we actually have all

2228
00:39:25,160 --> 00:39:25,170
 

2229
00:39:25,170 --> 00:39:26,420
that's going to be stored directly

2230
00:39:26,420 --> 00:39:26,430
 

2231
00:39:26,430 --> 00:39:29,349
inside the pages themselves right

2232
00:39:29,349 --> 00:39:29,359
 

2233
00:39:29,359 --> 00:39:31,370
there's no reason we couldn't it's just

2234
00:39:31,370 --> 00:39:31,380
 

2235
00:39:31,380 --> 00:39:32,329
this is sort of a strawman

2236
00:39:32,329 --> 00:39:32,339
 

2237
00:39:32,339 --> 00:39:34,509
implementation we don't actually do this

2238
00:39:34,509 --> 00:39:34,519
 

2239
00:39:34,519 --> 00:39:36,440
all right the other thing we have

2240
00:39:36,440 --> 00:39:36,450
 

2241
00:39:36,450 --> 00:39:37,940
problem is that say we want to get page

2242
00:39:37,940 --> 00:39:37,950
 

2243
00:39:37,950 --> 00:39:39,740
one to three we end up having to do

2244
00:39:39,740 --> 00:39:39,750
 

2245
00:39:39,750 --> 00:39:41,120
basically a sequential scan on both of

2246
00:39:41,120 --> 00:39:41,130

2247
00:39:41,130 --> 00:39:43,240
these until we find the one that we want

2248
00:39:43,240 --> 00:39:43,250
 

2249
00:39:43,250 --> 00:39:47,690
right so a better approach and whatever

2250
00:39:47,690 --> 00:39:47,700
 

2251
00:39:47,700 --> 00:39:49,549
much pretty much everyone does is to use

2252
00:39:49,549 --> 00:39:49,559
 

2253
00:39:49,559 --> 00:39:51,529
the page directory where this is now

2254
00:39:51,529 --> 00:39:51,539
 

2255
00:39:51,539 --> 00:39:53,029
you're gonna have a special directory

2256
00:39:53,029 --> 00:39:53,039
 

2257
00:39:53,039 --> 00:39:55,279
page it's usually at the beginning of

2258
00:39:55,279 --> 00:39:55,289
 

2259
00:39:55,289 --> 00:39:56,300
the file so c-cold like

2260
00:39:56,300 --> 00:39:56,310
 

2261
00:39:56,310 --> 00:39:58,070
first page is always this directory and

2262
00:39:58,070 --> 00:39:58,080
 

2263
00:39:58,080 --> 00:40:00,650
just tells you here's all the pages that

2264
00:40:00,650 --> 00:40:00,660
 

2265
00:40:00,660 --> 00:40:02,450
I have at different different locations

2266
00:40:02,450 --> 00:40:02,460
 

2267
00:40:02,460 --> 00:40:04,760
in my database files and here's

2268
00:40:04,760 --> 00:40:04,770
 

2269
00:40:04,770 --> 00:40:06,260
information about how many how much free

2270
00:40:06,260 --> 00:40:06,270
 

2271
00:40:06,270 --> 00:40:08,990
space they actually have so now you can

2272
00:40:08,990 --> 00:40:09,000
 

2273
00:40:09,000 --> 00:40:10,580
easily traverse to every single page cuz

2274
00:40:10,580 --> 00:40:10,590
 

2275
00:40:10,590 --> 00:40:12,170
you just look in the directory and you

2276
00:40:12,170 --> 00:40:12,180
 

2277
00:40:12,180 --> 00:40:13,940
say you want to get page 1 2 3 can you

2278
00:40:13,940 --> 00:40:13,950
 

2279
00:40:13,950 --> 00:40:15,020
look in the directory it tells you

2280
00:40:15,020 --> 00:40:15,030
 

2281
00:40:15,030 --> 00:40:17,600
exactly where it is and you want to find

2282
00:40:17,600 --> 00:40:17,610
 

2283
00:40:17,610 --> 00:40:19,130
a page with free space then the

2284
00:40:19,130 --> 00:40:19,140
 

2285
00:40:19,140 --> 00:40:20,720
directory can can maintain this as for

2286
00:40:20,720 --> 00:40:20,730
 

2287
00:40:20,730 --> 00:40:22,760
as well so of course now you have to

2288
00:40:22,760 --> 00:40:22,770

2289
00:40:22,770 --> 00:40:26,060
make sure that the directory page is

2290
00:40:26,060 --> 00:40:26,070
 

2291
00:40:26,070 --> 00:40:27,350
always in sync with the actual data

2292
00:40:27,350 --> 00:40:27,360
 

2293
00:40:27,360 --> 00:40:30,890
pages themselves right because if the

2294
00:40:30,890 --> 00:40:30,900
 

2295
00:40:30,900 --> 00:40:32,180
data page has free space and the

2296
00:40:32,180 --> 00:40:32,190
 

2297
00:40:32,190 --> 00:40:33,530
directory page thinks it doesn't and

2298
00:40:33,530 --> 00:40:33,540
 

2299
00:40:33,540 --> 00:40:34,700
you're never actually gonna use that

2300
00:40:34,700 --> 00:40:34,710
 

2301
00:40:34,710 --> 00:40:36,740
space alright so you always have to make

2302
00:40:36,740 --> 00:40:36,750
 

2303
00:40:36,750 --> 00:40:38,330
sure that you you flush out the dirty

2304
00:40:38,330 --> 00:40:38,340
 

2305
00:40:38,340 --> 00:40:40,280
page anytime you you add new pages or

2306
00:40:40,280 --> 00:40:40,290
 

2307
00:40:40,290 --> 00:40:42,920
modify these things so what what

2308
00:40:42,920 --> 00:40:42,930
 

2309
00:40:42,930 --> 00:40:44,900
happened in this case here if the the

2310
00:40:44,900 --> 00:40:44,910
 

2311
00:40:44,910 --> 00:40:49,570
directory page is trashed are we screwed

2312
00:40:49,570 --> 00:40:49,580


2313
00:40:49,580 --> 00:40:55,670
hey check ahead no why exactly so if the

2314
00:40:55,670 --> 00:40:55,680
 

2315
00:40:55,680 --> 00:40:57,350
first page gets blown away for whatever

2316
00:40:57,350 --> 00:40:57,360

2317
00:40:57,360 --> 00:41:00,260
reason hey we can always go back and

2318
00:41:00,260 --> 00:41:00,270
 

2319
00:41:00,270 --> 00:41:02,000
scan through and look at every single

2320
00:41:02,000 --> 00:41:02,010
 

2321
00:41:02,010 --> 00:41:05,120
page and reconstruct it right small

2322
00:41:05,120 --> 00:41:05,130
 

2323
00:41:05,130 --> 00:41:07,220
files no big deal if I have a one

2324
00:41:07,220 --> 00:41:07,230
 

2325
00:41:07,230 --> 00:41:09,080
petabyte database that's that's problem

2326
00:41:09,080 --> 00:41:09,090

2327
00:41:09,090 --> 00:41:10,580
right because it's gonna take me days to

2328
00:41:10,580 --> 00:41:10,590
 

2329
00:41:10,590 --> 00:41:12,980
actually do this so there's extra

2330
00:41:12,980 --> 00:41:12,990
 

2331
00:41:12,990 --> 00:41:14,540
protection mechanisms we can have in our

2332
00:41:14,540 --> 00:41:14,550

2333
00:41:14,550 --> 00:41:16,460
system by writing out to the log all the

2334
00:41:16,460 --> 00:41:16,470
 

2335
00:41:16,470 --> 00:41:19,160
updates we have to our directory page to

2336
00:41:19,160 --> 00:41:19,170
 

2337
00:41:19,170 --> 00:41:21,670
avoid having to recreate everything

2338
00:41:21,670 --> 00:41:21,680
 

2339
00:41:21,680 --> 00:41:23,690
alright so this this approach is

2340
00:41:23,690 --> 00:41:23,700
 

2341
00:41:23,700 --> 00:41:25,070
resilient to ferrars even if the

2342
00:41:25,070 --> 00:41:25,080
 

2343
00:41:25,080 --> 00:41:26,390
directory page fails even though again

2344
00:41:26,390 --> 00:41:26,400
 

2345
00:41:26,400 --> 00:41:28,040
remember I said that some systems don't

2346
00:41:28,040 --> 00:41:28,050
 

2347
00:41:28,050 --> 00:41:30,770
like to have data you need to

2348
00:41:30,770 --> 00:41:30,780
 

2349
00:41:30,780 --> 00:41:32,450
reconstruct you know for a single page

2350
00:41:32,450 --> 00:41:32,460
 

2351
00:41:32,460 --> 00:41:34,670
spread across multiple pages in this

2352
00:41:34,670 --> 00:41:34,680
 

2353
00:41:34,680 --> 00:41:36,680
case here we can always make sure we can

2354
00:41:36,680 --> 00:41:36,690
 

2355
00:41:36,690 --> 00:41:38,000
always go back and recreate the

2356
00:41:38,000 --> 00:41:38,010
 

2357
00:41:38,010 --> 00:41:39,620
directory page ideally it'd be nice if

2358
00:41:39,620 --> 00:41:39,630
 

2359
00:41:39,630 --> 00:41:41,780
we didn't have to but we always have

2360
00:41:41,780 --> 00:41:41,790
 

2361
00:41:41,790 --> 00:41:45,350
that sort of fail back mechanism okay

2362
00:41:45,350 --> 00:41:45,360
 

2363
00:41:45,360 --> 00:41:48,290
so at this point we know about files we

2364
00:41:48,290 --> 00:41:48,300
 

2365
00:41:48,300 --> 00:41:49,250
know about how we're gonna split the

2366
00:41:49,250 --> 00:41:49,260
 

2367
00:41:49,260 --> 00:41:50,900
files up into pages and then now we have

2368
00:41:50,900 --> 00:41:50,910
 

2369
00:41:50,910 --> 00:41:54,860
a directory page directory component

2370
00:41:54,860 --> 00:41:54,870
 

2371
00:41:54,870 --> 00:41:56,840
that allows us to find the pages that we

2372
00:41:56,840 --> 00:41:56,850
 

2373
00:41:56,850 --> 00:41:59,570
want so now the next question is how do

2374
00:41:59,570 --> 00:41:59,580
 

2375
00:41:59,580 --> 00:42:00,890
we act what are having actually organize

2376
00:42:00,890 --> 00:42:00,900
 

2377
00:42:00,900 --> 00:42:03,680
the data inside of these pages and this

2378
00:42:03,680 --> 00:42:03,690
 

2379
00:42:03,690 --> 00:42:07,160
was the page layout is so every page is

2380
00:42:07,160 --> 00:42:07,170
 

2381
00:42:07,170 --> 00:42:09,260
containing a header right regards what

2382
00:42:09,260 --> 00:42:09,270
 

2383
00:42:09,270 --> 00:42:10,220
size it is

2384
00:42:10,220 --> 00:42:10,230

2385
00:42:10,230 --> 00:42:11,240
and this header is going to contain

2386
00:42:11,240 --> 00:42:11,250
 

2387
00:42:11,250 --> 00:42:14,380
metadata about the that particular page

2388
00:42:14,380 --> 00:42:14,390
 

2389
00:42:14,390 --> 00:42:16,520
right things like how much free space

2390
00:42:16,520 --> 00:42:16,530
 

2391
00:42:16,530 --> 00:42:19,430
there is it can also maintain check sums

2392
00:42:19,430 --> 00:42:19,440
 

2393
00:42:19,440 --> 00:42:20,960
right so when you write out the file you

2394
00:42:20,960 --> 00:42:20,970
 

2395
00:42:20,970 --> 00:42:22,580
take a checksum of it and that way our

2396
00:42:22,580 --> 00:42:22,590
 

2397
00:42:22,590 --> 00:42:24,020
server out the page took a checksum of

2398
00:42:24,020 --> 00:42:24,030
 

2399
00:42:24,030 --> 00:42:25,430
it when you write it out and that way

2400
00:42:25,430 --> 00:42:25,440
 

2401
00:42:25,440 --> 00:42:26,570
when you read it back into the page

2402
00:42:26,570 --> 00:42:26,580
 

2403
00:42:26,580 --> 00:42:28,460
something the checksum doesn't match you

2404
00:42:28,460 --> 00:42:28,470
 

2405
00:42:28,470 --> 00:42:30,700
know the page got corrupted in some way

2406
00:42:30,700 --> 00:42:30,710
 

2407
00:42:30,710 --> 00:42:33,740
you'll also often want to maintain the

2408
00:42:33,740 --> 00:42:33,750
 

2409
00:42:33,750 --> 00:42:35,720
the version number of the data center

2410
00:42:35,720 --> 00:42:35,730
 

2411
00:42:35,730 --> 00:42:38,240
system that created the the page so that

2412
00:42:38,240 --> 00:42:38,250
 

2413
00:42:38,250 --> 00:42:39,680
way if you change your page layout and

2414
00:42:39,680 --> 00:42:39,690
 

2415
00:42:39,690 --> 00:42:41,540
you load in an old database file you

2416
00:42:41,540 --> 00:42:41,550
 

2417
00:42:41,550 --> 00:42:43,400
know it's not you know you know what

2418
00:42:43,400 --> 00:42:43,410
 

2419
00:42:43,410 --> 00:42:46,849
layout to expect we'll talk about this

2420
00:42:46,849 --> 00:42:46,859
 

2421
00:42:46,859 --> 00:42:49,010
later on for control information but

2422
00:42:49,010 --> 00:42:49,020
 

2423
00:42:49,020 --> 00:42:50,810
sometimes you contain transaction

2424
00:42:50,810 --> 00:42:50,820
 

2425
00:42:50,820 --> 00:42:53,000
visibility information about the data

2426
00:42:53,000 --> 00:42:53,010
 

2427
00:42:53,010 --> 00:42:54,859
that's on this page so that you know

2428
00:42:54,859 --> 00:42:54,869
 

2429
00:42:54,869 --> 00:42:56,840
whether a transaction that's active is

2430
00:42:56,840 --> 00:42:56,850
 

2431
00:42:56,850 --> 00:42:58,070
actually couldn't be able to see any of

2432
00:42:58,070 --> 00:42:58,080
 

2433
00:42:58,080 --> 00:43:00,550
the tuples or any data inside this page

2434
00:43:00,550 --> 00:43:00,560
 

2435
00:43:00,560 --> 00:43:02,570
it's compression information like the

2436
00:43:02,570 --> 00:43:02,580
 

2437
00:43:02,580 --> 00:43:03,620
dictionary encoding that we talked about

2438
00:43:03,620 --> 00:43:03,630
 

2439
00:43:03,630 --> 00:43:06,050
before right so all this is gonna be

2440
00:43:06,050 --> 00:43:06,060
 

2441
00:43:06,060 --> 00:43:08,060
stored in the header and as I mentioned

2442
00:43:08,060 --> 00:43:08,070
 

2443
00:43:08,070 --> 00:43:09,440
some systems will actually require the

2444
00:43:09,440 --> 00:43:09,450
 

2445
00:43:09,450 --> 00:43:14,810
pages to be self-contained so now within

2446
00:43:14,810 --> 00:43:14,820
 

2447
00:43:14,820 --> 00:43:16,790
a page right every page has a header now

2448
00:43:16,790 --> 00:43:16,800
 

2449
00:43:16,800 --> 00:43:17,810
we're gonna talk about what actually the

2450
00:43:17,810 --> 00:43:17,820
 

2451
00:43:17,820 --> 00:43:19,310
data block looks like what are we

2452
00:43:19,310 --> 00:43:19,320
 

2453
00:43:19,320 --> 00:43:22,310
actually storing so for this we're just

2454
00:43:22,310 --> 00:43:22,320
 

2455
00:43:22,320 --> 00:43:25,310
going to focus on tuples we'll see this

2456
00:43:25,310 --> 00:43:25,320
 

2457
00:43:25,320 --> 00:43:26,720
later when we talk about indexes or

2458
00:43:26,720 --> 00:43:26,730
 

2459
00:43:26,730 --> 00:43:28,609
other things or log records these are

2460
00:43:28,609 --> 00:43:28,619
 

2461
00:43:28,619 --> 00:43:30,620
also going to be stored in pages but for

2462
00:43:30,620 --> 00:43:30,630
 

2463
00:43:30,630 --> 00:43:32,030
our purposes here we just care about how

2464
00:43:32,030 --> 00:43:32,040
 

2465
00:43:32,040 --> 00:43:33,290
we're actually gonna represent two polls

2466
00:43:33,290 --> 00:43:33,300
 

2467
00:43:33,300 --> 00:43:36,320
inside of these pages so for this

2468
00:43:36,320 --> 00:43:36,330
 

2469
00:43:36,330 --> 00:43:38,240
there's essentially two two broad

2470
00:43:38,240 --> 00:43:38,250
 

2471
00:43:38,250 --> 00:43:40,220
approaches the first is a tuple

2472
00:43:40,220 --> 00:43:40,230
 

2473
00:43:40,230 --> 00:43:42,140
warrington approach we're actually

2474
00:43:42,140 --> 00:43:42,150
 

2475
00:43:42,150 --> 00:43:43,430
storing the data for actually individual

2476
00:43:43,430 --> 00:43:43,440
 

2477
00:43:43,440 --> 00:43:45,170
tuples and the second one is a log

2478
00:43:45,170 --> 00:43:45,180
 

2479
00:43:45,180 --> 00:43:47,180
structured approach I'll go through both

2480
00:43:47,180 --> 00:43:47,190
 

2481
00:43:47,190 --> 00:43:51,109
of them okay so having a store pages in

2482
00:43:51,109 --> 00:43:51,119
 

2483
00:43:51,119 --> 00:43:53,660
a table so I first want to propose a

2484
00:43:53,660 --> 00:43:53,670
 

2485
00:43:53,670 --> 00:43:56,540
strawman like a bad idea and then we'll

2486
00:43:56,540 --> 00:43:56,550
 

2487
00:43:56,550 --> 00:43:57,710
see how she had to make this better

2488
00:43:57,710 --> 00:43:57,720
 

2489
00:43:57,720 --> 00:44:00,980
right so let's say that in our page all

2490
00:44:00,980 --> 00:44:00,990
 

2491
00:44:00,990 --> 00:44:03,380
we really have in our in our header the

2492
00:44:03,380 --> 00:44:03,390
 

2493
00:44:03,390 --> 00:44:04,670
simple thing we need to keep track of is

2494
00:44:04,670 --> 00:44:04,680
 

2495
00:44:04,680 --> 00:44:06,590
the number of tuples that we have in our

2496
00:44:06,590 --> 00:44:06,600
 

2497
00:44:06,600 --> 00:44:09,080
in our page and for this we're gonna

2498
00:44:09,080 --> 00:44:09,090
 

2499
00:44:09,090 --> 00:44:10,580
assume that all our troubles are fixed

2500
00:44:10,580 --> 00:44:10,590
 

2501
00:44:10,590 --> 00:44:12,290
length size I mean they're always gonna

2502
00:44:12,290 --> 00:44:12,300
 

2503
00:44:12,300 --> 00:44:14,599
be you know 100 100 bytes or you know

2504
00:44:14,599 --> 00:44:14,609
 

2505
00:44:14,609 --> 00:44:17,540
some some some number like that all

2506
00:44:17,540 --> 00:44:17,550
 

2507
00:44:17,550 --> 00:44:18,710
right so what's the easiest thing we can

2508
00:44:18,710 --> 00:44:18,720
 

2509
00:44:18,720 --> 00:44:23,460
do to insert a new to Plymouth's

2510
00:44:23,460 --> 00:44:23,470


2511
00:44:23,470 --> 00:44:25,020
well I heard it yeah so I want to

2512
00:44:25,020 --> 00:44:25,030
 

2513
00:44:25,030 --> 00:44:27,000
certainly much new tuples I just I know

2514
00:44:27,000 --> 00:44:27,010
 

2515
00:44:27,010 --> 00:44:29,280
where my header stops in my page and I

2516
00:44:29,280 --> 00:44:29,290
 

2517
00:44:29,290 --> 00:44:31,800
just I just start appending to poles one

2518
00:44:31,800 --> 00:44:31,810
 

2519
00:44:31,810 --> 00:44:33,990
by one until you know jog run out of

2520
00:44:33,990 --> 00:44:34,000
 

2521
00:44:34,000 --> 00:44:36,839
space right simple and then let's say

2522
00:44:36,839 --> 00:44:36,849
 

2523
00:44:36,849 --> 00:44:38,820
I'm gonna update my my header to say I

2524
00:44:38,820 --> 00:44:38,830
 

2525
00:44:38,830 --> 00:44:40,080
have three tuples so that way when I

2526
00:44:40,080 --> 00:44:40,090
 

2527
00:44:40,090 --> 00:44:41,880
come back if I want to write a fourth

2528
00:44:41,880 --> 00:44:41,890
 

2529
00:44:41,890 --> 00:44:43,650
people I know how to jump to that

2530
00:44:43,650 --> 00:44:43,660
 

2531
00:44:43,660 --> 00:44:45,540
location all right what's the problem

2532
00:44:45,540 --> 00:44:45,550
 

2533
00:44:45,550 --> 00:44:51,330
with this approach right what happens if

2534
00:44:51,330 --> 00:44:51,340
 

2535
00:44:51,340 --> 00:44:53,460
I if I delete a tuple all right so I

2536
00:44:53,460 --> 00:44:53,470
 

2537
00:44:53,470 --> 00:44:56,370
sleep the middle guy here I have two

2538
00:44:56,370 --> 00:44:56,380
 

2539
00:44:56,380 --> 00:44:58,859
tuples now if I keep it pending I'm

2540
00:44:58,859 --> 00:44:58,869
 

2541
00:44:58,869 --> 00:44:59,430
gonna miss that

2542
00:44:59,430 --> 00:44:59,440

2543
00:44:59,440 --> 00:45:00,870
so maybe what I need to do is actually

2544
00:45:00,870 --> 00:45:00,880
 

2545
00:45:00,880 --> 00:45:02,310
start from the beginning and keep

2546
00:45:02,310 --> 00:45:02,320
 

2547
00:45:02,320 --> 00:45:05,400
scanning until I find tuple that are

2548
00:45:05,400 --> 00:45:05,410
 

2549
00:45:05,410 --> 00:45:08,240
tuple slob that's actually used right

2550
00:45:08,240 --> 00:45:08,250
 

2551
00:45:08,250 --> 00:45:12,470
what's another obvious problem with this

2552
00:45:12,470 --> 00:45:12,480


2553
00:45:12,480 --> 00:45:14,520
right I said it was fixed length right

2554
00:45:14,520 --> 00:45:14,530
 

2555
00:45:14,530 --> 00:45:16,710
what happens in is variable length does

2556
00:45:16,710 --> 00:45:16,720
 

2557
00:45:16,720 --> 00:45:22,080
this work no right so how would actually

2558
00:45:22,080 --> 00:45:22,090
 

2559
00:45:22,090 --> 00:45:24,030
store a very linked data in this if I

2560
00:45:24,030 --> 00:45:24,040
 

2561
00:45:24,040 --> 00:45:25,560
say I want to search the next tuple how

2562
00:45:25,560 --> 00:45:25,570
 

2563
00:45:25,570 --> 00:45:26,640
do I figure out where to where to put it

2564
00:45:26,640 --> 00:45:26,650
 

2565
00:45:26,650 --> 00:45:32,130
I either had something in the in the

2566
00:45:32,130 --> 00:45:32,140
 

2567
00:45:32,140 --> 00:45:33,630
header that says here's where every

2568
00:45:33,630 --> 00:45:33,640
 

2569
00:45:33,640 --> 00:45:35,070
tuple here is worth all set every tuple

2570
00:45:35,070 --> 00:45:35,080
 

2571
00:45:35,080 --> 00:45:38,280
is or I sequentially scan - I find a

2572
00:45:38,280 --> 00:45:38,290
 

2573
00:45:38,290 --> 00:45:40,230
free spot then had to figure out when

2574
00:45:40,230 --> 00:45:40,240
 

2575
00:45:40,240 --> 00:45:42,120
the next tuple starts because I then

2576
00:45:42,120 --> 00:45:42,130
 

2577
00:45:42,130 --> 00:45:43,320
figure out where actually I can start

2578
00:45:43,320 --> 00:45:43,330
 

2579
00:45:43,330 --> 00:45:47,970
storing data all right so this is what

2580
00:45:47,970 --> 00:45:47,980
 

2581
00:45:47,980 --> 00:45:49,740
the slotted page architecture or layout

2582
00:45:49,740 --> 00:45:49,750

2583
00:45:49,750 --> 00:45:52,680
fix fixes so what I'll say is that it's

2584
00:45:52,680 --> 00:45:52,690
 

2585
00:45:52,690 --> 00:45:54,450
a lot of pages are essentially how every

2586
00:45:54,450 --> 00:45:54,460
 

2587
00:45:54,460 --> 00:45:57,120
disk database system promotes the

2588
00:45:57,120 --> 00:45:57,130
 

2589
00:45:57,130 --> 00:45:57,930
majority of them actually are

2590
00:45:57,930 --> 00:45:57,940
 

2591
00:45:57,940 --> 00:46:00,210
implemented the exact details may be

2592
00:46:00,210 --> 00:46:00,220
 

2593
00:46:00,220 --> 00:46:01,950
slightly different but a high level they

2594
00:46:01,950 --> 00:46:01,960
 

2595
00:46:01,960 --> 00:46:04,380
work all the same way so what's gonna

2596
00:46:04,380 --> 00:46:04,390
 

2597
00:46:04,390 --> 00:46:06,180
happen now is our header we're gonna

2598
00:46:06,180 --> 00:46:06,190
 

2599
00:46:06,190 --> 00:46:08,490
have this thing called a slot array all

2600
00:46:08,490 --> 00:46:08,500
 

2601
00:46:08,500 --> 00:46:09,359
right so we have a header information

2602
00:46:09,359 --> 00:46:09,369
 

2603
00:46:09,369 --> 00:46:11,790
the things we talked about before now we

2604
00:46:11,790 --> 00:46:11,800
 

2605
00:46:11,800 --> 00:46:13,680
have a slot array that's going to

2606
00:46:13,680 --> 00:46:13,690
 

2607
00:46:13,690 --> 00:46:17,460
contain a mapping of all sets for tuples

2608
00:46:17,460 --> 00:46:17,470

2609
00:46:17,470 --> 00:46:19,620
at different positions to their their

2610
00:46:19,620 --> 00:46:19,630
 

2611
00:46:19,630 --> 00:46:22,260
starting location in in the actual data

2612
00:46:22,260 --> 00:46:22,270
 

2613
00:46:22,270 --> 00:46:24,839
space and so down below we have our

2614
00:46:24,839 --> 00:46:24,849
 

2615
00:46:24,849 --> 00:46:26,400
fixed length and verbling tuples - all

2616
00:46:26,400 --> 00:46:26,410
 

2617
00:46:26,410 --> 00:46:27,660
stored in line with each other

2618
00:46:27,660 --> 00:46:27,670
 

2619
00:46:27,670 --> 00:46:30,270
and then these these offsets point to

2620
00:46:30,270 --> 00:46:30,280
 

2621
00:46:30,280 --> 00:46:32,970
where they start all right so this is

2622
00:46:32,970 --> 00:46:32,980
 

2623
00:46:32,980 --> 00:46:34,470
sort of adding another indirection layer

2624
00:46:34,470 --> 00:46:34,480
 

2625
00:46:34,480 --> 00:46:36,750
inside of our page so we can say things

2626
00:46:36,750 --> 00:46:36,760
 

2627
00:46:36,760 --> 00:46:37,580
like

2628
00:46:37,580 --> 00:46:37,590
 

2629
00:46:37,590 --> 00:46:40,170
at a high level give me page one two

2630
00:46:40,170 --> 00:46:40,180
 

2631
00:46:40,180 --> 00:46:42,750
three and give me to pool five in that

2632
00:46:42,750 --> 00:46:42,760
 

2633
00:46:42,760 --> 00:46:44,700
inside that page and I go look at my

2634
00:46:44,700 --> 00:46:44,710
 

2635
00:46:44,710 --> 00:46:46,470
slot array and that'll tell me where I

2636
00:46:46,470 --> 00:46:46,480
 

2637
00:46:46,480 --> 00:46:49,470
can find page five right and the way

2638
00:46:49,470 --> 00:46:49,480
 

2639
00:46:49,480 --> 00:46:51,360
we're gonna add new tuples is that the

2640
00:46:51,360 --> 00:46:51,370

2641
00:46:51,370 --> 00:46:53,250
slot array is always gonna grow from

2642
00:46:53,250 --> 00:46:53,260
 

2643
00:46:53,260 --> 00:46:55,650
from beginning to the end and then the

2644
00:46:55,650 --> 00:46:55,660
 

2645
00:46:55,660 --> 00:46:57,780
fixed length the actual data of the

2646
00:46:57,780 --> 00:46:57,790
 

2647
00:46:57,790 --> 00:46:59,070
tuples themselves are going to grow from

2648
00:46:59,070 --> 00:46:59,080
 

2649
00:46:59,080 --> 00:47:00,810
the end to the beginning and at some

2650
00:47:00,810 --> 00:47:00,820
 

2651
00:47:00,820 --> 00:47:02,280
point the two meet and I can't store

2652
00:47:02,280 --> 00:47:02,290
 

2653
00:47:02,290 --> 00:47:04,410
anything anything else and then the page

2654
00:47:04,410 --> 00:47:04,420
 

2655
00:47:04,420 --> 00:47:08,130
is considered full right again this is

2656
00:47:08,130 --> 00:47:08,140
 

2657
00:47:08,140 --> 00:47:09,300
another indirection layer that allows us

2658
00:47:09,300 --> 00:47:09,310
 

2659
00:47:09,310 --> 00:47:11,490
to reorganize the pages without having

2660
00:47:11,490 --> 00:47:11,500
 

2661
00:47:11,500 --> 00:47:13,410
to modify or change anything up above in

2662
00:47:13,410 --> 00:47:13,420
 

2663
00:47:13,420 --> 00:47:15,720
our system so maybe the case let's say I

2664
00:47:15,720 --> 00:47:15,730
 

2665
00:47:15,730 --> 00:47:19,050
delete tuple 3 and now I have a bunch of

2666
00:47:19,050 --> 00:47:19,060
 

2667
00:47:19,060 --> 00:47:20,850
free space here and I can actually

2668
00:47:20,850 --> 00:47:20,860

2669
00:47:20,860 --> 00:47:22,800
compact and slide over tuple four to be

2670
00:47:22,800 --> 00:47:22,810
 

2671
00:47:22,810 --> 00:47:25,350
contiguous with tuple two and all that I

2672
00:47:25,350 --> 00:47:25,360
 

2673
00:47:25,360 --> 00:47:26,970
do is update my slot array to say where

2674
00:47:26,970 --> 00:47:26,980
 

2675
00:47:26,980 --> 00:47:29,280
tuple for now it starts and everything

2676
00:47:29,280 --> 00:47:29,290

2677
00:47:29,290 --> 00:47:30,600
else in the system doesn't know doesn't

2678
00:47:30,600 --> 00:47:30,610
 

2679
00:47:30,610 --> 00:47:33,960
care right it's sort of like doing

2680
00:47:33,960 --> 00:47:33,970
 

2681
00:47:33,970 --> 00:47:35,880
compaction in the page level as you

2682
00:47:35,880 --> 00:47:35,890
 

2683
00:47:35,890 --> 00:47:38,850
write it out the disk so as I said this

2684
00:47:38,850 --> 00:47:38,860
 

2685
00:47:38,860 --> 00:47:41,070
is the most common approach how they

2686
00:47:41,070 --> 00:47:41,080
 

2687
00:47:41,080 --> 00:47:42,420
actually organize the slot array could

2688
00:47:42,420 --> 00:47:42,430
 

2689
00:47:42,430 --> 00:47:44,130
be slightly different but put additional

2690
00:47:44,130 --> 00:47:44,140
 

2691
00:47:44,140 --> 00:47:45,540
metadata they store for the slaughter

2692
00:47:45,540 --> 00:47:45,550
 

2693
00:47:45,550 --> 00:47:47,040
array could be different but at a high

2694
00:47:47,040 --> 00:47:47,050
 

2695
00:47:47,050 --> 00:47:50,100
level everybody works like this so

2696
00:47:50,100 --> 00:47:50,110
 

2697
00:47:50,110 --> 00:47:52,080
another different architecture instead

2698
00:47:52,080 --> 00:47:52,090
 

2699
00:47:52,090 --> 00:47:53,910
of storing actually tuples in pages is

2700
00:47:53,910 --> 00:47:53,920
 

2701
00:47:53,920 --> 00:47:55,890
to do what's called a log structured

2702
00:47:55,890 --> 00:47:55,900
 

2703
00:47:55,900 --> 00:47:58,050
page layout a log structure organization

2704
00:47:58,050 --> 00:47:58,060
 

2705
00:47:58,060 --> 00:48:01,140
so last year I presented this in the

2706
00:48:01,140 --> 00:48:01,150
 

2707
00:48:01,150 --> 00:48:02,880
same the same material here in the same

2708
00:48:02,880 --> 00:48:02,890
 

2709
00:48:02,890 --> 00:48:04,980
lecture but just in a different part I

2710
00:48:04,980 --> 00:48:04,990
 

2711
00:48:04,990 --> 00:48:07,400
I'm never quite sure when actually to

2712
00:48:07,400 --> 00:48:07,410
 

2713
00:48:07,410 --> 00:48:10,500
discuss log structured files with all

2714
00:48:10,500 --> 00:48:10,510
 

2715
00:48:10,510 --> 00:48:13,470
shifted page layouts because it's sorted

2716
00:48:13,470 --> 00:48:13,480
 

2717
00:48:13,480 --> 00:48:14,850
it's a combination of a bunch of

2718
00:48:14,850 --> 00:48:14,860
 

2719
00:48:14,860 --> 00:48:16,230
different things I think this is the

2720
00:48:16,230 --> 00:48:16,240
 

2721
00:48:16,240 --> 00:48:20,070
right point but we'll see how it goes

2722
00:48:20,070 --> 00:48:20,080
 

2723
00:48:20,080 --> 00:48:23,070
the the way to sort of think about these

2724
00:48:23,070 --> 00:48:23,080
 

2725
00:48:23,080 --> 00:48:24,830
log structured file organization is that

2726
00:48:24,830 --> 00:48:24,840

2727
00:48:24,840 --> 00:48:27,150
instead of actually storing tuples

2728
00:48:27,150 --> 00:48:27,160
 

2729
00:48:27,160 --> 00:48:29,280
inside of pages we're gonna store log

2730
00:48:29,280 --> 00:48:29,290
 

2731
00:48:29,290 --> 00:48:31,650
records so we haven't discussed what

2732
00:48:31,650 --> 00:48:31,660
 

2733
00:48:31,660 --> 00:48:33,780
logging actually is but basically think

2734
00:48:33,780 --> 00:48:33,790
 

2735
00:48:33,790 --> 00:48:36,810
about it's like a you know it's like a

2736
00:48:36,810 --> 00:48:36,820
 

2737
00:48:36,820 --> 00:48:38,460
record of the changes that you made to

2738
00:48:38,460 --> 00:48:38,470
 

2739
00:48:38,470 --> 00:48:41,160
the database so if I updated Indies to

2740
00:48:41,160 --> 00:48:41,170
 

2741
00:48:41,170 --> 00:48:44,070
boil I made my salary go from $1 to $2 I

2742
00:48:44,070 --> 00:48:44,080
 

2743
00:48:44,080 --> 00:48:46,290
would have a log worker that says update

2744
00:48:46,290 --> 00:48:46,300

2745
00:48:46,300 --> 00:48:48,810
and each tuple from $1 or $2 and I can

2746
00:48:48,810 --> 00:48:48,820
 

2747
00:48:48,820 --> 00:48:50,640
always replay that log and recreate the

2748
00:48:50,640 --> 00:48:50,650
 

2749
00:48:50,650 --> 00:48:51,030
actual

2750
00:48:51,030 --> 00:48:51,040

2751
00:48:51,040 --> 00:48:54,330
itself so in a log structure database

2752
00:48:54,330 --> 00:48:54,340
 

2753
00:48:54,340 --> 00:48:56,220
system you actually don't store any

2754
00:48:56,220 --> 00:48:56,230
 

2755
00:48:56,230 --> 00:48:58,410
tuples at all you only store the log

2756
00:48:58,410 --> 00:48:58,420
 

2757
00:48:58,420 --> 00:48:59,970
records of the changes that transaction

2758
00:48:59,970 --> 00:48:59,980

2759
00:48:59,980 --> 00:49:01,440
the returns eight changes that queries

2760
00:49:01,440 --> 00:49:01,450
 

2761
00:49:01,450 --> 00:49:03,930
make alright so now in a single page

2762
00:49:03,930 --> 00:49:03,940
 

2763
00:49:03,940 --> 00:49:05,910
what I'm gonna have is I'm just gonna

2764
00:49:05,910 --> 00:49:05,920
 

2765
00:49:05,920 --> 00:49:07,470
keep appending log entries from

2766
00:49:07,470 --> 00:49:07,480
 

2767
00:49:07,480 --> 00:49:09,840
beginning to end that correspond to the

2768
00:49:09,840 --> 00:49:09,850
 

2769
00:49:09,850 --> 00:49:11,730
changes that that that the queries made

2770
00:49:11,730 --> 00:49:11,740
 

2771
00:49:11,740 --> 00:49:13,620
and sort of think of this as going in

2772
00:49:13,620 --> 00:49:13,630
 

2773
00:49:13,630 --> 00:49:17,310
contiguously in time right I never go

2774
00:49:17,310 --> 00:49:17,320
 

2775
00:49:17,320 --> 00:49:19,950
back and delete any log record inside of

2776
00:49:19,950 --> 00:49:19,960
 

2777
00:49:19,960 --> 00:49:21,350
a page so I'm never gonna have any holes

2778
00:49:21,350 --> 00:49:21,360
 

2779
00:49:21,360 --> 00:49:23,370
alright and these can be variable and

2780
00:49:23,370 --> 00:49:23,380
 

2781
00:49:23,380 --> 00:49:24,960
because my updates can have very length

2782
00:49:24,960 --> 00:49:24,970

2783
00:49:24,970 --> 00:49:27,390
data but I just keep it pending into my

2784
00:49:27,390 --> 00:49:27,400
 

2785
00:49:27,400 --> 00:49:29,010
page until I run out of space and then

2786
00:49:29,010 --> 00:49:29,020
 

2787
00:49:29,020 --> 00:49:30,680
the page are considered full

2788
00:49:30,680 --> 00:49:30,690
 

2789
00:49:30,690 --> 00:49:35,130
all right so these loggers won't if I do

2790
00:49:35,130 --> 00:49:35,140
 

2791
00:49:35,140 --> 00:49:36,420
an insert it just contains the entire

2792
00:49:36,420 --> 00:49:36,430
 

2793
00:49:36,430 --> 00:49:38,460
tuple if I do a delete I have some way

2794
00:49:38,460 --> 00:49:38,470
 

2795
00:49:38,470 --> 00:49:39,990
to mark that and tuple got deleted and

2796
00:49:39,990 --> 00:49:40,000
 

2797
00:49:40,000 --> 00:49:41,820
if I do an update it's just the Delta of

2798
00:49:41,820 --> 00:49:41,830

2799
00:49:41,830 --> 00:49:44,420
the change that got made that made right

2800
00:49:44,420 --> 00:49:44,430
 

2801
00:49:44,430 --> 00:49:47,160
so what's the tricky thing about log

2802
00:49:47,160 --> 00:49:47,170
 

2803
00:49:47,170 --> 00:49:50,510
structured pages

2804
00:49:50,510 --> 00:49:50,520


2805
00:49:50,520 --> 00:49:59,790
what's slower exactly read

2806
00:49:59,790 --> 00:49:59,800
 

2807
00:49:59,800 --> 00:50:02,400
reads are slow right updates are easy

2808
00:50:02,400 --> 00:50:02,410
 

2809
00:50:02,410 --> 00:50:04,620
just I find a page that has a free slot

2810
00:50:04,620 --> 00:50:04,630
 

2811
00:50:04,630 --> 00:50:07,620
and boom I append to the end I'm done if

2812
00:50:07,620 --> 00:50:07,630
 

2813
00:50:07,630 --> 00:50:09,300
I'm doing read now I need to go back

2814
00:50:09,300 --> 00:50:09,310

2815
00:50:09,310 --> 00:50:11,540
potentially and look to the page and

2816
00:50:11,540 --> 00:50:11,550
 

2817
00:50:11,550 --> 00:50:13,620
reconstruct the tuple into its original

2818
00:50:13,620 --> 00:50:13,630
 

2819
00:50:13,630 --> 00:50:16,020
form based on its log records so do new

2820
00:50:16,020 --> 00:50:16,030
 

2821
00:50:16,030 --> 00:50:18,230
reads I have to go in reverse order

2822
00:50:18,230 --> 00:50:18,240
 

2823
00:50:18,240 --> 00:50:22,380
right so that mean that's so that's so

2824
00:50:22,380 --> 00:50:22,390
 

2825
00:50:22,390 --> 00:50:23,220
that's a problem

2826
00:50:23,220 --> 00:50:23,230
 

2827
00:50:23,230 --> 00:50:24,480
and so now again this is within the

2828
00:50:24,480 --> 00:50:24,490
 

2829
00:50:24,490 --> 00:50:26,700
concept of a single page but you know in

2830
00:50:26,700 --> 00:50:26,710
 

2831
00:50:26,710 --> 00:50:28,320
a real vulture catholocism these are

2832
00:50:28,320 --> 00:50:28,330
 

2833
00:50:28,330 --> 00:50:29,760
still you know or a log structured

2834
00:50:29,760 --> 00:50:29,770
 

2835
00:50:29,770 --> 00:50:30,690
database these are strewn across

2836
00:50:30,690 --> 00:50:30,700

2837
00:50:30,700 --> 00:50:33,570
multiple pages so I made to go read

2838
00:50:33,570 --> 00:50:33,580
 

2839
00:50:33,580 --> 00:50:35,040
through multiple pages in order to

2840
00:50:35,040 --> 00:50:35,050
 

2841
00:50:35,050 --> 00:50:36,690
reconstruct the tuple back to the form

2842
00:50:36,690 --> 00:50:36,700
 

2843
00:50:36,700 --> 00:50:38,940
that I need for the read so the way to

2844
00:50:38,940 --> 00:50:38,950
 

2845
00:50:38,950 --> 00:50:40,680
avoid having to read everything is that

2846
00:50:40,680 --> 00:50:40,690
 

2847
00:50:40,690 --> 00:50:42,720
you can build indexes up above basically

2848
00:50:42,720 --> 00:50:42,730
 

2849
00:50:42,730 --> 00:50:45,060
say you know if you need to buy B 1 2 3

2850
00:50:45,060 --> 00:50:45,070
 

2851
00:50:45,070 --> 00:50:46,650
here's where to go get it right at these

2852
00:50:46,650 --> 00:50:46,660
 

2853
00:50:46,660 --> 00:50:50,190
different locations so log structured

2854
00:50:50,190 --> 00:50:50,200
 

2855
00:50:50,200 --> 00:50:52,860
systems are loyal structured databases

2856
00:50:52,860 --> 00:50:52,870

2857
00:50:52,870 --> 00:50:55,050
are not new they can't go date back to

2858
00:50:55,050 --> 00:50:55,060
 

2859
00:50:55,060 --> 00:50:58,110
the 1989 teen 80s early 1990s but

2860
00:50:58,110 --> 00:50:58,120
 

2861
00:50:58,120 --> 00:50:59,460
they're actually really in vogue now

2862
00:50:59,460 --> 00:50:59,470
 

2863
00:50:59,470 --> 00:51:00,990
there's a much more systems actually

2864
00:51:00,990 --> 00:51:01,000
 

2865
00:51:01,000 --> 00:51:04,170
implement this things like leveldb rocks

2866
00:51:04,170 --> 00:51:04,180
 

2867
00:51:04,180 --> 00:51:04,920
D because

2868
00:51:04,920 --> 00:51:04,930
 

2869
00:51:04,930 --> 00:51:07,740
Ondra HBase and this is partly because

2870
00:51:07,740 --> 00:51:07,750
 

2871
00:51:07,750 --> 00:51:09,809
they're running on things like HDFS

2872
00:51:09,809 --> 00:51:09,819
 

2873
00:51:09,819 --> 00:51:12,089
which are append-only file systems are

2874
00:51:12,089 --> 00:51:12,099

2875
00:51:12,099 --> 00:51:13,950
pending only storage all right so you

2876
00:51:13,950 --> 00:51:13,960
 

2877
00:51:13,960 --> 00:51:16,470
can only write blocks in HDFS you can't

2878
00:51:16,470 --> 00:51:16,480
 

2879
00:51:16,480 --> 00:51:18,540
go back and update things and that works

2880
00:51:18,540 --> 00:51:18,550
 

2881
00:51:18,550 --> 00:51:20,280
perfectly for a log structural system

2882
00:51:20,280 --> 00:51:20,290
 

2883
00:51:20,290 --> 00:51:25,920
like this so the second time I'm going

2884
00:51:25,920 --> 00:51:25,930
 

2885
00:51:25,930 --> 00:51:27,540
to have in addition to actually maybe

2886
00:51:27,540 --> 00:51:27,550
 

2887
00:51:27,550 --> 00:51:29,130
reading a lot it to avoid the problem

2888
00:51:29,130 --> 00:51:29,140
 

2889
00:51:29,140 --> 00:51:30,720
they're having to read everything we can

2890
00:51:30,720 --> 00:51:30,730
 

2891
00:51:30,730 --> 00:51:32,520
try to be clever and maybe do compaction

2892
00:51:32,520 --> 00:51:32,530
 

2893
00:51:32,530 --> 00:51:35,549
and recognize that instead of having to

2894
00:51:35,549 --> 00:51:35,559
 

2895
00:51:35,559 --> 00:51:37,109
replay the log every single for every

2896
00:51:37,109 --> 00:51:37,119
 

2897
00:51:37,119 --> 00:51:38,970
single log record we can take a chunk of

2898
00:51:38,970 --> 00:51:38,980
 

2899
00:51:38,980 --> 00:51:41,730
it and compress it back down to just so

2900
00:51:41,730 --> 00:51:41,740
 

2901
00:51:41,740 --> 00:51:43,079
that the the single records that

2902
00:51:43,079 --> 00:51:43,089
 

2903
00:51:43,089 --> 00:51:44,280
correspond to the changes actually got

2904
00:51:44,280 --> 00:51:44,290
 

2905
00:51:44,290 --> 00:51:47,339
made right so if I update my salary of

2906
00:51:47,339 --> 00:51:47,349
 

2907
00:51:47,349 --> 00:51:49,290
good from $1 or $2 and then the next day

2908
00:51:49,290 --> 00:51:49,300

2909
00:51:49,300 --> 00:51:50,370
I need to get another raise and go from

2910
00:51:50,370 --> 00:51:50,380
 

2911
00:51:50,380 --> 00:51:52,740
$2 or $3 instead of having to read those

2912
00:51:52,740 --> 00:51:52,750

2913
00:51:52,750 --> 00:51:54,180
2 log records I can just compress that

2914
00:51:54,180 --> 00:51:54,190
 

2915
00:51:54,190 --> 00:51:56,130
down and compact that down into a single

2916
00:51:56,130 --> 00:51:56,140
 

2917
00:51:56,140 --> 00:51:59,240
log record and now reads are much faster

2918
00:51:59,240 --> 00:51:59,250
 

2919
00:51:59,250 --> 00:52:01,980
right and again these are the systems

2920
00:52:01,980 --> 00:52:01,990
 

2921
00:52:01,990 --> 00:52:03,839
that are you actually using this so

2922
00:52:03,839 --> 00:52:03,849
 

2923
00:52:03,849 --> 00:52:10,770
what's the problem with compaction so

2924
00:52:10,770 --> 00:52:10,780
 

2925
00:52:10,780 --> 00:52:12,329
now for every sing to you were right

2926
00:52:12,329 --> 00:52:12,339
 

2927
00:52:12,339 --> 00:52:14,309
I penned my log record and then at some

2928
00:52:14,309 --> 00:52:14,319

2929
00:52:14,319 --> 00:52:17,370
later point I'm a compact these these

2930
00:52:17,370 --> 00:52:17,380
 

2931
00:52:17,380 --> 00:52:18,780
pages are compact the log records them I

2932
00:52:18,780 --> 00:52:18,790
 

2933
00:52:18,790 --> 00:52:20,730
send my page and I'm writing it out

2934
00:52:20,730 --> 00:52:20,740
 

2935
00:52:20,740 --> 00:52:23,099
again right this is called write

2936
00:52:23,099 --> 00:52:23,109
 

2937
00:52:23,109 --> 00:52:24,930
amplification if I do a write to a

2938
00:52:24,930 --> 00:52:24,940
 

2939
00:52:24,940 --> 00:52:27,510
record you know by transaction committer

2940
00:52:27,510 --> 00:52:27,520
 

2941
00:52:27,520 --> 00:52:29,190
my queries done I did my right it's in

2942
00:52:29,190 --> 00:52:29,200
 

2943
00:52:29,200 --> 00:52:31,200
my database but in the background I made

2944
00:52:31,200 --> 00:52:31,210
 

2945
00:52:31,210 --> 00:52:33,450
you be doing compaction and rewriting

2946
00:52:33,450 --> 00:52:33,460

2947
00:52:33,460 --> 00:52:35,150
that same log record over and over again

2948
00:52:35,150 --> 00:52:35,160
 

2949
00:52:35,160 --> 00:52:37,829
right in the tuple oriented pages that I

2950
00:52:37,829 --> 00:52:37,839
 

2951
00:52:37,839 --> 00:52:39,960
talked about for the most part if I

2952
00:52:39,960 --> 00:52:39,970
 

2953
00:52:39,970 --> 00:52:41,640
write to my page I write to my tuple

2954
00:52:41,640 --> 00:52:41,650
 

2955
00:52:41,650 --> 00:52:42,809
it's done

2956
00:52:42,809 --> 00:52:42,819

2957
00:52:42,819 --> 00:52:44,819
right once it's on disk I'm never to go

2958
00:52:44,819 --> 00:52:44,829
 

2959
00:52:44,829 --> 00:52:47,539
back and maybe write it out again I

2960
00:52:47,539 --> 00:52:47,549
 

2961
00:52:47,549 --> 00:52:49,170
different systems do different things

2962
00:52:49,170 --> 00:52:49,180
 

2963
00:52:49,180 --> 00:52:50,630
but in general that's the case

2964
00:52:50,630 --> 00:52:50,640
 

2965
00:52:50,640 --> 00:52:53,760
so with compaction the problem is that

2966
00:52:53,760 --> 00:52:53,770
 

2967
00:52:53,770 --> 00:52:55,349
we end up you know we end up writing up

2968
00:52:55,349 --> 00:52:55,359
 

2969
00:52:55,359 --> 00:52:56,760
the same record over and over again and

2970
00:52:56,760 --> 00:52:56,770
 

2971
00:52:56,770 --> 00:52:58,319
we amplify the amount of writes we do it

2972
00:52:58,319 --> 00:52:58,329

2973
00:52:58,329 --> 00:53:00,809
if using SSDs to have a limited number

2974
00:53:00,809 --> 00:53:00,819

2975
00:53:00,819 --> 00:53:02,309
of white right before they wear down the

2976
00:53:02,309 --> 00:53:02,319
 

2977
00:53:02,319 --> 00:53:04,680
cells you could burn this out you know

2978
00:53:04,680 --> 00:53:04,690
 

2979
00:53:04,690 --> 00:53:06,809
in a year or print out your device in a

2980
00:53:06,809 --> 00:53:06,819
 

2981
00:53:06,819 --> 00:53:08,970
year depending on how how many writes

2982
00:53:08,970 --> 00:53:08,980
 

2983
00:53:08,980 --> 00:53:11,670
this supports so there's different

2984
00:53:11,670 --> 00:53:11,680
 

2985
00:53:11,680 --> 00:53:13,109
levels of compaction or different sorry

2986
00:53:13,109 --> 00:53:13,119
 

2987
00:53:13,119 --> 00:53:14,640
different types of compaction you can do

2988
00:53:14,640 --> 00:53:14,650

2989
00:53:14,650 --> 00:53:16,950
I want to talk about two methods that

2990
00:53:16,950 --> 00:53:16,960
 

2991
00:53:16,960 --> 00:53:18,720
are used in rocks DB so

2992
00:53:18,720 --> 00:53:18,730
 

2993
00:53:18,730 --> 00:53:20,040
you might have heard a leveldb from

2994
00:53:20,040 --> 00:53:20,050
 

2995
00:53:20,050 --> 00:53:23,010
google leveldb is an M map database that

2996
00:53:23,010 --> 00:53:23,020
 

2997
00:53:23,020 --> 00:53:25,950
does log structured log structure

2998
00:53:25,950 --> 00:53:25,960
 

2999
00:53:25,960 --> 00:53:27,720
storage Facebook got a hold of it

3000
00:53:27,720 --> 00:53:27,730
 

3001
00:53:27,730 --> 00:53:29,849
renames and rocks TV got rid of em map

3002
00:53:29,849 --> 00:53:29,859
 

3003
00:53:29,859 --> 00:53:31,890
and then made it much much better so if

3004
00:53:31,890 --> 00:53:31,900
 

3005
00:53:31,900 --> 00:53:33,540
you want a log structured embedded

3006
00:53:33,540 --> 00:53:33,550
 

3007
00:53:33,550 --> 00:53:34,980
database you want to use rocks DB not

3008
00:53:34,980 --> 00:53:34,990
 

3009
00:53:34,990 --> 00:53:37,440
level DB and so rocks DB supports two

3010
00:53:37,440 --> 00:53:37,450
 

3011
00:53:37,450 --> 00:53:39,690
types of compaction the first is called

3012
00:53:39,690 --> 00:53:39,700
 

3013
00:53:39,700 --> 00:53:42,420
level compaction where the basic idea is

3014
00:53:42,420 --> 00:53:42,430
 

3015
00:53:42,430 --> 00:53:44,430
that all your rights first end up in

3016
00:53:44,430 --> 00:53:44,440
 

3017
00:53:44,440 --> 00:53:47,700
these sort of log files and then at some

3018
00:53:47,700 --> 00:53:47,710
 

3019
00:53:47,710 --> 00:53:49,290
point in the first level when you write

3020
00:53:49,290 --> 00:53:49,300
 

3021
00:53:49,300 --> 00:53:52,230
say to certain certain number files you

3022
00:53:52,230 --> 00:53:52,240

3023
00:53:52,240 --> 00:53:53,880
want to compact them and combine them

3024
00:53:53,880 --> 00:53:53,890
 

3025
00:53:53,890 --> 00:53:57,359
into a single larger sorted log log file

3026
00:53:57,359 --> 00:53:57,369
 

3027
00:53:57,369 --> 00:54:00,000
and put that into the next level you

3028
00:54:00,000 --> 00:54:00,010
 

3029
00:54:00,010 --> 00:54:01,590
keep doing this you keep doing this and

3030
00:54:01,590 --> 00:54:01,600
 

3031
00:54:01,600 --> 00:54:03,900
in the first level right you keep making

3032
00:54:03,900 --> 00:54:03,910
 

3033
00:54:03,910 --> 00:54:05,280
log records and they get too big you

3034
00:54:05,280 --> 00:54:05,290
 

3035
00:54:05,290 --> 00:54:06,990
move them down to the second level and

3036
00:54:06,990 --> 00:54:07,000
 

3037
00:54:07,000 --> 00:54:08,580
at some point the second level gets too

3038
00:54:08,580 --> 00:54:08,590
 

3039
00:54:08,590 --> 00:54:10,500
big and then you move them down into

3040
00:54:10,500 --> 00:54:10,510
 

3041
00:54:10,510 --> 00:54:13,560
giant files in the in the next level and

3042
00:54:13,560 --> 00:54:13,570
 

3043
00:54:13,570 --> 00:54:14,550
this is what I was me my write

3044
00:54:14,550 --> 00:54:14,560
 

3045
00:54:14,560 --> 00:54:15,810
amplification right I can do a single

3046
00:54:15,810 --> 00:54:15,820

3047
00:54:15,820 --> 00:54:18,000
write into the level zero but then as I

3048
00:54:18,000 --> 00:54:18,010
 

3049
00:54:18,010 --> 00:54:19,800
do compaction in the different levels I

3050
00:54:19,800 --> 00:54:19,810
 

3051
00:54:19,810 --> 00:54:21,630
end up writing that thing out over and

3052
00:54:21,630 --> 00:54:21,640
 

3053
00:54:21,640 --> 00:54:22,440
over again because I'm gonna read it

3054
00:54:22,440 --> 00:54:22,450
 

3055
00:54:22,450 --> 00:54:24,599
from one one page combine it with

3056
00:54:24,599 --> 00:54:24,609
 

3057
00:54:24,609 --> 00:54:27,390
another page and write it back out the

3058
00:54:27,390 --> 00:54:27,400
 

3059
00:54:27,400 --> 00:54:28,320
other type of compaction you knew

3060
00:54:28,320 --> 00:54:28,330
 

3061
00:54:28,330 --> 00:54:30,000
Universal compaction with this sort of

3062
00:54:30,000 --> 00:54:30,010
 

3063
00:54:30,010 --> 00:54:32,160
there's a single level and basically

3064
00:54:32,160 --> 00:54:32,170
 

3065
00:54:32,170 --> 00:54:34,349
what you do you just take two different

3066
00:54:34,349 --> 00:54:34,359
 

3067
00:54:34,359 --> 00:54:36,390
pages that are contiguous to each other

3068
00:54:36,390 --> 00:54:36,400
 

3069
00:54:36,400 --> 00:54:37,859
in space and then you combine them to a

3070
00:54:37,859 --> 00:54:37,869
 

3071
00:54:37,869 --> 00:54:40,710
single single single page or a single

3072
00:54:40,710 --> 00:54:40,720
 

3073
00:54:40,720 --> 00:54:43,500
file like this so we can talk about more

3074
00:54:43,500 --> 00:54:43,510
 

3075
00:54:43,510 --> 00:54:45,030
about rocks TB and leveldb maybe next

3076
00:54:45,030 --> 00:54:45,040
 

3077
00:54:45,040 --> 00:54:46,620
class but at a high level this is this

3078
00:54:46,620 --> 00:54:46,630
 

3079
00:54:46,630 --> 00:54:47,640
is what they're doing their log

3080
00:54:47,640 --> 00:54:47,650
 

3081
00:54:47,650 --> 00:54:49,830
structure page layouts and there's upper

3082
00:54:49,830 --> 00:54:49,840
 

3083
00:54:49,840 --> 00:54:51,570
levels of the systems know how to replay

3084
00:54:51,570 --> 00:54:51,580
 

3085
00:54:51,580 --> 00:54:53,190
the log records to put the data put the

3086
00:54:53,190 --> 00:54:53,200

3087
00:54:53,200 --> 00:54:54,420
page the two books back from the correct

3088
00:54:54,420 --> 00:54:54,430
 

3089
00:54:54,430 --> 00:54:57,540
form alright so the last thing I wanna

3090
00:54:57,540 --> 00:54:57,550
 

3091
00:54:57,550 --> 00:54:59,670
talk about is the tuple layout so again

3092
00:54:59,670 --> 00:54:59,680
 

3093
00:54:59,680 --> 00:55:02,070
we have files files up pages and within

3094
00:55:02,070 --> 00:55:02,080
 

3095
00:55:02,080 --> 00:55:03,650
those pages we can organize our data

3096
00:55:03,650 --> 00:55:03,660
 

3097
00:55:03,660 --> 00:55:06,359
that can contain tuples or critique log

3098
00:55:06,359 --> 00:55:06,369
 

3099
00:55:06,369 --> 00:55:08,250
records now we want to understand what

3100
00:55:08,250 --> 00:55:08,260
 

3101
00:55:08,260 --> 00:55:12,390
these actual tuples look like so a tuple

3102
00:55:12,390 --> 00:55:12,400
 

3103
00:55:12,400 --> 00:55:13,830
in our world is essentially a sequence

3104
00:55:13,830 --> 00:55:13,840
 

3105
00:55:13,840 --> 00:55:16,290
of bytes right that's all we're really

3106
00:55:16,290 --> 00:55:16,300
 

3107
00:55:16,300 --> 00:55:18,000
doing and it's the upper levels of the

3108
00:55:18,000 --> 00:55:18,010
 

3109
00:55:18,010 --> 00:55:19,859
systems that know how to then break

3110
00:55:19,859 --> 00:55:19,869
 

3111
00:55:19,869 --> 00:55:21,690
those bytes off into attributes put the

3112
00:55:21,690 --> 00:55:21,700
 

3113
00:55:21,700 --> 00:55:23,910
different types and expose them in a

3114
00:55:23,910 --> 00:55:23,920
 

3115
00:55:23,920 --> 00:55:26,190
more programmatic way to the to the

3116
00:55:26,190 --> 00:55:26,200
 

3117
00:55:26,200 --> 00:55:28,470
application so it's essentially the job

3118
00:55:28,470 --> 00:55:28,480

3119
00:55:28,480 --> 00:55:30,300
at the data system to indeed 'enter

3120
00:55:30,300 --> 00:55:30,310
 

3121
00:55:30,310 --> 00:55:32,450
prett those bytes interpret those values

3122
00:55:32,450 --> 00:55:32,460
 

3123
00:55:32,460 --> 00:55:35,059
in the manner that the program described

3124
00:55:35,059 --> 00:55:35,069
 

3125
00:55:35,069 --> 00:55:38,989
or defined for the for that table so now

3126
00:55:38,989 --> 00:55:38,999
 

3127
00:55:38,999 --> 00:55:41,329
within every single page we have tuples

3128
00:55:41,329 --> 00:55:41,339
 

3129
00:55:41,339 --> 00:55:42,589
again this is this is assumed we're

3130
00:55:42,589 --> 00:55:42,599
 

3131
00:55:42,599 --> 00:55:44,059
doing a tuple or the page layout not the

3132
00:55:44,059 --> 00:55:44,069
 

3133
00:55:44,069 --> 00:55:46,249
log structure stuff but every tuple is

3134
00:55:46,249 --> 00:55:46,259

3135
00:55:46,259 --> 00:55:48,559
gonna have a header and the header is

3136
00:55:48,559 --> 00:55:48,569

3137
00:55:48,569 --> 00:55:49,940
gonna take metadata about the tuple

3138
00:55:49,940 --> 00:55:49,950
 

3139
00:55:49,950 --> 00:55:52,190
itself right so it can contain more

3140
00:55:52,190 --> 00:55:52,200
 

3141
00:55:52,200 --> 00:55:53,989
visibility information about what

3142
00:55:53,989 --> 00:55:53,999

3143
00:55:53,999 --> 00:55:55,819
transactions read and wrote to that

3144
00:55:55,819 --> 00:55:55,829

3145
00:55:55,829 --> 00:55:59,089
tuple it contain a bitmap for which

3146
00:55:59,089 --> 00:55:59,099
 

3147
00:55:59,099 --> 00:56:04,160
attributes are consider null it usually

3148
00:56:04,160 --> 00:56:04,170
 

3149
00:56:04,170 --> 00:56:06,140
doesn't contain anything about what the

3150
00:56:06,140 --> 00:56:06,150

3151
00:56:06,150 --> 00:56:08,150
data actually looks like meaning we're

3152
00:56:08,150 --> 00:56:08,160
 

3153
00:56:08,160 --> 00:56:09,589
not gonna store any metadata about the

3154
00:56:09,589 --> 00:56:09,599
 

3155
00:56:09,599 --> 00:56:11,809
schema or the tuple all that is sort of

3156
00:56:11,809 --> 00:56:11,819
 

3157
00:56:11,819 --> 00:56:13,789
handled separately by other parts of the

3158
00:56:13,789 --> 00:56:13,799

3159
00:56:13,799 --> 00:56:15,589
system I said that means we don't to be

3160
00:56:15,589 --> 00:56:15,599
 

3161
00:56:15,599 --> 00:56:16,910
redundant least or the same information

3162
00:56:16,910 --> 00:56:16,920
 

3163
00:56:16,920 --> 00:56:18,289
about every single tuple over and over

3164
00:56:18,289 --> 00:56:18,299
 

3165
00:56:18,299 --> 00:56:21,349
again right so it sort of looks like

3166
00:56:21,349 --> 00:56:21,359
 

3167
00:56:21,359 --> 00:56:24,410
this right you have a you have a byte

3168
00:56:24,410 --> 00:56:24,420
 

3169
00:56:24,420 --> 00:56:26,239
array for your tuple you have your

3170
00:56:26,239 --> 00:56:26,249
 

3171
00:56:26,249 --> 00:56:27,469
header and then you're gonna have a

3172
00:56:27,469 --> 00:56:27,479
 

3173
00:56:27,479 --> 00:56:30,200
contiguous list of attributes that a

3174
00:56:30,200 --> 00:56:30,210
 

3175
00:56:30,210 --> 00:56:33,319
store just as a byte array right so

3176
00:56:33,319 --> 00:56:33,329
 

3177
00:56:33,329 --> 00:56:34,969
typically what happens is in those

3178
00:56:34,969 --> 00:56:34,979

3179
00:56:34,979 --> 00:56:38,120
database systems however you define the

3180
00:56:38,120 --> 00:56:38,130
 

3181
00:56:38,130 --> 00:56:40,579
the the ordering of the columns when you

3182
00:56:40,579 --> 00:56:40,589
 

3183
00:56:40,589 --> 00:56:42,739
call when you call create table that's

3184
00:56:42,739 --> 00:56:42,749

3185
00:56:42,749 --> 00:56:45,440
how it's gonna be written out to to disk

3186
00:56:45,440 --> 00:56:45,450
 

3187
00:56:45,450 --> 00:56:48,380
right so inside the page if I have my

3188
00:56:48,380 --> 00:56:48,390
 

3189
00:56:48,390 --> 00:56:49,880
five attributes ABCDE

3190
00:56:49,880 --> 00:56:49,890
 

3191
00:56:49,890 --> 00:56:53,029
I will have a Ashford's ABCDE lined up

3192
00:56:53,029 --> 00:56:53,039
 

3193
00:56:53,039 --> 00:56:54,769
in that order inside the tuple itself

3194
00:56:54,769 --> 00:56:54,779
 

3195
00:56:54,779 --> 00:56:57,170
now there's nothing about the relational

3196
00:56:57,170 --> 00:56:57,180
 

3197
00:56:57,180 --> 00:56:58,430
model that says you have to do that

3198
00:56:58,430 --> 00:56:58,440
 

3199
00:56:58,440 --> 00:56:59,989
right that's the beauty of the

3200
00:56:59,989 --> 00:56:59,999
 

3201
00:56:59,999 --> 00:57:01,489
abstraction between the logical and

3202
00:57:01,489 --> 00:57:01,499
 

3203
00:57:01,499 --> 00:57:04,160
physical so at the physical layer we can

3204
00:57:04,160 --> 00:57:04,170
 

3205
00:57:04,170 --> 00:57:06,499
reorganize these these these anyway we

3206
00:57:06,499 --> 00:57:06,509
 

3207
00:57:06,509 --> 00:57:09,259
want and at the logical layer you would

3208
00:57:09,259 --> 00:57:09,269
 

3209
00:57:09,269 --> 00:57:10,640
still see them and always in the correct

3210
00:57:10,640 --> 00:57:10,650
 

3211
00:57:10,650 --> 00:57:12,140
order now

3212
00:57:12,140 --> 00:57:12,150
 

3213
00:57:12,150 --> 00:57:13,999
as far as I know in dis based systems

3214
00:57:13,999 --> 00:57:14,009
 

3215
00:57:14,009 --> 00:57:16,759
except for the column store stuff which

3216
00:57:16,759 --> 00:57:16,769
 

3217
00:57:16,769 --> 00:57:18,589
we'll talk about next class pretty much

3218
00:57:18,589 --> 00:57:18,599
 

3219
00:57:18,599 --> 00:57:20,390
everyone always writes the data out and

3220
00:57:20,390 --> 00:57:20,400
 

3221
00:57:20,400 --> 00:57:21,709
the order that you define it that's just

3222
00:57:21,709 --> 00:57:21,719
 

3223
00:57:21,719 --> 00:57:24,499
done for simplicity reasons in the

3224
00:57:24,499 --> 00:57:24,509
 

3225
00:57:24,509 --> 00:57:25,999
advanced class we'll talk about in

3226
00:57:25,999 --> 00:57:26,009
 

3227
00:57:26,009 --> 00:57:27,920
memory databases where you actually do

3228
00:57:27,920 --> 00:57:27,930
 

3229
00:57:27,930 --> 00:57:30,680
want to reorganize how how you layout

3230
00:57:30,680 --> 00:57:30,690
 

3231
00:57:30,690 --> 00:57:33,349
data in memory because that that matters

3232
00:57:33,349 --> 00:57:33,359
 

3233
00:57:33,359 --> 00:57:34,910
for getting word

3234
00:57:34,910 --> 00:57:34,920
 

3235
00:57:34,920 --> 00:57:36,559
lines and you can get much better

3236
00:57:36,559 --> 00:57:36,569

3237
00:57:36,569 --> 00:57:38,809
performance that way but on disk again

3238
00:57:38,809 --> 00:57:38,819
 

3239
00:57:38,819 --> 00:57:40,069
we said we're just reading four kilobyte

3240
00:57:40,069 --> 00:57:40,079
 

3241
00:57:40,079 --> 00:57:42,739
pages from disk the

3242
00:57:42,739 --> 00:57:42,749
 

3243
00:57:42,749 --> 00:57:44,029
inside these pages actually doesn't

3244
00:57:44,029 --> 00:57:44,039
 

3245
00:57:44,039 --> 00:57:46,160
matter right that's always been the main

3246
00:57:46,160 --> 00:57:46,170
 

3247
00:57:46,170 --> 00:57:47,590
bottleneck

3248
00:57:47,590 --> 00:57:47,600

3249
00:57:47,600 --> 00:57:50,420
the other thing we can do also with with

3250
00:57:50,420 --> 00:57:50,430
 

3251
00:57:50,430 --> 00:57:53,390
with tuples is instead of just storing

3252
00:57:53,390 --> 00:57:53,400
 

3253
00:57:53,400 --> 00:57:57,200
all the data for a single single table

3254
00:57:57,200 --> 00:57:57,210
 

3255
00:57:57,210 --> 00:57:59,090
inside of a tuple we actually can

3256
00:57:59,090 --> 00:57:59,100
 

3257
00:57:59,100 --> 00:58:01,910
combine data from other tables inside of

3258
00:58:01,910 --> 00:58:01,920
 

3259
00:58:01,920 --> 00:58:04,070
our tuples inside our own page so

3260
00:58:04,070 --> 00:58:04,080
 

3261
00:58:04,080 --> 00:58:06,740
typically every page will have a for

3262
00:58:06,740 --> 00:58:06,750
 

3263
00:58:06,750 --> 00:58:08,840
doing tuple storage every page will only

3264
00:58:08,840 --> 00:58:08,850

3265
00:58:08,850 --> 00:58:11,270
contain data for one table so that I

3266
00:58:11,270 --> 00:58:11,280
 

3267
00:58:11,280 --> 00:58:13,250
have table foo then they'll be pages for

3268
00:58:13,250 --> 00:58:13,260
 

3269
00:58:13,260 --> 00:58:15,290
table foo but there's another technique

3270
00:58:15,290 --> 00:58:15,300
 

3271
00:58:15,300 --> 00:58:17,450
you can do to actually combine data from

3272
00:58:17,450 --> 00:58:17,460
 

3273
00:58:17,460 --> 00:58:19,040
different tables inside of a single page

3274
00:58:19,040 --> 00:58:19,050
 

3275
00:58:19,050 --> 00:58:21,109
to help you possibly speed up

3276
00:58:21,109 --> 00:58:21,119
 

3277
00:58:21,119 --> 00:58:24,560
performance so this is called Dino

3278
00:58:24,560 --> 00:58:24,570
 

3279
00:58:24,570 --> 00:58:28,190
denormalization so I didn't do a lecture

3280
00:58:28,190 --> 00:58:28,200
 

3281
00:58:28,200 --> 00:58:29,420
on normal forms and function

3282
00:58:29,420 --> 00:58:29,430
 

3283
00:58:29,430 --> 00:58:32,450
dependencies this year because it's you

3284
00:58:32,450 --> 00:58:32,460

3285
00:58:32,460 --> 00:58:34,220
really long and people always hate it

3286
00:58:34,220 --> 00:58:34,230
 

3287
00:58:34,230 --> 00:58:36,050
people start bleeding because it's

3288
00:58:36,050 --> 00:58:36,060
 

3289
00:58:36,060 --> 00:58:38,630
boring the only thing you really need to

3290
00:58:38,630 --> 00:58:38,640
 

3291
00:58:38,640 --> 00:58:39,950
know about normal forms is that they

3292
00:58:39,950 --> 00:58:39,960
 

3293
00:58:39,960 --> 00:58:41,300
exist in the textbook but nobody

3294
00:58:41,300 --> 00:58:41,310
 

3295
00:58:41,310 --> 00:58:44,450
actually does it in the real world the

3296
00:58:44,450 --> 00:58:44,460
 

3297
00:58:44,460 --> 00:58:45,320
way they start to think about it at a

3298
00:58:45,320 --> 00:58:45,330
 

3299
00:58:45,330 --> 00:58:47,450
high level it's a way to combine tables

3300
00:58:47,450 --> 00:58:47,460

3301
00:58:47,460 --> 00:58:49,250
or break tables apart and he's sure to

3302
00:58:49,250 --> 00:58:49,260
 

3303
00:58:49,260 --> 00:58:50,600
give this naturally if you have foreign

3304
00:58:50,600 --> 00:58:50,610

3305
00:58:50,610 --> 00:58:52,130
key dependencies right remember I talked

3306
00:58:52,130 --> 00:58:52,140
 

3307
00:58:52,140 --> 00:58:55,550
about artists and albums right you could

3308
00:58:55,550 --> 00:58:55,560
 

3309
00:58:55,560 --> 00:58:57,349
combine that into a single table but

3310
00:58:57,349 --> 00:58:57,359
 

3311
00:58:57,359 --> 00:58:59,210
then you're duplicating everything so

3312
00:58:59,210 --> 00:58:59,220
 

3313
00:58:59,220 --> 00:59:01,910
the normal forms to say actually split

3314
00:59:01,910 --> 00:59:01,920
 

3315
00:59:01,920 --> 00:59:04,820
them up so that you have you know single

3316
00:59:04,820 --> 00:59:04,830
 

3317
00:59:04,830 --> 00:59:06,530
records for thao for albums on single

3318
00:59:06,530 --> 00:59:06,540
 

3319
00:59:06,540 --> 00:59:08,690
records for artists right that's the

3320
00:59:08,690 --> 00:59:08,700

3321
00:59:08,700 --> 00:59:10,700
gist of normal forms do all that you

3322
00:59:10,700 --> 00:59:10,710
 

3323
00:59:10,710 --> 00:59:12,620
really need to know so with

3324
00:59:12,620 --> 00:59:12,630
 

3325
00:59:12,630 --> 00:59:14,810
denormalization it's it's instead of

3326
00:59:14,810 --> 00:59:14,820
 

3327
00:59:14,820 --> 00:59:16,070
splitting it apart it's putting it back

3328
00:59:16,070 --> 00:59:16,080
 

3329
00:59:16,080 --> 00:59:19,609
together so the user can define our

3330
00:59:19,609 --> 00:59:19,619
 

3331
00:59:19,619 --> 00:59:22,550
tables in the proper normal form with

3332
00:59:22,550 --> 00:59:22,560

3333
00:59:22,560 --> 00:59:24,680
separate you know separate tables but

3334
00:59:24,680 --> 00:59:24,690
 

3335
00:59:24,690 --> 00:59:26,000
underneath the covers inside of our

3336
00:59:26,000 --> 00:59:26,010

3337
00:59:26,010 --> 00:59:27,440
pages we actually can combine these

3338
00:59:27,440 --> 00:59:27,450
 

3339
00:59:27,450 --> 00:59:29,720
things to get better performance and

3340
00:59:29,720 --> 00:59:29,730
 

3341
00:59:29,730 --> 00:59:31,580
again it's completely transparent to the

3342
00:59:31,580 --> 00:59:31,590
 

3343
00:59:31,590 --> 00:59:34,190
actual application so I have two tables

3344
00:59:34,190 --> 00:59:34,200
 

3345
00:59:34,200 --> 00:59:36,920
here I have foo and bar and bar has a

3346
00:59:36,920 --> 00:59:36,930

3347
00:59:36,930 --> 00:59:39,710
foreign key dependency on actually a so

3348
00:59:39,710 --> 00:59:39,720
 

3349
00:59:39,720 --> 00:59:42,010
again if I'm destroying these things as

3350
00:59:42,010 --> 00:59:42,020
 

3351
00:59:42,020 --> 00:59:44,900
every page has its own tuples then I

3352
00:59:44,900 --> 00:59:44,910
 

3353
00:59:44,910 --> 00:59:46,910
would have a tuple for foo and one page

3354
00:59:46,910 --> 00:59:46,920
 

3355
00:59:46,920 --> 00:59:48,650
and then the tuples for bar and another

3356
00:59:48,650 --> 00:59:48,660
 

3357
00:59:48,660 --> 00:59:50,840
page so physical denormalization

3358
00:59:50,840 --> 00:59:50,850
 

3359
00:59:50,850 --> 00:59:53,390
essentially like doing a pre join since

3360
00:59:53,390 --> 00:59:53,400

3361
00:59:53,400 --> 00:59:54,230
I know there's a foreign key to

3362
00:59:54,230 --> 00:59:54,240
 

3363
00:59:54,240 --> 00:59:56,030
dependencies between these two tuples

3364
00:59:56,030 --> 00:59:56,040
 

3365
00:59:56,040 --> 00:59:57,620
so I'm likely to join them and together

3366
00:59:57,620 --> 00:59:57,630
 

3367
00:59:57,630 --> 00:59:59,840
all the time in queries so what I can

3368
00:59:59,840 --> 00:59:59,850
 

3369
00:59:59,850 --> 01:00:00,680
sted do

3370
01:00:00,680 --> 01:00:00,690
 

3371
01:00:00,690 --> 01:00:03,770
is actually in line all the values for

3372
01:00:03,770 --> 01:00:03,780
 

3373
01:00:03,780 --> 01:00:07,760
the bar table that relate to this

3374
01:00:07,760 --> 01:00:07,770
 

3375
01:00:07,770 --> 01:00:10,870
particular tuple inside that that tuple

3376
01:00:10,870 --> 01:00:10,880
 

3377
01:00:10,880 --> 01:00:14,270
so inside the tuple I have my actors ABC

3378
01:00:14,270 --> 01:00:14,280
 

3379
01:00:14,280 --> 01:00:16,309
its Rab but then I'm gonna have this

3380
01:00:16,309 --> 01:00:16,319
 

3381
01:00:16,319 --> 01:00:18,170
list of all the attributes see that

3382
01:00:18,170 --> 01:00:18,180
 

3383
01:00:18,180 --> 01:00:20,960
correspond to the bar table so now when

3384
01:00:20,960 --> 01:00:20,970
 

3385
01:00:20,970 --> 01:00:22,609
I when I won't run and run these run a

3386
01:00:22,609 --> 01:00:22,619

3387
01:00:22,619 --> 01:00:25,490
query I know how to sorry I know how to

3388
01:00:25,490 --> 01:00:25,500
 

3389
01:00:25,500 --> 01:00:27,230
come I know what portion of the tuple

3390
01:00:27,230 --> 01:00:27,240

3391
01:00:27,240 --> 01:00:29,839
belongs to foo and I know to it belongs

3392
01:00:29,839 --> 01:00:29,849
 

3393
01:00:29,849 --> 01:00:31,760
to bar and depending what the query once

3394
01:00:31,760 --> 01:00:31,770
 

3395
01:00:31,770 --> 01:00:34,510
I may actually read one or the other

3396
01:00:34,510 --> 01:00:34,520

3397
01:00:34,520 --> 01:00:37,819
right so again this piece of joins

3398
01:00:37,819 --> 01:00:37,829
 

3399
01:00:37,829 --> 01:00:39,230
because now instead of having to go get

3400
01:00:39,230 --> 01:00:39,240
 

3401
01:00:39,240 --> 01:00:41,210
one page fetch for foo one page fetch

3402
01:00:41,210 --> 01:00:41,220
 

3403
01:00:41,220 --> 01:00:42,829
for bar if I'm joining them together on

3404
01:00:42,829 --> 01:00:42,839

3405
01:00:42,839 --> 01:00:45,020
the foreign key it's one page fetch to

3406
01:00:45,020 --> 01:00:45,030
 

3407
01:00:45,030 --> 01:00:49,940
go get all deer that I need so I will

3408
01:00:49,940 --> 01:00:49,950
 

3409
01:00:49,950 --> 01:00:53,359
say that or this makes the Reapers

3410
01:00:53,359 --> 01:00:53,369
 

3411
01:00:53,369 --> 01:00:54,680
potentially faster but it can make

3412
01:00:54,680 --> 01:00:54,690

3413
01:00:54,690 --> 01:00:56,240
updates more expensive because if I run

3414
01:00:56,240 --> 01:00:56,250
 

3415
01:00:56,250 --> 01:00:58,099
out of space for putting advocacy in

3416
01:00:58,099 --> 01:00:58,109
 

3417
01:00:58,109 --> 01:01:01,730
then I need to reorganize my pages so as

3418
01:01:01,730 --> 01:01:01,740
 

3419
01:01:01,740 --> 01:01:03,470
in all cases in databases what seems

3420
01:01:03,470 --> 01:01:03,480
 

3421
01:01:03,480 --> 01:01:05,180
like a cool idea or a new idea is not

3422
01:01:05,180 --> 01:01:05,190
 

3423
01:01:05,190 --> 01:01:07,550
new and it's almost like that South Park

3424
01:01:07,550 --> 01:01:07,560
 

3425
01:01:07,560 --> 01:01:09,050
episode where they always say the

3426
01:01:09,050 --> 01:01:09,060
 

3427
01:01:09,060 --> 01:01:11,329
Simpsons did it right so in databases

3428
01:01:11,329 --> 01:01:11,339
 

3429
01:01:11,339 --> 01:01:13,880
it's always IBM did it so IBM did this

3430
01:01:13,880 --> 01:01:13,890
 

3431
01:01:13,890 --> 01:01:15,980
way back in 1970s with system R which is

3432
01:01:15,980 --> 01:01:15,990
 

3433
01:01:15,990 --> 01:01:17,210
the first relational database that they

3434
01:01:17,210 --> 01:01:17,220
 

3435
01:01:17,220 --> 01:01:20,569
built it turned out to be really

3436
01:01:20,569 --> 01:01:20,579
 

3437
01:01:20,579 --> 01:01:22,430
difficult to maintain and they abandoned

3438
01:01:22,430 --> 01:01:22,440
 

3439
01:01:22,440 --> 01:01:23,780
the idea when they went off and build

3440
01:01:23,780 --> 01:01:23,790
 

3441
01:01:23,790 --> 01:01:26,660
db2 right as I said doing updates it

3442
01:01:26,660 --> 01:01:26,670
 

3443
01:01:26,670 --> 01:01:28,250
becomes more expensive because you have

3444
01:01:28,250 --> 01:01:28,260
 

3445
01:01:28,260 --> 01:01:30,740
to reorganize things but now thirty

3446
01:01:30,740 --> 01:01:30,750
 

3447
01:01:30,750 --> 01:01:32,450
forty years later now a bunch of

3448
01:01:32,450 --> 01:01:32,460
 

3449
01:01:32,460 --> 01:01:33,500
companies are actually trying to do this

3450
01:01:33,500 --> 01:01:33,510
 

3451
01:01:33,510 --> 01:01:35,540
because it makes joins go faster so

3452
01:01:35,540 --> 01:01:35,550
 

3453
01:01:35,550 --> 01:01:37,940
Google does this in spanner for storing

3454
01:01:37,940 --> 01:01:37,950

3455
01:01:37,950 --> 01:01:39,950
protocol buffer data right they actually

3456
01:01:39,950 --> 01:01:39,960

3457
01:01:39,960 --> 01:01:42,349
in line the the the dependence the

3458
01:01:42,349 --> 01:01:42,359
 

3459
01:01:42,359 --> 01:01:45,260
dependent values for one sort of table

3460
01:01:45,260 --> 01:01:45,270

3461
01:01:45,270 --> 01:01:46,970
inside of another table so again you

3462
01:01:46,970 --> 01:01:46,980
 

3463
01:01:46,980 --> 01:01:48,020
reduce the number of page fetches you

3464
01:01:48,020 --> 01:01:48,030
 

3465
01:01:48,030 --> 01:01:49,970
have to go get there was a startup

3466
01:01:49,970 --> 01:01:49,980

3467
01:01:49,980 --> 01:01:52,940
called a key bond from up ten years ago

3468
01:01:52,940 --> 01:01:52,950
 

3469
01:01:52,950 --> 01:01:55,520
that was doing this for my sequel they

3470
01:01:55,520 --> 01:01:55,530
 

3471
01:01:55,530 --> 01:01:57,260
got bought up by a foundation DB which

3472
01:01:57,260 --> 01:01:57,270
 

3473
01:01:57,270 --> 01:02:00,410
then got bought out by Apple as far as

3474
01:02:00,410 --> 01:02:00,420
 

3475
01:02:00,420 --> 01:02:02,059
they know they end up abandoning this

3476
01:02:02,059 --> 01:02:02,069
 

3477
01:02:02,069 --> 01:02:04,430
this technique actually looks a lot also

3478
01:02:04,430 --> 01:02:04,440
 

3479
01:02:04,440 --> 01:02:06,980
too a lot like what the JSON or document

3480
01:02:06,980 --> 01:02:06,990
 

3481
01:02:06,990 --> 01:02:08,990
database is like rethink DB or MongoDB

3482
01:02:08,990 --> 01:02:09,000
 

3483
01:02:09,000 --> 01:02:11,660
or couch couch pays how they work right

3484
01:02:11,660 --> 01:02:11,670
 

3485
01:02:11,670 --> 01:02:12,920
because you don't really define tables

3486
01:02:12,920 --> 01:02:12,930
 

3487
01:02:12,930 --> 01:02:14,599
you define a JSON documents

3488
01:02:14,599 --> 01:02:14,609

3489
01:02:14,609 --> 01:02:17,359
and you can pre join related table or

3490
01:02:17,359 --> 01:02:17,369
 

3491
01:02:17,369 --> 01:02:19,220
related information inside that document

3492
01:02:19,220 --> 01:02:19,230
 

3493
01:02:19,230 --> 01:02:20,809
right so that you don't have to do

3494
01:02:20,809 --> 01:02:20,819
 

3495
01:02:20,819 --> 01:02:22,670
separate fetches to go get this at a

3496
01:02:22,670 --> 01:02:22,680
 

3497
01:02:22,680 --> 01:02:24,140
high level this is the same thing as

3498
01:02:24,140 --> 01:02:24,150
 

3499
01:02:24,150 --> 01:02:25,789
physical demineralization so it's the

3500
01:02:25,789 --> 01:02:25,799
 

3501
01:02:25,799 --> 01:02:30,160
same technique that IBM did in the 1970s

3502
01:02:30,160 --> 01:02:30,170
 

3503
01:02:30,170 --> 01:02:32,779
all right we have a few minutes left so

3504
01:02:32,779 --> 01:02:32,789
 

3505
01:02:32,789 --> 01:02:35,450
I want to about one last thing is how

3506
01:02:35,450 --> 01:02:35,460
 

3507
01:02:35,460 --> 01:02:37,999
we're gonna keep track of what what our

3508
01:02:37,999 --> 01:02:38,009
 

3509
01:02:38,009 --> 01:02:41,299
tuples are right right so again we said

3510
01:02:41,299 --> 01:02:41,309
 

3511
01:02:41,309 --> 01:02:43,160
every page has a page ID and there's a

3512
01:02:43,160 --> 01:02:43,170

3513
01:02:43,170 --> 01:02:44,210
page directory that says if you want

3514
01:02:44,210 --> 01:02:44,220
 

3515
01:02:44,220 --> 01:02:46,279
page 1 2 3 there's some directory

3516
01:02:46,279 --> 01:02:46,289
 

3517
01:02:46,289 --> 01:02:48,170
information that says where to go get it

3518
01:02:48,170 --> 01:02:48,180
 

3519
01:02:48,180 --> 01:02:51,410
now for tuples will talk about indexes

3520
01:02:51,410 --> 01:02:51,420
 

3521
01:02:51,420 --> 01:02:54,519
to go find them later on but internally

3522
01:02:54,519 --> 01:02:54,529
 

3523
01:02:54,529 --> 01:02:57,009
different data systems could represent

3524
01:02:57,009 --> 01:02:57,019
 

3525
01:02:57,019 --> 01:02:59,479
you know individual tuples in different

3526
01:02:59,479 --> 01:02:59,489
 

3527
01:02:59,489 --> 01:03:01,519
ways and these are usually called record

3528
01:03:01,519 --> 01:03:01,529
 

3529
01:03:01,529 --> 01:03:04,759
IDs so the most common approach where a

3530
01:03:04,759 --> 01:03:04,769
 

3531
01:03:04,769 --> 01:03:06,920
record ID is that it will be the page ID

3532
01:03:06,920 --> 01:03:06,930
 

3533
01:03:06,930 --> 01:03:10,160
plus an offset or a slot inside that

3534
01:03:10,160 --> 01:03:10,170

3535
01:03:10,170 --> 01:03:12,589
page right never I said if I want page 1

3536
01:03:12,589 --> 01:03:12,599
 

3537
01:03:12,599 --> 01:03:15,049
2 3 and give me the v tuple I know what

3538
01:03:15,049 --> 01:03:15,059
 

3539
01:03:15,059 --> 01:03:17,150
I've got and I look my slot array and

3540
01:03:17,150 --> 01:03:17,160
 

3541
01:03:17,160 --> 01:03:18,319
that tells you where to jump inside the

3542
01:03:18,319 --> 01:03:18,329
 

3543
01:03:18,329 --> 01:03:20,450
page to find that individual tuple so

3544
01:03:20,450 --> 01:03:20,460

3545
01:03:20,460 --> 01:03:22,400
some systems actually expose the

3546
01:03:22,400 --> 01:03:22,410
 

3547
01:03:22,410 --> 01:03:25,069
information to you at the application

3548
01:03:25,069 --> 01:03:25,079
 

3549
01:03:25,079 --> 01:03:28,220
level so in Postgres it's called the CT

3550
01:03:28,220 --> 01:03:28,230
 

3551
01:03:28,230 --> 01:03:30,559
ID and they store this has 44 bytes in

3552
01:03:30,559 --> 01:03:30,569
 

3553
01:03:30,569 --> 01:03:32,630
single byte they store this as a row ID

3554
01:03:32,630 --> 01:03:32,640
 

3555
01:03:32,640 --> 01:03:34,970
which is 8 bytes and then Oracle store

3556
01:03:34,970 --> 01:03:34,980
 

3557
01:03:34,980 --> 01:03:36,229
has their own row idea that stores this

3558
01:03:36,229 --> 01:03:36,239

3559
01:03:36,239 --> 01:03:39,950
in 10 bytes the reason why the Oracle

3560
01:03:39,950 --> 01:03:39,960
 

3561
01:03:39,960 --> 01:03:41,450
one is bigger is because they are

3562
01:03:41,450 --> 01:03:41,460
 

3563
01:03:41,460 --> 01:03:43,160
storing additional metadata information

3564
01:03:43,160 --> 01:03:43,170
 

3565
01:03:43,170 --> 01:03:45,529
about at what table what file this the

3566
01:03:45,529 --> 01:03:45,539

3567
01:03:45,539 --> 01:03:48,140
the tube election came from but in

3568
01:03:48,140 --> 01:03:48,150
 

3569
01:03:48,150 --> 01:03:49,880
practice it's sort of like this logical

3570
01:03:49,880 --> 01:03:49,890
 

3571
01:03:49,890 --> 01:03:52,519
number or that you're not really

3572
01:03:52,519 --> 01:03:52,529
 

3573
01:03:52,529 --> 01:03:53,599
supposed to using your application

3574
01:03:53,599 --> 01:03:53,609
 

3575
01:03:53,609 --> 01:03:56,210
because it can change at any time so I

3576
01:03:56,210 --> 01:03:56,220
 

3577
01:03:56,220 --> 01:03:59,269
want to give a quick demo of this so you

3578
01:03:59,269 --> 01:03:59,279
 

3579
01:03:59,279 --> 01:04:04,279
actually see them mmm right so this one

3580
01:04:04,279 --> 01:04:04,289
 

3581
01:04:04,289 --> 01:04:08,859
I'm gonna do Postgres at the top and and

3582
01:04:08,859 --> 01:04:08,869
 

3583
01:04:08,869 --> 01:04:13,519
seek a light at the bottom so I have two

3584
01:04:13,519 --> 01:04:13,529
 

3585
01:04:13,529 --> 01:04:15,589
tables actually have one table I just

3586
01:04:15,589 --> 01:04:15,599
 

3587
01:04:15,599 --> 01:04:18,229
made a simple table called R right so

3588
01:04:18,229 --> 01:04:18,239
 

3589
01:04:18,239 --> 01:04:19,940
post-course at the top has three tuples

3590
01:04:19,940 --> 01:04:19,950
 

3591
01:04:19,950 --> 01:04:22,670
1 0 1 1 0 2 1 2 3 and same thing that's

3592
01:04:22,670 --> 01:04:22,680
 

3593
01:04:22,680 --> 01:04:25,180
equal light at the bottom

3594
01:04:25,180 --> 01:04:25,190
 

3595
01:04:25,190 --> 01:04:27,700
so as I said Postgres is gonna store

3596
01:04:27,700 --> 01:04:27,710
 

3597
01:04:27,710 --> 01:04:31,270
what's called the CT ID and again this

3598
01:04:31,270 --> 01:04:31,280
 

3599
01:04:31,280 --> 01:04:33,370
is this is this is an internal thing

3600
01:04:33,370 --> 01:04:33,380
 

3601
01:04:33,380 --> 01:04:35,049
that you're not really supposed to using

3602
01:04:35,049 --> 01:04:35,059
 

3603
01:04:35,059 --> 01:04:36,700
your application because it can change

3604
01:04:36,700 --> 01:04:36,710
 

3605
01:04:36,710 --> 01:04:38,980
at any time so inside my query here I

3606
01:04:38,980 --> 01:04:38,990
 

3607
01:04:38,990 --> 01:04:41,230
can say r dot CT ID and Postgres knows

3608
01:04:41,230 --> 01:04:41,240
 

3609
01:04:41,240 --> 01:04:42,940
that I'm referring to its internal

3610
01:04:42,940 --> 01:04:42,950
 

3611
01:04:42,950 --> 01:04:44,740
identifier and you can see that

3612
01:04:44,740 --> 01:04:44,750
 

3613
01:04:44,750 --> 01:04:47,579
represent this as a pair of two numbers

3614
01:04:47,579 --> 01:04:47,589
 

3615
01:04:47,589 --> 01:04:50,020
right the first number is the page this

3616
01:04:50,020 --> 01:04:50,030
 

3617
01:04:50,030 --> 01:04:51,880
the second number is the offset in that

3618
01:04:51,880 --> 01:04:51,890
 

3619
01:04:51,890 --> 01:04:57,430
page right so now let's say if I do a if

3620
01:04:57,430 --> 01:04:57,440
 

3621
01:04:57,440 --> 01:05:02,140
I do a delete I go back right and it's

3622
01:05:02,140 --> 01:05:02,150
 

3623
01:05:02,150 --> 01:05:04,599
gone and you know the that's what used

3624
01:05:04,599 --> 01:05:04,609
 

3625
01:05:04,609 --> 01:05:07,539
to be the third tuple is is is still at

3626
01:05:07,539 --> 01:05:07,549
 

3627
01:05:07,549 --> 01:05:09,460
position zero two zero three because he

3628
01:05:09,460 --> 01:05:09,470
 

3629
01:05:09,470 --> 01:05:12,730
didn't reorganize things all right let's

3630
01:05:12,730 --> 01:05:12,740
 

3631
01:05:12,740 --> 01:05:17,020
say now I insert another tuple are you

3632
01:05:17,020 --> 01:05:17,030
 

3633
01:05:17,030 --> 01:05:19,150
married again and then you see Postgres

3634
01:05:19,150 --> 01:05:19,160
 

3635
01:05:19,160 --> 01:05:22,770
decided to rather than using position to

3636
01:05:22,770 --> 01:05:22,780
 

3637
01:05:22,780 --> 01:05:25,599
where the two budgets delete it was

3638
01:05:25,599 --> 01:05:25,609
 

3639
01:05:25,609 --> 01:05:27,250
stored they put it in the fourth

3640
01:05:27,250 --> 01:05:27,260
 

3641
01:05:27,260 --> 01:05:27,789
position

3642
01:05:27,789 --> 01:05:27,799

3643
01:05:27,799 --> 01:05:29,589
right so it's appending it to the the

3644
01:05:29,589 --> 01:05:29,599
 

3645
01:05:29,599 --> 01:05:32,380
end of the slot array so we won't talk

3646
01:05:32,380 --> 01:05:32,390

3647
01:05:32,390 --> 01:05:34,450
about the vacuum just now but the vac

3648
01:05:34,450 --> 01:05:34,460
 

3649
01:05:34,460 --> 01:05:35,890
can you think of the vacuum as doing

3650
01:05:35,890 --> 01:05:35,900
 

3651
01:05:35,900 --> 01:05:38,589
like garbage collection in in the JVM

3652
01:05:38,589 --> 01:05:38,599
 

3653
01:05:38,599 --> 01:05:40,180
right it's gonna go through and

3654
01:05:40,180 --> 01:05:40,190
 

3655
01:05:40,190 --> 01:05:41,950
reorganize every page and compact them

3656
01:05:41,950 --> 01:05:41,960
 

3657
01:05:41,960 --> 01:05:43,900
to free up any space that's not being

3658
01:05:43,900 --> 01:05:43,910
 

3659
01:05:43,910 --> 01:05:46,390
used anymore so now when I go back and

3660
01:05:46,390 --> 01:05:46,400
 

3661
01:05:46,400 --> 01:05:48,309
look at my table again remember I had

3662
01:05:48,309 --> 01:05:48,319
 

3663
01:05:48,319 --> 01:05:51,190
zero one zero three zero four right now

3664
01:05:51,190 --> 01:05:51,200
 

3665
01:05:51,200 --> 01:05:52,660
I have zero one zero two zero three

3666
01:05:52,660 --> 01:05:52,670
 

3667
01:05:52,670 --> 01:05:55,779
because it reorganizes the the layout of

3668
01:05:55,779 --> 01:05:55,789

3669
01:05:55,789 --> 01:05:57,309
the paper the tuples inside the slotted

3670
01:05:57,309 --> 01:05:57,319
 

3671
01:05:57,319 --> 01:05:58,870
page and then wrote that back out the

3672
01:05:58,870 --> 01:05:58,880
 

3673
01:05:58,880 --> 01:06:03,430
disk and now my CT IDs are different all

3674
01:06:03,430 --> 01:06:03,440
 

3675
01:06:03,440 --> 01:06:05,890
right so last year somebody had a

3676
01:06:05,890 --> 01:06:05,900
 

3677
01:06:05,900 --> 01:06:07,690
question whether I can do this can I

3678
01:06:07,690 --> 01:06:07,700
 

3679
01:06:07,700 --> 01:06:10,599
actually go to the table and say where a

3680
01:06:10,599 --> 01:06:10,609
 

3681
01:06:10,609 --> 01:06:17,410
CT ID equals something and Postgres is

3682
01:06:17,410 --> 01:06:17,420
 

3683
01:06:17,420 --> 01:06:22,480
amazing huh and let you do it right but

3684
01:06:22,480 --> 01:06:22,490
 

3685
01:06:22,490 --> 01:06:23,680
you're not supposed to do this right

3686
01:06:23,680 --> 01:06:23,690
 

3687
01:06:23,690 --> 01:06:27,039
you're not supposed to use the CT ID in

3688
01:06:27,039 --> 01:06:27,049
 

3689
01:06:27,049 --> 01:06:28,359
any way in your application form because

3690
01:06:28,359 --> 01:06:28,369
 

3691
01:06:28,369 --> 01:06:30,539
as I showed it can change at any time

3692
01:06:30,539 --> 01:06:30,549
 

3693
01:06:30,549 --> 01:06:35,800
all right so in sequel light

3694
01:06:35,800 --> 01:06:35,810


3695
01:06:35,810 --> 01:06:40,010
down below see the lights at a CCID they

3696
01:06:40,010 --> 01:06:40,020
 

3697
01:06:40,020 --> 01:06:42,710
call it a row ID right and you can see

3698
01:06:42,710 --> 01:06:42,720
 

3699
01:06:42,720 --> 01:06:44,960
it's just storing it as one two three I

3700
01:06:44,960 --> 01:06:44,970
 

3701
01:06:44,970 --> 01:06:47,390
said it's not a it's not like the page

3702
01:06:47,390 --> 01:06:47,400
 

3703
01:06:47,400 --> 01:06:49,130
ID and all set it's just this internal

3704
01:06:49,130 --> 01:06:49,140

3705
01:06:49,140 --> 01:06:52,520
sequence that Postgres maintains so now

3706
01:06:52,520 --> 01:06:52,530
 

3707
01:06:52,530 --> 01:06:57,230
if I do a delete right go back the the

3708
01:06:57,230 --> 01:06:57,240
 

3709
01:06:57,240 --> 01:07:00,370
second guy's gone and I do a new insert

3710
01:07:00,370 --> 01:07:00,380
 

3711
01:07:00,380 --> 01:07:04,040
and it didn't it didn't fill in the slot

3712
01:07:04,040 --> 01:07:04,050

3713
01:07:04,050 --> 01:07:05,720
it just used you know just depending to

3714
01:07:05,720 --> 01:07:05,730
 

3715
01:07:05,730 --> 01:07:11,900
the end right again I think in actually

3716
01:07:11,900 --> 01:07:11,910
 

3717
01:07:11,910 --> 01:07:13,100
secretly I don't know whether they

3718
01:07:13,100 --> 01:07:13,110
 

3719
01:07:13,110 --> 01:07:14,420
guarantee that's I think actually I

3720
01:07:14,420 --> 01:07:14,430
 

3721
01:07:14,430 --> 01:07:15,590
think it's sequel like they guarantee

3722
01:07:15,590 --> 01:07:15,600
 

3723
01:07:15,600 --> 01:07:19,640
that this is always always be always

3724
01:07:19,640 --> 01:07:19,650
 

3725
01:07:19,650 --> 01:07:22,280
increasing and they always stay with the

3726
01:07:22,280 --> 01:07:22,290

3727
01:07:22,290 --> 01:07:24,380
tuple let's say so if I delete every

3728
01:07:24,380 --> 01:07:24,390
 

3729
01:07:24,390 --> 01:07:30,710
single tuple right there's nothing there

3730
01:07:30,710 --> 01:07:30,720
 

3731
01:07:30,720 --> 01:07:35,120
now go insert back that same tuple yeah

3732
01:07:35,120 --> 01:07:35,130
 

3733
01:07:35,130 --> 01:07:36,350
I started off with one okay

3734
01:07:36,350 --> 01:07:36,360
 

3735
01:07:36,360 --> 01:07:38,330
so yeah I don't want to use it as a good

3736
01:07:38,330 --> 01:07:38,340
 

3737
01:07:38,340 --> 01:07:47,510
could change right yes so this question

3738
01:07:47,510 --> 01:07:47,520
 

3739
01:07:47,520 --> 01:07:51,640
is in the case of Postgres all right

3740
01:07:51,640 --> 01:07:51,650


3741
01:07:51,650 --> 01:07:54,530
this thing called the vacuum his

3742
01:07:54,530 --> 01:07:54,540
 

3743
01:07:54,540 --> 01:07:55,460
question is does this have to be done

3744
01:07:55,460 --> 01:07:55,470
 

3745
01:07:55,470 --> 01:07:57,410
manually newer versions of post-crisis

3746
01:07:57,410 --> 01:07:57,420
 

3747
01:07:57,420 --> 01:07:58,640
you know you do not do this man like

3748
01:07:58,640 --> 01:07:58,650
 

3749
01:07:58,650 --> 01:08:00,500
this look will cover this when we talk

3750
01:08:00,500 --> 01:08:00,510
 

3751
01:08:00,510 --> 01:08:02,110
about multi-version concurrency toll

3752
01:08:02,110 --> 01:08:02,120
 

3753
01:08:02,120 --> 01:08:04,340
basically post chris is doing is any

3754
01:08:04,340 --> 01:08:04,350
 

3755
01:08:04,350 --> 01:08:06,140
single time you update a tuple it

3756
01:08:06,140 --> 01:08:06,150
 

3757
01:08:06,150 --> 01:08:08,390
doesn't actually overwrite the existing

3758
01:08:08,390 --> 01:08:08,400

3759
01:08:08,400 --> 01:08:10,700
tuple it makes a new one and it

3760
01:08:10,700 --> 01:08:10,710
 

3761
01:08:10,710 --> 01:08:12,620
maintains an internal list internal like

3762
01:08:12,620 --> 01:08:12,630
 

3763
01:08:12,630 --> 01:08:14,540
link list I say here's go here's how to

3764
01:08:14,540 --> 01:08:14,550
 

3765
01:08:14,550 --> 01:08:16,010
go get the version that you ability that

3766
01:08:16,010 --> 01:08:16,020
 

3767
01:08:16,020 --> 01:08:19,250
you want right so if I go back here so

3768
01:08:19,250 --> 01:08:19,260
 

3769
01:08:19,260 --> 01:08:20,630
the back can be the way to go and prune

3770
01:08:20,630 --> 01:08:20,640
 

3771
01:08:20,640 --> 01:08:22,370
out the the older version that no one

3772
01:08:22,370 --> 01:08:22,380
 

3773
01:08:22,380 --> 01:08:25,280
can see anymore look we see that again

3774
01:08:25,280 --> 01:08:25,290
 

3775
01:08:25,290 --> 01:08:26,780
so if I go here I have three tuples so

3776
01:08:26,780 --> 01:08:26,790
 

3777
01:08:26,790 --> 01:08:33,170
I'd say I do update update are set vow

3778
01:08:33,170 --> 01:08:33,180
 

3779
01:08:33,180 --> 01:08:37,370
equal Y by Y where ID equals one or

3780
01:08:37,370 --> 01:08:37,380
 

3781
01:08:37,380 --> 01:08:39,880
three actually meeting to do this first

3782
01:08:39,880 --> 01:08:39,890
 

3783
01:08:39,890 --> 01:08:44,229
before I do that

3784
01:08:44,229 --> 01:08:44,239


3785
01:08:44,239 --> 01:08:47,590
let's go see what the c-jes RCT II's so

3786
01:08:47,590 --> 01:08:47,600
 

3787
01:08:47,600 --> 01:08:49,420
now I'll run that query all right so

3788
01:08:49,420 --> 01:08:49,430
 

3789
01:08:49,430 --> 01:08:51,490
we're gonna update the the the second

3790
01:08:51,490 --> 01:08:51,500
 

3791
01:08:51,500 --> 01:08:59,610
table I do my update is that correct

3792
01:08:59,610 --> 01:08:59,620
 

3793
01:08:59,620 --> 01:09:02,440
yeah and then it took that it took me

3794
01:09:02,440 --> 01:09:02,450
 

3795
01:09:02,450 --> 01:09:03,820
actually this is a good example of like

3796
01:09:03,820 --> 01:09:03,830
 

3797
01:09:03,830 --> 01:09:06,160
how the relation wall is ever so before

3798
01:09:06,160 --> 01:09:06,170
 

3799
01:09:06,170 --> 01:09:08,349
the update when I did a select it put

3800
01:09:08,349 --> 01:09:08,359
 

3801
01:09:08,359 --> 01:09:12,059
the second tuple in the second position

3802
01:09:12,059 --> 01:09:12,069
 

3803
01:09:12,069 --> 01:09:14,709
after my update it now became the third

3804
01:09:14,709 --> 01:09:14,719
 

3805
01:09:14,719 --> 01:09:17,920
tuple right because again the relational

3806
01:09:17,920 --> 01:09:17,930
 

3807
01:09:17,930 --> 01:09:20,950
model is unordered so what happened was

3808
01:09:20,950 --> 01:09:20,960
 

3809
01:09:20,960 --> 01:09:23,499
I did my update and I appended the new

3810
01:09:23,499 --> 01:09:23,509
 

3811
01:09:23,509 --> 01:09:26,260
change for this tuple that was here now

3812
01:09:26,260 --> 01:09:26,270
 

3813
01:09:26,270 --> 01:09:30,039
at 0 to now at 0 for so now as I'm doing

3814
01:09:30,039 --> 01:09:30,049
 

3815
01:09:30,049 --> 01:09:33,070
my scan I'm just reading them in based

3816
01:09:33,070 --> 01:09:33,080
 

3817
01:09:33,080 --> 01:09:35,590
on the offsets so the tuple in the last

3818
01:09:35,590 --> 01:09:35,600
 

3819
01:09:35,600 --> 01:09:37,690
all set and it's showing up as the last

3820
01:09:37,690 --> 01:09:37,700
 

3821
01:09:37,700 --> 01:09:41,050
one in my my output alright cuz again

3822
01:09:41,050 --> 01:09:41,060
 

3823
01:09:41,060 --> 01:09:43,269
the relational model isn't organized and

3824
01:09:43,269 --> 01:09:43,279
 

3825
01:09:43,279 --> 01:09:44,349
there's note there's no notion of

3826
01:09:44,349 --> 01:09:44,359
 

3827
01:09:44,359 --> 01:09:47,559
ordering in this case here right so same

3828
01:09:47,559 --> 01:09:47,569
 

3829
01:09:47,569 --> 01:09:49,150
thing I mean the point I wanted to make

3830
01:09:49,150 --> 01:09:49,160
 

3831
01:09:49,160 --> 01:09:51,430
here is that it was at position 0 2

3832
01:09:51,430 --> 01:09:51,440
 

3833
01:09:51,440 --> 01:09:54,340
after the update as now at 0 4 in the

3834
01:09:54,340 --> 01:09:54,350
 

3835
01:09:54,350 --> 01:09:56,410
background Postgres knows that it has to

3836
01:09:56,410 --> 01:09:56,420
 

3837
01:09:56,420 --> 01:09:58,810
run the vacuum I think it runs it's a

3838
01:09:58,810 --> 01:09:58,820
 

3839
01:09:58,820 --> 01:10:01,690
combination of either I've changed the

3840
01:10:01,690 --> 01:10:01,700
 

3841
01:10:01,700 --> 01:10:03,940
table so much or I'm running out of

3842
01:10:03,940 --> 01:10:03,950
 

3843
01:10:03,950 --> 01:10:06,550
space or it's it's a different periods

3844
01:10:06,550 --> 01:10:06,560
 

3845
01:10:06,560 --> 01:10:09,550
right again this is what a database

3846
01:10:09,550 --> 01:10:09,560
 

3847
01:10:09,560 --> 01:10:11,140
penetrator can do for you if the vacuum

3848
01:10:11,140 --> 01:10:11,150
 

3849
01:10:11,150 --> 01:10:12,400
can be expensive operation because

3850
01:10:12,400 --> 01:10:12,410
 

3851
01:10:12,410 --> 01:10:13,570
they're essentially reading everything

3852
01:10:13,570 --> 01:10:13,580
 

3853
01:10:13,580 --> 01:10:16,120
every page that has got changed since

3854
01:10:16,120 --> 01:10:16,130
 

3855
01:10:16,130 --> 01:10:18,070
the last time you ran the vacuum which

3856
01:10:18,070 --> 01:10:18,080
 

3857
01:10:18,080 --> 01:10:20,320
means reading them in reorganizing and

3858
01:10:20,320 --> 01:10:20,330
 

3859
01:10:20,330 --> 01:10:22,000
running back out you may not want to do

3860
01:10:22,000 --> 01:10:22,010
 

3861
01:10:22,010 --> 01:10:23,170
that during the day because you're

3862
01:10:23,170 --> 01:10:23,180
 

3863
01:10:23,180 --> 01:10:24,250
trying to you know keep up with the

3864
01:10:24,250 --> 01:10:24,260
 

3865
01:10:24,260 --> 01:10:25,780
workload so maybe want to do less

3866
01:10:25,780 --> 01:10:25,790
 

3867
01:10:25,790 --> 01:10:27,100
vacuuming during the day more vacuuming

3868
01:10:27,100 --> 01:10:27,110

3869
01:10:27,110 --> 01:10:28,900
it at night hey this is something that

3870
01:10:28,900 --> 01:10:28,910
 

3871
01:10:28,910 --> 01:10:32,560
they administrator can control all right

3872
01:10:32,560 --> 01:10:32,570
 

3873
01:10:32,570 --> 01:10:35,740
any questions about row IDs so the some

3874
01:10:35,740 --> 01:10:35,750
 

3875
01:10:35,750 --> 01:10:36,700
of them will actually store them

3876
01:10:36,700 --> 01:10:36,710
 

3877
01:10:36,710 --> 01:10:39,760
directly in the tuple I think C code

3878
01:10:39,760 --> 01:10:39,770
 

3879
01:10:39,770 --> 01:10:43,030
lights doing this Oracle does this all

3880
01:10:43,030 --> 01:10:43,040
 

3881
01:10:43,040 --> 01:10:44,890
those systems like Postgres don't

3882
01:10:44,890 --> 01:10:44,900
 

3883
01:10:44,900 --> 01:10:46,780
actually store the the record ID or the

3884
01:10:46,780 --> 01:10:46,790
 

3885
01:10:46,790 --> 01:10:49,180
row ID in the tuple itself right cuz

3886
01:10:49,180 --> 01:10:49,190
 

3887
01:10:49,190 --> 01:10:51,340
it's a waste of space I believe and

3888
01:10:51,340 --> 01:10:51,350
 

3889
01:10:51,350 --> 01:10:52,720
arrived at based on the page ID and all

3890
01:10:52,720 --> 01:10:52,730
 

3891
01:10:52,730 --> 01:10:54,420
set

3892
01:10:54,420 --> 01:10:54,430

3893
01:10:54,430 --> 01:10:57,120
all right so what we covered today we

3894
01:10:57,120 --> 01:10:57,130
 

3895
01:10:57,130 --> 01:10:59,190
covered how to organize the database and

3896
01:10:59,190 --> 01:10:59,200
 

3897
01:10:59,200 --> 01:11:01,200
pages we covered how to actually track

3898
01:11:01,200 --> 01:11:01,210
 

3899
01:11:01,210 --> 01:11:03,060
those pages so that when upper-level

3900
01:11:03,060 --> 01:11:03,070
 

3901
01:11:03,070 --> 01:11:04,950
system says give me a particular page it

3902
01:11:04,950 --> 01:11:04,960
 

3903
01:11:04,960 --> 01:11:07,380
knows how to go find that we didn't look

3904
01:11:07,380 --> 01:11:07,390
 

3905
01:11:07,390 --> 01:11:08,490
two different ways actually store those

3906
01:11:08,490 --> 01:11:08,500
 

3907
01:11:08,500 --> 01:11:10,470
pages we talked about how to actually

3908
01:11:10,470 --> 01:11:10,480
 

3909
01:11:10,480 --> 01:11:12,300
organize the tools inside of those pages

3910
01:11:12,300 --> 01:11:12,310
 

3911
01:11:12,310 --> 01:11:16,740
right so next class we'll talk about

3912
01:11:16,740 --> 01:11:16,750
 

3913
01:11:16,750 --> 01:11:18,420
sort of more more complicated things

3914
01:11:18,420 --> 01:11:18,430
 

3915
01:11:18,430 --> 01:11:21,750
that don't deviate from what we've

3916
01:11:21,750 --> 01:11:21,760
 

3917
01:11:21,760 --> 01:11:22,860
talked about here but it's sort of game

3918
01:11:22,860 --> 01:11:22,870
 

3919
01:11:22,870 --> 01:11:26,310
building upon what we've done so we'll

3920
01:11:26,310 --> 01:11:26,320
 

3921
01:11:26,320 --> 01:11:27,390
talk about how you have you back

3922
01:11:27,390 --> 01:11:27,400
 

3923
01:11:27,400 --> 01:11:30,300
actually represent the values inside of

3924
01:11:30,300 --> 01:11:30,310
 

3925
01:11:30,310 --> 01:11:32,220
the tuples themselves by going even

3926
01:11:32,220 --> 01:11:32,230
 

3927
01:11:32,230 --> 01:11:33,870
further inside the page and then we'll

3928
01:11:33,870 --> 01:11:33,880
 

3929
01:11:33,880 --> 01:11:35,970
talk about different storage models so a

3930
01:11:35,970 --> 01:11:35,980
 

3931
01:11:35,980 --> 01:11:37,650
storage model is a way to actually

3932
01:11:37,650 --> 01:11:37,660
 

3933
01:11:37,660 --> 01:11:41,220
organize the data within a table and so

3934
01:11:41,220 --> 01:11:41,230
 

3935
01:11:41,230 --> 01:11:42,840
what I'll say is everything I've showed

3936
01:11:42,840 --> 01:11:42,850
 

3937
01:11:42,850 --> 01:11:45,720
here today is called a roast or meaning

3938
01:11:45,720 --> 01:11:45,730
 

3939
01:11:45,730 --> 01:11:47,490
like the for every single tuple it's

3940
01:11:47,490 --> 01:11:47,500
 

3941
01:11:47,500 --> 01:11:49,710
sort of organized in contiguously across

3942
01:11:49,710 --> 01:11:49,720
 

3943
01:11:49,720 --> 01:11:51,360
all the attributes that one tuple

3944
01:11:51,360 --> 01:11:51,370
 

3945
01:11:51,370 --> 01:11:52,590
doesn't begin until the next one

3946
01:11:52,590 --> 01:11:52,600
 

3947
01:11:52,600 --> 01:11:54,570
finishes another way to do this is

3948
01:11:54,570 --> 01:11:54,580
 

3949
01:11:54,580 --> 01:11:55,620
actually organize these things as

3950
01:11:55,620 --> 01:11:55,630
 

3951
01:11:55,630 --> 01:11:58,140
columns for all the values for a single

3952
01:11:58,140 --> 01:11:58,150
 

3953
01:11:58,150 --> 01:11:59,490
column across multiple tuples or stored

3954
01:11:59,490 --> 01:11:59,500
 

3955
01:11:59,500 --> 01:12:02,280
contiguously right I mean the page

3956
01:12:02,280 --> 01:12:02,290
 

3957
01:12:02,290 --> 01:12:05,160
layout stuff doesn't change so the way

3958
01:12:05,160 --> 01:12:05,170
 

3959
01:12:05,170 --> 01:12:06,180
we're organizing our pages with

3960
01:12:06,180 --> 01:12:06,190
 

3961
01:12:06,190 --> 01:12:07,770
directories doesn't change just how

3962
01:12:07,770 --> 01:12:07,780
 

3963
01:12:07,780 --> 01:12:09,420
we're actually representing the data

3964
01:12:09,420 --> 01:12:09,430
 

3965
01:12:09,430 --> 01:12:18,940
inside this pages changes okay

3966
01:12:18,940 --> 01:12:18,950


3967
01:12:18,950 --> 01:12:21,680
[Music]

3968
01:12:21,680 --> 01:12:21,690

3969
01:12:21,690 --> 01:12:49,830
I wanna party by the 12-pack case of a

3970
01:12:49,830 --> 01:12:49,840
 

3971
01:12:49,840 --> 01:12:53,070
boy six-pack 40 actor gets the real I

3972
01:12:53,070 --> 01:12:53,080
 

3973
01:12:53,080 --> 01:12:55,590
dream please put your drinking proper 12

3974
01:12:55,590 --> 01:12:55,600
 

3975
01:12:55,600 --> 01:12:58,320
ow they say bill makes your flat but

3976
01:12:58,320 --> 01:12:58,330
 

3977
01:12:58,330 --> 01:13:00,300
saying eyes is straight so it really

3978
01:13:00,300 --> 01:13:00,310
 

3979
01:13:00,310 --> 01:13:02,670
don't matter

