1
00:00:00,740 --> 00:00:11,680
[Music]

2
00:00:11,680 --> 00:00:11,690

3
00:00:11,690 --> 00:00:14,930
today's lecture is gonna be on puff pool

4
00:00:14,930 --> 00:00:14,940
 

5
00:00:14,940 --> 00:00:17,510
right this is the how we're gonna manage

6
00:00:17,510 --> 00:00:17,520
 

7
00:00:17,520 --> 00:00:19,580
memory inside of our database system so

8
00:00:19,580 --> 00:00:19,590
 

9
00:00:19,590 --> 00:00:23,689
Before we jump into the material uh turn

10
00:00:23,689 --> 00:00:23,699
 

11
00:00:23,699 --> 00:00:31,040
this on on today okay the two upcoming

12
00:00:31,040 --> 00:00:31,050
 

13
00:00:31,050 --> 00:00:32,750
database talks that I think are

14
00:00:32,750 --> 00:00:32,760
 

15
00:00:32,760 --> 00:00:34,189
interesting you guys want to check out

16
00:00:34,189 --> 00:00:34,199
 

17
00:00:34,199 --> 00:00:37,130
so there's a talk today in the 8th floor

18
00:00:37,130 --> 00:00:37,140
 

19
00:00:37,140 --> 00:00:39,469
and gates from the co-founder of

20
00:00:39,469 --> 00:00:39,479
 

21
00:00:39,479 --> 00:00:41,780
relational AI I actually don't know what

22
00:00:41,780 --> 00:00:41,790
 

23
00:00:41,790 --> 00:00:44,030
they're doing I know who the person is I

24
00:00:44,030 --> 00:00:44,040
 

25
00:00:44,040 --> 00:00:46,180
don't know what the new companies doing

26
00:00:46,180 --> 00:00:46,190
 

27
00:00:46,190 --> 00:00:48,770
but so he's a semi-famous dude so this

28
00:00:48,770 --> 00:00:48,780
 

29
00:00:48,780 --> 00:00:50,060
this should should be an interesting

30
00:00:50,060 --> 00:00:50,070
 

31
00:00:50,070 --> 00:00:51,619
talk to this be I think sort of

32
00:00:51,619 --> 00:00:51,629
 

33
00:00:51,629 --> 00:00:53,060
databases meets machine learning and

34
00:00:53,060 --> 00:00:53,070
 

35
00:00:53,070 --> 00:00:54,110
machine learning needs it meets

36
00:00:54,110 --> 00:00:54,120
 

37
00:00:54,120 --> 00:00:56,840
databases and then Thursday next week

38
00:00:56,840 --> 00:00:56,850
 

39
00:00:56,850 --> 00:00:58,820
we'll have the second session in our

40
00:00:58,820 --> 00:00:58,830
 

41
00:00:58,830 --> 00:01:00,170
seminar series on Hardware accelerate

42
00:01:00,170 --> 00:01:00,180

43
00:01:00,180 --> 00:01:03,619
databases with the co-founder of map D

44
00:01:03,619 --> 00:01:03,629
 

45
00:01:03,629 --> 00:01:07,370
map D is a another GPU database system

46
00:01:07,370 --> 00:01:07,380
 

47
00:01:07,380 --> 00:01:10,550
so that'll be on Thursday on the fourth

48
00:01:10,550 --> 00:01:10,560
 

49
00:01:10,560 --> 00:01:11,090
floor

50
00:01:11,090 --> 00:01:11,100

51
00:01:11,100 --> 00:01:13,550
in the CIC building right whether you

52
00:01:13,550 --> 00:01:13,560
 

53
00:01:13,560 --> 00:01:15,440
come out of the elevators you go right

54
00:01:15,440 --> 00:01:15,450
 

55
00:01:15,450 --> 00:01:17,779
well left pretending what elevator but

56
00:01:17,779 --> 00:01:17,789
 

57
00:01:17,789 --> 00:01:19,520
there's these glass doors go inside that

58
00:01:19,520 --> 00:01:19,530
 

59
00:01:19,530 --> 00:01:25,389
and the talk will be in there ok ok so

60
00:01:25,389 --> 00:01:25,399
 

61
00:01:25,399 --> 00:01:29,959
as we said last class the last two

62
00:01:29,959 --> 00:01:29,969
 

63
00:01:29,969 --> 00:01:32,109
lectures were all about organizing

64
00:01:32,109 --> 00:01:32,119

65
00:01:32,119 --> 00:01:35,779
database files on disk right how we're

66
00:01:35,779 --> 00:01:35,789
 

67
00:01:35,789 --> 00:01:38,569
gonna lay out the the the files and

68
00:01:38,569 --> 00:01:38,579
 

69
00:01:38,579 --> 00:01:40,219
decide then we have pages and instead of

70
00:01:40,219 --> 00:01:40,229
 

71
00:01:40,229 --> 00:01:43,219
the pages we lay out our data and then

72
00:01:43,219 --> 00:01:43,229
 

73
00:01:43,229 --> 00:01:45,440
we sort of punted on this this idea of

74
00:01:45,440 --> 00:01:45,450
 

75
00:01:45,450 --> 00:01:47,149
how are we actually gonna bring this

76
00:01:47,149 --> 00:01:47,159
 

77
00:01:47,159 --> 00:01:48,919
into memory and manage that right

78
00:01:48,919 --> 00:01:48,929
 

79
00:01:48,929 --> 00:01:50,929
because we said we can't have our data

80
00:01:50,929 --> 00:01:50,939
 

81
00:01:50,939 --> 00:01:53,090
system operate directly on files on disk

82
00:01:53,090 --> 00:01:53,100
 

83
00:01:53,100 --> 00:01:54,620
everything blows it has to be brought in

84
00:01:54,620 --> 00:01:54,630
 

85
00:01:54,630 --> 00:01:55,999
memory before we can even read and write

86
00:01:55,999 --> 00:01:56,009
 

87
00:01:56,009 --> 00:01:58,609
to it so that's what today's lecture is

88
00:01:58,609 --> 00:01:58,619
 

89
00:01:58,619 --> 00:02:01,129
about right the second part of how we're

90
00:02:01,129 --> 00:02:01,139
 

91
00:02:01,139 --> 00:02:02,899
gonna actually make make decisions on on

92
00:02:02,899 --> 00:02:02,909
 

93
00:02:02,909 --> 00:02:05,450
where to bring in the pages into memory

94
00:02:05,450 --> 00:02:05,460
 

95
00:02:05,460 --> 00:02:06,830
and then how do you make decisions to

96
00:02:06,830 --> 00:02:06,840
 

97
00:02:06,840 --> 00:02:08,600
evict them when we run out of space

98
00:02:08,600 --> 00:02:08,610

99
00:02:08,610 --> 00:02:10,490
right because the the size of our

100
00:02:10,490 --> 00:02:10,500

101
00:02:10,500 --> 00:02:12,350
database is most often gonna be much

102
00:02:12,350 --> 00:02:12,360
 

103
00:02:12,360 --> 00:02:14,000
larger than the amount of memory that we

104
00:02:14,000 --> 00:02:14,010
 

105
00:02:14,010 --> 00:02:15,949
have so we can't keep everything in

106
00:02:15,949 --> 00:02:15,959
 

107
00:02:15,959 --> 00:02:17,690
memory

108
00:02:17,690 --> 00:02:17,700
 

109
00:02:17,700 --> 00:02:20,850
so the another way to think about the

110
00:02:20,850 --> 00:02:20,860
 

111
00:02:20,860 --> 00:02:24,510
problem is is discussing this this sort

112
00:02:24,510 --> 00:02:24,520
 

113
00:02:24,520 --> 00:02:25,920
of this trade-off between sort of

114
00:02:25,920 --> 00:02:25,930
 

115
00:02:25,930 --> 00:02:29,730
spatial and temporal control of data so

116
00:02:29,730 --> 00:02:29,740
 

117
00:02:29,740 --> 00:02:30,930
spatial control is what we've talked

118
00:02:30,930 --> 00:02:30,940

119
00:02:30,940 --> 00:02:33,180
about so far it's right it's basically

120
00:02:33,180 --> 00:02:33,190
 

121
00:02:33,190 --> 00:02:34,890
how we're gonna write files to disk

122
00:02:34,890 --> 00:02:34,900

123
00:02:34,900 --> 00:02:36,900
we're gonna like lay out our pages on

124
00:02:36,900 --> 00:02:36,910
 

125
00:02:36,910 --> 00:02:39,270
disk right and the goal of this was as

126
00:02:39,270 --> 00:02:39,280
 

127
00:02:39,280 --> 00:02:42,600
we said is that since discs are faster

128
00:02:42,600 --> 00:02:42,610
 

129
00:02:42,610 --> 00:02:45,180
at doing salento access definitely we're

130
00:02:45,180 --> 00:02:45,190
 

131
00:02:45,190 --> 00:02:46,380
spinning disk hard drive because it's a

132
00:02:46,380 --> 00:02:46,390
 

133
00:02:46,390 --> 00:02:47,940
mechanical arm it has to jump around on

134
00:02:47,940 --> 00:02:47,950
 

135
00:02:47,950 --> 00:02:49,530
the platter and read and we read the

136
00:02:49,530 --> 00:02:49,540
 

137
00:02:49,540 --> 00:02:52,260
tracks but even the SSDs as well if we

138
00:02:52,260 --> 00:02:52,270
 

139
00:02:52,270 --> 00:02:53,940
can have the data that we know is gonna

140
00:02:53,940 --> 00:02:53,950
 

141
00:02:53,950 --> 00:02:57,290
be accessed together in a query

142
00:02:57,290 --> 00:02:57,300
 

143
00:02:57,300 --> 00:02:59,310
physically located next to each other

144
00:02:59,310 --> 00:02:59,320
 

145
00:02:59,320 --> 00:03:02,310
inside of our disks then we'll have will

146
00:03:02,310 --> 00:03:02,320
 

147
00:03:02,320 --> 00:03:04,320
have faster access right cuz they're now

148
00:03:04,320 --> 00:03:04,330
 

149
00:03:04,330 --> 00:03:05,910
again thinking of the worst case

150
00:03:05,910 --> 00:03:05,920
 

151
00:03:05,920 --> 00:03:07,320
scenario of the spinning spinning disk

152
00:03:07,320 --> 00:03:07,330
 

153
00:03:07,330 --> 00:03:09,570
our drive the arm has to jump around all

154
00:03:09,570 --> 00:03:09,580
 

155
00:03:09,580 --> 00:03:10,920
over the platter every single time I

156
00:03:10,920 --> 00:03:10,930
 

157
00:03:10,930 --> 00:03:12,780
need to read a single page that's gonna

158
00:03:12,780 --> 00:03:12,790
 

159
00:03:12,790 --> 00:03:14,790
be really slow or if I'm to plop the arm

160
00:03:14,790 --> 00:03:14,800
 

161
00:03:14,800 --> 00:03:16,230
down in one location and then read

162
00:03:16,230 --> 00:03:16,240
 

163
00:03:16,240 --> 00:03:18,510
sequentially a bunch of pages that's

164
00:03:18,510 --> 00:03:18,520
 

165
00:03:18,520 --> 00:03:21,600
gonna be much faster so now what we're

166
00:03:21,600 --> 00:03:21,610
 

167
00:03:21,610 --> 00:03:24,479
talking about today is the second issue

168
00:03:24,479 --> 00:03:24,489
 

169
00:03:24,489 --> 00:03:27,540
of thinking about the temporality of the

170
00:03:27,540 --> 00:03:27,550
 

171
00:03:27,550 --> 00:03:30,420
data we're accessing right and this

172
00:03:30,420 --> 00:03:30,430
 

173
00:03:30,430 --> 00:03:32,040
means how we're actually going to

174
00:03:32,040 --> 00:03:32,050
 

175
00:03:32,050 --> 00:03:33,900
control when do we read pages into

176
00:03:33,900 --> 00:03:33,910
 

177
00:03:33,910 --> 00:03:35,970
memory and when do we write the map back

178
00:03:35,970 --> 00:03:35,980
 

179
00:03:35,980 --> 00:03:39,810
out the disk if necessary right so we're

180
00:03:39,810 --> 00:03:39,820
 

181
00:03:39,820 --> 00:03:41,699
not discussing where we're gonna write

182
00:03:41,699 --> 00:03:41,709
 

183
00:03:41,709 --> 00:03:43,590
these things a disk we'll talk a little

184
00:03:43,590 --> 00:03:43,600
 

185
00:03:43,600 --> 00:03:44,820
bit where we actually store them in

186
00:03:44,820 --> 00:03:44,830
 

187
00:03:44,830 --> 00:03:47,039
memory but overall it's it's you know

188
00:03:47,039 --> 00:03:47,049

189
00:03:47,049 --> 00:03:48,270
whether the pages are next to each other

190
00:03:48,270 --> 00:03:48,280
 

191
00:03:48,280 --> 00:03:50,220
in memory for our purposes here doesn't

192
00:03:50,220 --> 00:03:50,230
 

193
00:03:50,230 --> 00:03:52,140
actually matter in real systems if

194
00:03:52,140 --> 00:03:52,150
 

195
00:03:52,150 --> 00:03:53,580
you're in memory it does but for our

196
00:03:53,580 --> 00:03:53,590
 

197
00:03:53,590 --> 00:03:55,650
purposes here we ignore that so it's

198
00:03:55,650 --> 00:03:55,660
 

199
00:03:55,660 --> 00:03:57,060
really about been deciding how we're

200
00:03:57,060 --> 00:03:57,070
 

201
00:03:57,070 --> 00:03:59,490
actually going to when we actually want

202
00:03:59,490 --> 00:03:59,500
 

203
00:03:59,500 --> 00:04:01,530
to move data back and forth and the goal

204
00:04:01,530 --> 00:04:01,540
 

205
00:04:01,540 --> 00:04:03,660
here obviously since this was so much

206
00:04:03,660 --> 00:04:03,670
 

207
00:04:03,670 --> 00:04:06,449
slower than then mandi ram and memory we

208
00:04:06,449 --> 00:04:06,459
 

209
00:04:06,459 --> 00:04:07,920
want to minimize the number of stalls

210
00:04:07,920 --> 00:04:07,930
 

211
00:04:07,930 --> 00:04:10,890
that will incur because we had to read

212
00:04:10,890 --> 00:04:10,900
 

213
00:04:10,900 --> 00:04:13,199
data from disk right it's in some ways

214
00:04:13,199 --> 00:04:13,209
 

215
00:04:13,209 --> 00:04:15,180
just unavoidable as I said because the

216
00:04:15,180 --> 00:04:15,190
 

217
00:04:15,190 --> 00:04:16,860
databases we larger than total matter

218
00:04:16,860 --> 00:04:16,870
 

219
00:04:16,870 --> 00:04:19,020
memory that we have but if we're smart

220
00:04:19,020 --> 00:04:19,030
 

221
00:04:19,030 --> 00:04:21,570
about how we stage things and time our

222
00:04:21,570 --> 00:04:21,580
 

223
00:04:21,580 --> 00:04:24,330
accesses and write backs we can we can

224
00:04:24,330 --> 00:04:24,340
 

225
00:04:24,340 --> 00:04:27,300
minimize this impact right way to think

226
00:04:27,300 --> 00:04:27,310
 

227
00:04:27,310 --> 00:04:28,620
about this is I know I'm gonna see read

228
00:04:28,620 --> 00:04:28,630
 

229
00:04:28,630 --> 00:04:30,000
the same page over and over and over

230
00:04:30,000 --> 00:04:30,010
 

231
00:04:30,010 --> 00:04:31,090
again

232
00:04:31,090 --> 00:04:31,100
 

233
00:04:31,100 --> 00:04:32,050
maybe I don't want to write that out

234
00:04:32,050 --> 00:04:32,060
 

235
00:04:32,060 --> 00:04:33,100
that disk and I always keep that in

236
00:04:33,100 --> 00:04:33,110
 

237
00:04:33,110 --> 00:04:35,140
memory but if I read something once and

238
00:04:35,140 --> 00:04:35,150
 

239
00:04:35,150 --> 00:04:36,610
I'll never read it again then I want to

240
00:04:36,610 --> 00:04:36,620
 

241
00:04:36,620 --> 00:04:37,960
go ahead and maybe evict it and throw it

242
00:04:37,960 --> 00:04:37,970
 

243
00:04:37,970 --> 00:04:39,880
away so these are the kind of things

244
00:04:39,880 --> 00:04:39,890
 

245
00:04:39,890 --> 00:04:42,550
that we're gonna discuss today and this

246
00:04:42,550 --> 00:04:42,560
 

247
00:04:42,560 --> 00:04:45,130
providing in this overyou diagram that I

248
00:04:45,130 --> 00:04:45,140
 

249
00:04:45,140 --> 00:04:47,200
showed last class we've covered the

250
00:04:47,200 --> 00:04:47,210
 

251
00:04:47,210 --> 00:04:49,510
bottom part we know how to lay up pages

252
00:04:49,510 --> 00:04:49,520
 

253
00:04:49,520 --> 00:04:51,850
in the files and now it's the second

254
00:04:51,850 --> 00:04:51,860
 

255
00:04:51,860 --> 00:04:53,260
part above this write the buffer pool

256
00:04:53,260 --> 00:04:53,270
 

257
00:04:53,270 --> 00:04:55,210
alright the buffer pool is gonna be the

258
00:04:55,210 --> 00:04:55,220
 

259
00:04:55,220 --> 00:04:58,090
in memory cache that the the database

260
00:04:58,090 --> 00:04:58,100
 

261
00:04:58,100 --> 00:05:00,280
systems going to maintain all the pages

262
00:05:00,280 --> 00:05:00,290
 

263
00:05:00,290 --> 00:05:02,590
that it read from the files on disk and

264
00:05:02,590 --> 00:05:02,600
 

265
00:05:02,600 --> 00:05:04,630
we said before that this looks a lot

266
00:05:04,630 --> 00:05:04,640
 

267
00:05:04,640 --> 00:05:05,680
like virtual memory from the operating

268
00:05:05,680 --> 00:05:05,690

269
00:05:05,690 --> 00:05:08,140
system but the operating system as we'll

270
00:05:08,140 --> 00:05:08,150
 

271
00:05:08,150 --> 00:05:09,610
see it was go along it's not gonna do as

272
00:05:09,610 --> 00:05:09,620
 

273
00:05:09,620 --> 00:05:11,020
a good job as our database system

274
00:05:11,020 --> 00:05:11,030
 

275
00:05:11,030 --> 00:05:14,020
because we fully not fully but we have a

276
00:05:14,020 --> 00:05:14,030
 

277
00:05:14,030 --> 00:05:15,760
better understanding of exactly what

278
00:05:15,760 --> 00:05:15,770
 

279
00:05:15,770 --> 00:05:18,130
queries want to do and therefore we can

280
00:05:18,130 --> 00:05:18,140
 

281
00:05:18,140 --> 00:05:19,930
prepare ourselves and read and write

282
00:05:19,930 --> 00:05:19,940

283
00:05:19,940 --> 00:05:22,480
data from disk into memory accordingly

284
00:05:22,480 --> 00:05:22,490
 

285
00:05:22,490 --> 00:05:23,890
in a way that the operating system can't

286
00:05:23,890 --> 00:05:23,900

287
00:05:23,900 --> 00:05:25,810
do because the operating system only

288
00:05:25,810 --> 00:05:25,820
 

289
00:05:25,820 --> 00:05:29,220
sees like the reads and white sort of

290
00:05:29,220 --> 00:05:29,230
 

291
00:05:29,230 --> 00:05:31,270
granular level just sees the reads and

292
00:05:31,270 --> 00:05:31,280
 

293
00:05:31,280 --> 00:05:33,070
sees the writes on a page doesn't

294
00:05:33,070 --> 00:05:33,080
 

295
00:05:33,080 --> 00:05:34,750
understand anything about how the extra

296
00:05:34,750 --> 00:05:34,760
 

297
00:05:34,760 --> 00:05:36,340
queries are accessing those pages

298
00:05:36,340 --> 00:05:36,350
 

299
00:05:36,350 --> 00:05:38,650
because the OS treats all pages is the

300
00:05:38,650 --> 00:05:38,660
 

301
00:05:38,660 --> 00:05:40,330
same where as well see as we go along

302
00:05:40,330 --> 00:05:40,340
 

303
00:05:40,340 --> 00:05:42,640
inside our database system some pages

304
00:05:42,640 --> 00:05:42,650
 

305
00:05:42,650 --> 00:05:44,950
correspond to indexes some pages

306
00:05:44,950 --> 00:05:44,960
 

307
00:05:44,960 --> 00:05:46,480
correspond to inmate it results of

308
00:05:46,480 --> 00:05:46,490

309
00:05:46,490 --> 00:05:48,340
queries and not all of them are the same

310
00:05:48,340 --> 00:05:48,350
 

311
00:05:48,350 --> 00:05:49,690
it should not always be treated the same

312
00:05:49,690 --> 00:05:49,700
 

313
00:05:49,700 --> 00:05:53,110
but the OS doesn't know this so it can't

314
00:05:53,110 --> 00:05:53,120
 

315
00:05:53,120 --> 00:05:56,380
do as good a job as we can so for

316
00:05:56,380 --> 00:05:56,390
 

317
00:05:56,390 --> 00:05:57,790
today's agenda we're gonna first sort of

318
00:05:57,790 --> 00:05:57,800
 

319
00:05:57,800 --> 00:06:00,010
talk about the the bubble manager right

320
00:06:00,010 --> 00:06:00,020
 

321
00:06:00,020 --> 00:06:01,780
at a high level pretty easy to implement

322
00:06:01,780 --> 00:06:01,790
 

323
00:06:01,790 --> 00:06:04,600
the basic the basic concept of it but

324
00:06:04,600 --> 00:06:04,610
 

325
00:06:04,610 --> 00:06:06,280
we'll see the more complicated things

326
00:06:06,280 --> 00:06:06,290
 

327
00:06:06,290 --> 00:06:08,320
you can do in the actual policies you

328
00:06:08,320 --> 00:06:08,330
 

329
00:06:08,330 --> 00:06:09,610
maintain inside of this and for

330
00:06:09,610 --> 00:06:09,620
 

331
00:06:09,620 --> 00:06:12,130
replacement and allocation and then

332
00:06:12,130 --> 00:06:12,140
 

333
00:06:12,140 --> 00:06:13,600
we'll talk briefly about what are the

334
00:06:13,600 --> 00:06:13,610
 

335
00:06:13,610 --> 00:06:15,400
other memory pools look like inside the

336
00:06:15,400 --> 00:06:15,410
 

337
00:06:15,410 --> 00:06:20,710
database system okay so at a high level

338
00:06:20,710 --> 00:06:20,720
 

339
00:06:20,720 --> 00:06:23,200
the barber pole is just a large region

340
00:06:23,200 --> 00:06:23,210
 

341
00:06:23,210 --> 00:06:25,390
of memory that the database is going to

342
00:06:25,390 --> 00:06:25,400
 

343
00:06:25,400 --> 00:06:28,450
manage in its own address space and it's

344
00:06:28,450 --> 00:06:28,460
 

345
00:06:28,460 --> 00:06:30,730
gonna use this to again copy pages that

346
00:06:30,730 --> 00:06:30,740
 

347
00:06:30,740 --> 00:06:32,770
the queries want to access from the disk

348
00:06:32,770 --> 00:06:32,780

349
00:06:32,780 --> 00:06:35,890
and put them into the buffer pool all

350
00:06:35,890 --> 00:06:35,900
 

351
00:06:35,900 --> 00:06:38,110
right so you sort of think this duffel

352
00:06:38,110 --> 00:06:38,120
 

353
00:06:38,120 --> 00:06:39,880
is just some large memory region like a

354
00:06:39,880 --> 00:06:39,890
 

355
00:06:39,890 --> 00:06:41,980
giant a byte array and then it's gonna

356
00:06:41,980 --> 00:06:41,990
 

357
00:06:41,990 --> 00:06:43,900
split up the byte array into what are

358
00:06:43,900 --> 00:06:43,910

359
00:06:43,910 --> 00:06:44,940
called frames

360
00:06:44,940 --> 00:06:44,950

361
00:06:44,950 --> 00:06:46,980
and these will be this the same size

362
00:06:46,980 --> 00:06:46,990
 

363
00:06:46,990 --> 00:06:48,930
size as your pages everything was a

364
00:06:48,930 --> 00:06:48,940
 

365
00:06:48,940 --> 00:06:52,050
question last time whether the size of a

366
00:06:52,050 --> 00:06:52,060

367
00:06:52,060 --> 00:06:55,050
page for you know the the large overflow

368
00:06:55,050 --> 00:06:55,060
 

369
00:06:55,060 --> 00:06:56,850
pages are they different than the the

370
00:06:56,850 --> 00:06:56,860
 

371
00:06:56,860 --> 00:06:58,950
rather tuple pages everything's always

372
00:06:58,950 --> 00:06:58,960
 

373
00:06:58,960 --> 00:07:00,900
be the same page size because they need

374
00:07:00,900 --> 00:07:00,910
 

375
00:07:00,910 --> 00:07:02,730
to fit into these frames right and

376
00:07:02,730 --> 00:07:02,740
 

377
00:07:02,740 --> 00:07:03,990
that's how it's gonna figure out you

378
00:07:03,990 --> 00:07:04,000
 

379
00:07:04,000 --> 00:07:05,370
know where the next we're the stopping

380
00:07:05,370 --> 00:07:05,380
 

381
00:07:05,380 --> 00:07:07,260
starting point for every pages because

382
00:07:07,260 --> 00:07:07,270
 

383
00:07:07,270 --> 00:07:08,130
otherwise you have to have an

384
00:07:08,130 --> 00:07:08,140
 

385
00:07:08,140 --> 00:07:09,420
indirection layer to figure out you know

386
00:07:09,420 --> 00:07:09,430

387
00:07:09,430 --> 00:07:10,710
help the length of things at their

388
00:07:10,710 --> 00:07:10,720
 

389
00:07:10,720 --> 00:07:13,320
verbal length so we call these these

390
00:07:13,320 --> 00:07:13,330
 

391
00:07:13,330 --> 00:07:14,490
open spaces frames

392
00:07:14,490 --> 00:07:14,500
 

393
00:07:14,500 --> 00:07:15,720
alright the slot where you can actually

394
00:07:15,720 --> 00:07:15,730
 

395
00:07:15,730 --> 00:07:17,580
write data in I'll try to use frame as

396
00:07:17,580 --> 00:07:17,590

397
00:07:17,590 --> 00:07:18,810
much as possible but you can sort of see

398
00:07:18,810 --> 00:07:18,820
 

399
00:07:18,820 --> 00:07:21,690
how the same concept at a high level

400
00:07:21,690 --> 00:07:21,700
 

401
00:07:21,700 --> 00:07:22,890
just has to have different names in the

402
00:07:22,890 --> 00:07:22,900
 

403
00:07:22,900 --> 00:07:25,530
database system right so we have a file

404
00:07:25,530 --> 00:07:25,540
 

405
00:07:25,540 --> 00:07:27,150
you have pages and set of pages we can

406
00:07:27,150 --> 00:07:27,160
 

407
00:07:27,160 --> 00:07:28,710
have slots and the slots and where we

408
00:07:28,710 --> 00:07:28,720
 

409
00:07:28,720 --> 00:07:30,420
can store tuples and then instead of our

410
00:07:30,420 --> 00:07:30,430
 

411
00:07:30,430 --> 00:07:32,640
buffer pool what we may want to call

412
00:07:32,640 --> 00:07:32,650
 

413
00:07:32,650 --> 00:07:34,920
slots or to call frames writes the space

414
00:07:34,920 --> 00:07:34,930
 

415
00:07:34,930 --> 00:07:38,040
where we can write a page so what

416
00:07:38,040 --> 00:07:38,050
 

417
00:07:38,050 --> 00:07:40,410
happens is when when the davison when a

418
00:07:40,410 --> 00:07:40,420
 

419
00:07:40,420 --> 00:07:42,780
query wants to read a page we're just

420
00:07:42,780 --> 00:07:42,790
 

421
00:07:42,790 --> 00:07:44,190
going to go down on disk and make an

422
00:07:44,190 --> 00:07:44,200
 

423
00:07:44,200 --> 00:07:46,590
exact copy of this in our in our in our

424
00:07:46,590 --> 00:07:46,600
 

425
00:07:46,600 --> 00:07:48,150
buffer pool right so the query wants to

426
00:07:48,150 --> 00:07:48,160
 

427
00:07:48,160 --> 00:07:50,100
read page one there's an exact copy of

428
00:07:50,100 --> 00:07:50,110
 

429
00:07:50,110 --> 00:07:53,040
that page in that in a frame in our

430
00:07:53,040 --> 00:07:53,050
 

431
00:07:53,050 --> 00:07:55,020
buffer pool right so there's no

432
00:07:55,020 --> 00:07:55,030
 

433
00:07:55,030 --> 00:07:57,020
transformation there's no marshalling or

434
00:07:57,020 --> 00:07:57,030
 

435
00:07:57,030 --> 00:07:59,580
serialization process of copying the

436
00:07:59,580 --> 00:07:59,590
 

437
00:07:59,590 --> 00:08:01,770
data from from the disk into the page

438
00:08:01,770 --> 00:08:01,780
 

439
00:08:01,780 --> 00:08:05,040
it's an exact byte for byte copy if you

440
00:08:05,040 --> 00:08:05,050
 

441
00:08:05,050 --> 00:08:06,330
bring in compression that complicates

442
00:08:06,330 --> 00:08:06,340
 

443
00:08:06,340 --> 00:08:08,130
things slightly but for our purposes

444
00:08:08,130 --> 00:08:08,140
 

445
00:08:08,140 --> 00:08:09,840
here how it's being stored on disk is

446
00:08:09,840 --> 00:08:09,850
 

447
00:08:09,850 --> 00:08:11,340
exactly how it's been gonna be stored in

448
00:08:11,340 --> 00:08:11,350
 

449
00:08:11,350 --> 00:08:13,440
memory and our database has knows how to

450
00:08:13,440 --> 00:08:13,450
 

451
00:08:13,450 --> 00:08:15,150
operate on that structure right now it

452
00:08:15,150 --> 00:08:15,160
 

453
00:08:15,160 --> 00:08:16,290
was about slot of page layouts that

454
00:08:16,290 --> 00:08:16,300
 

455
00:08:16,300 --> 00:08:17,970
knows how to operate on the tuples

456
00:08:17,970 --> 00:08:17,980
 

457
00:08:17,980 --> 00:08:22,440
inside of them no windows I do not want

458
00:08:22,440 --> 00:08:22,450

459
00:08:22,450 --> 00:08:28,830
to upgrade okay so the for this purpose

460
00:08:28,830 --> 00:08:28,840
 

461
00:08:28,840 --> 00:08:30,780
here again I might show my example

462
00:08:30,780 --> 00:08:30,790
 

463
00:08:30,790 --> 00:08:32,310
before I talk about how the execution

464
00:08:32,310 --> 00:08:32,320
 

465
00:08:32,320 --> 00:08:33,600
engine wants to say I want page number

466
00:08:33,600 --> 00:08:33,610

467
00:08:33,610 --> 00:08:35,280
two and then there had to be something

468
00:08:35,280 --> 00:08:35,290
 

469
00:08:35,290 --> 00:08:37,080
that says well here's the here's the

470
00:08:37,080 --> 00:08:37,090
 

471
00:08:37,090 --> 00:08:39,180
frame in my buffer pool where you can go

472
00:08:39,180 --> 00:08:39,190
 

473
00:08:39,190 --> 00:08:41,670
find a copy of page two and this is

474
00:08:41,670 --> 00:08:41,680
 

475
00:08:41,680 --> 00:08:43,980
called the page table insert sense you

476
00:08:43,980 --> 00:08:43,990

477
00:08:43,990 --> 00:08:46,230
just think of this as a hash map that

478
00:08:46,230 --> 00:08:46,240
 

479
00:08:46,240 --> 00:08:50,580
map's page IDs to a frame a where can

480
00:08:50,580 --> 00:08:50,590
 

481
00:08:50,590 --> 00:08:54,510
you store it right and so if I want to

482
00:08:54,510 --> 00:08:54,520
 

483
00:08:54,520 --> 00:08:55,920
do my look up and say you know I want

484
00:08:55,920 --> 00:08:55,930
 

485
00:08:55,930 --> 00:08:58,360
page two I go my page table either

486
00:08:58,360 --> 00:08:58,370
 

487
00:08:58,370 --> 00:09:00,250
tells me it's there and where and what

488
00:09:00,250 --> 00:09:00,260
 

489
00:09:00,260 --> 00:09:02,500
frame it's in in my buffer pool or it's

490
00:09:02,500 --> 00:09:02,510
 

491
00:09:02,510 --> 00:09:04,780
gonna tell me it's not there in which

492
00:09:04,780 --> 00:09:04,790
 

493
00:09:04,790 --> 00:09:06,490
case I have to go to my page directory

494
00:09:06,490 --> 00:09:06,500
 

495
00:09:06,500 --> 00:09:09,610
and find where that location is on disk

496
00:09:09,610 --> 00:09:09,620
 

497
00:09:09,620 --> 00:09:12,310
and then decide you know where I can

498
00:09:12,310 --> 00:09:12,320
 

499
00:09:12,320 --> 00:09:15,100
copy that frame into this so now we want

500
00:09:15,100 --> 00:09:15,110
 

501
00:09:15,110 --> 00:09:17,079
to talk a little bit about you know

502
00:09:17,079 --> 00:09:17,089
 

503
00:09:17,089 --> 00:09:19,240
thread safety in this because you know

504
00:09:19,240 --> 00:09:19,250
 

505
00:09:19,250 --> 00:09:21,070
if you're if it's single threaded then

506
00:09:21,070 --> 00:09:21,080
 

507
00:09:21,080 --> 00:09:22,480
this this hash people doesn't need to be

508
00:09:22,480 --> 00:09:22,490
 

509
00:09:22,490 --> 00:09:24,519
protected right you just you just go in

510
00:09:24,519 --> 00:09:24,529
 

511
00:09:24,529 --> 00:09:26,050
just find the entry one and then just

512
00:09:26,050 --> 00:09:26,060
 

513
00:09:26,060 --> 00:09:28,420
read it but because we're on disk and

514
00:09:28,420 --> 00:09:28,430
 

515
00:09:28,430 --> 00:09:30,790
because modern systems have a lot of CPU

516
00:09:30,790 --> 00:09:30,800
 

517
00:09:30,800 --> 00:09:32,829
cores we're gonna have multiple threads

518
00:09:32,829 --> 00:09:32,839
 

519
00:09:32,839 --> 00:09:33,940
multiple queries running at the same

520
00:09:33,940 --> 00:09:33,950

521
00:09:33,950 --> 00:09:36,900
time all accessing this this page table

522
00:09:36,900 --> 00:09:36,910

523
00:09:36,910 --> 00:09:39,220
so what we don't want to happen is we

524
00:09:39,220 --> 00:09:39,230
 

525
00:09:39,230 --> 00:09:42,070
don't want to maybe access a page all

526
00:09:42,070 --> 00:09:42,080
 

527
00:09:42,080 --> 00:09:43,360
right we go to the page table we find

528
00:09:43,360 --> 00:09:43,370
 

529
00:09:43,370 --> 00:09:45,340
out actually where it is and then we

530
00:09:45,340 --> 00:09:45,350
 

531
00:09:45,350 --> 00:09:47,140
start reading it and then some other

532
00:09:47,140 --> 00:09:47,150
 

533
00:09:47,150 --> 00:09:48,700
thread comes along says why I'm taking

534
00:09:48,700 --> 00:09:48,710

535
00:09:48,710 --> 00:09:50,829
this page away and goes and replaces

536
00:09:50,829 --> 00:09:50,839
 

537
00:09:50,839 --> 00:09:54,310
replaces it so what we're gonna do is

538
00:09:54,310 --> 00:09:54,320

539
00:09:54,320 --> 00:09:57,550
anytime we want to access a page we're

540
00:09:57,550 --> 00:09:57,560
 

541
00:09:57,560 --> 00:10:00,180
gonna have to pin it in the page table

542
00:10:00,180 --> 00:10:00,190
 

543
00:10:00,190 --> 00:10:02,680
right think of this like a simple

544
00:10:02,680 --> 00:10:02,690
 

545
00:10:02,690 --> 00:10:04,710
reference counter it's just you know a

546
00:10:04,710 --> 00:10:04,720
 

547
00:10:04,720 --> 00:10:07,240
counter that says the number of active

548
00:10:07,240 --> 00:10:07,250
 

549
00:10:07,250 --> 00:10:08,560
queries that are accessing this page

550
00:10:08,560 --> 00:10:08,570

551
00:10:08,570 --> 00:10:10,630
right right now okay and we stored this

552
00:10:10,630 --> 00:10:10,640
 

553
00:10:10,640 --> 00:10:12,010
in the page table and not inside the

554
00:10:12,010 --> 00:10:12,020
 

555
00:10:12,020 --> 00:10:14,079
page themselves because we don't

556
00:10:14,079 --> 00:10:14,089

557
00:10:14,089 --> 00:10:16,990
actually need to make this this

558
00:10:16,990 --> 00:10:17,000
 

559
00:10:17,000 --> 00:10:18,970
reference counter adorable right so when

560
00:10:18,970 --> 00:10:18,980
 

561
00:10:18,980 --> 00:10:20,980
the page gets evicted the reference

562
00:10:20,980 --> 00:10:20,990
 

563
00:10:20,990 --> 00:10:22,000
counter doesn't need to be stored as

564
00:10:22,000 --> 00:10:22,010
 

565
00:10:22,010 --> 00:10:22,930
well right so we're gonna store

566
00:10:22,930 --> 00:10:22,940
 

567
00:10:22,940 --> 00:10:26,590
everything in the in memory and in marry

568
00:10:26,590 --> 00:10:26,600
 

569
00:10:26,600 --> 00:10:29,430
page table and so I'm gonna pages pin

570
00:10:29,430 --> 00:10:29,440
 

571
00:10:29,440 --> 00:10:31,870
anybody else mate can still come and go

572
00:10:31,870 --> 00:10:31,880
 

573
00:10:31,880 --> 00:10:33,730
find page three in this case here and

574
00:10:33,730 --> 00:10:33,740
 

575
00:10:33,740 --> 00:10:35,620
still read it it's just the buffer pool

576
00:10:35,620 --> 00:10:35,630
 

577
00:10:35,630 --> 00:10:36,820
manager is not allowed to evict it

578
00:10:36,820 --> 00:10:36,830
 

579
00:10:36,830 --> 00:10:38,110
because it knows somebody is actually

580
00:10:38,110 --> 00:10:38,120
 

581
00:10:38,120 --> 00:10:40,300
accessing right now so now I'll say I

582
00:10:40,300 --> 00:10:40,310

583
00:10:40,310 --> 00:10:41,500
come along and another thread comes

584
00:10:41,500 --> 00:10:41,510
 

585
00:10:41,510 --> 00:10:44,440
along and wants to read a page that's

586
00:10:44,440 --> 00:10:44,450
 

587
00:10:44,450 --> 00:10:46,930
not either one and three and it's not in

588
00:10:46,930 --> 00:10:46,940
 

589
00:10:46,940 --> 00:10:50,610
there so then it's gonna go ahead and

590
00:10:50,610 --> 00:10:50,620
 

591
00:10:50,620 --> 00:10:54,220
actually take up pick up a lock on this

592
00:10:54,220 --> 00:10:54,230
 

593
00:10:54,230 --> 00:10:56,920
location right so I want to read this

594
00:10:56,920 --> 00:10:56,930
 

595
00:10:56,930 --> 00:10:59,440
page I know that it's not there I'll

596
00:10:59,440 --> 00:10:59,450
 

597
00:10:59,450 --> 00:11:01,900
find a slot night and iframe and my page

598
00:11:01,900 --> 00:11:01,910
 

599
00:11:01,910 --> 00:11:03,550
table there I know a I want to store

600
00:11:03,550 --> 00:11:03,560
 

601
00:11:03,560 --> 00:11:05,260
this and so I take a take a latch and

602
00:11:05,260 --> 00:11:05,270
 

603
00:11:05,270 --> 00:11:07,480
then I go ahead and then fetch the data

604
00:11:07,480 --> 00:11:07,490
 

605
00:11:07,490 --> 00:11:08,920
that I need and update the page entry

606
00:11:08,920 --> 00:11:08,930
 

607
00:11:08,930 --> 00:11:12,280
right so this is the weight again I

608
00:11:12,280 --> 00:11:12,290
 

609
00:11:12,290 --> 00:11:13,870
I want to I want to read a page that's

610
00:11:13,870 --> 00:11:13,880
 

611
00:11:13,880 --> 00:11:16,540
not there so then I have to find a place

612
00:11:16,540 --> 00:11:16,550
 

613
00:11:16,550 --> 00:11:18,280
where I can store the reference to that

614
00:11:18,280 --> 00:11:18,290

615
00:11:18,290 --> 00:11:20,860
page in my page table so I take a latch

616
00:11:20,860 --> 00:11:20,870
 

617
00:11:20,870 --> 00:11:23,710
on that on that location then in the

618
00:11:23,710 --> 00:11:23,720
 

619
00:11:23,720 --> 00:11:25,780
background go fetch it and then update

620
00:11:25,780 --> 00:11:25,790
 

621
00:11:25,790 --> 00:11:28,900
the page table right and then at this

622
00:11:28,900 --> 00:11:28,910
 

623
00:11:28,910 --> 00:11:30,790
point I released my latch because I've

624
00:11:30,790 --> 00:11:30,800
 

625
00:11:30,800 --> 00:11:32,650
done whatever I wanted to do if I just

626
00:11:32,650 --> 00:11:32,660
 

627
00:11:32,660 --> 00:11:34,900
had to read it then I don't need to pin

628
00:11:34,900 --> 00:11:34,910
 

629
00:11:34,910 --> 00:11:36,579
it if I'm gonna modify it then I want it

630
00:11:36,579 --> 00:11:36,589
 

631
00:11:36,589 --> 00:11:39,730
then I want to pit it okay actually

632
00:11:39,730 --> 00:11:39,740
 

633
00:11:39,740 --> 00:11:40,870
sorry that's not true I mean you know

634
00:11:40,870 --> 00:11:40,880
 

635
00:11:40,880 --> 00:11:44,249
Claire if I'm gonna read it I pin it

636
00:11:44,249 --> 00:11:44,259
 

637
00:11:44,259 --> 00:11:46,240
even though I'm gonna write to it I pin

638
00:11:46,240 --> 00:11:46,250
 

639
00:11:46,250 --> 00:11:48,160
it but I don't need to maintain any

640
00:11:48,160 --> 00:11:48,170
 

641
00:11:48,170 --> 00:11:49,720
additional information if I'm just

642
00:11:49,720 --> 00:11:49,730
 

643
00:11:49,730 --> 00:11:50,800
reading it as soon as I'm done reading

644
00:11:50,800 --> 00:11:50,810
 

645
00:11:50,810 --> 00:11:53,019
it I can throw the pin away if I'm

646
00:11:53,019 --> 00:11:53,029
 

647
00:11:53,029 --> 00:11:54,699
writing to it I have to maintain a dirty

648
00:11:54,699 --> 00:11:54,709
 

649
00:11:54,709 --> 00:11:56,860
bit dirty flag says I modified this

650
00:11:56,860 --> 00:11:56,870
 

651
00:11:56,870 --> 00:11:58,809
thing and this is prevent the database

652
00:11:58,809 --> 00:11:58,819
 

653
00:11:58,819 --> 00:12:00,340
system from writing it back out to disk

654
00:12:00,340 --> 00:12:00,350
 

655
00:12:00,350 --> 00:12:01,780
or just throwing it away because it

656
00:12:01,780 --> 00:12:01,790
 

657
00:12:01,790 --> 00:12:03,550
knows that some other query modified the

658
00:12:03,550 --> 00:12:03,560
 

659
00:12:03,560 --> 00:12:07,420
page when it was when it went access to

660
00:12:07,420 --> 00:12:07,430
 

661
00:12:07,430 --> 00:12:08,379
it and therefore we have to make sure

662
00:12:08,379 --> 00:12:08,389
 

663
00:12:08,389 --> 00:12:09,850
that those changes eventually make it

664
00:12:09,850 --> 00:12:09,860
 

665
00:12:09,860 --> 00:12:12,309
back to disk so that's the dirty flag

666
00:12:12,309 --> 00:12:12,319
 

667
00:12:12,319 --> 00:12:16,600
does for us so the one thing I need to

668
00:12:16,600 --> 00:12:16,610
 

669
00:12:16,610 --> 00:12:18,550
discuss is the distinction between locks

670
00:12:18,550 --> 00:12:18,560
 

671
00:12:18,560 --> 00:12:22,000
and latches if you're coming from an

672
00:12:22,000 --> 00:12:22,010
 

673
00:12:22,010 --> 00:12:24,460
operating system background right you

674
00:12:24,460 --> 00:12:24,470
 

675
00:12:24,470 --> 00:12:26,110
may have you know you may just refer to

676
00:12:26,110 --> 00:12:26,120
 

677
00:12:26,120 --> 00:12:28,420
everything you know as logs in a

678
00:12:28,420 --> 00:12:28,430
 

679
00:12:28,430 --> 00:12:29,829
database system least in the database

680
00:12:29,829 --> 00:12:29,839
 

681
00:12:29,839 --> 00:12:32,470
world locks are different than latches

682
00:12:32,470 --> 00:12:32,480
 

683
00:12:32,480 --> 00:12:34,750
so if your operating system world a lock

684
00:12:34,750 --> 00:12:34,760
 

685
00:12:34,760 --> 00:12:36,670
is basically what we would call latch

686
00:12:36,670 --> 00:12:36,680
 

687
00:12:36,680 --> 00:12:38,050
here like you think of like a mutex

688
00:12:38,050 --> 00:12:38,060
 

689
00:12:38,060 --> 00:12:40,740
would be up what we're calling a latch

690
00:12:40,740 --> 00:12:40,750
 

691
00:12:40,750 --> 00:12:43,210
so latch is going to be used to protect

692
00:12:43,210 --> 00:12:43,220
 

693
00:12:43,220 --> 00:12:45,100
the internal data structures of the

694
00:12:45,100 --> 00:12:45,110
 

695
00:12:45,110 --> 00:12:46,540
database system so my example I showed

696
00:12:46,540 --> 00:12:46,550
 

697
00:12:46,550 --> 00:12:48,639
before I want to write to my hash table

698
00:12:48,639 --> 00:12:48,649
 

699
00:12:48,649 --> 00:12:50,889
I set a latch to prevent anybody else

700
00:12:50,889 --> 00:12:50,899
 

701
00:12:50,899 --> 00:12:52,269
from modifying that location because I

702
00:12:52,269 --> 00:12:52,279
 

703
00:12:52,279 --> 00:12:54,610
want to write into it and that latch can

704
00:12:54,610 --> 00:12:54,620
 

705
00:12:54,620 --> 00:12:58,300
be implemented as a mutex it can also be

706
00:12:58,300 --> 00:12:58,310
 

707
00:12:58,310 --> 00:12:59,679
implemented as a spin lock which is an

708
00:12:59,679 --> 00:12:59,689
 

709
00:12:59,689 --> 00:13:01,030
unfortunate name because that muddies

710
00:13:01,030 --> 00:13:01,040
 

711
00:13:01,040 --> 00:13:04,210
the story here in the database where a

712
00:13:04,210 --> 00:13:04,220
 

713
00:13:04,220 --> 00:13:06,129
lock will see later on this has to be a

714
00:13:06,129 --> 00:13:06,139
 

715
00:13:06,139 --> 00:13:08,350
higher-level construct or a logical

716
00:13:08,350 --> 00:13:08,360
 

717
00:13:08,360 --> 00:13:10,269
construct that we're going to use to

718
00:13:10,269 --> 00:13:10,279
 

719
00:13:10,279 --> 00:13:13,300
protect database entities so I can take

720
00:13:13,300 --> 00:13:13,310
 

721
00:13:13,310 --> 00:13:16,150
a lock on a tuple write or I can take a

722
00:13:16,150 --> 00:13:16,160
 

723
00:13:16,160 --> 00:13:20,410
lock on on a on a on a database or a

724
00:13:20,410 --> 00:13:20,420
 

725
00:13:20,420 --> 00:13:21,650
table

726
00:13:21,650 --> 00:13:21,660

727
00:13:21,660 --> 00:13:23,930
but I can't take a latch on this because

728
00:13:23,930 --> 00:13:23,940

729
00:13:23,940 --> 00:13:25,400
that's the underlying data structure so

730
00:13:25,400 --> 00:13:25,410
 

731
00:13:25,410 --> 00:13:27,380
when I take a lock I would have to take

732
00:13:27,380 --> 00:13:27,390
 

733
00:13:27,390 --> 00:13:32,180
a latch to update the lock table so this

734
00:13:32,180 --> 00:13:32,190
 

735
00:13:32,190 --> 00:13:34,190
clear locks are for high level

736
00:13:34,190 --> 00:13:34,200
 

737
00:13:34,200 --> 00:13:35,330
constructs and we'll see this later on

738
00:13:35,330 --> 00:13:35,340
 

739
00:13:35,340 --> 00:13:36,740
when we talk about you know concurrency

740
00:13:36,740 --> 00:13:36,750
 

741
00:13:36,750 --> 00:13:38,360
control the latches that we're going to

742
00:13:38,360 --> 00:13:38,370
 

743
00:13:38,370 --> 00:13:39,980
use to protect the internal data

744
00:13:39,980 --> 00:13:39,990
 

745
00:13:39,990 --> 00:13:42,770
structures so in sequel I can take locks

746
00:13:42,770 --> 00:13:42,780
 

747
00:13:42,780 --> 00:13:45,260
I can't take latches latches are

748
00:13:45,260 --> 00:13:45,270
 

749
00:13:45,270 --> 00:13:46,760
actually how the Davis isms actually

750
00:13:46,760 --> 00:13:46,770
 

751
00:13:46,770 --> 00:13:50,960
implemented okay and as I said this if

752
00:13:50,960 --> 00:13:50,970
 

753
00:13:50,970 --> 00:13:52,790
you're coming from an OS background you

754
00:13:52,790 --> 00:13:52,800
 

755
00:13:52,800 --> 00:13:55,760
would call latch a lock but in databases

756
00:13:55,760 --> 00:13:55,770

757
00:13:55,770 --> 00:14:00,230
we use the term latch okay the other

758
00:14:00,230 --> 00:14:00,240
 

759
00:14:00,240 --> 00:14:01,340
thing we don't talk about is the

760
00:14:01,340 --> 00:14:01,350
 

761
00:14:01,350 --> 00:14:02,840
distinction between the page table and

762
00:14:02,840 --> 00:14:02,850
 

763
00:14:02,850 --> 00:14:06,020
the page directory so the page directory

764
00:14:06,020 --> 00:14:06,030

765
00:14:06,030 --> 00:14:12,740
is the on disk information about where

766
00:14:12,740 --> 00:14:12,750
 

767
00:14:12,750 --> 00:14:16,730
to find pages for a given page ID so as

768
00:14:16,730 --> 00:14:16,740
 

769
00:14:16,740 --> 00:14:19,520
I said like the the if our data is

770
00:14:19,520 --> 00:14:19,530
 

771
00:14:19,530 --> 00:14:21,440
broken across multiple files the page

772
00:14:21,440 --> 00:14:21,450
 

773
00:14:21,450 --> 00:14:23,300
directory could say Oh page 1 2 3 is in

774
00:14:23,300 --> 00:14:23,310
 

775
00:14:23,310 --> 00:14:26,450
this file that's all set page 4 5 6 4 5

776
00:14:26,450 --> 00:14:26,460
 

777
00:14:26,460 --> 00:14:29,660
6 is in another file at this all set so

778
00:14:29,660 --> 00:14:29,670
 

779
00:14:29,670 --> 00:14:31,250
any changes we make to the page

780
00:14:31,250 --> 00:14:31,260
 

781
00:14:31,260 --> 00:14:33,140
directory when we bring it into memory

782
00:14:33,140 --> 00:14:33,150
 

783
00:14:33,150 --> 00:14:35,240
has to then get written out to disk cuz

784
00:14:35,240 --> 00:14:35,250
 

785
00:14:35,250 --> 00:14:36,680
when we if we restart the system come

786
00:14:36,680 --> 00:14:36,690
 

787
00:14:36,690 --> 00:14:38,650
back we need to know where our pages are

788
00:14:38,650 --> 00:14:38,660
 

789
00:14:38,660 --> 00:14:41,750
the page table is the in-memory data

790
00:14:41,750 --> 00:14:41,760
 

791
00:14:41,760 --> 00:14:43,190
structure that we're going to use to

792
00:14:43,190 --> 00:14:43,200
 

793
00:14:43,200 --> 00:14:45,830
figure out inside of our buffer pool how

794
00:14:45,830 --> 00:14:45,840
 

795
00:14:45,840 --> 00:14:49,160
to map B page IDs to a frame if it's

796
00:14:49,160 --> 00:14:49,170

797
00:14:49,170 --> 00:14:51,620
been copied in and so for this we don't

798
00:14:51,620 --> 00:14:51,630
 

799
00:14:51,630 --> 00:14:53,080
need to write this out to disk at all

800
00:14:53,080 --> 00:14:53,090
 

801
00:14:53,090 --> 00:14:55,700
because if we crash to come back we

802
00:14:55,700 --> 00:14:55,710
 

803
00:14:55,710 --> 00:14:57,020
don't care we don't care what the buffer

804
00:14:57,020 --> 00:14:57,030
 

805
00:14:57,030 --> 00:14:58,730
pool looks like the last time we crash

806
00:14:58,730 --> 00:14:58,740
 

807
00:14:58,740 --> 00:15:01,490
because we're going to repopulate it as

808
00:15:01,490 --> 00:15:01,500
 

809
00:15:01,500 --> 00:15:03,350
query start executing and reading start

810
00:15:03,350 --> 00:15:03,360

811
00:15:03,360 --> 00:15:06,440
reading data so the page directory again

812
00:15:06,440 --> 00:15:06,450
 

813
00:15:06,450 --> 00:15:08,780
is on disk it's mapping page IDs to

814
00:15:08,780 --> 00:15:08,790
 

815
00:15:08,790 --> 00:15:12,830
locations on files the page table is in

816
00:15:12,830 --> 00:15:12,840
 

817
00:15:12,840 --> 00:15:14,900
memory and it's mapping page IDs to

818
00:15:14,900 --> 00:15:14,910
 

819
00:15:14,910 --> 00:15:17,060
slots in the buffer pool and we don't

820
00:15:17,060 --> 00:15:17,070

821
00:15:17,070 --> 00:15:21,650
need to make that durable okay

822
00:15:21,650 --> 00:15:21,660


823
00:15:21,660 --> 00:15:25,010
all right so the as I said anytime we

824
00:15:25,010 --> 00:15:25,020
 

825
00:15:25,020 --> 00:15:26,330
want to go into the page table and do a

826
00:15:26,330 --> 00:15:26,340
 

827
00:15:26,340 --> 00:15:28,520
lookup we always have to take a latch to

828
00:15:28,520 --> 00:15:28,530

829
00:15:28,530 --> 00:15:29,930
make sure that nobody swaps out the

830
00:15:29,930 --> 00:15:29,940
 

831
00:15:29,940 --> 00:15:31,280
thing we're trying to read as we're

832
00:15:31,280 --> 00:15:31,290
 

833
00:15:31,290 --> 00:15:34,550
trying to read it right but this becomes

834
00:15:34,550 --> 00:15:34,560
 

835
00:15:34,560 --> 00:15:35,690
a contention point because now if you

836
00:15:35,690 --> 00:15:35,700

837
00:15:35,700 --> 00:15:37,070
have a lot of threads aulac trying to

838
00:15:37,070 --> 00:15:37,080
 

839
00:15:37,080 --> 00:15:39,170
access the page table at the same time

840
00:15:39,170 --> 00:15:39,180
 

841
00:15:39,180 --> 00:15:41,900
and there may be taking latches you know

842
00:15:41,900 --> 00:15:41,910
 

843
00:15:41,910 --> 00:15:43,490
do something really coarse-grained I got

844
00:15:43,490 --> 00:15:43,500
 

845
00:15:43,500 --> 00:15:45,380
latch for the entire page table or you

846
00:15:45,380 --> 00:15:45,390
 

847
00:15:45,390 --> 00:15:46,730
take latches for you know individual

848
00:15:46,730 --> 00:15:46,740
 

849
00:15:46,740 --> 00:15:48,980
elements or buckets but regardless if

850
00:15:48,980 --> 00:15:48,990
 

851
00:15:48,990 --> 00:15:50,120
you have a lot of threads and everyone's

852
00:15:50,120 --> 00:15:50,130
 

853
00:15:50,130 --> 00:15:51,140
trying to do the same thing at the same

854
00:15:51,140 --> 00:15:51,150
 

855
00:15:51,150 --> 00:15:52,610
time then this is going to become a

856
00:15:52,610 --> 00:15:52,620
 

857
00:15:52,620 --> 00:15:55,430
major bottleneck in our system so one

858
00:15:55,430 --> 00:15:55,440
 

859
00:15:55,440 --> 00:15:56,840
way to alleviate this problem is

860
00:15:56,840 --> 00:15:56,850
 

861
00:15:56,850 --> 00:15:58,700
actually to have multiple buffer pools

862
00:15:58,700 --> 00:15:58,710
 

863
00:15:58,710 --> 00:16:00,800
so my example I just showed I had a

864
00:16:00,800 --> 00:16:00,810
 

865
00:16:00,810 --> 00:16:02,180
single page table in single buffer pool

866
00:16:02,180 --> 00:16:02,190
 

867
00:16:02,190 --> 00:16:03,710
there's no reason the data system

868
00:16:03,710 --> 00:16:03,720
 

869
00:16:03,720 --> 00:16:06,680
couldn't have multiple ones and that way

870
00:16:06,680 --> 00:16:06,690
 

871
00:16:06,690 --> 00:16:08,090
it's a basically what happen is your if

872
00:16:08,090 --> 00:16:08,100
 

873
00:16:08,100 --> 00:16:10,160
you if your query comes along and says I

874
00:16:10,160 --> 00:16:10,170
 

875
00:16:10,170 --> 00:16:12,410
want page one to three you can just hash

876
00:16:12,410 --> 00:16:12,420
 

877
00:16:12,420 --> 00:16:14,630
that one to three and that will map you

878
00:16:14,630 --> 00:16:14,640

879
00:16:14,640 --> 00:16:17,120
to a buffer pool instance and then

880
00:16:17,120 --> 00:16:17,130

881
00:16:17,130 --> 00:16:18,500
inside of that buffer pool instance then

882
00:16:18,500 --> 00:16:18,510

883
00:16:18,510 --> 00:16:19,880
it has its own page table and its own

884
00:16:19,880 --> 00:16:19,890
 

885
00:16:19,890 --> 00:16:22,340
region of memory right this is sort of

886
00:16:22,340 --> 00:16:22,350
 

887
00:16:22,350 --> 00:16:24,650
way to partition the the workload across

888
00:16:24,650 --> 00:16:24,660
 

889
00:16:24,660 --> 00:16:25,910
multiple multiple instances so that

890
00:16:25,910 --> 00:16:25,920
 

891
00:16:25,920 --> 00:16:26,930
everyone's not trying to acquire the

892
00:16:26,930 --> 00:16:26,940
 

893
00:16:26,940 --> 00:16:30,800
same latches at the same time so much of

894
00:16:30,800 --> 00:16:30,810
 

895
00:16:30,810 --> 00:16:31,820
different ways you can implement this

896
00:16:31,820 --> 00:16:31,830
 

897
00:16:31,830 --> 00:16:33,500
you just sort of say the database

898
00:16:33,500 --> 00:16:33,510

899
00:16:33,510 --> 00:16:35,300
instance itself or the debasement system

900
00:16:35,300 --> 00:16:35,310
 

901
00:16:35,310 --> 00:16:37,100
instance two can have multiple buffer

902
00:16:37,100 --> 00:16:37,110
 

903
00:16:37,110 --> 00:16:38,960
pools and they're allocated you know

904
00:16:38,960 --> 00:16:38,970
 

905
00:16:38,970 --> 00:16:40,760
they're split evenly for the total

906
00:16:40,760 --> 00:16:40,770

907
00:16:40,770 --> 00:16:41,870
amount of memory you want to allocate

908
00:16:41,870 --> 00:16:41,880
 

909
00:16:41,880 --> 00:16:44,090
for your buffer pool you can have a

910
00:16:44,090 --> 00:16:44,100
 

911
00:16:44,100 --> 00:16:46,580
buffer pool per database you have a

912
00:16:46,580 --> 00:16:46,590
 

913
00:16:46,590 --> 00:16:48,950
buffer pool per page type so you could

914
00:16:48,950 --> 00:16:48,960
 

915
00:16:48,960 --> 00:16:50,420
say here's my buffer pool for index

916
00:16:50,420 --> 00:16:50,430
 

917
00:16:50,430 --> 00:16:52,190
pages here's my buffer pool for data

918
00:16:52,190 --> 00:16:52,200

919
00:16:52,200 --> 00:16:55,430
pages or tuple pages so these are bunch

920
00:16:55,430 --> 00:16:55,440
 

921
00:16:55,440 --> 00:16:57,680
of systems that support this my sequel

922
00:16:57,680 --> 00:16:57,690
 

923
00:16:57,690 --> 00:16:59,300
db2 oracle sybase and see what server

924
00:16:59,300 --> 00:16:59,310
 

925
00:16:59,310 --> 00:17:01,850
Informix so with the exception of my

926
00:17:01,850 --> 00:17:01,860
 

927
00:17:01,860 --> 00:17:03,740
sequel although my sequel is really good

928
00:17:03,740 --> 00:17:03,750

929
00:17:03,750 --> 00:17:06,440
I would call these other ones below it

930
00:17:06,440 --> 00:17:06,450
 

931
00:17:06,450 --> 00:17:08,780
enterprise databases right these are

932
00:17:08,780 --> 00:17:08,790
 

933
00:17:08,790 --> 00:17:10,250
like what traditional old companies

934
00:17:10,250 --> 00:17:10,260

935
00:17:10,260 --> 00:17:12,260
would actually use but my Siegel is

936
00:17:12,260 --> 00:17:12,270
 

937
00:17:12,270 --> 00:17:13,460
super common it's used everywhere now

938
00:17:13,460 --> 00:17:13,470
 

939
00:17:13,470 --> 00:17:16,130
though so in the case of my sequel as

940
00:17:16,130 --> 00:17:16,140
 

941
00:17:16,140 --> 00:17:18,320
far as I know at least for version 5 I

942
00:17:18,320 --> 00:17:18,330
 

943
00:17:18,330 --> 00:17:20,300
haven't checked version 8 you can only

944
00:17:20,300 --> 00:17:20,310
 

945
00:17:20,310 --> 00:17:22,400
declare that you have multiple buffer

946
00:17:22,400 --> 00:17:22,410

947
00:17:22,410 --> 00:17:25,430
pool instances in the commercial systems

948
00:17:25,430 --> 00:17:25,440

949
00:17:25,440 --> 00:17:27,380
they have way more knobs that you can

950
00:17:27,380 --> 00:17:27,390
 

951
00:17:27,390 --> 00:17:29,450
you can change and tune and they support

952
00:17:29,450 --> 00:17:29,460
 

953
00:17:29,460 --> 00:17:31,820
all these different variations in the

954
00:17:31,820 --> 00:17:31,830
 

955
00:17:31,830 --> 00:17:40,200
back yes

956
00:17:40,200 --> 00:17:40,210


957
00:17:40,210 --> 00:17:42,220
so your question is if you have multiple

958
00:17:42,220 --> 00:17:42,230
 

959
00:17:42,230 --> 00:17:45,340
instances how do you map what sorry both

960
00:17:45,340 --> 00:17:45,350
 

961
00:17:45,350 --> 00:17:50,770
the second part its question so if I

962
00:17:50,770 --> 00:17:50,780
 

963
00:17:50,780 --> 00:17:53,140
have multiple buffer pool instances how

964
00:17:53,140 --> 00:17:53,150
 

965
00:17:53,150 --> 00:17:55,630
do I map a page ID how do I take a page

966
00:17:55,630 --> 00:17:55,640
 

967
00:17:55,640 --> 00:17:57,130
ID and know what instance I should look

968
00:17:57,130 --> 00:17:57,140
 

969
00:17:57,140 --> 00:18:00,190
in yeah so it's easiest way to use it's

970
00:18:00,190 --> 00:18:00,200
 

971
00:18:00,200 --> 00:18:02,860
just hashing right I have I have five

972
00:18:02,860 --> 00:18:02,870
 

973
00:18:02,870 --> 00:18:05,289
buffer pool instances for a given page

974
00:18:05,289 --> 00:18:05,299
 

975
00:18:05,299 --> 00:18:09,370
ID I hash it mod five and that'll tell

976
00:18:09,370 --> 00:18:09,380
 

977
00:18:09,380 --> 00:18:11,680
me you know which instance I go to right

978
00:18:11,680 --> 00:18:11,690

979
00:18:11,690 --> 00:18:12,820
and that me and that's immutable right

980
00:18:12,820 --> 00:18:12,830
 

981
00:18:12,830 --> 00:18:15,610
so no matter what you know the same page

982
00:18:15,610 --> 00:18:15,620
 

983
00:18:15,620 --> 00:18:17,260
ID is always gonna match to the same

984
00:18:17,260 --> 00:18:17,270
 

985
00:18:17,270 --> 00:18:20,289
page buffer pool instance you can do

986
00:18:20,289 --> 00:18:20,299
 

987
00:18:20,299 --> 00:18:21,490
something real simple too like you can

988
00:18:21,490 --> 00:18:21,500
 

989
00:18:21,500 --> 00:18:23,620
do range partitioning but that's I don't

990
00:18:23,620 --> 00:18:23,630
 

991
00:18:23,630 --> 00:18:25,210
think anybody actually does this right

992
00:18:25,210 --> 00:18:25,220
 

993
00:18:25,220 --> 00:18:27,070
you could say anyway anything would pay

994
00:18:27,070 --> 00:18:27,080
 

995
00:18:27,080 --> 00:18:28,690
to be zero to a thousand goes to this

996
00:18:28,690 --> 00:18:28,700

997
00:18:28,700 --> 00:18:30,700
one one thousand one to two thousand

998
00:18:30,700 --> 00:18:30,710
 

999
00:18:30,710 --> 00:18:32,740
those of this one the hashing wants more

1000
00:18:32,740 --> 00:18:32,750
 

1001
00:18:32,750 --> 00:18:34,210
common because that handles the case

1002
00:18:34,210 --> 00:18:34,220
 

1003
00:18:34,220 --> 00:18:35,289
where that if the database is always

1004
00:18:35,289 --> 00:18:35,299
 

1005
00:18:35,299 --> 00:18:37,690
growing your your range of page IDs

1006
00:18:37,690 --> 00:18:37,700
 

1007
00:18:37,700 --> 00:18:39,610
increases you don't have to reshuffle

1008
00:18:39,610 --> 00:18:39,620
 

1009
00:18:39,620 --> 00:18:47,830
things around okay and again the reason

1010
00:18:47,830 --> 00:18:47,840
 

1011
00:18:47,840 --> 00:18:49,390
why we want to do this because will

1012
00:18:49,390 --> 00:18:49,400
 

1013
00:18:49,400 --> 00:18:51,220
reduce contention on the latches as we

1014
00:18:51,220 --> 00:18:51,230
 

1015
00:18:51,230 --> 00:18:53,320
as we go into our page table and we can

1016
00:18:53,320 --> 00:18:53,330
 

1017
00:18:53,330 --> 00:18:55,539
actually improve our locality so if we

1018
00:18:55,539 --> 00:18:55,549
 

1019
00:18:55,549 --> 00:18:57,310
know that we see certain queries are

1020
00:18:57,310 --> 00:18:57,320
 

1021
00:18:57,320 --> 00:19:00,210
doing have certain access patterns

1022
00:19:00,210 --> 00:19:00,220

1023
00:19:00,220 --> 00:19:02,380
having a buffle instance for maybe

1024
00:19:02,380 --> 00:19:02,390
 

1025
00:19:02,390 --> 00:19:04,450
indexes versus the tuples we can sort of

1026
00:19:04,450 --> 00:19:04,460
 

1027
00:19:04,460 --> 00:19:07,299
isolate the two buffer pool instances to

1028
00:19:07,299 --> 00:19:07,309
 

1029
00:19:07,309 --> 00:19:09,549
two different replacement policies or

1030
00:19:09,549 --> 00:19:09,559
 

1031
00:19:09,559 --> 00:19:11,470
allocation policies for each of those

1032
00:19:11,470 --> 00:19:11,480
 

1033
00:19:11,480 --> 00:19:13,690
different access patterns all right and

1034
00:19:13,690 --> 00:19:13,700
 

1035
00:19:13,700 --> 00:19:15,430
what we'll see examples as examples of

1036
00:19:15,430 --> 00:19:15,440
 

1037
00:19:15,440 --> 00:19:21,370
this in a second so so the again the the

1038
00:19:21,370 --> 00:19:21,380
 

1039
00:19:21,380 --> 00:19:22,510
context are talking about here again

1040
00:19:22,510 --> 00:19:22,520
 

1041
00:19:22,520 --> 00:19:23,710
these are the things that the operating

1042
00:19:23,710 --> 00:19:23,720
 

1043
00:19:23,720 --> 00:19:24,940
system can't do for you because it

1044
00:19:24,940 --> 00:19:24,950

1045
00:19:24,950 --> 00:19:26,200
doesn't know what you're actually trying

1046
00:19:26,200 --> 00:19:26,210
 

1047
00:19:26,210 --> 00:19:29,440
to do right so again because we know

1048
00:19:29,440 --> 00:19:29,450
 

1049
00:19:29,450 --> 00:19:31,240
what our pages actually mean in some

1050
00:19:31,240 --> 00:19:31,250
 

1051
00:19:31,250 --> 00:19:32,950
ways might be know whether this index

1052
00:19:32,950 --> 00:19:32,960
 

1053
00:19:32,960 --> 00:19:34,810
versus data we can allocate different

1054
00:19:34,810 --> 00:19:34,820
 

1055
00:19:34,820 --> 00:19:37,810
buffer pool instances like this another

1056
00:19:37,810 --> 00:19:37,820
 

1057
00:19:37,820 --> 00:19:40,539
thing we can do that that's right no

1058
00:19:40,539 --> 00:19:40,549
 

1059
00:19:40,549 --> 00:19:42,399
clutter that the OS can't always do

1060
00:19:42,399 --> 00:19:42,409
 

1061
00:19:42,409 --> 00:19:46,020
correctly is to do prefetching so

1062
00:19:46,020 --> 00:19:46,030
 

1063
00:19:46,030 --> 00:19:47,480
prefetching is basically

1064
00:19:47,480 --> 00:19:47,490
 

1065
00:19:47,490 --> 00:19:49,810
says that I know I'm gonna go ahead and

1066
00:19:49,810 --> 00:19:49,820
 

1067
00:19:49,820 --> 00:19:52,940
read read subsequent pages given what my

1068
00:19:52,940 --> 00:19:52,950
 

1069
00:19:52,950 --> 00:19:54,830
queries trying to do so rather than

1070
00:19:54,830 --> 00:19:54,840

1071
00:19:54,840 --> 00:19:56,299
waiting for me to then try to access

1072
00:19:56,299 --> 00:19:56,309
 

1073
00:19:56,309 --> 00:19:58,460
that page in the page table see that

1074
00:19:58,460 --> 00:19:58,470
 

1075
00:19:58,470 --> 00:19:59,990
there's no entry you know get it get a

1076
00:19:59,990 --> 00:20:00,000
 

1077
00:20:00,000 --> 00:20:01,610
page fault while I go have to go fetch

1078
00:20:01,610 --> 00:20:01,620
 

1079
00:20:01,620 --> 00:20:03,980
the page that I need I can go ahead and

1080
00:20:03,980 --> 00:20:03,990
 

1081
00:20:03,990 --> 00:20:05,540
start prefetching pages ahead of time

1082
00:20:05,540 --> 00:20:05,550

1083
00:20:05,550 --> 00:20:07,580
because I know my queries gonna need it

1084
00:20:07,580 --> 00:20:07,590
 

1085
00:20:07,590 --> 00:20:10,669
in the future so let's say on a simple

1086
00:20:10,669 --> 00:20:10,679
 

1087
00:20:10,679 --> 00:20:12,230
query that's key one that's doing

1088
00:20:12,230 --> 00:20:12,240
 

1089
00:20:12,240 --> 00:20:13,940
sequential scan across the entire table

1090
00:20:13,940 --> 00:20:13,950
 

1091
00:20:13,950 --> 00:20:17,900
right now my page is 0 to 5 and my

1092
00:20:17,900 --> 00:20:17,910
 

1093
00:20:17,910 --> 00:20:19,700
buffer pool is empty so in the first

1094
00:20:19,700 --> 00:20:19,710
 

1095
00:20:19,710 --> 00:20:22,460
case I repaid 0 it's not there so go

1096
00:20:22,460 --> 00:20:22,470
 

1097
00:20:22,470 --> 00:20:25,580
ahead and fetch it in and I do this as I

1098
00:20:25,580 --> 00:20:25,590
 

1099
00:20:25,590 --> 00:20:27,770
scan along but if I recognize that my

1100
00:20:27,770 --> 00:20:27,780
 

1101
00:20:27,780 --> 00:20:29,120
query is essentially gonna read every

1102
00:20:29,120 --> 00:20:29,130
 

1103
00:20:29,130 --> 00:20:32,030
page then maybe at some point I

1104
00:20:32,030 --> 00:20:32,040
 

1105
00:20:32,040 --> 00:20:33,740
recognize that oh I know I'm gonna read

1106
00:20:33,740 --> 00:20:33,750
 

1107
00:20:33,750 --> 00:20:37,310
page 2 &amp; 3 so while I'm accessing page 1

1108
00:20:37,310 --> 00:20:37,320
 

1109
00:20:37,320 --> 00:20:39,230
or I'm retrieving page 1 and putting my

1110
00:20:39,230 --> 00:20:39,240
 

1111
00:20:39,240 --> 00:20:41,240
buffer pool let me go ahead and prefetch

1112
00:20:41,240 --> 00:20:41,250

1113
00:20:41,250 --> 00:20:44,720
2 &amp; 3 put that into my buffer pool and

1114
00:20:44,720 --> 00:20:44,730
 

1115
00:20:44,730 --> 00:20:47,690
then that way when now my query keeps on

1116
00:20:47,690 --> 00:20:47,700

1117
00:20:47,700 --> 00:20:49,820
going I don't have to stall because the

1118
00:20:49,820 --> 00:20:49,830
 

1119
00:20:49,830 --> 00:20:52,360
the next pages I need are already there

1120
00:20:52,360 --> 00:20:52,370
 

1121
00:20:52,370 --> 00:20:55,760
right so the operating system can do

1122
00:20:55,760 --> 00:20:55,770
 

1123
00:20:55,770 --> 00:20:57,260
this in some cases right it can

1124
00:20:57,260 --> 00:20:57,270

1125
00:20:57,270 --> 00:20:58,940
recognize that when you're doing so much

1126
00:20:58,940 --> 00:20:58,950
 

1127
00:20:58,950 --> 00:21:01,910
to scan across a large file it'll

1128
00:21:01,910 --> 00:21:01,920
 

1129
00:21:01,920 --> 00:21:03,049
essentially do the same thing it'll

1130
00:21:03,049 --> 00:21:03,059
 

1131
00:21:03,059 --> 00:21:04,790
start trying to prefetch prefetch your

1132
00:21:04,790 --> 00:21:04,800
 

1133
00:21:04,800 --> 00:21:08,419
your pages and this example here the

1134
00:21:08,419 --> 00:21:08,429
 

1135
00:21:08,429 --> 00:21:10,130
obvious it could probably do this or can

1136
00:21:10,130 --> 00:21:10,140
 

1137
00:21:10,140 --> 00:21:11,960
do this because we're accessing a file

1138
00:21:11,960 --> 00:21:11,970
 

1139
00:21:11,970 --> 00:21:12,730
sequentially

1140
00:21:12,730 --> 00:21:12,740

1141
00:21:12,740 --> 00:21:16,070
but not every access pattern of the

1142
00:21:16,070 --> 00:21:16,080

1143
00:21:16,080 --> 00:21:17,480
database system is going to be

1144
00:21:17,480 --> 00:21:17,490
 

1145
00:21:17,490 --> 00:21:21,410
sequential like this right so a very

1146
00:21:21,410 --> 00:21:21,420
 

1147
00:21:21,420 --> 00:21:23,600
common case is to do index scans or

1148
00:21:23,600 --> 00:21:23,610
 

1149
00:21:23,610 --> 00:21:26,870
index range scans so again so say we

1150
00:21:26,870 --> 00:21:26,880

1151
00:21:26,880 --> 00:21:29,299
have an index here and we're gonna run

1152
00:21:29,299 --> 00:21:29,309
 

1153
00:21:29,309 --> 00:21:30,980
it we want to run a range scan where

1154
00:21:30,980 --> 00:21:30,990
 

1155
00:21:30,990 --> 00:21:33,110
we're gonna traverse the tree doesn't

1156
00:21:33,110 --> 00:21:33,120
 

1157
00:21:33,120 --> 00:21:34,370
matter whether it's a B+ tree or

1158
00:21:34,370 --> 00:21:34,380

1159
00:21:34,380 --> 00:21:36,290
whatever data structure just it's a tree

1160
00:21:36,290 --> 00:21:36,300
 

1161
00:21:36,300 --> 00:21:38,540
and we're going to traverse the tree get

1162
00:21:38,540 --> 00:21:38,550
 

1163
00:21:38,550 --> 00:21:40,700
to some leaf page and then scan along

1164
00:21:40,700 --> 00:21:40,710
 

1165
00:21:40,710 --> 00:21:42,950
the leaf leaf pages to find all the data

1166
00:21:42,950 --> 00:21:42,960
 

1167
00:21:42,960 --> 00:21:45,290
that we need so the very first thing we

1168
00:21:45,290 --> 00:21:45,300
 

1169
00:21:45,300 --> 00:21:46,910
have to do a query starts we have to

1170
00:21:46,910 --> 00:21:46,920
 

1171
00:21:46,920 --> 00:21:49,040
read the the index page right because we

1172
00:21:49,040 --> 00:21:49,050
 

1173
00:21:49,050 --> 00:21:50,690
have to know you know with the to know

1174
00:21:50,690 --> 00:21:50,700
 

1175
00:21:50,700 --> 00:21:52,100
where our entry point into the index is

1176
00:21:52,100 --> 00:21:52,110
 

1177
00:21:52,110 --> 00:21:54,500
so therefore this when we go ahead and

1178
00:21:54,500 --> 00:21:54,510
 

1179
00:21:54,510 --> 00:21:57,230
pet fetch page page index page 0 bring

1180
00:21:57,230 --> 00:21:57,240
 

1181
00:21:57,240 --> 00:21:59,540
that into our buffer pool then we jump

1182
00:21:59,540 --> 00:21:59,550

1183
00:21:59,550 --> 00:22:01,430
down maybe to this side of the tree

1184
00:22:01,430 --> 00:22:01,440
 

1185
00:22:01,440 --> 00:22:04,550
and we went index page one together and

1186
00:22:04,550 --> 00:22:04,560
 

1187
00:22:04,560 --> 00:22:06,140
get that but now we're gonna go down

1188
00:22:06,140 --> 00:22:06,150
 

1189
00:22:06,150 --> 00:22:07,340
this too

1190
00:22:07,340 --> 00:22:07,350
 

1191
00:22:07,350 --> 00:22:10,460
to the other side of the tree and start

1192
00:22:10,460 --> 00:22:10,470
 

1193
00:22:10,470 --> 00:22:12,170
scanning across the the lead pages like

1194
00:22:12,170 --> 00:22:12,180
 

1195
00:22:12,180 --> 00:22:14,360
that so now we're gonna read page three

1196
00:22:14,360 --> 00:22:14,370
 

1197
00:22:14,370 --> 00:22:15,440
and page five

1198
00:22:15,440 --> 00:22:15,450
 

1199
00:22:15,450 --> 00:22:17,420
but the OS may think that oh well I

1200
00:22:17,420 --> 00:22:17,430

1201
00:22:17,430 --> 00:22:18,620
think you're actually going to read page

1202
00:22:18,620 --> 00:22:18,630
 

1203
00:22:18,630 --> 00:22:20,990
two and let me go ahead and prefetch

1204
00:22:20,990 --> 00:22:21,000
 

1205
00:22:21,000 --> 00:22:23,450
that bat for you which is not actually

1206
00:22:23,450 --> 00:22:23,460

1207
00:22:23,460 --> 00:22:27,500
one right so we want page three and five

1208
00:22:27,500 --> 00:22:27,510
 

1209
00:22:27,510 --> 00:22:29,210
so we the database system could

1210
00:22:29,210 --> 00:22:29,220
 

1211
00:22:29,220 --> 00:22:31,460
recognize oh well I didn't go to page

1212
00:22:31,460 --> 00:22:31,470

1213
00:22:31,470 --> 00:22:33,260
two I want to go to page three and then

1214
00:22:33,260 --> 00:22:33,270
 

1215
00:22:33,270 --> 00:22:35,330
the next leaf page that I'm gonna scan

1216
00:22:35,330 --> 00:22:35,340
 

1217
00:22:35,340 --> 00:22:38,060
across is page five so not page four so

1218
00:22:38,060 --> 00:22:38,070

1219
00:22:38,070 --> 00:22:39,440
let me go ahead and prefetch those two

1220
00:22:39,440 --> 00:22:39,450
 

1221
00:22:39,450 --> 00:22:41,780
guys all right

1222
00:22:41,780 --> 00:22:41,790
 

1223
00:22:41,790 --> 00:22:43,970
the OS can't do this because it doesn't

1224
00:22:43,970 --> 00:22:43,980
 

1225
00:22:43,980 --> 00:22:46,220
know what's inside these pages right we

1226
00:22:46,220 --> 00:22:46,230
 

1227
00:22:46,230 --> 00:22:47,780
know in their database ISM that you know

1228
00:22:47,780 --> 00:22:47,790
 

1229
00:22:47,790 --> 00:22:49,220
because we where the one X you built

1230
00:22:49,220 --> 00:22:49,230
 

1231
00:22:49,230 --> 00:22:51,170
this data structure we built the tree we

1232
00:22:51,170 --> 00:22:51,180
 

1233
00:22:51,180 --> 00:22:53,060
know what pages are there we know what

1234
00:22:53,060 --> 00:22:53,070
 

1235
00:22:53,070 --> 00:22:54,710
the queries trying to do right cuz we

1236
00:22:54,710 --> 00:22:54,720
 

1237
00:22:54,720 --> 00:22:56,360
have the sequel we have the query plan

1238
00:22:56,360 --> 00:22:56,370
 

1239
00:22:56,370 --> 00:22:59,270
so we can then infer from that what

1240
00:22:59,270 --> 00:22:59,280
 

1241
00:22:59,280 --> 00:23:01,790
pages we think you're gonna need now

1242
00:23:01,790 --> 00:23:01,800
 

1243
00:23:01,800 --> 00:23:02,990
this does mean we have to do some extra

1244
00:23:02,990 --> 00:23:03,000
 

1245
00:23:03,000 --> 00:23:04,820
work like you know maintain symmetric

1246
00:23:04,820 --> 00:23:04,830
 

1247
00:23:04,830 --> 00:23:07,100
metadata possibly in the index to know

1248
00:23:07,100 --> 00:23:07,110
 

1249
00:23:07,110 --> 00:23:09,650
what our neighbor page is right so then

1250
00:23:09,650 --> 00:23:09,660
 

1251
00:23:09,660 --> 00:23:11,660
go ahead and prefetch if they have rules

1252
00:23:11,660 --> 00:23:11,670
 

1253
00:23:11,670 --> 00:23:13,040
to recognize that I think we're doing a

1254
00:23:13,040 --> 00:23:13,050
 

1255
00:23:13,050 --> 00:23:14,540
special scan of along the lead pages or

1256
00:23:14,540 --> 00:23:14,550
 

1257
00:23:14,550 --> 00:23:16,280
index again and luckily pages have

1258
00:23:16,280 --> 00:23:16,290
 

1259
00:23:16,290 --> 00:23:17,780
recognized with it you know that's an

1260
00:23:17,780 --> 00:23:17,790
 

1261
00:23:17,790 --> 00:23:20,180
opportunity for us to prefetch it's more

1262
00:23:20,180 --> 00:23:20,190
 

1263
00:23:20,190 --> 00:23:22,310
work but the benefit can be quite

1264
00:23:22,310 --> 00:23:22,320
 

1265
00:23:22,320 --> 00:23:24,800
substantial and this is actually a very

1266
00:23:24,800 --> 00:23:24,810
 

1267
00:23:24,810 --> 00:23:26,330
common access pattern do range scans

1268
00:23:26,330 --> 00:23:26,340
 

1269
00:23:26,340 --> 00:23:33,410
along an index like this the next kind

1270
00:23:33,410 --> 00:23:33,420
 

1271
00:23:33,420 --> 00:23:35,120
of optimization we can do is called scan

1272
00:23:35,120 --> 00:23:35,130
 

1273
00:23:35,130 --> 00:23:38,000
sharing so with scan sharing the basic

1274
00:23:38,000 --> 00:23:38,010
 

1275
00:23:38,010 --> 00:23:41,510
idea is that if we have queries that are

1276
00:23:41,510 --> 00:23:41,520
 

1277
00:23:41,520 --> 00:23:43,160
running at the same time and they're

1278
00:23:43,160 --> 00:23:43,170
 

1279
00:23:43,170 --> 00:23:45,800
accessing the same data rather than

1280
00:23:45,800 --> 00:23:45,810
 

1281
00:23:45,810 --> 00:23:48,950
treating every every query as in its own

1282
00:23:48,950 --> 00:23:48,960

1283
00:23:48,960 --> 00:23:51,500
island by itself and just making

1284
00:23:51,500 --> 00:23:51,510
 

1285
00:23:51,510 --> 00:23:53,450
decisions about what pages are fetching

1286
00:23:53,450 --> 00:23:53,460
 

1287
00:23:53,460 --> 00:23:54,830
in and out you know for each individual

1288
00:23:54,830 --> 00:23:54,840
 

1289
00:23:54,840 --> 00:23:57,680
query the data system can recognize that

1290
00:23:57,680 --> 00:23:57,690
 

1291
00:23:57,690 --> 00:23:58,610
the queries are trying to do the

1292
00:23:58,610 --> 00:23:58,620
 

1293
00:23:58,620 --> 00:24:00,230
basically the same thing or they're

1294
00:24:00,230 --> 00:24:00,240
 

1295
00:24:00,240 --> 00:24:02,330
trying to read the same data it may not

1296
00:24:02,330 --> 00:24:02,340
 

1297
00:24:02,340 --> 00:24:03,710
be the exact same query but there have

1298
00:24:03,710 --> 00:24:03,720
 

1299
00:24:03,720 --> 00:24:06,170
to read the same data and then we can

1300
00:24:06,170 --> 00:24:06,180
 

1301
00:24:06,180 --> 00:24:08,900
just have the the queries sort of

1302
00:24:08,900 --> 00:24:08,910
 

1303
00:24:08,910 --> 00:24:11,270
piggyback off each other and reuse the

1304
00:24:11,270 --> 00:24:11,280
 

1305
00:24:11,280 --> 00:24:12,620
data that we've already pulled into our

1306
00:24:12,620 --> 00:24:12,630
 

1307
00:24:12,630 --> 00:24:15,289
buffer pool to avoid having to us

1308
00:24:15,289 --> 00:24:15,299
 

1309
00:24:15,299 --> 00:24:17,299
things out unnecessarily and incurred

1310
00:24:17,299 --> 00:24:17,309
 

1311
00:24:17,309 --> 00:24:20,840
more disk rights right so the way it is

1312
00:24:20,840 --> 00:24:20,850
 

1313
00:24:20,850 --> 00:24:22,009
sort of that again think about this is

1314
00:24:22,009 --> 00:24:22,019
 

1315
00:24:22,019 --> 00:24:23,450
that if I'm doing so much on scans I

1316
00:24:23,450 --> 00:24:23,460
 

1317
00:24:23,460 --> 00:24:25,369
have my one query starts the second

1318
00:24:25,369 --> 00:24:25,379

1319
00:24:25,379 --> 00:24:26,899
quarter comes behind it and start a

1320
00:24:26,899 --> 00:24:26,909
 

1321
00:24:26,909 --> 00:24:28,879
little bit later I maybe want to pick up

1322
00:24:28,879 --> 00:24:28,889
 

1323
00:24:28,889 --> 00:24:31,220
whether the the first guy is already

1324
00:24:31,220 --> 00:24:31,230
 

1325
00:24:31,230 --> 00:24:33,409
running and reused the data that it's

1326
00:24:33,409 --> 00:24:33,419
 

1327
00:24:33,419 --> 00:24:35,149
already pulled in rather than starting

1328
00:24:35,149 --> 00:24:35,159
 

1329
00:24:35,159 --> 00:24:36,909
everything from scratch

1330
00:24:36,909 --> 00:24:36,919
 

1331
00:24:36,919 --> 00:24:39,320
alright the way the way we're gonna

1332
00:24:39,320 --> 00:24:39,330
 

1333
00:24:39,330 --> 00:24:40,609
implement these scans we'll see this

1334
00:24:40,609 --> 00:24:40,619
 

1335
00:24:40,619 --> 00:24:42,200
when we talk about query processing it's

1336
00:24:42,200 --> 00:24:42,210
 

1337
00:24:42,210 --> 00:24:44,479
essentially a cursor for each query that

1338
00:24:44,479 --> 00:24:44,489

1339
00:24:44,489 --> 00:24:46,729
keeps track of what pages it's read as

1340
00:24:46,729 --> 00:24:46,739
 

1341
00:24:46,739 --> 00:24:50,330
it goes along the the table scan and it

1342
00:24:50,330 --> 00:24:50,340
 

1343
00:24:50,340 --> 00:24:51,769
knows what you know how far it's got to

1344
00:24:51,769 --> 00:24:51,779
 

1345
00:24:51,779 --> 00:24:54,159
go and what pages that it's missing

1346
00:24:54,159 --> 00:24:54,169

1347
00:24:54,169 --> 00:25:01,009
right so the this is supported again as

1348
00:25:01,009 --> 00:25:01,019
 

1349
00:25:01,019 --> 00:25:02,479
far as I know only in the major

1350
00:25:02,479 --> 00:25:02,489
 

1351
00:25:02,489 --> 00:25:04,310
commercial systems right so this be a

1352
00:25:04,310 --> 00:25:04,320
 

1353
00:25:04,320 --> 00:25:05,359
reoccurring theme throughout the

1354
00:25:05,359 --> 00:25:05,369
 

1355
00:25:05,369 --> 00:25:06,979
semester we'll see that the very

1356
00:25:06,979 --> 00:25:06,989
 

1357
00:25:06,989 --> 00:25:09,259
expensive enterprise databases do way

1358
00:25:09,259 --> 00:25:09,269
 

1359
00:25:09,269 --> 00:25:11,479
more sophisticated things than the open

1360
00:25:11,479 --> 00:25:11,489
 

1361
00:25:11,489 --> 00:25:13,220
source ones just because they've had a

1362
00:25:13,220 --> 00:25:13,230
 

1363
00:25:13,230 --> 00:25:14,450
lot of money and a lot of people

1364
00:25:14,450 --> 00:25:14,460
 

1365
00:25:14,460 --> 00:25:15,710
spending time to fix these things you

1366
00:25:15,710 --> 00:25:15,720
 

1367
00:25:15,720 --> 00:25:17,210
know make these things work as well good

1368
00:25:17,210 --> 00:25:17,220
 

1369
00:25:17,220 --> 00:25:19,609
as possible so as far as they know for

1370
00:25:19,609 --> 00:25:19,619
 

1371
00:25:19,619 --> 00:25:22,159
those scan sharing which we'll see in

1372
00:25:22,159 --> 00:25:22,169
 

1373
00:25:22,169 --> 00:25:24,470
the next slide this is fully supported

1374
00:25:24,470 --> 00:25:24,480
 

1375
00:25:24,480 --> 00:25:27,710
in IBM db2 and sequel server oracle only

1376
00:25:27,710 --> 00:25:27,720
 

1377
00:25:27,720 --> 00:25:29,330
supports what are called cursor sharing

1378
00:25:29,330 --> 00:25:29,340
 

1379
00:25:29,340 --> 00:25:32,239
if you actually run the exact same query

1380
00:25:32,239 --> 00:25:32,249
 

1381
00:25:32,249 --> 00:25:34,220
at the exact same time right if there's

1382
00:25:34,220 --> 00:25:34,230
 

1383
00:25:34,230 --> 00:25:36,529
any sort of minor deviation in the where

1384
00:25:36,529 --> 00:25:36,539
 

1385
00:25:36,539 --> 00:25:38,930
clause or even like that what the Select

1386
00:25:38,930 --> 00:25:38,940
 

1387
00:25:38,940 --> 00:25:41,060
output is it doesn't think that this

1388
00:25:41,060 --> 00:25:41,070
 

1389
00:25:41,070 --> 00:25:42,229
they can read the same data and it

1390
00:25:42,229 --> 00:25:42,239
 

1391
00:25:42,239 --> 00:25:45,560
treats them as separate 7-piece so to do

1392
00:25:45,560 --> 00:25:45,570
 

1393
00:25:45,570 --> 00:25:48,499
scan sharing basically for the the first

1394
00:25:48,499 --> 00:25:48,509
 

1395
00:25:48,509 --> 00:25:49,820
query starts it has its cursor at

1396
00:25:49,820 --> 00:25:49,830
 

1397
00:25:49,830 --> 00:25:51,830
scanning through and then the second

1398
00:25:51,830 --> 00:25:51,840

1399
00:25:51,840 --> 00:25:53,659
queries cursor will will recognize I can

1400
00:25:53,659 --> 00:25:53,669

1401
00:25:53,669 --> 00:25:55,399
I can run along with them with the first

1402
00:25:55,399 --> 00:25:55,409
 

1403
00:25:55,409 --> 00:25:57,499
guy and just keep track of what data it

1404
00:25:57,499 --> 00:25:57,509
 

1405
00:25:57,509 --> 00:25:59,060
has missed from not starting at the

1406
00:25:59,060 --> 00:25:59,070
 

1407
00:25:59,070 --> 00:26:00,619
beginning so that it can loop back

1408
00:26:00,619 --> 00:26:00,629
 

1409
00:26:00,629 --> 00:26:02,060
around and pick everything that it

1410
00:26:02,060 --> 00:26:02,070
 

1411
00:26:02,070 --> 00:26:04,609
missed so a simple example will be like

1412
00:26:04,609 --> 00:26:04,619
 

1413
00:26:04,619 --> 00:26:07,159
this today I have query one and it's

1414
00:26:07,159 --> 00:26:07,169
 

1415
00:26:07,169 --> 00:26:08,389
doing special scan it's going to read

1416
00:26:08,389 --> 00:26:08,399
 

1417
00:26:08,399 --> 00:26:10,039
every page to compute the the sum on the

1418
00:26:10,039 --> 00:26:10,049
 

1419
00:26:10,049 --> 00:26:12,560
value so when it starts it's at the

1420
00:26:12,560 --> 00:26:12,570
 

1421
00:26:12,570 --> 00:26:13,879
beginning there's nothing nothing in our

1422
00:26:13,879 --> 00:26:13,889
 

1423
00:26:13,889 --> 00:26:15,619
buffer pool so we go ahead and fetch

1424
00:26:15,619 --> 00:26:15,629
 

1425
00:26:15,629 --> 00:26:17,539
page zero and we just keep going down

1426
00:26:17,539 --> 00:26:17,549
 

1427
00:26:17,549 --> 00:26:21,799
and to get the second page here now we

1428
00:26:21,799 --> 00:26:21,809
 

1429
00:26:21,809 --> 00:26:24,470
want to read page three and then we have

1430
00:26:24,470 --> 00:26:24,480
 

1431
00:26:24,480 --> 00:26:26,330
to we only have three frames and our

1432
00:26:26,330 --> 00:26:26,340
 

1433
00:26:26,340 --> 00:26:28,279
buffer bolus we have to victim a so

1434
00:26:28,279 --> 00:26:28,289
 

1435
00:26:28,289 --> 00:26:29,180
assuming

1436
00:26:29,180 --> 00:26:29,190

1437
00:26:29,190 --> 00:26:30,710
a simple replacement policy we just

1438
00:26:30,710 --> 00:26:30,720
 

1439
00:26:30,720 --> 00:26:32,410
picked the page that was last accessed

1440
00:26:32,410 --> 00:26:32,420
 

1441
00:26:32,420 --> 00:26:35,120
that would be page zero so you want to

1442
00:26:35,120 --> 00:26:35,130
 

1443
00:26:35,130 --> 00:26:36,740
go ahead and throw that away so that we

1444
00:26:36,740 --> 00:26:36,750
 

1445
00:26:36,750 --> 00:26:38,210
can put in page three the next page that

1446
00:26:38,210 --> 00:26:38,220
 

1447
00:26:38,220 --> 00:26:41,210
we need but now during this time query

1448
00:26:41,210 --> 00:26:41,220
 

1449
00:26:41,220 --> 00:26:43,460
two starts and it basically wants to

1450
00:26:43,460 --> 00:26:43,470
 

1451
00:26:43,470 --> 00:26:45,590
execute this new it's not the exact same

1452
00:26:45,590 --> 00:26:45,600
 

1453
00:26:45,600 --> 00:26:46,940
query it's computing an average instead

1454
00:26:46,940 --> 00:26:46,950
 

1455
00:26:46,950 --> 00:26:48,680
of a sum but it's still going to read

1456
00:26:48,680 --> 00:26:48,690
 

1457
00:26:48,690 --> 00:26:52,160
all the same pages so if we started from

1458
00:26:52,160 --> 00:26:52,170
 

1459
00:26:52,170 --> 00:26:55,850
the beginning what's the problem the

1460
00:26:55,850 --> 00:26:55,860
 

1461
00:26:55,860 --> 00:26:57,800
first page that this this query needs is

1462
00:26:57,800 --> 00:26:57,810
 

1463
00:26:57,810 --> 00:26:59,900
page zero but that was actually the last

1464
00:26:59,900 --> 00:26:59,910
 

1465
00:26:59,910 --> 00:27:02,780
page we just evicted so now what would

1466
00:27:02,780 --> 00:27:02,790
 

1467
00:27:02,790 --> 00:27:04,610
happen is we'd have to go back in our

1468
00:27:04,610 --> 00:27:04,620
 

1469
00:27:04,620 --> 00:27:06,050
buffer pool and figure out all right

1470
00:27:06,050 --> 00:27:06,060
 

1471
00:27:06,060 --> 00:27:08,210
well you know I need to make space let

1472
00:27:08,210 --> 00:27:08,220
 

1473
00:27:08,220 --> 00:27:11,240
me go Victor page right and it sucks

1474
00:27:11,240 --> 00:27:11,250
 

1475
00:27:11,250 --> 00:27:12,530
because we just we just fetch that you

1476
00:27:12,530 --> 00:27:12,540
 

1477
00:27:12,540 --> 00:27:14,000
know we just we just had it in memory

1478
00:27:14,000 --> 00:27:14,010
 

1479
00:27:14,010 --> 00:27:16,460
and we lost it so we now we have to pay

1480
00:27:16,460 --> 00:27:16,470

1481
00:27:16,470 --> 00:27:19,310
another another disk read so instead

1482
00:27:19,310 --> 00:27:19,320
 

1483
00:27:19,320 --> 00:27:21,860
with scan sharing you can recognize that

1484
00:27:21,860 --> 00:27:21,870
 

1485
00:27:21,870 --> 00:27:23,390
these these two queries that need to

1486
00:27:23,390 --> 00:27:23,400
 

1487
00:27:23,400 --> 00:27:25,700
read the same data in the same pages so

1488
00:27:25,700 --> 00:27:25,710
 

1489
00:27:25,710 --> 00:27:28,430
cue to just hops along with q1 it reads

1490
00:27:28,430 --> 00:27:28,440
 

1491
00:27:28,440 --> 00:27:30,860
the same same same pages right some one

1492
00:27:30,860 --> 00:27:30,870
 

1493
00:27:30,870 --> 00:27:32,180
disk read brings it to the buffer pool

1494
00:27:32,180 --> 00:27:32,190

1495
00:27:32,190 --> 00:27:33,950
and the sort of a notification system

1496
00:27:33,950 --> 00:27:33,960
 

1497
00:27:33,960 --> 00:27:35,930
that says all right you two guys need

1498
00:27:35,930 --> 00:27:35,940
 

1499
00:27:35,940 --> 00:27:37,120
these pages it's now ready

1500
00:27:37,120 --> 00:27:37,130
 

1501
00:27:37,130 --> 00:27:39,680
so then q1 finishes because it reaches

1502
00:27:39,680 --> 00:27:39,690

1503
00:27:39,690 --> 00:27:42,380
all the pages and then q2 recognizes oh

1504
00:27:42,380 --> 00:27:42,390
 

1505
00:27:42,390 --> 00:27:44,210
well I need to go back and get the other

1506
00:27:44,210 --> 00:27:44,220
 

1507
00:27:44,220 --> 00:27:49,250
two pages that I missed right so again

1508
00:27:49,250 --> 00:27:49,260
 

1509
00:27:49,260 --> 00:27:52,910
this this by being smarter about what we

1510
00:27:52,910 --> 00:27:52,920
 

1511
00:27:52,920 --> 00:27:55,340
know queries want to do we can avoid

1512
00:27:55,340 --> 00:27:55,350
 

1513
00:27:55,350 --> 00:27:58,100
having unnecessary disk reads in a way

1514
00:27:58,100 --> 00:27:58,110
 

1515
00:27:58,110 --> 00:28:00,110
that would be difficult to do with if

1516
00:28:00,110 --> 00:28:00,120
 

1517
00:28:00,120 --> 00:28:01,490
you don't know anything about what the

1518
00:28:01,490 --> 00:28:01,500
 

1519
00:28:01,500 --> 00:28:04,240
queries are actually trying to do

1520
00:28:04,240 --> 00:28:04,250
 

1521
00:28:04,250 --> 00:28:06,440
another optimization is be what's called

1522
00:28:06,440 --> 00:28:06,450
 

1523
00:28:06,450 --> 00:28:09,530
buffer pool bypass so we'll see this in

1524
00:28:09,530 --> 00:28:09,540

1525
00:28:09,540 --> 00:28:12,190
a second but these special scans are

1526
00:28:12,190 --> 00:28:12,200
 

1527
00:28:12,200 --> 00:28:14,510
problematic because they're gonna

1528
00:28:14,510 --> 00:28:14,520

1529
00:28:14,520 --> 00:28:15,950
pollute our cache with data that we

1530
00:28:15,950 --> 00:28:15,960
 

1531
00:28:15,960 --> 00:28:17,990
actually don't may not need again in the

1532
00:28:17,990 --> 00:28:18,000
 

1533
00:28:18,000 --> 00:28:20,690
future so in my last example in the last

1534
00:28:20,690 --> 00:28:20,700
 

1535
00:28:20,700 --> 00:28:22,340
slide I did was I was doing scratch to

1536
00:28:22,340 --> 00:28:22,350
 

1537
00:28:22,350 --> 00:28:25,340
scan on the table so as I read a page I

1538
00:28:25,340 --> 00:28:25,350
 

1539
00:28:25,350 --> 00:28:27,740
brought into my buffer pool I did you

1540
00:28:27,740 --> 00:28:27,750
 

1541
00:28:27,750 --> 00:28:29,000
know dip whatever query processing I

1542
00:28:29,000 --> 00:28:29,010
 

1543
00:28:29,010 --> 00:28:30,950
wanted to own it and then I just went on

1544
00:28:30,950 --> 00:28:30,960
 

1545
00:28:30,960 --> 00:28:32,390
to the next next page

1546
00:28:32,390 --> 00:28:32,400
 

1547
00:28:32,400 --> 00:28:35,300
but now the that page I just read is

1548
00:28:35,300 --> 00:28:35,310
 

1549
00:28:35,310 --> 00:28:36,530
probably not gonna be needed and again

1550
00:28:36,530 --> 00:28:36,540
 

1551
00:28:36,540 --> 00:28:38,600
in the future but it's the last thing I

1552
00:28:38,600 --> 00:28:38,610
 

1553
00:28:38,610 --> 00:28:40,820
just put in my buffer pool so and then

1554
00:28:40,820 --> 00:28:40,830
 

1555
00:28:40,830 --> 00:28:42,950
it may be evicting data that actually

1556
00:28:42,950 --> 00:28:42,960
 

1557
00:28:42,960 --> 00:28:44,539
you want to keep in there but I had to

1558
00:28:44,539 --> 00:28:44,549

1559
00:28:44,549 --> 00:28:45,649
do that cuz I didn't make space for all

1560
00:28:45,649 --> 00:28:45,659
 

1561
00:28:45,659 --> 00:28:47,990
these pages I'm reading as I'm doing the

1562
00:28:47,990 --> 00:28:48,000
 

1563
00:28:48,000 --> 00:28:50,630
scan so with buffer pool bypass the

1564
00:28:50,630 --> 00:28:50,640

1565
00:28:50,640 --> 00:28:53,899
basic idea is that the database system

1566
00:28:53,899 --> 00:28:53,909
 

1567
00:28:53,909 --> 00:28:55,610
can say all right I'm gonna do a central

1568
00:28:55,610 --> 00:28:55,620
 

1569
00:28:55,620 --> 00:28:57,200
scan and I know that this data is

1570
00:28:57,200 --> 00:28:57,210
 

1571
00:28:57,210 --> 00:28:58,370
probably not to be neat about anybody

1572
00:28:58,370 --> 00:28:58,380
 

1573
00:28:58,380 --> 00:29:00,740
else so rather than going paying the

1574
00:29:00,740 --> 00:29:00,750
 

1575
00:29:00,750 --> 00:29:01,340
overhead of

1576
00:29:01,340 --> 00:29:01,350

1577
00:29:01,350 --> 00:29:02,750
updating the page table and putting it

1578
00:29:02,750 --> 00:29:02,760
 

1579
00:29:02,760 --> 00:29:04,430
in a frame in the buffer pool I'll just

1580
00:29:04,430 --> 00:29:04,440
 

1581
00:29:04,440 --> 00:29:06,350
keep it a local copy in my private

1582
00:29:06,350 --> 00:29:06,360
 

1583
00:29:06,360 --> 00:29:08,450
memory for my query and then when I'm

1584
00:29:08,450 --> 00:29:08,460

1585
00:29:08,460 --> 00:29:10,330
done with it I just throw it away

1586
00:29:10,330 --> 00:29:10,340
 

1587
00:29:10,340 --> 00:29:12,350
right so this avoids having to go to

1588
00:29:12,350 --> 00:29:12,360
 

1589
00:29:12,360 --> 00:29:14,090
update the page table update the buffer

1590
00:29:14,090 --> 00:29:14,100
 

1591
00:29:14,100 --> 00:29:16,820
pool I update my own local copy of it

1592
00:29:16,820 --> 00:29:16,830
 

1593
00:29:16,830 --> 00:29:20,690
all right so in inform X these are

1594
00:29:20,690 --> 00:29:20,700
 

1595
00:29:20,700 --> 00:29:23,870
called Lite scans in Postgres we'll see

1596
00:29:23,870 --> 00:29:23,880
 

1597
00:29:23,880 --> 00:29:25,580
in a second they basically have our own

1598
00:29:25,580 --> 00:29:25,590
 

1599
00:29:25,590 --> 00:29:27,560
private buffer for queries as well if

1600
00:29:27,560 --> 00:29:27,570
 

1601
00:29:27,570 --> 00:29:29,120
you're doing sequential scan I actually

1602
00:29:29,120 --> 00:29:29,130
 

1603
00:29:29,130 --> 00:29:30,620
don't know whether it actually goes to

1604
00:29:30,620 --> 00:29:30,630
 

1605
00:29:30,630 --> 00:29:32,600
the buffalo manager I just know that it

1606
00:29:32,600 --> 00:29:32,610
 

1607
00:29:32,610 --> 00:29:34,250
maintains a zone a little private buffer

1608
00:29:34,250 --> 00:29:34,260
 

1609
00:29:34,260 --> 00:29:38,779
for every query so another thing we need

1610
00:29:38,779 --> 00:29:38,789
 

1611
00:29:38,789 --> 00:29:41,480
to talk about now is the the OS page

1612
00:29:41,480 --> 00:29:41,490
 

1613
00:29:41,490 --> 00:29:45,080
cache so the operating system is gonna

1614
00:29:45,080 --> 00:29:45,090
 

1615
00:29:45,090 --> 00:29:47,000
maintain for the file system its own

1616
00:29:47,000 --> 00:29:47,010
 

1617
00:29:47,010 --> 00:29:49,730
cache of pages that it reads right if

1618
00:29:49,730 --> 00:29:49,740
 

1619
00:29:49,740 --> 00:29:53,269
you ever look on H top on Linux but

1620
00:29:53,269 --> 00:29:53,279
 

1621
00:29:53,279 --> 00:29:55,220
you'll see how much the how much

1622
00:29:55,220 --> 00:29:55,230
 

1623
00:29:55,230 --> 00:29:57,590
remember your processes are using you

1624
00:29:57,590 --> 00:29:57,600
 

1625
00:29:57,600 --> 00:29:59,659
know on the heap but then there's also

1626
00:29:59,659 --> 00:29:59,669
 

1627
00:29:59,669 --> 00:30:02,180
going to be the OS page cache of copies

1628
00:30:02,180 --> 00:30:02,190
 

1629
00:30:02,190 --> 00:30:03,740
of pages that it's read from from the

1630
00:30:03,740 --> 00:30:03,750
 

1631
00:30:03,750 --> 00:30:07,039
file system so if you don't do anything

1632
00:30:07,039 --> 00:30:07,049
 

1633
00:30:07,049 --> 00:30:08,899
special when you open up a file in your

1634
00:30:08,899 --> 00:30:08,909
 

1635
00:30:08,909 --> 00:30:11,630
in your program and read a bunch of data

1636
00:30:11,630 --> 00:30:11,640
 

1637
00:30:11,640 --> 00:30:14,120
in the OS is gonna copy make copies of

1638
00:30:14,120 --> 00:30:14,130
 

1639
00:30:14,130 --> 00:30:15,710
that and the certain file system a page

1640
00:30:15,710 --> 00:30:15,720
 

1641
00:30:15,720 --> 00:30:17,149
cache alright this is different than

1642
00:30:17,149 --> 00:30:17,159
 

1643
00:30:17,159 --> 00:30:20,720
virtual memory but now the problem is if

1644
00:30:20,720 --> 00:30:20,730
 

1645
00:30:20,730 --> 00:30:23,840
we do this then now every time I read a

1646
00:30:23,840 --> 00:30:23,850
 

1647
00:30:23,850 --> 00:30:26,000
page in my buffer pool my database

1648
00:30:26,000 --> 00:30:26,010

1649
00:30:26,010 --> 00:30:28,399
system the OS is gonna make a copy of it

1650
00:30:28,399 --> 00:30:28,409
 

1651
00:30:28,409 --> 00:30:29,990
and then I'm have another copy of it in

1652
00:30:29,990 --> 00:30:30,000
 

1653
00:30:30,000 --> 00:30:34,580
my in my in my database system so it's

1654
00:30:34,580 --> 00:30:34,590
 

1655
00:30:34,590 --> 00:30:35,899
it's doubled amount of memory for

1656
00:30:35,899 --> 00:30:35,909
 

1657
00:30:35,909 --> 00:30:40,070
reading the same data so most database

1658
00:30:40,070 --> 00:30:40,080

1659
00:30:40,080 --> 00:30:42,799
systems turn off this page cache and the

1660
00:30:42,799 --> 00:30:42,809
 

1661
00:30:42,809 --> 00:30:44,810
way you do it is you pass the Oh direct

1662
00:30:44,810 --> 00:30:44,820
 

1663
00:30:44,820 --> 00:30:47,570
flag in Lib C when you open up a file

1664
00:30:47,570 --> 00:30:47,580
 

1665
00:30:47,580 --> 00:30:50,029
and say I don't want this file to be

1666
00:30:50,029 --> 00:30:50,039
 

1667
00:30:50,039 --> 00:30:52,220
backed by the the file system cache I'm

1668
00:30:52,220 --> 00:30:52,230
 

1669
00:30:52,230 --> 00:30:56,120
gonna manage manage it myself so this

1670
00:30:56,120 --> 00:30:56,130
 

1671
00:30:56,130 --> 00:30:56,930
avoids having

1672
00:30:56,930 --> 00:30:56,940
 

1673
00:30:56,940 --> 00:30:58,810
again these were done in copies of pages

1674
00:30:58,810 --> 00:30:58,820
 

1675
00:30:58,820 --> 00:31:02,570
it allows you to have begin full control

1676
00:31:02,570 --> 00:31:02,580
 

1677
00:31:02,580 --> 00:31:04,370
over the eviction policies of how things

1678
00:31:04,370 --> 00:31:04,380
 

1679
00:31:04,380 --> 00:31:08,240
are evicted out of memory right as far

1680
00:31:08,240 --> 00:31:08,250
 

1681
00:31:08,250 --> 00:31:12,740
as I know most major database systems

1682
00:31:12,740 --> 00:31:12,750
 

1683
00:31:12,750 --> 00:31:14,930
with except from one tells you to turn

1684
00:31:14,930 --> 00:31:14,940
 

1685
00:31:14,940 --> 00:31:17,210
off the page cache in the operating

1686
00:31:17,210 --> 00:31:17,220
 

1687
00:31:17,220 --> 00:31:18,230
system because they want to manage

1688
00:31:18,230 --> 00:31:18,240
 

1689
00:31:18,240 --> 00:31:20,810
memory itself the major system that I

1690
00:31:20,810 --> 00:31:20,820
 

1691
00:31:20,820 --> 00:31:22,160
know that does use it is actually

1692
00:31:22,160 --> 00:31:22,170
 

1693
00:31:22,170 --> 00:31:25,010
Postgres Postgres actually uses the

1694
00:31:25,010 --> 00:31:25,020
 

1695
00:31:25,020 --> 00:31:27,290
theirs page cache and they argue that

1696
00:31:27,290 --> 00:31:27,300
 

1697
00:31:27,300 --> 00:31:30,380
the this is not a significant problem

1698
00:31:30,380 --> 00:31:30,390
 

1699
00:31:30,390 --> 00:31:35,420
for them because the the OS it still has

1700
00:31:35,420 --> 00:31:35,430
 

1701
00:31:35,430 --> 00:31:36,740
its own buffer pool but it's but it

1702
00:31:36,740 --> 00:31:36,750
 

1703
00:31:36,750 --> 00:31:38,450
still relies on the OS page cache and

1704
00:31:38,450 --> 00:31:38,460
 

1705
00:31:38,460 --> 00:31:41,060
just by having that sort of an extra

1706
00:31:41,060 --> 00:31:41,070
 

1707
00:31:41,070 --> 00:31:42,830
layer it's one less thing that they have

1708
00:31:42,830 --> 00:31:42,840
 

1709
00:31:42,840 --> 00:31:44,840
to manage and they it's a minimal impact

1710
00:31:44,840 --> 00:31:44,850
 

1711
00:31:44,850 --> 00:31:48,200
on performance so let's let's see how

1712
00:31:48,200 --> 00:31:48,210

1713
00:31:48,210 --> 00:31:52,430
actually how this works all right so

1714
00:31:52,430 --> 00:31:52,440
 

1715
00:31:52,440 --> 00:31:54,650
this is Postgres running on machine back

1716
00:31:54,650 --> 00:31:54,660
 

1717
00:31:54,660 --> 00:32:04,460
in my office and connect to it here so

1718
00:32:04,460 --> 00:32:04,470
 

1719
00:32:04,470 --> 00:32:06,500
the first thing I want to show you is

1720
00:32:06,500 --> 00:32:06,510
 

1721
00:32:06,510 --> 00:32:10,000
what the page cache actually looks like

1722
00:32:10,000 --> 00:32:10,010


1723
00:32:10,010 --> 00:32:14,930
one again if you run H top it's kind of

1724
00:32:14,930 --> 00:32:14,940
 

1725
00:32:14,940 --> 00:32:16,550
hard to see there and I'm a laser

1726
00:32:16,550 --> 00:32:16,560

1727
00:32:16,560 --> 00:32:20,930
pointer right so this is the matter of

1728
00:32:20,930 --> 00:32:20,940
 

1729
00:32:20,940 --> 00:32:23,180
memory that the system is using right so

1730
00:32:23,180 --> 00:32:23,190
 

1731
00:32:23,190 --> 00:32:25,310
this green bar here that's the resident

1732
00:32:25,310 --> 00:32:25,320
 

1733
00:32:25,320 --> 00:32:26,960
memory of the processes running on the

1734
00:32:26,960 --> 00:32:26,970
 

1735
00:32:26,970 --> 00:32:29,480
system then all of this yellow stuff

1736
00:32:29,480 --> 00:32:29,490
 

1737
00:32:29,490 --> 00:32:33,070
here is the the OS file system cache

1738
00:32:33,070 --> 00:32:33,080

1739
00:32:33,080 --> 00:32:36,200
right so this machine has 32 gigs of ram

1740
00:32:36,200 --> 00:32:36,210
 

1741
00:32:36,210 --> 00:32:39,350
the resident set size of the processes

1742
00:32:39,350 --> 00:32:39,360
 

1743
00:32:39,360 --> 00:32:40,700
running on my shoot machine is only 5

1744
00:32:40,700 --> 00:32:40,710
 

1745
00:32:40,710 --> 00:32:42,950
gigs and the rest is being used by the

1746
00:32:42,950 --> 00:32:42,960
 

1747
00:32:42,960 --> 00:32:50,840
OS page cache right so we can flush this

1748
00:32:50,840 --> 00:32:50,850


1749
00:32:50,850 --> 00:32:53,730
if you pass in this command here sink

1750
00:32:53,730 --> 00:32:53,740
 

1751
00:32:53,740 --> 00:32:56,090
echo three and you pass it to this

1752
00:32:56,090 --> 00:32:56,100
 

1753
00:32:56,100 --> 00:32:58,860
special location in the proc file system

1754
00:32:58,860 --> 00:32:58,870
 

1755
00:32:58,870 --> 00:33:01,650
this will flush all the page caches in

1756
00:33:01,650 --> 00:33:01,660
 

1757
00:33:01,660 --> 00:33:03,330
for my system so now if I go back and

1758
00:33:03,330 --> 00:33:03,340
 

1759
00:33:03,340 --> 00:33:05,750
look at each top again right now my

1760
00:33:05,750 --> 00:33:05,760
 

1761
00:33:05,760 --> 00:33:08,430
resident set size is still five gigs but

1762
00:33:08,430 --> 00:33:08,440
 

1763
00:33:08,440 --> 00:33:11,070
my but my total matter memory systems

1764
00:33:11,070 --> 00:33:11,080
 

1765
00:33:11,080 --> 00:33:13,890
using is is now exactly five gigs

1766
00:33:13,890 --> 00:33:13,900
 

1767
00:33:13,900 --> 00:33:16,880
because the OS file system cache is gone

1768
00:33:16,880 --> 00:33:16,890
 

1769
00:33:16,890 --> 00:33:19,680
so let's go into post read so we're

1770
00:33:19,680 --> 00:33:19,690
 

1771
00:33:19,690 --> 00:33:22,799
gonna use the same two tables that I

1772
00:33:22,799 --> 00:33:22,809
 

1773
00:33:22,809 --> 00:33:24,960
used last time to show you the district

1774
00:33:24,960 --> 00:33:24,970
 

1775
00:33:24,970 --> 00:33:26,490
between decimals and reals right I think

1776
00:33:26,490 --> 00:33:26,500
 

1777
00:33:26,500 --> 00:33:30,330
is like ten million entries so we're

1778
00:33:30,330 --> 00:33:30,340
 

1779
00:33:30,340 --> 00:33:32,149
gonna do is we're gonna turn off

1780
00:33:32,149 --> 00:33:32,159
 

1781
00:33:32,159 --> 00:33:36,029
parallel workers right again this this

1782
00:33:36,029 --> 00:33:36,039
 

1783
00:33:36,039 --> 00:33:37,560
is a it's only one query running at a

1784
00:33:37,560 --> 00:33:37,570
 

1785
00:33:37,570 --> 00:33:40,289
time so what we're gonna do is we can

1786
00:33:40,289 --> 00:33:40,299
 

1787
00:33:40,299 --> 00:33:44,370
execute a query that will just just do

1788
00:33:44,370 --> 00:33:44,380
 

1789
00:33:44,380 --> 00:33:45,810
that same summation that we have before

1790
00:33:45,810 --> 00:33:45,820
 

1791
00:33:45,820 --> 00:33:47,880
so now I'm gonna pass in I'm gonna use

1792
00:33:47,880 --> 00:33:47,890
 

1793
00:33:47,890 --> 00:33:49,860
explain and I'm gonna explain analyze

1794
00:33:49,860 --> 00:33:49,870
 

1795
00:33:49,870 --> 00:33:50,970
which actually runs the query throughs

1796
00:33:50,970 --> 00:33:50,980
 

1797
00:33:50,980 --> 00:33:52,740
use the query plan but I'm gonna pass in

1798
00:33:52,740 --> 00:33:52,750
 

1799
00:33:52,750 --> 00:33:54,870
this extra flag called buffers that's

1800
00:33:54,870 --> 00:33:54,880
 

1801
00:33:54,880 --> 00:33:58,919
going to show you what percentage of the

1802
00:33:58,919 --> 00:33:58,929
 

1803
00:33:58,929 --> 00:34:00,750
data that or pages we read actually this

1804
00:34:00,750 --> 00:34:00,760
 

1805
00:34:00,760 --> 00:34:03,630
query will be either in the buffer pool

1806
00:34:03,630 --> 00:34:03,640
 

1807
00:34:03,640 --> 00:34:06,810
cache or in the or had to read it

1808
00:34:06,810 --> 00:34:06,820
 

1809
00:34:06,820 --> 00:34:10,859
actually on disk okay so let me know so

1810
00:34:10,859 --> 00:34:10,869
 

1811
00:34:10,869 --> 00:34:13,950
let me restart Postgres to so it there's

1812
00:34:13,950 --> 00:34:13,960
 

1813
00:34:13,960 --> 00:34:18,510
nothing in the file system cache sorry

1814
00:34:18,510 --> 00:34:18,520
 

1815
00:34:18,520 --> 00:34:20,090
there's nothing in its buffer pool cache

1816
00:34:20,090 --> 00:34:20,100
 

1817
00:34:20,100 --> 00:34:22,409
so this point I flushed the file system

1818
00:34:22,409 --> 00:34:22,419
 

1819
00:34:22,419 --> 00:34:24,659
buffers and I restarted Postgres there's

1820
00:34:24,659 --> 00:34:24,669
 

1821
00:34:24,669 --> 00:34:26,040
nothing in memory that I can use

1822
00:34:26,040 --> 00:34:26,050
 

1823
00:34:26,050 --> 00:34:27,540
everything's always gonna have to go to

1824
00:34:27,540 --> 00:34:27,550
 

1825
00:34:27,550 --> 00:34:32,570
disk so now yeah execute this query

1826
00:34:32,570 --> 00:34:32,580
 

1827
00:34:32,580 --> 00:34:35,060
right so he did though

1828
00:34:35,060 --> 00:34:35,070

1829
00:34:35,070 --> 00:34:37,169
it did the parallel scan but that's okay

1830
00:34:37,169 --> 00:34:37,179
 

1831
00:34:37,179 --> 00:34:43,409
actually me restart this

1832
00:34:43,409 --> 00:34:43,419


1833
00:34:43,419 --> 00:34:48,629
blow that away blow that away come back

1834
00:34:48,629 --> 00:34:48,639
 

1835
00:34:48,639 --> 00:34:50,599
here

1836
00:34:50,599 --> 00:34:50,609

1837
00:34:50,609 --> 00:34:53,849
turn off parallel workers good okay same

1838
00:34:53,849 --> 00:34:53,859
 

1839
00:34:53,859 --> 00:35:02,970
query right so this part here this told

1840
00:35:02,970 --> 00:35:02,980

1841
00:35:02,980 --> 00:35:05,250
you that for to do this special scale on

1842
00:35:05,250 --> 00:35:05,260
 

1843
00:35:05,260 --> 00:35:09,329
this table that it had to read 400 for

1844
00:35:09,329 --> 00:35:09,339
 

1845
00:35:09,339 --> 00:35:12,450
forty four thousand pages right so this

1846
00:35:12,450 --> 00:35:12,460
 

1847
00:35:12,460 --> 00:35:13,740
is saying that there's nothing there's

1848
00:35:13,740 --> 00:35:13,750
 

1849
00:35:13,750 --> 00:35:14,880
nothing in the cache that it actually

1850
00:35:14,880 --> 00:35:14,890
 

1851
00:35:14,890 --> 00:35:17,880
was able to reuse so now if I come back

1852
00:35:17,880 --> 00:35:17,890
 

1853
00:35:17,890 --> 00:35:23,759
and execute the same query again now it

1854
00:35:23,759 --> 00:35:23,769
 

1855
00:35:23,769 --> 00:35:26,490
says that um can I highlight this yeah

1856
00:35:26,490 --> 00:35:26,500
 

1857
00:35:26,500 --> 00:35:30,180
here now says hit 32 I'll explain what

1858
00:35:30,180 --> 00:35:30,190
 

1859
00:35:30,190 --> 00:35:31,980
that is in a second right this is

1860
00:35:31,980 --> 00:35:31,990
 

1861
00:35:31,990 --> 00:35:33,779
actually the private cache for the for

1862
00:35:33,779 --> 00:35:33,789
 

1863
00:35:33,789 --> 00:35:35,849
the for this query it's always gonna be

1864
00:35:35,849 --> 00:35:35,859
 

1865
00:35:35,859 --> 00:35:38,880
32 32 pages right but then the the the

1866
00:35:38,880 --> 00:35:38,890
 

1867
00:35:38,890 --> 00:35:40,589
number of pages we read from disk went

1868
00:35:40,589 --> 00:35:40,599
 

1869
00:35:40,599 --> 00:35:43,079
down by 32 because we we had 32 in our

1870
00:35:43,079 --> 00:35:43,089
 

1871
00:35:43,089 --> 00:35:48,059
and our buffer pool alright so we can

1872
00:35:48,059 --> 00:35:48,069
 

1873
00:35:48,069 --> 00:35:49,859
force the database system to fetch

1874
00:35:49,859 --> 00:35:49,869
 

1875
00:35:49,869 --> 00:35:53,339
everything into into its buffer pool so

1876
00:35:53,339 --> 00:35:53,349
 

1877
00:35:53,349 --> 00:35:58,019
it has this thing called PG warm right

1878
00:35:58,019 --> 00:35:58,029
 

1879
00:35:58,029 --> 00:35:59,880
it says it's a special extension for

1880
00:35:59,880 --> 00:35:59,890
 

1881
00:35:59,890 --> 00:36:01,710
Postgres that comes with when you stall

1882
00:36:01,710 --> 00:36:01,720
 

1883
00:36:01,720 --> 00:36:02,819
post graph this tells it basically

1884
00:36:02,819 --> 00:36:02,829
 

1885
00:36:02,829 --> 00:36:04,289
pre-war my buffer pool by reading

1886
00:36:04,289 --> 00:36:04,299
 

1887
00:36:04,299 --> 00:36:07,980
everything right so we execute that and

1888
00:36:07,980 --> 00:36:07,990
 

1889
00:36:07,990 --> 00:36:09,620
it's gonna come back and tell us that it

1890
00:36:09,620 --> 00:36:09,630
 

1891
00:36:09,630 --> 00:36:13,410
read for that 44,000 pages and into our

1892
00:36:13,410 --> 00:36:13,420
 

1893
00:36:13,420 --> 00:36:16,980
buffer pool right so now when I go back

1894
00:36:16,980 --> 00:36:16,990
 

1895
00:36:16,990 --> 00:36:22,550
and run that same query

1896
00:36:22,550 --> 00:36:22,560


1897
00:36:22,560 --> 00:36:24,980
my hit ratio went up or right the number

1898
00:36:24,980 --> 00:36:24,990
 

1899
00:36:24,990 --> 00:36:28,220
of hits went up I still had to read some

1900
00:36:28,220 --> 00:36:28,230
 

1901
00:36:28,230 --> 00:36:33,080
data from desk right everything guess

1902
00:36:33,080 --> 00:36:33,090
 

1903
00:36:33,090 --> 00:36:36,500
what's the issue here why did why wasn't

1904
00:36:36,500 --> 00:36:36,510
 

1905
00:36:36,510 --> 00:36:40,670
everything in the buffer pool it's not

1906
00:36:40,670 --> 00:36:40,680
 

1907
00:36:40,680 --> 00:36:41,690
large enough exactly right

1908
00:36:41,690 --> 00:36:41,700
 

1909
00:36:41,700 --> 00:36:44,660
so you set when you when you set the

1910
00:36:44,660 --> 00:36:44,670
 

1911
00:36:44,670 --> 00:36:45,830
data system up you say how much remember

1912
00:36:45,830 --> 00:36:45,840
 

1913
00:36:45,840 --> 00:36:46,760
you want to use for the buffer pool

1914
00:36:46,760 --> 00:36:46,770
 

1915
00:36:46,770 --> 00:36:48,380
right the data system has to be told

1916
00:36:48,380 --> 00:36:48,390
 

1917
00:36:48,390 --> 00:36:49,430
that because otherwise it just takes

1918
00:36:49,430 --> 00:36:49,440
 

1919
00:36:49,440 --> 00:36:53,090
everything right so that's why we only

1920
00:36:53,090 --> 00:36:53,100
 

1921
00:36:53,100 --> 00:36:56,060
had we had we didn't wasn't everything

1922
00:36:56,060 --> 00:36:56,070
 

1923
00:36:56,070 --> 00:36:57,920
wasn't always we didn't all of our page

1924
00:36:57,920 --> 00:36:57,930
 

1925
00:36:57,930 --> 00:37:00,140
reads all of our pages we want to access

1926
00:37:00,140 --> 00:37:00,150
 

1927
00:37:00,150 --> 00:37:03,110
work in our buffer pool so what we can

1928
00:37:03,110 --> 00:37:03,120
 

1929
00:37:03,120 --> 00:37:05,120
do now is go back to the Postgres

1930
00:37:05,120 --> 00:37:05,130
 

1931
00:37:05,130 --> 00:37:12,440
configuration alright Postgres has this

1932
00:37:12,440 --> 00:37:12,450
 

1933
00:37:12,450 --> 00:37:14,150
flag has something called shared buffers

1934
00:37:14,150 --> 00:37:14,160
 

1935
00:37:14,160 --> 00:37:18,170
all right so we want to set this to be

1936
00:37:18,170 --> 00:37:18,180
 

1937
00:37:18,180 --> 00:37:20,900
the right size so for this if we go back

1938
00:37:20,900 --> 00:37:20,910
 

1939
00:37:20,910 --> 00:37:26,600
here we know we had to read we had to

1940
00:37:26,600 --> 00:37:26,610
 

1941
00:37:26,610 --> 00:37:30,530
read this number of pages right Postgres

1942
00:37:30,530 --> 00:37:30,540
 

1943
00:37:30,540 --> 00:37:32,870
pages are 8 kilobytes so what we're

1944
00:37:32,870 --> 00:37:32,880
 

1945
00:37:32,880 --> 00:37:33,740
going to want to do is we're going to

1946
00:37:33,740 --> 00:37:33,750
 

1947
00:37:33,750 --> 00:37:35,210
store it we want to have set our buffer

1948
00:37:35,210 --> 00:37:35,220
 

1949
00:37:35,220 --> 00:37:39,440
pool size to be 8 kilobytes times 4 4 -

1950
00:37:39,440 --> 00:37:39,450
 

1951
00:37:39,450 --> 00:37:47,060
8 4 so that'll be 4 4 - 8 4 times 8 all

1952
00:37:47,060 --> 00:37:47,070
 

1953
00:37:47,070 --> 00:37:51,410
right so about 350 5 megabytes so now we

1954
00:37:51,410 --> 00:37:51,420
 

1955
00:37:51,420 --> 00:37:58,090
go back to this guy let's round up 356

1956
00:37:58,090 --> 00:37:58,100


1957
00:37:58,100 --> 00:38:00,230
right so now again we're setting the

1958
00:38:00,230 --> 00:38:00,240

1959
00:38:00,240 --> 00:38:03,680
buffer pool size to be 300 356 megabytes

1960
00:38:03,680 --> 00:38:03,690
 

1961
00:38:03,690 --> 00:38:05,540
we got our restart Postgres to tell it

1962
00:38:05,540 --> 00:38:05,550
 

1963
00:38:05,550 --> 00:38:09,320
to take that in effect all right

1964
00:38:09,320 --> 00:38:09,330
 

1965
00:38:09,330 --> 00:38:11,510
then we go back here where you connect

1966
00:38:11,510 --> 00:38:11,520
 

1967
00:38:11,520 --> 00:38:17,120
to our database I'm going to pre-warm

1968
00:38:17,120 --> 00:38:17,130
 

1969
00:38:17,130 --> 00:38:20,300
the table and then now when I run my

1970
00:38:20,300 --> 00:38:20,310
 

1971
00:38:20,310 --> 00:38:23,670
query

1972
00:38:23,670 --> 00:38:23,680


1973
00:38:23,680 --> 00:38:26,280
there you go the hit went to exactly

1974
00:38:26,280 --> 00:38:26,290
 

1975
00:38:26,290 --> 00:38:31,730
what we wanted sorry hello my cursor is

1976
00:38:31,730 --> 00:38:31,740

1977
00:38:31,740 --> 00:38:37,260
there yeah right there see so to do this

1978
00:38:37,260 --> 00:38:37,270
 

1979
00:38:37,270 --> 00:38:38,250
we didn't have to read anything from

1980
00:38:38,250 --> 00:38:38,260

1981
00:38:38,260 --> 00:38:40,920
bump from from the database I'm sorry

1982
00:38:40,920 --> 00:38:40,930
 

1983
00:38:40,930 --> 00:38:42,270
read anything from disk everything was

1984
00:38:42,270 --> 00:38:42,280
 

1985
00:38:42,280 --> 00:38:44,250
in our buffer pool all right the reason

1986
00:38:44,250 --> 00:38:44,260
 

1987
00:38:44,260 --> 00:38:45,810
I like using Postgres is like and omus

1988
00:38:45,810 --> 00:38:45,820
 

1989
00:38:45,820 --> 00:38:47,130
is a textbook implantation of a database

1990
00:38:47,130 --> 00:38:47,140
 

1991
00:38:47,140 --> 00:38:58,760
system yes so his question is is is the

1992
00:38:58,760 --> 00:38:58,770
 

1993
00:38:58,770 --> 00:39:02,160
is the buffer pool allocated where sorry

1994
00:39:02,160 --> 00:39:02,170
 

1995
00:39:02,170 --> 00:39:18,960
in the in the yeah so this question is I

1996
00:39:18,960 --> 00:39:18,970
 

1997
00:39:18,970 --> 00:39:21,360
showed this version H not before and I

1998
00:39:21,360 --> 00:39:21,370
 

1999
00:39:21,370 --> 00:39:22,950
said the green bar from memory was the

2000
00:39:22,950 --> 00:39:22,960
 

2001
00:39:22,960 --> 00:39:25,410
resident memory of processes and this

2002
00:39:25,410 --> 00:39:25,420
 

2003
00:39:25,420 --> 00:39:27,480
question is where's the buffer pool is

2004
00:39:27,480 --> 00:39:27,490
 

2005
00:39:27,490 --> 00:39:29,490
it is it in this resident memory or is

2006
00:39:29,490 --> 00:39:29,500
 

2007
00:39:29,500 --> 00:39:31,350
it in the file system cache it is in the

2008
00:39:31,350 --> 00:39:31,360
 

2009
00:39:31,360 --> 00:39:32,730
resident memory it's literally calling

2010
00:39:32,730 --> 00:39:32,740

2011
00:39:32,740 --> 00:39:35,550
malloc inside of the process and that

2012
00:39:35,550 --> 00:39:35,560
 

2013
00:39:35,560 --> 00:39:37,740
shows up in in part of the green bars

2014
00:39:37,740 --> 00:39:37,750

2015
00:39:37,750 --> 00:39:38,360
here

2016
00:39:38,360 --> 00:39:38,370

2017
00:39:38,370 --> 00:39:40,590
it doesn't have any control over the

2018
00:39:40,590 --> 00:39:40,600
 

2019
00:39:40,600 --> 00:39:43,080
file system cache that is all managed by

2020
00:39:43,080 --> 00:39:43,090
 

2021
00:39:43,090 --> 00:39:44,400
the operating system at the subsequent

2022
00:39:44,400 --> 00:39:44,410
 

2023
00:39:44,410 --> 00:39:46,790
bars so that so the file system decides

2024
00:39:46,790 --> 00:39:46,800
 

2025
00:39:46,800 --> 00:39:48,900
the file I started the operating system

2026
00:39:48,900 --> 00:39:48,910
 

2027
00:39:48,910 --> 00:39:50,520
decides how much I wants to allocate or

2028
00:39:50,520 --> 00:39:50,530
 

2029
00:39:50,530 --> 00:39:52,830
split up the memory for the fosston cash

2030
00:39:52,830 --> 00:39:52,840
 

2031
00:39:52,840 --> 00:39:56,480
versus the memory for processes right

2032
00:39:56,480 --> 00:39:56,490

2033
00:39:56,490 --> 00:39:58,380
post-christmas doesn't have any control

2034
00:39:58,380 --> 00:39:58,390
 

2035
00:39:58,390 --> 00:40:00,480
over that they always just does whatever

2036
00:40:00,480 --> 00:40:00,490
 

2037
00:40:00,490 --> 00:40:04,710
wants to do so I want to show you how we

2038
00:40:04,710 --> 00:40:04,720
 

2039
00:40:04,720 --> 00:40:08,280
know that the the database system is

2040
00:40:08,280 --> 00:40:08,290
 

2041
00:40:08,290 --> 00:40:11,580
hitting the file system cache in case of

2042
00:40:11,580 --> 00:40:11,590
 

2043
00:40:11,590 --> 00:40:15,660
Postgres so if I go back to I say this

2044
00:40:15,660 --> 00:40:15,670
 

2045
00:40:15,670 --> 00:40:19,470
query took me it takes about 12

2046
00:40:19,470 --> 00:40:19,480
 

2047
00:40:19,480 --> 00:40:24,990
milliseconds so this is run it or take

2048
00:40:24,990 --> 00:40:25,000
 

2049
00:40:25,000 --> 00:40:26,790
700 milliseconds right so I run it

2050
00:40:26,790 --> 00:40:26,800
 

2051
00:40:26,800 --> 00:40:28,290
multiple times it's always gonna take

2052
00:40:28,290 --> 00:40:28,300
 

2053
00:40:28,300 --> 00:40:30,720
the same amount roughly that's actually

2054
00:40:30,720 --> 00:40:30,730
 

2055
00:40:30,730 --> 00:40:32,210
going faster

2056
00:40:32,210 --> 00:40:32,220

2057
00:40:32,220 --> 00:40:33,670
all right guys all right so fluctuates

2058
00:40:33,670 --> 00:40:33,680
 

2059
00:40:33,680 --> 00:40:38,000
so in this case here now if I restart

2060
00:40:38,000 --> 00:40:38,010
 

2061
00:40:38,010 --> 00:40:43,490
Postgres this will blow away the buffer

2062
00:40:43,490 --> 00:40:43,500
 

2063
00:40:43,500 --> 00:40:46,250
pool right from the process if I now go

2064
00:40:46,250 --> 00:40:46,260
 

2065
00:40:46,260 --> 00:40:50,150
back here turn timing back on make sure

2066
00:40:50,150 --> 00:40:50,160
 

2067
00:40:50,160 --> 00:40:51,040
I'm connected

2068
00:40:51,040 --> 00:40:51,050
 

2069
00:40:51,050 --> 00:40:56,180
turn off parallel threads so at this

2070
00:40:56,180 --> 00:40:56,190
 

2071
00:40:56,190 --> 00:40:59,000
point I've restarted the database the

2072
00:40:59,000 --> 00:40:59,010

2073
00:40:59,010 --> 00:41:00,170
buffer pool is gone there's nothing in

2074
00:41:00,170 --> 00:41:00,180
 

2075
00:41:00,180 --> 00:41:02,480
the buffer pool I'm not gonna run PG

2076
00:41:02,480 --> 00:41:02,490
 

2077
00:41:02,490 --> 00:41:04,160
warm I'm just gonna run the query and

2078
00:41:04,160 --> 00:41:04,170
 

2079
00:41:04,170 --> 00:41:07,190
see how how fast it is and if it's the

2080
00:41:07,190 --> 00:41:07,200
 

2081
00:41:07,200 --> 00:41:10,339
same speed as this seven hundred seven

2082
00:41:10,339 --> 00:41:10,349
 

2083
00:41:10,349 --> 00:41:12,050
hundred forty milliseconds if it's the

2084
00:41:12,050 --> 00:41:12,060
 

2085
00:41:12,060 --> 00:41:13,640
same speed as that then we know it's

2086
00:41:13,640 --> 00:41:13,650
 

2087
00:41:13,650 --> 00:41:21,829
hitting the fossum cache right it's it's

2088
00:41:21,829 --> 00:41:21,839
 

2089
00:41:21,839 --> 00:41:26,270
a little bit slower right so if I was if

2090
00:41:26,270 --> 00:41:26,280
 

2091
00:41:26,280 --> 00:41:28,550
I blow away the faucet in cache

2092
00:41:28,550 --> 00:41:28,560
 

2093
00:41:28,560 --> 00:41:31,040
I actually did this in beginning I was

2094
00:41:31,040 --> 00:41:31,050
 

2095
00:41:31,050 --> 00:41:33,319
roughly about one point two seconds now

2096
00:41:33,319 --> 00:41:33,329
 

2097
00:41:33,329 --> 00:41:34,790
I'm 700 millisecond there was nothing in

2098
00:41:34,790 --> 00:41:34,800
 

2099
00:41:34,800 --> 00:41:36,260
the buffer pool but the thought the

2100
00:41:36,260 --> 00:41:36,270
 

2101
00:41:36,270 --> 00:41:38,540
operating system has it cached so the

2102
00:41:38,540 --> 00:41:38,550
 

2103
00:41:38,550 --> 00:41:41,150
davidon can go ahead and read that so

2104
00:41:41,150 --> 00:41:41,160
 

2105
00:41:41,160 --> 00:41:42,980
again this is specific to Postgres most

2106
00:41:42,980 --> 00:41:42,990
 

2107
00:41:42,990 --> 00:41:45,079
data systems do not rely on the page

2108
00:41:45,079 --> 00:41:45,089
 

2109
00:41:45,089 --> 00:41:47,089
cache of the operating system because

2110
00:41:47,089 --> 00:41:47,099
 

2111
00:41:47,099 --> 00:41:48,170
they want to manage all memory

2112
00:41:48,170 --> 00:41:48,180
 

2113
00:41:48,180 --> 00:41:49,300
themselves

2114
00:41:49,300 --> 00:41:49,310

2115
00:41:49,310 --> 00:41:53,329
okay so is this clear and again we can

2116
00:41:53,329 --> 00:41:53,339
 

2117
00:41:53,339 --> 00:41:57,410
use explain explain analyze with put the

2118
00:41:57,410 --> 00:41:57,420
 

2119
00:41:57,420 --> 00:42:00,470
buffers and it'll tell us what

2120
00:42:00,470 --> 00:42:00,480

2121
00:42:00,480 --> 00:42:01,640
percentage of the queries are hitting

2122
00:42:01,640 --> 00:42:01,650
 

2123
00:42:01,650 --> 00:42:02,900
the butter pool in this case here

2124
00:42:02,900 --> 00:42:02,910
 

2125
00:42:02,910 --> 00:42:05,359
because I didn't run PG warm it still

2126
00:42:05,359 --> 00:42:05,369
 

2127
00:42:05,369 --> 00:42:06,890
has to read a lot of things from from

2128
00:42:06,890 --> 00:42:06,900
 

2129
00:42:06,900 --> 00:42:09,890
the from the file system actually that

2130
00:42:09,890 --> 00:42:09,900
 

2131
00:42:09,900 --> 00:42:21,580
exigent time is pretty slow

2132
00:42:21,580 --> 00:42:21,590


2133
00:42:21,590 --> 00:42:32,030
and I will do that later but maybe

2134
00:42:32,030 --> 00:42:32,040
 

2135
00:42:32,040 --> 00:42:35,290
because we're running analyze now okay

2136
00:42:35,290 --> 00:42:35,300
 

2137
00:42:35,300 --> 00:42:40,130
alright so these demos are sort of

2138
00:42:40,130 --> 00:42:40,140
 

2139
00:42:40,140 --> 00:42:42,680
expose to you or show you that like the

2140
00:42:42,680 --> 00:42:42,690
 

2141
00:42:42,690 --> 00:42:43,730
things I'm talking about here you can

2142
00:42:43,730 --> 00:42:43,740
 

2143
00:42:43,740 --> 00:42:45,770
actually see in some ways without

2144
00:42:45,770 --> 00:42:45,780
 

2145
00:42:45,780 --> 00:42:47,810
reading the postcode you can see the

2146
00:42:47,810 --> 00:42:47,820
 

2147
00:42:47,820 --> 00:42:50,240
behavior that matches up with with the

2148
00:42:50,240 --> 00:42:50,250
 

2149
00:42:50,250 --> 00:42:53,510
policies that were described all right

2150
00:42:53,510 --> 00:42:53,520
 

2151
00:42:53,520 --> 00:42:54,650
so the next thing we want to talk about

2152
00:42:54,650 --> 00:42:54,660
 

2153
00:42:54,660 --> 00:42:58,780
is how do we actually make decisions on

2154
00:42:58,780 --> 00:42:58,790
 

2155
00:42:58,790 --> 00:43:02,270
what frames or what pages to remove from

2156
00:43:02,270 --> 00:43:02,280
 

2157
00:43:02,280 --> 00:43:04,280
our buffer pool right it's super easy

2158
00:43:04,280 --> 00:43:04,290
 

2159
00:43:04,290 --> 00:43:06,140
when everything's and we have enough

2160
00:43:06,140 --> 00:43:06,150
 

2161
00:43:06,150 --> 00:43:07,340
memory because we just fetch the pages

2162
00:43:07,340 --> 00:43:07,350
 

2163
00:43:07,350 --> 00:43:09,290
in and we don't worry about you know

2164
00:43:09,290 --> 00:43:09,300
 

2165
00:43:09,300 --> 00:43:11,080
making new space but obviously again we

2166
00:43:11,080 --> 00:43:11,090
 

2167
00:43:11,090 --> 00:43:14,210
our database may be larger than the

2168
00:43:14,210 --> 00:43:14,220
 

2169
00:43:14,220 --> 00:43:15,830
amount of memory we have so we have to

2170
00:43:15,830 --> 00:43:15,840
 

2171
00:43:15,840 --> 00:43:17,450
make decisions about how to make a room

2172
00:43:17,450 --> 00:43:17,460
 

2173
00:43:17,460 --> 00:43:20,510
for new pages we want to fetch and and

2174
00:43:20,510 --> 00:43:20,520
 

2175
00:43:20,520 --> 00:43:22,460
and victim our buffer pool to put the

2176
00:43:22,460 --> 00:43:22,470
 

2177
00:43:22,470 --> 00:43:27,290
new one in so the there's a couple sort

2178
00:43:27,290 --> 00:43:27,300
 

2179
00:43:27,300 --> 00:43:28,640
of trade-offs or things we're gonna care

2180
00:43:28,640 --> 00:43:28,650
 

2181
00:43:28,650 --> 00:43:31,130
about and our replacement policy all

2182
00:43:31,130 --> 00:43:31,140
 

2183
00:43:31,140 --> 00:43:32,990
right one is obviously correctness and

2184
00:43:32,990 --> 00:43:33,000
 

2185
00:43:33,000 --> 00:43:35,420
by correctness I mean that we don't want

2186
00:43:35,420 --> 00:43:35,430
 

2187
00:43:35,430 --> 00:43:36,710
to write up you know we don't want to

2188
00:43:36,710 --> 00:43:36,720
 

2189
00:43:36,720 --> 00:43:38,690
throw away data that a transaction just

2190
00:43:38,690 --> 00:43:38,700
 

2191
00:43:38,700 --> 00:43:40,310
updated or query just updated before

2192
00:43:40,310 --> 00:43:40,320
 

2193
00:43:40,320 --> 00:43:42,230
actually making out the disk right

2194
00:43:42,230 --> 00:43:42,240
 

2195
00:43:42,240 --> 00:43:44,750
because then we lose everything we want

2196
00:43:44,750 --> 00:43:44,760
 

2197
00:43:44,760 --> 00:43:48,230
our replacement policy to be accurate in

2198
00:43:48,230 --> 00:43:48,240

2199
00:43:48,240 --> 00:43:50,600
that we don't want to do the dumbest

2200
00:43:50,600 --> 00:43:50,610
 

2201
00:43:50,610 --> 00:43:51,980
thing and like a Vick the most important

2202
00:43:51,980 --> 00:43:51,990
 

2203
00:43:51,990 --> 00:43:54,710
page because you know we're gonna need

2204
00:43:54,710 --> 00:43:54,720

2205
00:43:54,720 --> 00:43:56,600
it right away we want to have a good

2206
00:43:56,600 --> 00:43:56,610
 

2207
00:43:56,610 --> 00:43:58,010
estimation of making decisions about

2208
00:43:58,010 --> 00:43:58,020
 

2209
00:43:58,020 --> 00:44:00,110
pages that we know we think we're not

2210
00:44:00,110 --> 00:44:00,120
 

2211
00:44:00,120 --> 00:44:01,250
gonna need so we go ahead and throw them

2212
00:44:01,250 --> 00:44:01,260
 

2213
00:44:01,260 --> 00:44:05,870
away we want this be fast because as I

2214
00:44:05,870 --> 00:44:05,880
 

2215
00:44:05,880 --> 00:44:07,850
said when I do a lookup into the page

2216
00:44:07,850 --> 00:44:07,860
 

2217
00:44:07,860 --> 00:44:09,800
table and like my page is not there and

2218
00:44:09,800 --> 00:44:09,810
 

2219
00:44:09,810 --> 00:44:11,600
then I need to decide what page to

2220
00:44:11,600 --> 00:44:11,610
 

2221
00:44:11,610 --> 00:44:14,210
remove I have to figure out what page I

2222
00:44:14,210 --> 00:44:14,220
 

2223
00:44:14,220 --> 00:44:16,460
want to take out and put a latch there

2224
00:44:16,460 --> 00:44:16,470
 

2225
00:44:16,470 --> 00:44:18,380
so I'm holding a latch while I'm running

2226
00:44:18,380 --> 00:44:18,390
 

2227
00:44:18,390 --> 00:44:21,410
this for placement policy and if my

2228
00:44:21,410 --> 00:44:21,420
 

2229
00:44:21,420 --> 00:44:23,960
proposed policy is like you know NP

2230
00:44:23,960 --> 00:44:23,970
 

2231
00:44:23,970 --> 00:44:26,000
complete and takes days to run then

2232
00:44:26,000 --> 00:44:26,010
 

2233
00:44:26,010 --> 00:44:27,320
that's bad because I'm holding that

2234
00:44:27,320 --> 00:44:27,330
 

2235
00:44:27,330 --> 00:44:29,480
latch during that entire time so you

2236
00:44:29,480 --> 00:44:29,490
 

2237
00:44:29,490 --> 00:44:30,470
want this thing to be as fast as

2238
00:44:30,470 --> 00:44:30,480
 

2239
00:44:30,480 --> 00:44:32,900
possible and of course we want to have a

2240
00:44:32,900 --> 00:44:32,910
 

2241
00:44:32,910 --> 00:44:33,980
low metadata overhead

2242
00:44:33,980 --> 00:44:33,990

2243
00:44:33,990 --> 00:44:35,210
cuz we don't want to at the store you

2244
00:44:35,210 --> 00:44:35,220
 

2245
00:44:35,220 --> 00:44:37,160
know a ton of extra data then maybe

2246
00:44:37,160 --> 00:44:37,170
 

2247
00:44:37,170 --> 00:44:39,080
larger than the echo page itself just to

2248
00:44:39,080 --> 00:44:39,090
 

2249
00:44:39,090 --> 00:44:41,050
figure out what page we want to remove

2250
00:44:41,050 --> 00:44:41,060
 

2251
00:44:41,060 --> 00:44:44,030
so this cached replacement policy of

2252
00:44:44,030 --> 00:44:44,040
 

2253
00:44:44,040 --> 00:44:45,230
buffer placement policy this is like one

2254
00:44:45,230 --> 00:44:45,240
 

2255
00:44:45,240 --> 00:44:47,180
of the oldest problems in CS the

2256
00:44:47,180 --> 00:44:47,190
 

2257
00:44:47,190 --> 00:44:48,859
literature goes back to like the 1950s

2258
00:44:48,859 --> 00:44:48,869
 

2259
00:44:48,869 --> 00:44:53,600
1960s there are some things that that we

2260
00:44:53,600 --> 00:44:53,610
 

2261
00:44:53,610 --> 00:44:55,520
can that we can apply from newer systems

2262
00:44:55,520 --> 00:44:55,530
 

2263
00:44:55,530 --> 00:44:58,040
and newer would be like 1990s that we

2264
00:44:58,040 --> 00:44:58,050
 

2265
00:44:58,050 --> 00:45:00,680
can do smarter things than sort of the

2266
00:45:00,680 --> 00:45:00,690
 

2267
00:45:00,690 --> 00:45:02,180
general approach that everyone uses but

2268
00:45:02,180 --> 00:45:02,190
 

2269
00:45:02,190 --> 00:45:03,920
we'll just go over high levels what

2270
00:45:03,920 --> 00:45:03,930
 

2271
00:45:03,930 --> 00:45:06,500
these other better ways to implement is

2272
00:45:06,500 --> 00:45:06,510
 

2273
00:45:06,510 --> 00:45:08,210
the better way the abilities things are

2274
00:45:08,210 --> 00:45:08,220
 

2275
00:45:08,220 --> 00:45:11,950
so the the most commonly used policy is

2276
00:45:11,950 --> 00:45:11,960
 

2277
00:45:11,960 --> 00:45:15,050
LRU or least recently used and all we

2278
00:45:15,050 --> 00:45:15,060
 

2279
00:45:15,060 --> 00:45:16,640
really do here is just mainly maintain a

2280
00:45:16,640 --> 00:45:16,650
 

2281
00:45:16,650 --> 00:45:19,220
timestamp of when a page was accessed by

2282
00:45:19,220 --> 00:45:19,230
 

2283
00:45:19,230 --> 00:45:21,620
a query and then when we have to select

2284
00:45:21,620 --> 00:45:21,630
 

2285
00:45:21,630 --> 00:45:23,540
a page to a bit from our buffer pool we

2286
00:45:23,540 --> 00:45:23,550
 

2287
00:45:23,550 --> 00:45:26,930
just choose the one with the the oldest

2288
00:45:26,930 --> 00:45:26,940
 

2289
00:45:26,940 --> 00:45:31,100
timestamp right pretty easy to speed

2290
00:45:31,100 --> 00:45:31,110
 

2291
00:45:31,110 --> 00:45:32,720
things up and what maybe what we can do

2292
00:45:32,720 --> 00:45:32,730
 

2293
00:45:32,730 --> 00:45:35,660
in our in our page table or our buffer

2294
00:45:35,660 --> 00:45:35,670

2295
00:45:35,670 --> 00:45:38,030
pool list frames we can maybe sort them

2296
00:45:38,030 --> 00:45:38,040
 

2297
00:45:38,040 --> 00:45:40,970
ahead of time by the by their timestamp

2298
00:45:40,970 --> 00:45:40,980
 

2299
00:45:40,980 --> 00:45:43,400
and just always pop things out and move

2300
00:45:43,400 --> 00:45:43,410
 

2301
00:45:43,410 --> 00:45:44,930
it to the end as every time their access

2302
00:45:44,930 --> 00:45:44,940
 

2303
00:45:44,940 --> 00:45:46,550
so that way when it comes time to evict

2304
00:45:46,550 --> 00:45:46,560
 

2305
00:45:46,560 --> 00:45:47,900
something we just look at the head of

2306
00:45:47,900 --> 00:45:47,910
 

2307
00:45:47,910 --> 00:45:50,240
that list and is those the pages we want

2308
00:45:50,240 --> 00:45:50,250
 

2309
00:45:50,250 --> 00:45:54,109
to go ahead and remove another approach

2310
00:45:54,109 --> 00:45:54,119
 

2311
00:45:54,119 --> 00:45:56,450
that's commonly used is called clock you

2312
00:45:56,450 --> 00:45:56,460
 

2313
00:45:56,460 --> 00:45:59,180
think clock is just an approximation of

2314
00:45:59,180 --> 00:45:59,190
 

2315
00:45:59,190 --> 00:46:02,599
LRU I know this is used in a couple

2316
00:46:02,599 --> 00:46:02,609
 

2317
00:46:02,609 --> 00:46:04,280
systems there's actually used also in

2318
00:46:04,280 --> 00:46:04,290
 

2319
00:46:04,290 --> 00:46:07,970
Linux roughly for their page page

2320
00:46:07,970 --> 00:46:07,980
 

2321
00:46:07,980 --> 00:46:10,370
replacement policy so the basic idea is

2322
00:46:10,370 --> 00:46:10,380
 

2323
00:46:10,380 --> 00:46:12,320
that you're gonna maintain a simple bit

2324
00:46:12,320 --> 00:46:12,330
 

2325
00:46:12,330 --> 00:46:15,050
for every single page that tells you

2326
00:46:15,050 --> 00:46:15,060
 

2327
00:46:15,060 --> 00:46:17,060
whether it has been accessed since the

2328
00:46:17,060 --> 00:46:17,070
 

2329
00:46:17,070 --> 00:46:19,640
last time you checked it and then every

2330
00:46:19,640 --> 00:46:19,650
 

2331
00:46:19,650 --> 00:46:21,349
time you do access it you just set that

2332
00:46:21,349 --> 00:46:21,359
 

2333
00:46:21,359 --> 00:46:23,120
bit to one and then there's gonna be

2334
00:46:23,120 --> 00:46:23,130
 

2335
00:46:23,130 --> 00:46:24,230
this clock hand that's going to go

2336
00:46:24,230 --> 00:46:24,240
 

2337
00:46:24,240 --> 00:46:26,060
around and the circular buffer and just

2338
00:46:26,060 --> 00:46:26,070
 

2339
00:46:26,070 --> 00:46:28,880
checks every you know every page to see

2340
00:46:28,880 --> 00:46:28,890
 

2341
00:46:28,890 --> 00:46:30,260
whether it was accessed the last time it

2342
00:46:30,260 --> 00:46:30,270
 

2343
00:46:30,270 --> 00:46:33,950
was the clock hand went around so say we

2344
00:46:33,950 --> 00:46:33,960

2345
00:46:33,960 --> 00:46:35,570
have four buffers like this or pages

2346
00:46:35,570 --> 00:46:35,580
 

2347
00:46:35,580 --> 00:46:39,770
like this 1 2 3 4 every page is gonna

2348
00:46:39,770 --> 00:46:39,780
 

2349
00:46:39,780 --> 00:46:42,770
have a reference yet and initially it's

2350
00:46:42,770 --> 00:46:42,780
 

2351
00:46:42,780 --> 00:46:47,180
always set to 0 so when I start off if I

2352
00:46:47,180 --> 00:46:47,190
 

2353
00:46:47,190 --> 00:46:47,870
if I

2354
00:46:47,870 --> 00:46:47,880

2355
00:46:47,880 --> 00:46:49,460
QWERTY access to this page I just go

2356
00:46:49,460 --> 00:46:49,470
 

2357
00:46:49,470 --> 00:46:52,100
ahead and flip a bit to one and then now

2358
00:46:52,100 --> 00:46:52,110
 

2359
00:46:52,110 --> 00:46:54,260
there's this clock hand that gets moves

2360
00:46:54,260 --> 00:46:54,270

2361
00:46:54,270 --> 00:46:55,940
around in a circular fashion every

2362
00:46:55,940 --> 00:46:55,950
 

2363
00:46:55,950 --> 00:46:57,640
single time I need to go a Bic to page

2364
00:46:57,640 --> 00:46:57,650
 

2365
00:46:57,650 --> 00:47:00,200
it just you know looks at the next one

2366
00:47:00,200 --> 00:47:00,210
 

2367
00:47:00,210 --> 00:47:02,900
and decides whether the bid is zero if

2368
00:47:02,900 --> 00:47:02,910
 

2369
00:47:02,910 --> 00:47:04,970
yes it can be evicted if it's one then

2370
00:47:04,970 --> 00:47:04,980
 

2371
00:47:04,980 --> 00:47:07,160
it keeps it but it resets it resets it

2372
00:47:07,160 --> 00:47:07,170
 

2373
00:47:07,170 --> 00:47:09,830
to zero so the very beginning the clock

2374
00:47:09,830 --> 00:47:09,840
 

2375
00:47:09,840 --> 00:47:11,960
says I need to fix something so I'm

2376
00:47:11,960 --> 00:47:11,970
 

2377
00:47:11,970 --> 00:47:15,680
pointing to the first guy I said it's

2378
00:47:15,680 --> 00:47:15,690
 

2379
00:47:15,690 --> 00:47:17,510
set the one so I know I don't want to

2380
00:47:17,510 --> 00:47:17,520
 

2381
00:47:17,520 --> 00:47:18,890
throw it away but I'll go ahead and set

2382
00:47:18,890 --> 00:47:18,900
 

2383
00:47:18,900 --> 00:47:21,050
it to zero so then I come down to the

2384
00:47:21,050 --> 00:47:21,060
 

2385
00:47:21,060 --> 00:47:23,690
next guy his reference counter is zero

2386
00:47:23,690 --> 00:47:23,700
 

2387
00:47:23,700 --> 00:47:25,850
so I know it's not been it has not been

2388
00:47:25,850 --> 00:47:25,860

2389
00:47:25,860 --> 00:47:27,290
accessed since the last time I came

2390
00:47:27,290 --> 00:47:27,300

2391
00:47:27,300 --> 00:47:29,210
around so it's safe for me to go ahead

2392
00:47:29,210 --> 00:47:29,220
 

2393
00:47:29,220 --> 00:47:30,980
and indict this and I can replace it

2394
00:47:30,980 --> 00:47:30,990
 

2395
00:47:30,990 --> 00:47:33,530
with with another page then I keep going

2396
00:47:33,530 --> 00:47:33,540
 

2397
00:47:33,540 --> 00:47:35,270
around the clock like this I say page

2398
00:47:35,270 --> 00:47:35,280
 

2399
00:47:35,280 --> 00:47:37,100
three and four have been accessed so I'm

2400
00:47:37,100 --> 00:47:37,110
 

2401
00:47:37,110 --> 00:47:39,470
gonna come around I keep that key page

2402
00:47:39,470 --> 00:47:39,480
 

2403
00:47:39,480 --> 00:47:42,230
three keep key page four but page one

2404
00:47:42,230 --> 00:47:42,240
 

2405
00:47:42,240 --> 00:47:44,150
has not been accessed since the lesson I

2406
00:47:44,150 --> 00:47:44,160
 

2407
00:47:44,160 --> 00:47:45,830
checked so then go ahead and throw that

2408
00:47:45,830 --> 00:47:45,840
 

2409
00:47:45,840 --> 00:47:49,280
away right it's an approximation to LRU

2410
00:47:49,280 --> 00:47:49,290
 

2411
00:47:49,290 --> 00:47:50,720
because it's essentially giving you the

2412
00:47:50,720 --> 00:47:50,730
 

2413
00:47:50,730 --> 00:47:52,790
same thing but instead of saying what's

2414
00:47:52,790 --> 00:47:52,800
 

2415
00:47:52,800 --> 00:47:54,980
the global timestamps of how how things

2416
00:47:54,980 --> 00:47:54,990

2417
00:47:54,990 --> 00:47:57,860
are accessed it's just a approximation

2418
00:47:57,860 --> 00:47:57,870

2419
00:47:57,870 --> 00:47:59,600
of whether was access since the last

2420
00:47:59,600 --> 00:47:59,610
 

2421
00:47:59,610 --> 00:48:03,770
time but I checked all right let's

2422
00:48:03,770 --> 00:48:03,780
 

2423
00:48:03,780 --> 00:48:05,870
metadata less overhead of maintaining

2424
00:48:05,870 --> 00:48:05,880
 

2425
00:48:05,880 --> 00:48:08,000
the link lists a lot of systems do this

2426
00:48:08,000 --> 00:48:08,010
 

2427
00:48:08,010 --> 00:48:10,240
because it's pretty easy

2428
00:48:10,240 --> 00:48:10,250
 

2429
00:48:10,250 --> 00:48:13,640
the problem with LRU and clock is that

2430
00:48:13,640 --> 00:48:13,650

2431
00:48:13,650 --> 00:48:16,100
they are susceptible to the to the issue

2432
00:48:16,100 --> 00:48:16,110

2433
00:48:16,110 --> 00:48:18,830
of what's called sequential flooding so

2434
00:48:18,830 --> 00:48:18,840
 

2435
00:48:18,840 --> 00:48:20,000
this is the examples I was showing

2436
00:48:20,000 --> 00:48:20,010

2437
00:48:20,010 --> 00:48:21,710
before where if we were doing a

2438
00:48:21,710 --> 00:48:21,720
 

2439
00:48:21,720 --> 00:48:24,320
sequential scan over it over over the

2440
00:48:24,320 --> 00:48:24,330
 

2441
00:48:24,330 --> 00:48:28,640
entire table the pages I just read in to

2442
00:48:28,640 --> 00:48:28,650
 

2443
00:48:28,650 --> 00:48:30,560
you know as I was scanning down is

2444
00:48:30,560 --> 00:48:30,570
 

2445
00:48:30,570 --> 00:48:32,570
actually the most useless page that I

2446
00:48:32,570 --> 00:48:32,580
 

2447
00:48:32,580 --> 00:48:35,570
actually need and now if I have a bunch

2448
00:48:35,570 --> 00:48:35,580

2449
00:48:35,580 --> 00:48:37,580
of other pages that the may being

2450
00:48:37,580 --> 00:48:37,590
 

2451
00:48:37,590 --> 00:48:39,830
accessed a lot by other queries the

2452
00:48:39,830 --> 00:48:39,840
 

2453
00:48:39,840 --> 00:48:41,300
semental scan is going to go through and

2454
00:48:41,300 --> 00:48:41,310
 

2455
00:48:41,310 --> 00:48:42,530
blow the air all those pages away

2456
00:48:42,530 --> 00:48:42,540
 

2457
00:48:42,540 --> 00:48:44,540
because it's gonna fetch in a bunch of

2458
00:48:44,540 --> 00:48:44,550
 

2459
00:48:44,550 --> 00:48:47,080
pages and then not need them anymore

2460
00:48:47,080 --> 00:48:47,090
 

2461
00:48:47,090 --> 00:48:48,950
right your since you're polluting the

2462
00:48:48,950 --> 00:48:48,960
 

2463
00:48:48,960 --> 00:48:51,080
buffer pool with pages that you need

2464
00:48:51,080 --> 00:48:51,090
 

2465
00:48:51,090 --> 00:48:52,430
once and then you don't need to ever

2466
00:48:52,430 --> 00:48:52,440
 

2467
00:48:52,440 --> 00:48:53,620
again

2468
00:48:53,620 --> 00:48:53,630

2469
00:48:53,630 --> 00:48:56,950
so in this case here LRU is actually the

2470
00:48:56,950 --> 00:48:56,960
 

2471
00:48:56,960 --> 00:48:59,200
exact opposite of what you want the

2472
00:48:59,200 --> 00:48:59,210
 

2473
00:48:59,210 --> 00:49:00,790
policy you really want is the most

2474
00:49:00,790 --> 00:49:00,800
 

2475
00:49:00,800 --> 00:49:03,220
recently used least in the case of the

2476
00:49:03,220 --> 00:49:03,230
 

2477
00:49:03,230 --> 00:49:06,910
structural scan right so to sort of

2478
00:49:06,910 --> 00:49:06,920
 

2479
00:49:06,920 --> 00:49:09,040
illustrate this I have one query when

2480
00:49:09,040 --> 00:49:09,050
 

2481
00:49:09,050 --> 00:49:10,510
students when shil skynyrd I have one

2482
00:49:10,510 --> 00:49:10,520
 

2483
00:49:10,520 --> 00:49:12,970
query a sort of a one query that's going

2484
00:49:12,970 --> 00:49:12,980
 

2485
00:49:12,980 --> 00:49:15,190
to access a single tuple all right and

2486
00:49:15,190 --> 00:49:15,200
 

2487
00:49:15,200 --> 00:49:17,410
say that's in page one I go ahead and

2488
00:49:17,410 --> 00:49:17,420
 

2489
00:49:17,420 --> 00:49:18,640
fetch it and make them into my buffer

2490
00:49:18,640 --> 00:49:18,650
 

2491
00:49:18,650 --> 00:49:19,810
pool and I'm done

2492
00:49:19,810 --> 00:49:19,820

2493
00:49:19,820 --> 00:49:23,590
page one it goes away now I started xre

2494
00:49:23,590 --> 00:49:23,600
 

2495
00:49:23,600 --> 00:49:25,990
query one goes away queries two starts

2496
00:49:25,990 --> 00:49:26,000
 

2497
00:49:26,000 --> 00:49:28,690
executing and it does the sequential

2498
00:49:28,690 --> 00:49:28,700
 

2499
00:49:28,700 --> 00:49:30,100
scan and again it's gonna fill up the

2500
00:49:30,100 --> 00:49:30,110
 

2501
00:49:30,110 --> 00:49:31,240
bumper pool with all the pages that it

2502
00:49:31,240 --> 00:49:31,250
 

2503
00:49:31,250 --> 00:49:34,210
reads so now I get to page three I need

2504
00:49:34,210 --> 00:49:34,220
 

2505
00:49:34,220 --> 00:49:35,950
to decide what page I want a victim

2506
00:49:35,950 --> 00:49:35,960
 

2507
00:49:35,960 --> 00:49:38,170
using LRU or clock it'll be page zero

2508
00:49:38,170 --> 00:49:38,180
 

2509
00:49:38,180 --> 00:49:39,790
because that's the one that was last the

2510
00:49:39,790 --> 00:49:39,800
 

2511
00:49:39,800 --> 00:49:42,190
least recently used I go ahead and evict

2512
00:49:42,190 --> 00:49:42,200
 

2513
00:49:42,200 --> 00:49:44,860
that but now another query comes along

2514
00:49:44,860 --> 00:49:44,870
 

2515
00:49:44,870 --> 00:49:46,510
but does the exact same thing that the

2516
00:49:46,510 --> 00:49:46,520
 

2517
00:49:46,520 --> 00:49:48,820
first guy did and it once

2518
00:49:48,820 --> 00:49:48,830
 

2519
00:49:48,830 --> 00:49:51,730
page page zero but that just got evicted

2520
00:49:51,730 --> 00:49:51,740
 

2521
00:49:51,740 --> 00:49:54,610
so it'll choose page one choose

2522
00:49:54,610 --> 00:49:54,620
 

2523
00:49:54,620 --> 00:49:56,080
something else so again I have to do an

2524
00:49:56,080 --> 00:49:56,090
 

2525
00:49:56,090 --> 00:49:58,690
additional read for something that I

2526
00:49:58,690 --> 00:49:58,700
 

2527
00:49:58,700 --> 00:50:03,340
just threw away so the ways to avoid

2528
00:50:03,340 --> 00:50:03,350
 

2529
00:50:03,350 --> 00:50:06,210
this is to sort of special case the

2530
00:50:06,210 --> 00:50:06,220
 

2531
00:50:06,220 --> 00:50:09,520
scruncho scan and recognize that it's

2532
00:50:09,520 --> 00:50:09,530
 

2533
00:50:09,530 --> 00:50:10,750
doing the scruncher scan and it's

2534
00:50:10,750 --> 00:50:10,760

2535
00:50:10,760 --> 00:50:13,090
unlikely to read that data again now

2536
00:50:13,090 --> 00:50:13,100
 

2537
00:50:13,100 --> 00:50:14,200
what other query comes along there's the

2538
00:50:14,200 --> 00:50:14,210
 

2539
00:50:14,210 --> 00:50:15,820
same special scan that's unavoidable

2540
00:50:15,820 --> 00:50:15,830
 

2541
00:50:15,830 --> 00:50:17,470
we'll have to go fetch those things in

2542
00:50:17,470 --> 00:50:17,480
 

2543
00:50:17,480 --> 00:50:19,990
but if I'm not doing these through if I

2544
00:50:19,990 --> 00:50:20,000
 

2545
00:50:20,000 --> 00:50:21,550
have a skewed workload where I'm always

2546
00:50:21,550 --> 00:50:21,560

2547
00:50:21,560 --> 00:50:23,020
trying to maybe access the first page or

2548
00:50:23,020 --> 00:50:23,030
 

2549
00:50:23,030 --> 00:50:25,480
for small number of pages I don't want

2550
00:50:25,480 --> 00:50:25,490
 

2551
00:50:25,490 --> 00:50:28,960
to evict those guys so three different

2552
00:50:28,960 --> 00:50:28,970

2553
00:50:28,970 --> 00:50:31,560
ways to handle this or through LRU Kay

2554
00:50:31,560 --> 00:50:31,570
 

2555
00:50:31,570 --> 00:50:35,080
private priorities and localization so

2556
00:50:35,080 --> 00:50:35,090
 

2557
00:50:35,090 --> 00:50:38,230
LRU K is it's basically like LRU but and

2558
00:50:38,230 --> 00:50:38,240
 

2559
00:50:38,240 --> 00:50:39,910
then rather than just keeping a single

2560
00:50:39,910 --> 00:50:39,920
 

2561
00:50:39,920 --> 00:50:42,310
timestamp of when the tuple was last

2562
00:50:42,310 --> 00:50:42,320
 

2563
00:50:42,320 --> 00:50:44,470
accessed I'm actually gonna keep a

2564
00:50:44,470 --> 00:50:44,480
 

2565
00:50:44,480 --> 00:50:47,530
history of all these accesses and then

2566
00:50:47,530 --> 00:50:47,540
 

2567
00:50:47,540 --> 00:50:49,180
from the history I can then compute the

2568
00:50:49,180 --> 00:50:49,190
 

2569
00:50:49,190 --> 00:50:52,060
intervals of the time from when the

2570
00:50:52,060 --> 00:50:52,070
 

2571
00:50:52,070 --> 00:50:54,160
tuple was accessed the first you know at

2572
00:50:54,160 --> 00:50:54,170
 

2573
00:50:54,170 --> 00:50:55,660
one point and then how long it took

2574
00:50:55,660 --> 00:50:55,670
 

2575
00:50:55,670 --> 00:50:58,480
before it was accessed again and now the

2576
00:50:58,480 --> 00:50:58,490
 

2577
00:50:58,490 --> 00:51:00,370
idea here is I can use this history to

2578
00:51:00,370 --> 00:51:00,380
 

2579
00:51:00,380 --> 00:51:03,400
estimate what's the likelihood that this

2580
00:51:03,400 --> 00:51:03,410

2581
00:51:03,410 --> 00:51:04,930
tuples can be accessed in the near

2582
00:51:04,930 --> 00:51:04,940
 

2583
00:51:04,940 --> 00:51:07,530
future and if that at that time

2584
00:51:07,530 --> 00:51:07,540
 

2585
00:51:07,540 --> 00:51:09,090
greater than all the other times then

2586
00:51:09,090 --> 00:51:09,100
 

2587
00:51:09,100 --> 00:51:11,660
that's the one I actually want a bit

2588
00:51:11,660 --> 00:51:11,670
 

2589
00:51:11,670 --> 00:51:13,950
right so my my example I showed in the

2590
00:51:13,950 --> 00:51:13,960
 

2591
00:51:13,960 --> 00:51:16,710
last slide the the the first tuple is

2592
00:51:16,710 --> 00:51:16,720
 

2593
00:51:16,720 --> 00:51:18,390
want all those query the first the first

2594
00:51:18,390 --> 00:51:18,400

2595
00:51:18,400 --> 00:51:20,190
and third query were accessing the first

2596
00:51:20,190 --> 00:51:20,200
 

2597
00:51:20,200 --> 00:51:22,410
page so if I recognize at a history of

2598
00:51:22,410 --> 00:51:22,420
 

2599
00:51:22,420 --> 00:51:23,970
that oh I'm gonna access this page over

2600
00:51:23,970 --> 00:51:23,980
 

2601
00:51:23,980 --> 00:51:25,950
and over again and I know how long in

2602
00:51:25,950 --> 00:51:25,960
 

2603
00:51:25,960 --> 00:51:27,330
between I'm gonna access those things

2604
00:51:27,330 --> 00:51:27,340
 

2605
00:51:27,340 --> 00:51:29,550
then that first page we actually would

2606
00:51:29,550 --> 00:51:29,560
 

2607
00:51:29,560 --> 00:51:31,260
be considered more important and should

2608
00:51:31,260 --> 00:51:31,270
 

2609
00:51:31,270 --> 00:51:33,540
stay in memory whereas the other ones

2610
00:51:33,540 --> 00:51:33,550
 

2611
00:51:33,550 --> 00:51:35,190
were used for the torrential scan and

2612
00:51:35,190 --> 00:51:35,200
 

2613
00:51:35,200 --> 00:51:36,540
it'll be a long time before they're

2614
00:51:36,540 --> 00:51:36,550
 

2615
00:51:36,550 --> 00:51:37,590
accessed again so I can go ahead and

2616
00:51:37,590 --> 00:51:37,600
 

2617
00:51:37,600 --> 00:51:41,130
indict those right and so the K and L

2618
00:51:41,130 --> 00:51:41,140
 

2619
00:51:41,140 --> 00:51:43,380
are UK basically says how much of a

2620
00:51:43,380 --> 00:51:43,390
 

2621
00:51:43,390 --> 00:51:46,080
history do you want to maintain right

2622
00:51:46,080 --> 00:51:46,090
 

2623
00:51:46,090 --> 00:51:47,370
because you could keep infinite history

2624
00:51:47,370 --> 00:51:47,380

2625
00:51:47,380 --> 00:51:48,720
of this but then that's again that's a

2626
00:51:48,720 --> 00:51:48,730
 

2627
00:51:48,730 --> 00:51:51,630
but the large storage overhead so

2628
00:51:51,630 --> 00:51:51,640
 

2629
00:51:51,640 --> 00:51:55,860
typically typically K equals one is it's

2630
00:51:55,860 --> 00:51:55,870
 

2631
00:51:55,870 --> 00:51:57,330
a very common approach for people to I

2632
00:51:57,330 --> 00:51:57,340
 

2633
00:51:57,340 --> 00:51:59,310
do this right and it works reasonably

2634
00:51:59,310 --> 00:51:59,320
 

2635
00:51:59,320 --> 00:52:04,530
well another way to handle this it's

2636
00:52:04,530 --> 00:52:04,540
 

2637
00:52:04,540 --> 00:52:08,010
called localization where you you rather

2638
00:52:08,010 --> 00:52:08,020

2639
00:52:08,020 --> 00:52:10,770
than having the the central scan access

2640
00:52:10,770 --> 00:52:10,780
 

2641
00:52:10,780 --> 00:52:13,110
the global buffer pool and pollute it

2642
00:52:13,110 --> 00:52:13,120
 

2643
00:52:13,120 --> 00:52:15,090
with the pages I want to read you can

2644
00:52:15,090 --> 00:52:15,100
 

2645
00:52:15,100 --> 00:52:17,490
actually just keep the pages that it

2646
00:52:17,490 --> 00:52:17,500
 

2647
00:52:17,500 --> 00:52:20,250
reads you can keep you can sort of

2648
00:52:20,250 --> 00:52:20,260
 

2649
00:52:20,260 --> 00:52:23,610
confine the query to a subset of the

2650
00:52:23,610 --> 00:52:23,620
 

2651
00:52:23,620 --> 00:52:26,460
buffer pool and don't let it pollute the

2652
00:52:26,460 --> 00:52:26,470
 

2653
00:52:26,470 --> 00:52:29,250
entire thing so my example I shared in

2654
00:52:29,250 --> 00:52:29,260
 

2655
00:52:29,260 --> 00:52:30,720
Postgres remember I showed that the

2656
00:52:30,720 --> 00:52:30,730
 

2657
00:52:30,730 --> 00:52:33,450
number of reads versus hits the number

2658
00:52:33,450 --> 00:52:33,460
 

2659
00:52:33,460 --> 00:52:34,830
of hits was only 32

2660
00:52:34,830 --> 00:52:34,840
 

2661
00:52:34,840 --> 00:52:38,280
this is because Postgres when a first

2662
00:52:38,280 --> 00:52:38,290
 

2663
00:52:38,290 --> 00:52:40,560
execute essential scan it only gives you

2664
00:52:40,560 --> 00:52:40,570
 

2665
00:52:40,570 --> 00:52:43,800
a 32-page local buffer for you to put

2666
00:52:43,800 --> 00:52:43,810

2667
00:52:43,810 --> 00:52:45,410
your essential scan pages in there and

2668
00:52:45,410 --> 00:52:45,420
 

2669
00:52:45,420 --> 00:52:47,910
that again that avoids polluting the

2670
00:52:47,910 --> 00:52:47,920
 

2671
00:52:47,920 --> 00:52:55,230
entire Buffalo space the the way some

2672
00:52:55,230 --> 00:52:55,240
 

2673
00:52:55,240 --> 00:52:57,270
systems in the case of Informix will

2674
00:52:57,270 --> 00:52:57,280
 

2675
00:52:57,280 --> 00:52:59,640
have a private memory that's not in the

2676
00:52:59,640 --> 00:52:59,650
 

2677
00:52:59,650 --> 00:53:00,240
buffer pool

2678
00:53:00,240 --> 00:53:00,250

2679
00:53:00,250 --> 00:53:01,950
I think post ghost actually backs them

2680
00:53:01,950 --> 00:53:01,960
 

2681
00:53:01,960 --> 00:53:03,120
with pages that are in the purple as

2682
00:53:03,120 --> 00:53:03,130
 

2683
00:53:03,130 --> 00:53:04,800
well right

2684
00:53:04,800 --> 00:53:04,810
 

2685
00:53:04,810 --> 00:53:08,580
and not one ways not better than other

2686
00:53:08,580 --> 00:53:08,590
 

2687
00:53:08,590 --> 00:53:10,020
the avoiding had to go the patient

2688
00:53:10,020 --> 00:53:10,030
 

2689
00:53:10,030 --> 00:53:11,550
obviously is faster because you don't

2690
00:53:11,550 --> 00:53:11,560
 

2691
00:53:11,560 --> 00:53:17,250
take latches but at a high level the how

2692
00:53:17,250 --> 00:53:17,260
 

2693
00:53:17,260 --> 00:53:18,990
it affects the proper pool is is it

2694
00:53:18,990 --> 00:53:19,000
 

2695
00:53:19,000 --> 00:53:21,000
roughly the same whether it's local or

2696
00:53:21,000 --> 00:53:21,010
 

2697
00:53:21,010 --> 00:53:24,660
global the last approach to use priority

2698
00:53:24,660 --> 00:53:24,670
 

2699
00:53:24,670 --> 00:53:26,849
hints and this is where you tell the

2700
00:53:26,849 --> 00:53:26,859
 

2701
00:53:26,859 --> 00:53:28,710
buffer pools something about the context

2702
00:53:28,710 --> 00:53:28,720
 

2703
00:53:28,720 --> 00:53:30,240
about how the pages were access are what

2704
00:53:30,240 --> 00:53:30,250
 

2705
00:53:30,250 --> 00:53:32,550
actually was inside of them so we saw a

2706
00:53:32,550 --> 00:53:32,560
 

2707
00:53:32,560 --> 00:53:34,140
little bit already when we talked about

2708
00:53:34,140 --> 00:53:34,150
 

2709
00:53:34,150 --> 00:53:35,520
having different buffer pool instances

2710
00:53:35,520 --> 00:53:35,530
 

2711
00:53:35,530 --> 00:53:37,590
that were allocated for either data

2712
00:53:37,590 --> 00:53:37,600
 

2713
00:53:37,600 --> 00:53:41,130
pages or index pages I began going more

2714
00:53:41,130 --> 00:53:41,140
 

2715
00:53:41,140 --> 00:53:42,960
fine-grained than that and say well how

2716
00:53:42,960 --> 00:53:42,970

2717
00:53:42,970 --> 00:53:45,510
you know it may be an index page or but

2718
00:53:45,510 --> 00:53:45,520
 

2719
00:53:45,520 --> 00:53:46,710
how is it actually gonna be accessed

2720
00:53:46,710 --> 00:53:46,720
 

2721
00:53:46,720 --> 00:53:49,770
again in the future right and then this

2722
00:53:49,770 --> 00:53:49,780
 

2723
00:53:49,780 --> 00:53:51,270
allows the poppable manager to then make

2724
00:53:51,270 --> 00:53:51,280

2725
00:53:51,280 --> 00:53:54,000
decisions about whether you know whether

2726
00:53:54,000 --> 00:53:54,010
 

2727
00:53:54,010 --> 00:53:55,710
one page should be evicted versus

2728
00:53:55,710 --> 00:53:55,720
 

2729
00:53:55,720 --> 00:53:58,470
another so let's say that we have an

2730
00:53:58,470 --> 00:53:58,480
 

2731
00:53:58,480 --> 00:54:00,090
index and gave me a we have index pages

2732
00:54:00,090 --> 00:54:00,100
 

2733
00:54:00,100 --> 00:54:02,580
for our nodes if we have a query that

2734
00:54:02,580 --> 00:54:02,590
 

2735
00:54:02,590 --> 00:54:05,070
wants to do an insert and say that we're

2736
00:54:05,070 --> 00:54:05,080
 

2737
00:54:05,080 --> 00:54:07,320
doing insert with a primary key that's

2738
00:54:07,320 --> 00:54:07,330
 

2739
00:54:07,330 --> 00:54:10,109
that's that's Auto incremented or it's

2740
00:54:10,109 --> 00:54:10,119
 

2741
00:54:10,119 --> 00:54:11,910
monotonically increasing so every single

2742
00:54:11,910 --> 00:54:11,920

2743
00:54:11,920 --> 00:54:13,770
tuple has ID one the next one has ID too

2744
00:54:13,770 --> 00:54:13,780
 

2745
00:54:13,780 --> 00:54:16,680
and so what we always count all right so

2746
00:54:16,680 --> 00:54:16,690
 

2747
00:54:16,690 --> 00:54:18,570
when we do these inserts what's going to

2748
00:54:18,570 --> 00:54:18,580
 

2749
00:54:18,580 --> 00:54:20,280
happen is we're gonna end up always

2750
00:54:20,280 --> 00:54:20,290
 

2751
00:54:20,290 --> 00:54:22,560
inserting to this side of the tree

2752
00:54:22,560 --> 00:54:22,570
 

2753
00:54:22,570 --> 00:54:26,730
because if it's based on ID then all the

2754
00:54:26,730 --> 00:54:26,740
 

2755
00:54:26,740 --> 00:54:28,310
new entries always end up on this side

2756
00:54:28,310 --> 00:54:28,320
 

2757
00:54:28,320 --> 00:54:30,990
so what we can do is we can may provide

2758
00:54:30,990 --> 00:54:31,000
 

2759
00:54:31,000 --> 00:54:32,370
hints to the buffer pool manager and say

2760
00:54:32,370 --> 00:54:32,380
 

2761
00:54:32,380 --> 00:54:34,680
we know that these pages are always the

2762
00:54:34,680 --> 00:54:34,690
 

2763
00:54:34,690 --> 00:54:36,420
ones that are going to access every time

2764
00:54:36,420 --> 00:54:36,430
 

2765
00:54:36,430 --> 00:54:38,220
I do an in new insert because they're

2766
00:54:38,220 --> 00:54:38,230
 

2767
00:54:38,230 --> 00:54:40,530
always on this side of the tree so they

2768
00:54:40,530 --> 00:54:40,540
 

2769
00:54:40,540 --> 00:54:41,970
should have higher priority then maybe

2770
00:54:41,970 --> 00:54:41,980
 

2771
00:54:41,980 --> 00:54:46,280
then some other pages in the index right

2772
00:54:46,280 --> 00:54:46,290
 

2773
00:54:46,290 --> 00:54:48,630
again this avoids having the problem up

2774
00:54:48,630 --> 00:54:48,640
 

2775
00:54:48,640 --> 00:54:50,190
again but since I always know I'm gonna

2776
00:54:50,190 --> 00:54:50,200
 

2777
00:54:50,200 --> 00:54:51,960
go down the side I don't have to a page

2778
00:54:51,960 --> 00:54:51,970
 

2779
00:54:51,970 --> 00:54:55,670
fetch every single time I do an insert

2780
00:54:55,670 --> 00:54:55,680

2781
00:54:55,680 --> 00:54:59,160
another thing you can do also too is say

2782
00:54:59,160 --> 00:54:59,170
 

2783
00:54:59,170 --> 00:55:00,930
I have queries that are just doing a

2784
00:55:00,930 --> 00:55:00,940
 

2785
00:55:00,940 --> 00:55:04,170
random key lookup anywhere in the tree

2786
00:55:04,170 --> 00:55:04,180
 

2787
00:55:04,180 --> 00:55:06,810
in that case maybe all the nodes will be

2788
00:55:06,810 --> 00:55:06,820
 

2789
00:55:06,820 --> 00:55:10,109
accessed uniformly but there's always me

2790
00:55:10,109 --> 00:55:10,119
 

2791
00:55:10,119 --> 00:55:11,910
one note or subset of nodes that I know

2792
00:55:11,910 --> 00:55:11,920
 

2793
00:55:11,920 --> 00:55:13,590
I'm always in access every single time I

2794
00:55:13,590 --> 00:55:13,600
 

2795
00:55:13,600 --> 00:55:15,810
do this lookup right and that's gonna be

2796
00:55:15,810 --> 00:55:15,820

2797
00:55:15,820 --> 00:55:18,000
the root cause because I can't get in

2798
00:55:18,000 --> 00:55:18,010
 

2799
00:55:18,010 --> 00:55:20,099
the index any other way so we

2800
00:55:20,099 --> 00:55:20,109
 

2801
00:55:20,109 --> 00:55:22,020
essentially tell the the buffer pool

2802
00:55:22,020 --> 00:55:22,030
 

2803
00:55:22,030 --> 00:55:23,280
manager that this page

2804
00:55:23,280 --> 00:55:23,290
 

2805
00:55:23,290 --> 00:55:25,050
don't even bother recording how often

2806
00:55:25,050 --> 00:55:25,060

2807
00:55:25,060 --> 00:55:26,520
its access I know that this thing should

2808
00:55:26,520 --> 00:55:26,530
 

2809
00:55:26,530 --> 00:55:28,590
always be in memory because every time I

2810
00:55:28,590 --> 00:55:28,600
 

2811
00:55:28,600 --> 00:55:30,050
do a lookup I'm always gonna go to it

2812
00:55:30,050 --> 00:55:30,060
 

2813
00:55:30,060 --> 00:55:32,580
then you can actually do even more

2814
00:55:32,580 --> 00:55:32,590
 

2815
00:55:32,590 --> 00:55:33,799
complicated things you can

2816
00:55:33,799 --> 00:55:33,809
 

2817
00:55:33,809 --> 00:55:36,380
that I have 5 indexes but everyone's

2818
00:55:36,380 --> 00:55:36,390
 

2819
00:55:36,390 --> 00:55:37,789
always going to this one so then this

2820
00:55:37,789 --> 00:55:37,799
 

2821
00:55:37,799 --> 00:55:39,499
one should have higher priority than all

2822
00:55:39,499 --> 00:55:39,509
 

2823
00:55:39,509 --> 00:55:43,160
the other indexes so this is what the

2824
00:55:43,160 --> 00:55:43,170
 

2825
00:55:43,170 --> 00:55:44,900
commercial systems do so the commercial

2826
00:55:44,900 --> 00:55:44,910
 

2827
00:55:44,910 --> 00:55:47,390
systems have all sorts of you know extra

2828
00:55:47,390 --> 00:55:47,400

2829
00:55:47,400 --> 00:55:49,039
hooks and extra information that divided

2830
00:55:49,039 --> 00:55:49,049
 

2831
00:55:49,049 --> 00:55:51,170
their bubble managers then allow them to

2832
00:55:51,170 --> 00:55:51,180
 

2833
00:55:51,180 --> 00:55:52,640
make better decisions than the open

2834
00:55:52,640 --> 00:55:52,650
 

2835
00:55:52,650 --> 00:55:54,920
source guys right this is sort what

2836
00:55:54,920 --> 00:55:54,930
 

2837
00:55:54,930 --> 00:55:56,239
separates the the sort of expensive

2838
00:55:56,239 --> 00:55:56,249
 

2839
00:55:56,249 --> 00:55:58,189
enterprise systems from the open source

2840
00:55:58,189 --> 00:55:58,199
 

2841
00:55:58,199 --> 00:56:00,289
ones open source ones like post custom

2842
00:56:00,289 --> 00:56:00,299
 

2843
00:56:00,299 --> 00:56:03,109
Icicle is still very good but the the

2844
00:56:03,109 --> 00:56:03,119
 

2845
00:56:03,119 --> 00:56:04,429
bubble manager policies in the

2846
00:56:04,429 --> 00:56:04,439
 

2847
00:56:04,439 --> 00:56:05,359
commercial ones are much more

2848
00:56:05,359 --> 00:56:05,369
 

2849
00:56:05,369 --> 00:56:09,859
sophisticated much more complex the next

2850
00:56:09,859 --> 00:56:09,869
 

2851
00:56:09,869 --> 00:56:11,449
thing I want to talk about that we've

2852
00:56:11,449 --> 00:56:11,459
 

2853
00:56:11,459 --> 00:56:14,509
sort of have been ignoring this entire

2854
00:56:14,509 --> 00:56:14,519
 

2855
00:56:14,519 --> 00:56:17,599
time is how do we deal with pages that

2856
00:56:17,599 --> 00:56:17,609
 

2857
00:56:17,609 --> 00:56:20,420
have been modified they've been dirty so

2858
00:56:20,420 --> 00:56:20,430
 

2859
00:56:20,430 --> 00:56:21,559
everything I'm sharing so far I just

2860
00:56:21,559 --> 00:56:21,569
 

2861
00:56:21,569 --> 00:56:23,749
assumed yeah I need to read a page I

2862
00:56:23,749 --> 00:56:23,759
 

2863
00:56:23,759 --> 00:56:24,949
need I need to make space I'll fix

2864
00:56:24,949 --> 00:56:24,959
 

2865
00:56:24,959 --> 00:56:27,049
another one I just throw it away right

2866
00:56:27,049 --> 00:56:27,059
 

2867
00:56:27,059 --> 00:56:28,999
that the page in the buffer pool that I

2868
00:56:28,999 --> 00:56:29,009
 

2869
00:56:29,009 --> 00:56:30,769
wanna replace I don't need to worry

2870
00:56:30,769 --> 00:56:30,779
 

2871
00:56:30,779 --> 00:56:33,049
about it about storing anything I just

2872
00:56:33,049 --> 00:56:33,059
 

2873
00:56:33,059 --> 00:56:35,170
drop it and go ahead and take its frame

2874
00:56:35,170 --> 00:56:35,180
 

2875
00:56:35,180 --> 00:56:37,640
but in real systems obviously we're

2876
00:56:37,640 --> 00:56:37,650
 

2877
00:56:37,650 --> 00:56:39,169
gonna update data means we're updating

2878
00:56:39,169 --> 00:56:39,179
 

2879
00:56:39,179 --> 00:56:42,079
data and in the pages and that means we

2880
00:56:42,079 --> 00:56:42,089
 

2881
00:56:42,089 --> 00:56:44,660
have to write them back out the disk so

2882
00:56:44,660 --> 00:56:44,670
 

2883
00:56:44,670 --> 00:56:46,339
there's this again this is another

2884
00:56:46,339 --> 00:56:46,349
 

2885
00:56:46,349 --> 00:56:47,719
example of the trade-offs we have to

2886
00:56:47,719 --> 00:56:47,729
 

2887
00:56:47,729 --> 00:56:49,219
make and our replacement policy because

2888
00:56:49,219 --> 00:56:49,229
 

2889
00:56:49,229 --> 00:56:51,819
the easiest thing to do would be just

2890
00:56:51,819 --> 00:56:51,829
 

2891
00:56:51,829 --> 00:56:55,069
only choose pages that are that are not

2892
00:56:55,069 --> 00:56:55,079
 

2893
00:56:55,079 --> 00:56:58,459
dirty and drop them right but then at

2894
00:56:58,459 --> 00:56:58,469
 

2895
00:56:58,469 --> 00:56:59,630
some point you're a bunch of pages that

2896
00:56:59,630 --> 00:56:59,640
 

2897
00:56:59,640 --> 00:57:00,890
are gonna be dirty you have to make a

2898
00:57:00,890 --> 00:57:00,900
 

2899
00:57:00,900 --> 00:57:03,019
decision or there may be pages like the

2900
00:57:03,019 --> 00:57:03,029
 

2901
00:57:03,029 --> 00:57:04,370
root of the index I'm gonna read all the

2902
00:57:04,370 --> 00:57:04,380
 

2903
00:57:04,380 --> 00:57:06,799
time and they never I may not actually

2904
00:57:06,799 --> 00:57:06,809
 

2905
00:57:06,809 --> 00:57:09,079
update it a lot but I I don't want to

2906
00:57:09,079 --> 00:57:09,089
 

2907
00:57:09,089 --> 00:57:10,009
drop it because I'm gonna have to go

2908
00:57:10,009 --> 00:57:10,019
 

2909
00:57:10,019 --> 00:57:11,749
through the index that way so there's

2910
00:57:11,749 --> 00:57:11,759
 

2911
00:57:11,759 --> 00:57:13,279
this trade-off between deciding do I

2912
00:57:13,279 --> 00:57:13,289
 

2913
00:57:13,289 --> 00:57:15,529
when I picked a page do I do the fast

2914
00:57:15,529 --> 00:57:15,539
 

2915
00:57:15,539 --> 00:57:16,969
thing this drop a page that's that's

2916
00:57:16,969 --> 00:57:16,979

2917
00:57:16,979 --> 00:57:18,739
clean or do I actually need to write

2918
00:57:18,739 --> 00:57:18,749
 

2919
00:57:18,749 --> 00:57:20,689
back a page that's dirty and be more

2920
00:57:20,689 --> 00:57:20,699
 

2921
00:57:20,699 --> 00:57:22,400
expensive but maybe a page that I know

2922
00:57:22,400 --> 00:57:22,410
 

2923
00:57:22,410 --> 00:57:24,890
I'm not gonna need in the future right

2924
00:57:24,890 --> 00:57:24,900
 

2925
00:57:24,900 --> 00:57:26,719
so cuz again if I choose a page that's

2926
00:57:26,719 --> 00:57:26,729
 

2927
00:57:26,729 --> 00:57:27,140
dirty

2928
00:57:27,140 --> 00:57:27,150

2929
00:57:27,150 --> 00:57:28,819
I have to write it out now there's a

2930
00:57:28,819 --> 00:57:28,829
 

2931
00:57:28,829 --> 00:57:30,019
whole other issue with the deal with

2932
00:57:30,019 --> 00:57:30,029
 

2933
00:57:30,029 --> 00:57:32,329
about logging and and making sure we

2934
00:57:32,329 --> 00:57:32,339
 

2935
00:57:32,339 --> 00:57:34,249
write pages at the right time but we'll

2936
00:57:34,249 --> 00:57:34,259
 

2937
00:57:34,259 --> 00:57:37,519
cover that later in the semester so one

2938
00:57:37,519 --> 00:57:37,529
 

2939
00:57:37,529 --> 00:57:39,679
way to preemptively take care of this

2940
00:57:39,679 --> 00:57:39,689
 

2941
00:57:39,689 --> 00:57:42,439
problem so that you know when we need to

2942
00:57:42,439 --> 00:57:42,449
 

2943
00:57:42,449 --> 00:57:43,549
evict a page we don't they medially

2944
00:57:43,549 --> 00:57:43,559
 

2945
00:57:43,559 --> 00:57:45,079
write it back is that we can do

2946
00:57:45,079 --> 00:57:45,089
 

2947
00:57:45,089 --> 00:57:47,690
background writing where we

2948
00:57:47,690 --> 00:57:47,700
 

2949
00:57:47,700 --> 00:57:50,240
periodically walk through the page table

2950
00:57:50,240 --> 00:57:50,250
 

2951
00:57:50,250 --> 00:57:52,730
find any dirty pages and they make a

2952
00:57:52,730 --> 00:57:52,740
 

2953
00:57:52,740 --> 00:57:54,170
decision about whether we want to go

2954
00:57:54,170 --> 00:57:54,180
 

2955
00:57:54,180 --> 00:57:55,400
ahead and write them out the disk ahead

2956
00:57:55,400 --> 00:57:55,410
 

2957
00:57:55,410 --> 00:57:58,310
of time so now when we do that we can

2958
00:57:58,310 --> 00:57:58,320
 

2959
00:57:58,320 --> 00:57:59,569
decide whether we want to evict it right

2960
00:57:59,569 --> 00:57:59,579
 

2961
00:57:59,579 --> 00:58:01,310
then and there or we keep it in memory

2962
00:58:01,310 --> 00:58:01,320
 

2963
00:58:01,320 --> 00:58:03,140
and we just flip it to be from the dirty

2964
00:58:03,140 --> 00:58:03,150
 

2965
00:58:03,150 --> 00:58:05,240
bit to be clean so that when the

2966
00:58:05,240 --> 00:58:05,250
 

2967
00:58:05,250 --> 00:58:07,250
eviction policy runs again it now has a

2968
00:58:07,250 --> 00:58:07,260
 

2969
00:58:07,260 --> 00:58:08,930
clean page that it knows it can throw

2970
00:58:08,930 --> 00:58:08,940

2971
00:58:08,940 --> 00:58:13,220
away all right so Postgres does this I

2972
00:58:13,220 --> 00:58:13,230
 

2973
00:58:13,230 --> 00:58:15,500
don't my sequel does this but a bunch of

2974
00:58:15,500 --> 00:58:15,510
 

2975
00:58:15,510 --> 00:58:16,970
the commercial systems do sort of the

2976
00:58:16,970 --> 00:58:16,980
 

2977
00:58:16,980 --> 00:58:22,130
same thing the issue we're going to talk

2978
00:58:22,130 --> 00:58:22,140
 

2979
00:58:22,140 --> 00:58:23,480
about later went about logging recovery

2980
00:58:23,480 --> 00:58:23,490
 

2981
00:58:23,490 --> 00:58:25,310
is that we can't write out a dirty page

2982
00:58:25,310 --> 00:58:25,320
 

2983
00:58:25,320 --> 00:58:28,130
to disk until the log that the law of

2984
00:58:28,130 --> 00:58:28,140
 

2985
00:58:28,140 --> 00:58:29,359
the corresponds to the change that was

2986
00:58:29,359 --> 00:58:29,369
 

2987
00:58:29,369 --> 00:58:30,880
made to that page is written out so disk

2988
00:58:30,880 --> 00:58:30,890
 

2989
00:58:30,890 --> 00:58:33,140
right and there's a whole process of

2990
00:58:33,140 --> 00:58:33,150
 

2991
00:58:33,150 --> 00:58:34,940
figuring out what pages are safe to

2992
00:58:34,940 --> 00:58:34,950
 

2993
00:58:34,950 --> 00:58:36,349
write based on what would you've written

2994
00:58:36,349 --> 00:58:36,359
 

2995
00:58:36,359 --> 00:58:39,730
to the log and of course there's this

2996
00:58:39,730 --> 00:58:39,740
 

2997
00:58:39,740 --> 00:58:42,260
contention issue now where I may be

2998
00:58:42,260 --> 00:58:42,270

2999
00:58:42,270 --> 00:58:44,030
trying to write data out there to the

3000
00:58:44,030 --> 00:58:44,040
 

3001
00:58:44,040 --> 00:58:46,310
log as fast as possible and I don't want

3002
00:58:46,310 --> 00:58:46,320
 

3003
00:58:46,320 --> 00:58:47,839
the background writer to interfere with

3004
00:58:47,839 --> 00:58:47,849
 

3005
00:58:47,849 --> 00:58:49,880
this but I want my background writer to

3006
00:58:49,880 --> 00:58:49,890
 

3007
00:58:49,890 --> 00:58:51,170
go ahead and write out 30 pages because

3008
00:58:51,170 --> 00:58:51,180
 

3009
00:58:51,180 --> 00:58:52,790
that'll free up slots or free up frames

3010
00:58:52,790 --> 00:58:52,800

3011
00:58:52,800 --> 00:58:55,339
in memory alright so how you balance all

3012
00:58:55,339 --> 00:58:55,349
 

3013
00:58:55,349 --> 00:58:56,510
these things is really tricky and

3014
00:58:56,510 --> 00:58:56,520
 

3015
00:58:56,520 --> 00:58:58,160
there's no there's no magical way to do

3016
00:58:58,160 --> 00:58:58,170
 

3017
00:58:58,170 --> 00:58:59,690
this people sort of have these default

3018
00:58:59,690 --> 00:58:59,700
 

3019
00:58:59,700 --> 00:59:02,990
settings and you can tune them a little

3020
00:59:02,990 --> 00:59:03,000
 

3021
00:59:03,000 --> 00:59:05,000
bit but it's it's it's very application

3022
00:59:05,000 --> 00:59:05,010
 

3023
00:59:05,010 --> 00:59:06,859
specific it's very difficult to get

3024
00:59:06,859 --> 00:59:06,869
 

3025
00:59:06,869 --> 00:59:12,470
right alright to finish up the last few

3026
00:59:12,470 --> 00:59:12,480
 

3027
00:59:12,480 --> 00:59:13,550
things to talk about or allocation

3028
00:59:13,550 --> 00:59:13,560
 

3029
00:59:13,560 --> 00:59:16,130
policies and the different types of

3030
00:59:16,130 --> 00:59:16,140
 

3031
00:59:16,140 --> 00:59:18,200
memory pools you can have so for

3032
00:59:18,200 --> 00:59:18,210
 

3033
00:59:18,210 --> 00:59:20,720
allocation policy is basically how do we

3034
00:59:20,720 --> 00:59:20,730
 

3035
00:59:20,730 --> 00:59:23,300
make decisions about how much memory to

3036
00:59:23,300 --> 00:59:23,310
 

3037
00:59:23,310 --> 00:59:25,130
give to different threads or different

3038
00:59:25,130 --> 00:59:25,140
 

3039
00:59:25,140 --> 00:59:27,140
different queries and do make decisions

3040
00:59:27,140 --> 00:59:27,150
 

3041
00:59:27,150 --> 00:59:29,569
about doing this for the entire system

3042
00:59:29,569 --> 00:59:29,579
 

3043
00:59:29,579 --> 00:59:32,120
or do we have localized policies that

3044
00:59:32,120 --> 00:59:32,130
 

3045
00:59:32,130 --> 00:59:35,780
say you know for this for this given

3046
00:59:35,780 --> 00:59:35,790
 

3047
00:59:35,790 --> 00:59:37,730
transaction the seventh query it's

3048
00:59:37,730 --> 00:59:37,740
 

3049
00:59:37,740 --> 00:59:38,930
allowed this amount of memory and we

3050
00:59:38,930 --> 00:59:38,940
 

3051
00:59:38,940 --> 00:59:41,450
don't care about anybody else so again

3052
00:59:41,450 --> 00:59:41,460
 

3053
00:59:41,460 --> 00:59:43,700
there's there's this kin trade-off of

3054
00:59:43,700 --> 00:59:43,710
 

3055
00:59:43,710 --> 00:59:45,140
trying to make decisions that will

3056
00:59:45,140 --> 00:59:45,150
 

3057
00:59:45,150 --> 00:59:47,359
maximize performance without having to

3058
00:59:47,359 --> 00:59:47,369
 

3059
00:59:47,369 --> 00:59:49,339
you know punish any one query that the

3060
00:59:49,339 --> 00:59:49,349
 

3061
00:59:49,349 --> 00:59:51,530
most and again there's no magic way to

3062
00:59:51,530 --> 00:59:51,540
 

3063
00:59:51,540 --> 00:59:52,880
do this it's sort of these things that

3064
00:59:52,880 --> 00:59:52,890
 

3065
00:59:52,890 --> 00:59:53,900
mean back into mind when you make

3066
00:59:53,900 --> 00:59:53,910
 

3067
00:59:53,910 --> 00:59:54,859
decisions about how you actually

3068
00:59:54,859 --> 00:59:54,869
 

3069
00:59:54,869 --> 00:59:57,359
implement your Buffalo manager

3070
00:59:57,359 --> 00:59:57,369
 

3071
00:59:57,369 --> 00:59:59,219
and the last piece to talk about is the

3072
00:59:59,219 --> 00:59:59,229
 

3073
00:59:59,229 --> 01:00:00,569
other memory pools that better running

3074
01:00:00,569 --> 01:00:00,579
 

3075
01:00:00,579 --> 01:00:04,589
inside the system so everything we

3076
01:00:04,589 --> 01:00:04,599
 

3077
01:00:04,599 --> 01:00:06,539
talked about here before today is just I

3078
01:00:06,539 --> 01:00:06,549
 

3079
01:00:06,549 --> 01:00:08,339
need to read a tuple it's not a page I

3080
01:00:08,339 --> 01:00:08,349
 

3081
01:00:08,349 --> 01:00:10,469
go bring that into my buffer pool but

3082
01:00:10,469 --> 01:00:10,479
 

3083
01:00:10,479 --> 01:00:11,640
there's all those other stuff we have to

3084
01:00:11,640 --> 01:00:11,650
 

3085
01:00:11,650 --> 01:00:13,799
maintain a memory that may or may not be

3086
01:00:13,799 --> 01:00:13,809
 

3087
01:00:13,809 --> 01:00:15,839
back by pages on disk that we now have

3088
01:00:15,839 --> 01:00:15,849
 

3089
01:00:15,849 --> 01:00:19,109
to consider as well so when we do query

3090
01:00:19,109 --> 01:00:19,119
 

3091
01:00:19,119 --> 01:00:20,249
processing we'll see this when we do

3092
01:00:20,249 --> 01:00:20,259
 

3093
01:00:20,259 --> 01:00:23,729
sorting and joins those things need the

3094
01:00:23,729 --> 01:00:23,739

3095
01:00:23,739 --> 01:00:26,219
memory obviously and we have to decide

3096
01:00:26,219 --> 01:00:26,229
 

3097
01:00:26,229 --> 01:00:28,019
where actually to put that memory so

3098
01:00:28,019 --> 01:00:28,029
 

3099
01:00:28,029 --> 01:00:29,579
some things will just be allocated on

3100
01:00:29,579 --> 01:00:29,589
 

3101
01:00:29,589 --> 01:00:33,630
the heap usually like in a memory pool

3102
01:00:33,630 --> 01:00:33,640
 

3103
01:00:33,640 --> 01:00:35,789
or an arena for a given query or thread

3104
01:00:35,789 --> 01:00:35,799
 

3105
01:00:35,799 --> 01:00:37,469
but other things you actually want to

3106
01:00:37,469 --> 01:00:37,479
 

3107
01:00:37,479 --> 01:00:40,259
back behind the buffer pool so that if

3108
01:00:40,259 --> 01:00:40,269
 

3109
01:00:40,269 --> 01:00:42,479
you need more memory to run your query

3110
01:00:42,479 --> 01:00:42,489
 

3111
01:00:42,489 --> 01:00:44,190
than it's actually available to you then

3112
01:00:44,190 --> 01:00:44,200
 

3113
01:00:44,200 --> 01:00:45,450
you can have them of a pool swap those

3114
01:00:45,450 --> 01:00:45,460
 

3115
01:00:45,460 --> 01:00:47,579
things out the disk so a lot of times

3116
01:00:47,579 --> 01:00:47,589
 

3117
01:00:47,589 --> 01:00:50,370
you'll see systems talk about you know I

3118
01:00:50,370 --> 01:00:50,380
 

3119
01:00:50,380 --> 01:00:52,469
run a query and I run out of memory it's

3120
01:00:52,469 --> 01:00:52,479
 

3121
01:00:52,479 --> 01:00:53,940
usually because the queries not backed

3122
01:00:53,940 --> 01:00:53,950
 

3123
01:00:53,950 --> 01:00:56,430
by the intermediate results are not

3124
01:00:56,430 --> 01:00:56,440
 

3125
01:00:56,440 --> 01:00:58,170
backed by the buffer pool and it can't

3126
01:00:58,170 --> 01:00:58,180
 

3127
01:00:58,180 --> 01:01:00,539
write those things out the disk so in

3128
01:01:00,539 --> 01:01:00,549
 

3129
01:01:00,549 --> 01:01:02,999
Postgres some things will be back by

3130
01:01:02,999 --> 01:01:03,009
 

3131
01:01:03,009 --> 01:01:05,549
disk like for doing cash joins but

3132
01:01:05,549 --> 01:01:05,559
 

3133
01:01:05,559 --> 01:01:07,620
there's other cases where if you we see

3134
01:01:07,620 --> 01:01:07,630
 

3135
01:01:07,630 --> 01:01:09,150
an exact query to show you right now

3136
01:01:09,150 --> 01:01:09,160
 

3137
01:01:09,160 --> 01:01:11,130
what we have ways of like concatenating

3138
01:01:11,130 --> 01:01:11,140
 

3139
01:01:11,140 --> 01:01:12,479
bunch of strings together and I'll just

3140
01:01:12,479 --> 01:01:12,489
 

3141
01:01:12,489 --> 01:01:14,309
run out of memory because it's not

3142
01:01:14,309 --> 01:01:14,319
 

3143
01:01:14,319 --> 01:01:15,599
backing this by the buffer pool it's

3144
01:01:15,599 --> 01:01:15,609
 

3145
01:01:15,609 --> 01:01:19,950
just stored in the heap so the the main

3146
01:01:19,950 --> 01:01:19,960
 

3147
01:01:19,960 --> 01:01:21,630
takeaway from this is that different

3148
01:01:21,630 --> 01:01:21,640
 

3149
01:01:21,640 --> 01:01:23,069
systems do different things sometimes

3150
01:01:23,069 --> 01:01:23,079
 

3151
01:01:23,079 --> 01:01:24,390
all these different types of memory

3152
01:01:24,390 --> 01:01:24,400
 

3153
01:01:24,400 --> 01:01:26,700
pools that you need will just be in the

3154
01:01:26,700 --> 01:01:26,710
 

3155
01:01:26,710 --> 01:01:28,049
heap and sometimes it actually backed by

3156
01:01:28,049 --> 01:01:28,059
 

3157
01:01:28,059 --> 01:01:31,950
the buffer pool ideally well there's no

3158
01:01:31,950 --> 01:01:31,960
 

3159
01:01:31,960 --> 01:01:32,999
one way that's better than another

3160
01:01:32,999 --> 01:01:33,009
 

3161
01:01:33,009 --> 01:01:34,200
because again if it's backed by the

3162
01:01:34,200 --> 01:01:34,210
 

3163
01:01:34,210 --> 01:01:35,609
buffer pool then you have to update a

3164
01:01:35,609 --> 01:01:35,619
 

3165
01:01:35,619 --> 01:01:36,930
page table we have to update all that

3166
01:01:36,930 --> 01:01:36,940
 

3167
01:01:36,940 --> 01:01:38,789
extra information if you just malloc on

3168
01:01:38,789 --> 01:01:38,799
 

3169
01:01:38,799 --> 01:01:40,979
the heap that's super fast but then you

3170
01:01:40,979 --> 01:01:40,989
 

3171
01:01:40,989 --> 01:01:43,259
can you don't have full control of the

3172
01:01:43,259 --> 01:01:43,269
 

3173
01:01:43,269 --> 01:01:44,249
amount of memory you may be actually be

3174
01:01:44,249 --> 01:01:44,259
 

3175
01:01:44,259 --> 01:01:49,769
using okay so the main takeaway from

3176
01:01:49,769 --> 01:01:49,779
 

3177
01:01:49,779 --> 01:01:52,769
this is that the database systems always

3178
01:01:52,769 --> 01:01:52,779
 

3179
01:01:52,779 --> 01:01:56,160
gonna do a much better job than the the

3180
01:01:56,160 --> 01:01:56,170
 

3181
01:01:56,170 --> 01:01:59,430
operating system for managing memory you

3182
01:01:59,430 --> 01:01:59,440
 

3183
01:01:59,440 --> 01:02:00,930
don't want to use em map you don't want

3184
01:02:00,930 --> 01:02:00,940
 

3185
01:02:00,940 --> 01:02:02,849
to rely on virtual memory you want to do

3186
01:02:02,849 --> 01:02:02,859
 

3187
01:02:02,859 --> 01:02:04,380
everything yourself because this doesn't

3188
01:02:04,380 --> 01:02:04,390
 

3189
01:02:04,390 --> 01:02:06,359
allow you to have to leverage the

3190
01:02:06,359 --> 01:02:06,369
 

3191
01:02:06,369 --> 01:02:07,650
information that you know about the

3192
01:02:07,650 --> 01:02:07,660
 

3193
01:02:07,660 --> 01:02:08,609
queries you're executing

3194
01:02:08,609 --> 01:02:08,619
 

3195
01:02:08,619 --> 01:02:11,040
to learn make better decisions on

3196
01:02:11,040 --> 01:02:11,050
 

3197
01:02:11,050 --> 01:02:12,630
on their policies about how you move

3198
01:02:12,630 --> 01:02:12,640
 

3199
01:02:12,640 --> 01:02:17,940
data back and forth okay and with the

3200
01:02:17,940 --> 01:02:17,950
 

3201
01:02:17,950 --> 01:02:19,830
exception of Postgres most data systems

3202
01:02:19,830 --> 01:02:19,840
 

3203
01:02:19,840 --> 01:02:21,180
do not rely on the file system cache

3204
01:02:21,180 --> 01:02:21,190
 

3205
01:02:21,190 --> 01:02:24,290
they do everything themselves

3206
01:02:24,290 --> 01:02:24,300
 

3207
01:02:24,300 --> 01:02:28,110
okay so given this lecture this is a

3208
01:02:28,110 --> 01:02:28,120
 

3209
01:02:28,120 --> 01:02:29,520
nice segue now into what the first touch

3210
01:02:29,520 --> 01:02:29,530
 

3211
01:02:29,530 --> 01:02:31,740
beers so the first project is you guys

3212
01:02:31,740 --> 01:02:31,750
 

3213
01:02:31,750 --> 01:02:35,970
got a bit of buffer pool alright so the

3214
01:02:35,970 --> 01:02:35,980
 

3215
01:02:35,980 --> 01:02:37,770
project is gonna be going out today I'll

3216
01:02:37,770 --> 01:02:37,780
 

3217
01:02:37,780 --> 01:02:39,660
post it online immediately after class

3218
01:02:39,660 --> 01:02:39,670
 

3219
01:02:39,670 --> 01:02:41,730
you're gonna have three parts you have

3220
01:02:41,730 --> 01:02:41,740
 

3221
01:02:41,740 --> 01:02:44,220
to build a hash table replacement policy

3222
01:02:44,220 --> 01:02:44,230
 

3223
01:02:44,230 --> 01:02:47,360
and the actual manager themselves so

3224
01:02:47,360 --> 01:02:47,370
 

3225
01:02:47,370 --> 01:02:50,190
this year all the products were based on

3226
01:02:50,190 --> 01:02:50,200
 

3227
01:02:50,200 --> 01:02:53,250
sequel light we looked at trying to make

3228
01:02:53,250 --> 01:02:53,260
 

3229
01:02:53,260 --> 01:02:54,990
use Postgres or it was just sort of more

3230
01:02:54,990 --> 01:02:55,000
 

3231
01:02:55,000 --> 01:02:56,340
complicated we do have enough time to do

3232
01:02:56,340 --> 01:02:56,350
 

3233
01:02:56,350 --> 01:02:59,010
this but basically C code lights gonna

3234
01:02:59,010 --> 01:02:59,020
 

3235
01:02:59,020 --> 01:03:00,720
be the front end to your to your the

3236
01:03:00,720 --> 01:03:00,730
 

3237
01:03:00,730 --> 01:03:02,370
database sort of engine you're building

3238
01:03:02,370 --> 01:03:02,380
 

3239
01:03:02,380 --> 01:03:05,460
as it what's called a virtual table so

3240
01:03:05,460 --> 01:03:05,470
 

3241
01:03:05,470 --> 01:03:07,200
you want to happen as your startup's

3242
01:03:07,200 --> 01:03:07,210
 

3243
01:03:07,210 --> 01:03:08,430
equal light and you say create me a

3244
01:03:08,430 --> 01:03:08,440
 

3245
01:03:08,440 --> 01:03:11,340
table using my cervix virtual table

3246
01:03:11,340 --> 01:03:11,350
 

3247
01:03:11,350 --> 01:03:13,590
extension and then any reads and writes

3248
01:03:13,590 --> 01:03:13,600

3249
01:03:13,600 --> 01:03:15,390
won't go to your to the engine that

3250
01:03:15,390 --> 01:03:15,400
 

3251
01:03:15,400 --> 01:03:17,430
you're building so for the first project

3252
01:03:17,430 --> 01:03:17,440
 

3253
01:03:17,440 --> 01:03:18,660
you don't actually need to use any

3254
01:03:18,660 --> 01:03:18,670
 

3255
01:03:18,670 --> 01:03:20,250
sequel light you don't need actually

3256
01:03:20,250 --> 01:03:20,260

3257
01:03:20,260 --> 01:03:21,450
even look at the internals on a single

3258
01:03:21,450 --> 01:03:21,460
 

3259
01:03:21,460 --> 01:03:22,200
light throughout the entire semester

3260
01:03:22,200 --> 01:03:22,210
 

3261
01:03:22,210 --> 01:03:24,540
where we're hiding all that from you you

3262
01:03:24,540 --> 01:03:24,550
 

3263
01:03:24,550 --> 01:03:26,610
just you work on your own C++ code base

3264
01:03:26,610 --> 01:03:26,620
 

3265
01:03:26,620 --> 01:03:31,020
so the project we do in two weeks on

3266
01:03:31,020 --> 01:03:31,030
 

3267
01:03:31,030 --> 01:03:33,960
September 26 you'll submit this on on

3268
01:03:33,960 --> 01:03:33,970
 

3269
01:03:33,970 --> 01:03:35,880
grade scope well again we'll turn all

3270
01:03:35,880 --> 01:03:35,890
 

3271
01:03:35,890 --> 01:03:38,510
this on later today at least get started

3272
01:03:38,510 --> 01:03:38,520
 

3273
01:03:38,520 --> 01:03:40,920
so the first task is that you have to

3274
01:03:40,920 --> 01:03:40,930
 

3275
01:03:40,930 --> 01:03:42,270
build an extendable hash table so I'll

3276
01:03:42,270 --> 01:03:42,280
 

3277
01:03:42,280 --> 01:03:43,860
explain what it what a symbol hash table

3278
01:03:43,860 --> 01:03:43,870
 

3279
01:03:43,870 --> 01:03:46,200
is next class but this is this is your

3280
01:03:46,200 --> 01:03:46,210
 

3281
01:03:46,210 --> 01:03:47,730
me end up using this as your page table

3282
01:03:47,730 --> 01:03:47,740
 

3283
01:03:47,740 --> 01:03:50,730
so it's a hash table that can grow so

3284
01:03:50,730 --> 01:03:50,740
 

3285
01:03:50,740 --> 01:03:52,560
that way as you insert new data and you

3286
01:03:52,560 --> 01:03:52,570
 

3287
01:03:52,570 --> 01:03:54,000
make new pages your hash table can grow

3288
01:03:54,000 --> 01:03:54,010

3289
01:03:54,010 --> 01:03:56,250
with it to keep track of these things so

3290
01:03:56,250 --> 01:03:56,260
 

3291
01:03:56,260 --> 01:03:59,130
for this you don't need to support

3292
01:03:59,130 --> 01:03:59,140
 

3293
01:03:59,140 --> 01:04:00,660
shrinking because that's actually harder

3294
01:04:00,660 --> 01:04:00,670
 

3295
01:04:00,670 --> 01:04:02,520
to do but you knew you need to support

3296
01:04:02,520 --> 01:04:02,530
 

3297
01:04:02,530 --> 01:04:03,990
growing and the basic extendable hash

3298
01:04:03,990 --> 01:04:04,000
 

3299
01:04:04,000 --> 01:04:06,350
table algorithm will do that for you

3300
01:04:06,350 --> 01:04:06,360
 

3301
01:04:06,360 --> 01:04:08,460
you're allowed to use some of the things

3302
01:04:08,460 --> 01:04:08,470
 

3303
01:04:08,470 --> 01:04:10,770
that are in the STL so this be all SS

3304
01:04:10,770 --> 01:04:10,780
 

3305
01:04:10,780 --> 01:04:13,950
C++ 11 so you can use sed hash as your

3306
01:04:13,950 --> 01:04:13,960
 

3307
01:04:13,960 --> 01:04:15,750
hash function you can use sed mutex

3308
01:04:15,750 --> 01:04:15,760
 

3309
01:04:15,760 --> 01:04:17,340
protect this right this needs to be

3310
01:04:17,340 --> 01:04:17,350
 

3311
01:04:17,350 --> 01:04:22,140
thread safe you can't just use a STD map

3312
01:04:22,140 --> 01:04:22,150
 

3313
01:04:22,150 --> 01:04:23,700
right use you have to build your own

3314
01:04:23,700 --> 01:04:23,710
 

3315
01:04:23,710 --> 01:04:24,980
hash map

3316
01:04:24,980 --> 01:04:24,990

3317
01:04:24,990 --> 01:04:27,650
once you try to do that later don't

3318
01:04:27,650 --> 01:04:27,660
 

3319
01:04:27,660 --> 01:04:29,930
don't do that

3320
01:04:29,930 --> 01:04:29,940

3321
01:04:29,940 --> 01:04:31,920
the next thing get a build is the

3322
01:04:31,920 --> 01:04:31,930
 

3323
01:04:31,930 --> 01:04:33,810
replacement policy so you don't have to

3324
01:04:33,810 --> 01:04:33,820
 

3325
01:04:33,820 --> 01:04:38,880
build LRU and you don't have to worry

3326
01:04:38,880 --> 01:04:38,890
 

3327
01:04:38,890 --> 01:04:42,780
about the weight way we sort of

3328
01:04:42,780 --> 01:04:42,790
 

3329
01:04:42,790 --> 01:04:44,730
extracted out the api's you know

3330
01:04:44,730 --> 01:04:44,740

3331
01:04:44,740 --> 01:04:46,160
actually actually to worry about whether

3332
01:04:46,160 --> 01:04:46,170
 

3333
01:04:46,170 --> 01:04:50,520
it's it's it's pinned not you just know

3334
01:04:50,520 --> 01:04:50,530
 

3335
01:04:50,530 --> 01:04:51,870
that these are the pages that that are

3336
01:04:51,870 --> 01:04:51,880
 

3337
01:04:51,880 --> 01:04:53,100
free and I have to make a decision about

3338
01:04:53,100 --> 01:04:53,110
 

3339
01:04:53,110 --> 01:04:54,680
which ones I actually want to evict

3340
01:04:54,680 --> 01:04:54,690
 

3341
01:04:54,690 --> 01:04:57,570
sometime this this part should be pretty

3342
01:04:57,570 --> 01:04:57,580
 

3343
01:04:57,580 --> 01:04:59,910
straightforward and then you put the the

3344
01:04:59,910 --> 01:04:59,920
 

3345
01:04:59,920 --> 01:05:01,680
LRU management policy that you

3346
01:05:01,680 --> 01:05:01,690
 

3347
01:05:01,690 --> 01:05:03,330
implemented plus your extendable hash

3348
01:05:03,330 --> 01:05:03,340
 

3349
01:05:03,340 --> 01:05:04,590
table and actually build now your own

3350
01:05:04,590 --> 01:05:04,600
 

3351
01:05:04,600 --> 01:05:06,930
buffer pool manager so we will take care

3352
01:05:06,930 --> 01:05:06,940
 

3353
01:05:06,940 --> 01:05:08,460
of reading the writing data from from

3354
01:05:08,460 --> 01:05:08,470
 

3355
01:05:08,470 --> 01:05:09,030
disk

3356
01:05:09,030 --> 01:05:09,040
 

3357
01:05:09,040 --> 01:05:11,340
I believe I'd you an API to say give me

3358
01:05:11,340 --> 01:05:11,350
 

3359
01:05:11,350 --> 01:05:13,230
this page from disk and knows where to

3360
01:05:13,230 --> 01:05:13,240
 

3361
01:05:13,240 --> 01:05:15,390
go get it Tom but you have to make a

3362
01:05:15,390 --> 01:05:15,400
 

3363
01:05:15,400 --> 01:05:16,920
copy of the page and you into your hash

3364
01:05:16,920 --> 01:05:16,930
 

3365
01:05:16,930 --> 01:05:19,230
map or your turn data structure and then

3366
01:05:19,230 --> 01:05:19,240
 

3367
01:05:19,240 --> 01:05:23,310
map any page IDs to it all right so the

3368
01:05:23,310 --> 01:05:23,320
 

3369
01:05:23,320 --> 01:05:27,030
tricky thing about this that that sort

3370
01:05:27,030 --> 01:05:27,040
 

3371
01:05:27,040 --> 01:05:28,350
of fowls up students is that you want to

3372
01:05:28,350 --> 01:05:28,360
 

3373
01:05:28,360 --> 01:05:29,610
make sure you get the operations correct

3374
01:05:29,610 --> 01:05:29,620
 

3375
01:05:29,620 --> 01:05:33,000
when you do pinning right if you know

3376
01:05:33,000 --> 01:05:33,010
 

3377
01:05:33,010 --> 01:05:34,530
you don't want to go look up it's not

3378
01:05:34,530 --> 01:05:34,540
 

3379
01:05:34,540 --> 01:05:36,450
there then try to pin something to take

3380
01:05:36,450 --> 01:05:36,460
 

3381
01:05:36,460 --> 01:05:38,520
out take a slot take a frame you have to

3382
01:05:38,520 --> 01:05:38,530
 

3383
01:05:38,530 --> 01:05:39,900
always set the pin first because another

3384
01:05:39,900 --> 01:05:39,910
 

3385
01:05:39,910 --> 01:05:41,310
third could come in and take take your

3386
01:05:41,310 --> 01:05:41,320
 

3387
01:05:41,320 --> 01:05:47,610
take your location yeah this part this I

3388
01:05:47,610 --> 01:05:47,620
 

3389
01:05:47,620 --> 01:05:50,010
mean this part is is this part is a more

3390
01:05:50,010 --> 01:05:50,020
 

3391
01:05:50,020 --> 01:05:51,630
complicated part of all this is sort of

3392
01:05:51,630 --> 01:05:51,640
 

3393
01:05:51,640 --> 01:05:54,060
putting everything together um but in it

3394
01:05:54,060 --> 01:05:54,070
 

3395
01:05:54,070 --> 01:05:55,410
we're only giving you two weeks because

3396
01:05:55,410 --> 01:05:55,420
 

3397
01:05:55,420 --> 01:05:57,060
it is actually not that bad in my

3398
01:05:57,060 --> 01:05:57,070
 

3399
01:05:57,070 --> 01:05:59,160
opinion so the way to get started is

3400
01:05:59,160 --> 01:05:59,170
 

3401
01:05:59,170 --> 01:06:01,070
that when we post it online today

3402
01:06:01,070 --> 01:06:01,080
 

3403
01:06:01,080 --> 01:06:03,090
download the source code will give you a

3404
01:06:03,090 --> 01:06:03,100
 

3405
01:06:03,100 --> 01:06:03,890
tarball

3406
01:06:03,890 --> 01:06:03,900

3407
01:06:03,900 --> 01:06:08,370
that'll have a bunch of stub files that

3408
01:06:08,370 --> 01:06:08,380
 

3409
01:06:08,380 --> 01:06:10,410
that you can run or you can implement

3410
01:06:10,410 --> 01:06:10,420
 

3411
01:06:10,420 --> 01:06:13,800
your actual code so the code when you

3412
01:06:13,800 --> 01:06:13,810
 

3413
01:06:13,810 --> 01:06:15,330
download it should be be able to you

3414
01:06:15,330 --> 01:06:15,340
 

3415
01:06:15,340 --> 01:06:17,070
should be able to compile it right you

3416
01:06:17,070 --> 01:06:17,080
 

3417
01:06:17,080 --> 01:06:18,810
should test that right away they'll

3418
01:06:18,810 --> 01:06:18,820
 

3419
01:06:18,820 --> 01:06:21,450
we've and we have API if you have

3420
01:06:21,450 --> 01:06:21,460
 

3421
01:06:21,460 --> 01:06:22,470
functions you actually have to implement

3422
01:06:22,470 --> 01:06:22,480
 

3423
01:06:22,480 --> 01:06:25,020
with documentation inside them the tests

3424
01:06:25,020 --> 01:06:25,030
 

3425
01:06:25,030 --> 01:06:26,190
will fail because obviously you haven't

3426
01:06:26,190 --> 01:06:26,200

3427
01:06:26,200 --> 01:06:27,660
written any of your code but you should

3428
01:06:27,660 --> 01:06:27,670
 

3429
01:06:27,670 --> 01:06:28,950
be able to compile it you should do that

3430
01:06:28,950 --> 01:06:28,960
 

3431
01:06:28,960 --> 01:06:30,210
right away and check your your

3432
01:06:30,210 --> 01:06:30,220
 

3433
01:06:30,220 --> 01:06:32,220
development environment so we've tested

3434
01:06:32,220 --> 01:06:32,230
 

3435
01:06:32,230 --> 01:06:34,770
all the andrew machines that are in

3436
01:06:34,770 --> 01:06:34,780
 

3437
01:06:34,780 --> 01:06:36,990
gates they everything should compile on

3438
01:06:36,990 --> 01:06:37,000
 

3439
01:06:37,000 --> 01:06:38,070
that there's no sort of

3440
01:06:38,070 --> 01:06:38,080
 

3441
01:06:38,080 --> 01:06:40,610
crazy dependencies to make this all work

3442
01:06:40,610 --> 01:06:40,620
 

3443
01:06:40,620 --> 01:06:43,080
we know it works on OSX we know it works

3444
01:06:43,080 --> 01:06:43,090
 

3445
01:06:43,090 --> 01:06:45,270
on Linux although I have a Windows

3446
01:06:45,270 --> 01:06:45,280
 

3447
01:06:45,280 --> 01:06:46,980
laptop I don't use it for anything other

3448
01:06:46,980 --> 01:06:46,990
 

3449
01:06:46,990 --> 01:06:49,800
than PowerPoint I don't know whether it

3450
01:06:49,800 --> 01:06:49,810
 

3451
01:06:49,810 --> 01:06:51,630
actually compiles on Windows 10 with the

3452
01:06:51,630 --> 01:06:51,640
 

3453
01:06:51,640 --> 01:06:54,000
Ubuntu package I think a student last

3454
01:06:54,000 --> 01:06:54,010
 

3455
01:06:54,010 --> 01:06:56,040
year got to work but I don't know what

3456
01:06:56,040 --> 01:06:56,050
 

3457
01:06:56,050 --> 01:06:57,060
you know I don't know what whether

3458
01:06:57,060 --> 01:06:57,070
 

3459
01:06:57,070 --> 01:07:00,870
worked out of the box if you can't if

3460
01:07:00,870 --> 01:07:00,880
 

3461
01:07:00,880 --> 01:07:02,340
you don't have access to a Linux machine

3462
01:07:02,340 --> 01:07:02,350
 

3463
01:07:02,350 --> 01:07:03,360
or machine you can actually use the

3464
01:07:03,360 --> 01:07:03,370
 

3465
01:07:03,370 --> 01:07:05,640
compiled in this email me we can give

3466
01:07:05,640 --> 01:07:05,650
 

3467
01:07:05,650 --> 01:07:07,110
you like a virtual machine image that

3468
01:07:07,110 --> 01:07:07,120
 

3469
01:07:07,120 --> 01:07:09,900
that if you want to run it that way but

3470
01:07:09,900 --> 01:07:09,910
 

3471
01:07:09,910 --> 01:07:11,040
everyone should access that should have

3472
01:07:11,040 --> 01:07:11,050
 

3473
01:07:11,050 --> 01:07:12,330
access to the engine machine if you're a

3474
01:07:12,330 --> 01:07:12,340
 

3475
01:07:12,340 --> 01:07:15,680
student here and it should work there

3476
01:07:15,680 --> 01:07:15,690
 

3477
01:07:15,690 --> 01:07:18,960
alright so the instructions will lay out

3478
01:07:18,960 --> 01:07:18,970
 

3479
01:07:18,970 --> 01:07:20,520
exactly what files you need to modify

3480
01:07:20,520 --> 01:07:20,530
 

3481
01:07:20,530 --> 01:07:23,550
you should not modify any other files in

3482
01:07:23,550 --> 01:07:23,560
 

3483
01:07:23,560 --> 01:07:25,860
the so the tarball we give you because

3484
01:07:25,860 --> 01:07:25,870
 

3485
01:07:25,870 --> 01:07:27,600
when when you run your tests right when

3486
01:07:27,600 --> 01:07:27,610
 

3487
01:07:27,610 --> 01:07:28,560
you upload the grade-school we're gonna

3488
01:07:28,560 --> 01:07:28,570
 

3489
01:07:28,570 --> 01:07:30,030
pick out those six files if we ask you

3490
01:07:30,030 --> 01:07:30,040
 

3491
01:07:30,040 --> 01:07:32,310
to modify and we're to overlay them into

3492
01:07:32,310 --> 01:07:32,320
 

3493
01:07:32,320 --> 01:07:35,220
our sort of clean cook codebase so if

3494
01:07:35,220 --> 01:07:35,230
 

3495
01:07:35,230 --> 01:07:36,330
you might there is something you have to

3496
01:07:36,330 --> 01:07:36,340
 

3497
01:07:36,340 --> 01:07:38,070
modify to make your thing to work that

3498
01:07:38,070 --> 01:07:38,080
 

3499
01:07:38,080 --> 01:07:39,870
aren't in the six files it will fail

3500
01:07:39,870 --> 01:07:39,880
 

3501
01:07:39,880 --> 01:07:41,580
when we actually run it because we're

3502
01:07:41,580 --> 01:07:41,590
 

3503
01:07:41,590 --> 01:07:43,610
not gonna copy those things at all right

3504
01:07:43,610 --> 01:07:43,620
 

3505
01:07:43,620 --> 01:07:46,050
the other thing to say - - is that the

3506
01:07:46,050 --> 01:07:46,060
 

3507
01:07:46,060 --> 01:07:47,220
four projects in the class are all

3508
01:07:47,220 --> 01:07:47,230
 

3509
01:07:47,230 --> 01:07:48,510
cumulative so you need to get this thing

3510
01:07:48,510 --> 01:07:48,520

3511
01:07:48,520 --> 01:07:49,950
working before you can do the subsequent

3512
01:07:49,950 --> 01:07:49,960
 

3513
01:07:49,960 --> 01:07:51,270
things so you can't build an index

3514
01:07:51,270 --> 01:07:51,280
 

3515
01:07:51,280 --> 01:07:53,400
unless you have a buffer pool and you

3516
01:07:53,400 --> 01:07:53,410
 

3517
01:07:53,410 --> 01:07:55,440
can't do control unless you have an

3518
01:07:55,440 --> 01:07:55,450
 

3519
01:07:55,450 --> 01:07:58,620
index so we would not be providing

3520
01:07:58,620 --> 01:07:58,630
 

3521
01:07:58,630 --> 01:08:02,550
solutions because of this in the case in

3522
01:08:02,550 --> 01:08:02,560
 

3523
01:08:02,560 --> 01:08:04,620
cases last year with some kids had

3524
01:08:04,620 --> 01:08:04,630
 

3525
01:08:04,630 --> 01:08:06,570
problems due to medical reasons we can

3526
01:08:06,570 --> 01:08:06,580
 

3527
01:08:06,580 --> 01:08:09,180
give you a you know an obfuscated turbo

3528
01:08:09,180 --> 01:08:09,190
 

3529
01:08:09,190 --> 01:08:11,640
obfuscated binary that'll implement some

3530
01:08:11,640 --> 01:08:11,650

3531
01:08:11,650 --> 01:08:13,290
of the files that you may be missing and

3532
01:08:13,290 --> 01:08:13,300
 

3533
01:08:13,300 --> 01:08:14,850
so that way you you can keep keep up

3534
01:08:14,850 --> 01:08:14,860

3535
01:08:14,860 --> 01:08:17,579
right but for the most part we set these

3536
01:08:17,579 --> 01:08:17,589
 

3537
01:08:17,589 --> 01:08:19,590
deadlines such that you you sort of keep

3538
01:08:19,590 --> 01:08:19,600

3539
01:08:19,600 --> 01:08:21,840
implementing things and you you'll have

3540
01:08:21,840 --> 01:08:21,850
 

3541
01:08:21,850 --> 01:08:23,099
enough time to do them in order to get

3542
01:08:23,099 --> 01:08:23,109
 

3543
01:08:23,109 --> 01:08:28,200
started on the next project okay so if

3544
01:08:28,200 --> 01:08:28,210
 

3545
01:08:28,210 --> 01:08:29,880
you have questions about about basic

3546
01:08:29,880 --> 01:08:29,890
 

3547
01:08:29,890 --> 01:08:32,490
things or the high level ideas or where

3548
01:08:32,490 --> 01:08:32,500
 

3549
01:08:32,500 --> 01:08:34,320
to find certain things in the code post

3550
01:08:34,320 --> 01:08:34,330
 

3551
01:08:34,330 --> 01:08:36,690
them on Piazza do not post on Piazza

3552
01:08:36,690 --> 01:08:36,700
 

3553
01:08:36,700 --> 01:08:39,000
like I get a segfault I don't understand

3554
01:08:39,000 --> 01:08:39,010
 

3555
01:08:39,010 --> 01:08:40,590
why all right we're not gonna help you

3556
01:08:40,590 --> 01:08:40,600
 

3557
01:08:40,600 --> 01:08:42,990
debug theirs we have tutorials online

3558
01:08:42,990 --> 01:08:43,000
 

3559
01:08:43,000 --> 01:08:45,120
that will send you guys how to use gdb

3560
01:08:45,120 --> 01:08:45,130
 

3561
01:08:45,130 --> 01:08:46,860
right how to do basic things with C

3562
01:08:46,860 --> 01:08:46,870
 

3563
01:08:46,870 --> 01:08:48,450
closed eleven but we're not gonna come

3564
01:08:48,450 --> 01:08:48,460
 

3565
01:08:48,460 --> 01:08:50,890
sit and look at your code with you okay

3566
01:08:50,890 --> 01:08:50,900
 

3567
01:08:50,900 --> 01:08:52,870
the last thing I'll say is - is that

3568
01:08:52,870 --> 01:08:52,880
 

3569
01:08:52,880 --> 01:08:55,180
please do not plagiarize we will run the

3570
01:08:55,180 --> 01:08:55,190

3571
01:08:55,190 --> 01:08:57,460
most detector

3572
01:08:57,460 --> 01:08:57,470

3573
01:08:57,470 --> 01:08:59,530
please also do not post your thing

3574
01:08:59,530 --> 01:08:59,540
 

3575
01:08:59,540 --> 01:09:03,040
publicly on github because again we

3576
01:09:03,040 --> 01:09:03,050

3577
01:09:03,050 --> 01:09:04,090
don't want other people just taking your

3578
01:09:04,090 --> 01:09:04,100
 

3579
01:09:04,100 --> 01:09:05,590
code right if you said a private repo if

3580
01:09:05,590 --> 01:09:05,600
 

3581
01:09:05,600 --> 01:09:07,480
you want and I realize a lot of you want

3582
01:09:07,480 --> 01:09:07,490
 

3583
01:09:07,490 --> 01:09:08,650
to be able to show your to your

3584
01:09:08,650 --> 01:09:08,660
 

3585
01:09:08,660 --> 01:09:10,480
employers you here's the project

3586
01:09:10,480 --> 01:09:10,490
 

3587
01:09:10,490 --> 01:09:13,450
projects I've done that actually doesn't

3588
01:09:13,450 --> 01:09:13,460
 

3589
01:09:13,460 --> 01:09:15,490
matter all right

3590
01:09:15,490 --> 01:09:15,500
 

3591
01:09:15,500 --> 01:09:20,020
they don't care good no cos because

3592
01:09:20,020 --> 01:09:20,030
 

3593
01:09:20,030 --> 01:09:21,640
you're all implementing the same thing

3594
01:09:21,640 --> 01:09:21,650

3595
01:09:21,650 --> 01:09:22,810
it's not only gonna have this magical

3596
01:09:22,810 --> 01:09:22,820
 

3597
01:09:22,820 --> 01:09:24,820
breakthrough right in the little code

3598
01:09:24,820 --> 01:09:24,830

3599
01:09:24,830 --> 01:09:27,520
you're writing for our projects okay so

3600
01:09:27,520 --> 01:09:27,530
 

3601
01:09:27,530 --> 01:09:28,990
don't personally because of github don't

3602
01:09:28,990 --> 01:09:29,000
 

3603
01:09:29,000 --> 01:09:31,270
cheat don't copy from each other if you

3604
01:09:31,270 --> 01:09:31,280
 

3605
01:09:31,280 --> 01:09:33,220
have questions email me and then next

3606
01:09:33,220 --> 01:09:33,230
 

3607
01:09:33,230 --> 01:10:03,010
hash tables okay put the butter cap on

3608
01:10:03,010 --> 01:10:03,020
 

3609
01:10:03,020 --> 01:10:06,450
Bushwick on the bow with a blow to the I

3610
01:10:06,450 --> 01:10:06,460
 

3611
01:10:06,460 --> 01:10:09,970
would indeed that's me rolling with one

3612
01:10:09,970 --> 01:10:09,980
 

3613
01:10:09,980 --> 01:10:12,850
parking south-central teeth and thank

3614
01:10:12,850 --> 01:10:12,860
 

3615
01:10:12,860 --> 01:10:16,090
eyes when I party by the 12-pack case of

3616
01:10:16,090 --> 01:10:16,100

3617
01:10:16,100 --> 01:10:18,280
a boy six-pack for the act against the

3618
01:10:18,280 --> 01:10:18,290
 

3619
01:10:18,290 --> 01:10:21,280
real I'm three please put your drinking

3620
01:10:21,280 --> 01:10:21,290
 

3621
01:10:21,290 --> 01:10:22,450
proper 12 ow

3622
01:10:22,450 --> 01:10:22,460
 

3623
01:10:22,460 --> 01:10:25,390
they say Filmation flat but sane eyes is

3624
01:10:25,390 --> 01:10:25,400
 

3625
01:10:25,400 --> 01:10:28,930
straight so it really don't matter

