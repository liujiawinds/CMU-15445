1
00:00:00,740 --> 00:00:10,709
[Music]

2
00:00:10,709 --> 00:00:10,719


3
00:00:10,719 --> 00:00:15,249
maybe all the jewels started alright

4
00:00:15,249 --> 00:00:15,259
 

5
00:00:15,259 --> 00:00:17,909
hold again any questions about the

6
00:00:17,909 --> 00:00:17,919
 

7
00:00:17,919 --> 00:00:20,140
logistics of the course or anything that

8
00:00:20,140 --> 00:00:20,150
 

9
00:00:20,150 --> 00:00:24,490
we discussed last class again I'll talk

10
00:00:24,490 --> 00:00:24,500
 

11
00:00:24,500 --> 00:00:25,750
about homework 1 at the end of the class

12
00:00:25,750 --> 00:00:25,760
 

13
00:00:25,760 --> 00:00:27,849
and then it'll be posted immediately

14
00:00:27,849 --> 00:00:27,859
 

15
00:00:27,859 --> 00:00:29,230
after the lecture is over so everyone

16
00:00:29,230 --> 00:00:29,240
 

17
00:00:29,240 --> 00:00:33,759
can start at the same time ok all right

18
00:00:33,759 --> 00:00:33,769
 

19
00:00:33,769 --> 00:00:38,229
so today's lecture is on advanced sequel

20
00:00:38,229 --> 00:00:38,239
 

21
00:00:38,239 --> 00:00:42,039
and by advanced I mean going beyond what

22
00:00:42,039 --> 00:00:42,049
 

23
00:00:42,049 --> 00:00:44,079
you may or may not already know about

24
00:00:44,079 --> 00:00:44,089
 

25
00:00:44,089 --> 00:00:48,009
basic sequel right it's it's 2018 sequel

26
00:00:48,009 --> 00:00:48,019
 

27
00:00:48,019 --> 00:00:51,640
was invented in 1973 I imagine most you

28
00:00:51,640 --> 00:00:51,650
 

29
00:00:51,650 --> 00:00:53,259
have seen some sequel throughout your

30
00:00:53,259 --> 00:00:53,269
 

31
00:00:53,269 --> 00:00:55,119
life so I don't feel it's necessary to

32
00:00:55,119 --> 00:00:55,129
 

33
00:00:55,129 --> 00:00:56,920
teach you the basics of it so I'm gonna

34
00:00:56,920 --> 00:00:56,930
 

35
00:00:56,930 --> 00:00:58,149
spend time actually talking about the

36
00:00:58,149 --> 00:00:58,159
 

37
00:00:58,159 --> 00:00:59,590
more complicated or interesting things

38
00:00:59,590 --> 00:00:59,600
 

39
00:00:59,600 --> 00:01:03,399
you can do with sequel okay so just to

40
00:01:03,399 --> 00:01:03,409
 

41
00:01:03,409 --> 00:01:05,890
pick up where we left last class we were

42
00:01:05,890 --> 00:01:05,900
 

43
00:01:05,900 --> 00:01:07,300
discussing the relational model and

44
00:01:07,300 --> 00:01:07,310
 

45
00:01:07,310 --> 00:01:09,970
relational algebra and we sort of

46
00:01:09,970 --> 00:01:09,980
 

47
00:01:09,980 --> 00:01:12,130
mentioned that the with relational

48
00:01:12,130 --> 00:01:12,140
 

49
00:01:12,140 --> 00:01:15,610
algebra sir the goal was sort of at a

50
00:01:15,610 --> 00:01:15,620
 

51
00:01:15,620 --> 00:01:19,450
high level to describe what the answer

52
00:01:19,450 --> 00:01:19,460
 

53
00:01:19,460 --> 00:01:20,950
we wanted that the database system would

54
00:01:20,950 --> 00:01:20,960
 

55
00:01:20,960 --> 00:01:23,380
compute rather than the exact steps of

56
00:01:23,380 --> 00:01:23,390
 

57
00:01:23,390 --> 00:01:25,660
actually how to do it all right so the

58
00:01:25,660 --> 00:01:25,670
 

59
00:01:25,670 --> 00:01:27,160
way to think about this is like say we

60
00:01:27,160 --> 00:01:27,170
 

61
00:01:27,170 --> 00:01:30,790
want to sort our data if we have to tell

62
00:01:30,790 --> 00:01:30,800
 

63
00:01:30,800 --> 00:01:32,380
the day system exactly what to do we

64
00:01:32,380 --> 00:01:32,390
 

65
00:01:32,390 --> 00:01:34,120
have to provide it you know with the

66
00:01:34,120 --> 00:01:34,130
 

67
00:01:34,130 --> 00:01:36,610
quick sort of bubble sort algorithm but

68
00:01:36,610 --> 00:01:36,620
 

69
00:01:36,620 --> 00:01:38,320
with a high level language or

70
00:01:38,320 --> 00:01:38,330
 

71
00:01:38,330 --> 00:01:39,790
declarative language we just say hey we

72
00:01:39,790 --> 00:01:39,800
 

73
00:01:39,800 --> 00:01:41,740
want you to sort this we don't care how

74
00:01:41,740 --> 00:01:41,750
 

75
00:01:41,750 --> 00:01:44,110
you actually do it but this is the

76
00:01:44,110 --> 00:01:44,120
 

77
00:01:44,120 --> 00:01:46,420
answer that we want and we'll see this

78
00:01:46,420 --> 00:01:46,430
 

79
00:01:46,430 --> 00:01:48,070
throughout today's lecture and then

80
00:01:48,070 --> 00:01:48,080
 

81
00:01:48,080 --> 00:01:49,300
going forward throughout later in the

82
00:01:49,300 --> 00:01:49,310

83
00:01:49,310 --> 00:01:50,860
semester all right this is one of the

84
00:01:50,860 --> 00:01:50,870
 

85
00:01:50,870 --> 00:01:52,719
advantage of using something like Secord

86
00:01:52,719 --> 00:01:52,729
 

87
00:01:52,729 --> 00:01:54,550
our declarative languages we don't have

88
00:01:54,550 --> 00:01:54,560
 

89
00:01:54,560 --> 00:01:56,230
to tell today's system exactly how to do

90
00:01:56,230 --> 00:01:56,240
 

91
00:01:56,240 --> 00:01:58,360
things it can figure it out own zone and

92
00:01:58,360 --> 00:01:58,370
 

93
00:01:58,370 --> 00:02:00,550
that frees it up to figure out what

94
00:02:00,550 --> 00:02:00,560

95
00:02:00,560 --> 00:02:02,469
there was optimal way it is to actually

96
00:02:02,469 --> 00:02:02,479
 

97
00:02:02,479 --> 00:02:03,670
execute the query that you want to

98
00:02:03,670 --> 00:02:03,680
 

99
00:02:03,680 --> 00:02:05,800
execute based on the data that you have

100
00:02:05,800 --> 00:02:05,810
 

101
00:02:05,810 --> 00:02:07,780
and and give the harbor that's available

102
00:02:07,780 --> 00:02:07,790
 

103
00:02:07,790 --> 00:02:11,199
to you so we'll see this later when we

104
00:02:11,199 --> 00:02:11,209
 

105
00:02:11,209 --> 00:02:12,580
talk about the query optimizer but the

106
00:02:12,580 --> 00:02:12,590
 

107
00:02:12,590 --> 00:02:13,690
query optimizer is this complicated

108
00:02:13,690 --> 00:02:13,700
 

109
00:02:13,700 --> 00:02:16,660
piece of machinery inside of a database

110
00:02:16,660 --> 00:02:16,670
 

111
00:02:16,670 --> 00:02:17,630
system that's

112
00:02:17,630 --> 00:02:17,640
 

113
00:02:17,640 --> 00:02:19,820
take our sequel query and convert it to

114
00:02:19,820 --> 00:02:19,830
 

115
00:02:19,830 --> 00:02:21,949
the most efficient plan and we'll cover

116
00:02:21,949 --> 00:02:21,959
 

117
00:02:21,959 --> 00:02:24,530
how they actually do this later on but I

118
00:02:24,530 --> 00:02:24,540
 

119
00:02:24,540 --> 00:02:27,559
will say is that if you if you you know

120
00:02:27,559 --> 00:02:27,569
 

121
00:02:27,569 --> 00:02:29,270
if you get involved in doing research on

122
00:02:29,270 --> 00:02:29,280
 

123
00:02:29,280 --> 00:02:30,920
query optimization or just help you know

124
00:02:30,920 --> 00:02:30,930

125
00:02:30,930 --> 00:02:33,020
working on Cori optimizers you can get a

126
00:02:33,020 --> 00:02:33,030
 

127
00:02:33,030 --> 00:02:35,270
job yesterday because this is the one

128
00:02:35,270 --> 00:02:35,280
 

129
00:02:35,280 --> 00:02:36,770
thing that all my friends at Davis

130
00:02:36,770 --> 00:02:36,780
 

131
00:02:36,780 --> 00:02:38,570
company companies email me about over

132
00:02:38,570 --> 00:02:38,580
 

133
00:02:38,580 --> 00:02:40,580
and over again do I have any students to

134
00:02:40,580 --> 00:02:40,590
 

135
00:02:40,590 --> 00:02:42,830
do query optimization we've had some and

136
00:02:42,830 --> 00:02:42,840
 

137
00:02:42,840 --> 00:02:44,390
they all get off go off and do awesome

138
00:02:44,390 --> 00:02:44,400
 

139
00:02:44,400 --> 00:02:47,030
jobs this is the one thing that

140
00:02:47,030 --> 00:02:47,040
 

141
00:02:47,040 --> 00:02:48,440
everybody wants because it's really hard

142
00:02:48,440 --> 00:02:48,450
 

143
00:02:48,450 --> 00:02:50,810
to do so that's not the focus here right

144
00:02:50,810 --> 00:02:50,820
 

145
00:02:50,820 --> 00:02:52,130
just in the back your mind will see

146
00:02:52,130 --> 00:02:52,140
 

147
00:02:52,140 --> 00:02:54,080
examples as we go along where a query

148
00:02:54,080 --> 00:02:54,090
 

149
00:02:54,090 --> 00:02:55,580
optimizer could try out different things

150
00:02:55,580 --> 00:02:55,590
 

151
00:02:55,590 --> 00:02:56,750
I try to come up with different plans

152
00:02:56,750 --> 00:02:56,760
 

153
00:02:56,760 --> 00:02:58,670
well we'll discuss how you actually do

154
00:02:58,670 --> 00:02:58,680
 

155
00:02:58,680 --> 00:03:03,699
query optimization later on so the the

156
00:03:03,699 --> 00:03:03,709

157
00:03:03,709 --> 00:03:06,050
history of sequel as I said goes back

158
00:03:06,050 --> 00:03:06,060

159
00:03:06,060 --> 00:03:10,610
into the early 1970s so you may notice

160
00:03:10,610 --> 00:03:10,620
 

161
00:03:10,620 --> 00:03:11,750
that I say sequel

162
00:03:11,750 --> 00:03:11,760

163
00:03:11,760 --> 00:03:14,120
some people say SQL write the part of

164
00:03:14,120 --> 00:03:14,130
 

165
00:03:14,130 --> 00:03:16,040
the reason I say sequel is because in

166
00:03:16,040 --> 00:03:16,050
 

167
00:03:16,050 --> 00:03:18,590
not that I was alive in 1970s but the

168
00:03:18,590 --> 00:03:18,600
 

169
00:03:18,600 --> 00:03:20,420
original name of the language was

170
00:03:20,420 --> 00:03:20,430
 

171
00:03:20,430 --> 00:03:23,240
actually spelled out as EQ UAL sequel

172
00:03:23,240 --> 00:03:23,250

173
00:03:23,250 --> 00:03:26,120
and this was invited by IBM as part of

174
00:03:26,120 --> 00:03:26,130
 

175
00:03:26,130 --> 00:03:28,400
the system our project right so it stood

176
00:03:28,400 --> 00:03:28,410
 

177
00:03:28,410 --> 00:03:29,870
for the structured English query

178
00:03:29,870 --> 00:03:29,880
 

179
00:03:29,880 --> 00:03:32,720
language so if you remember from the TED

180
00:03:32,720 --> 00:03:32,730
 

181
00:03:32,730 --> 00:03:34,970
Cod paper I said that Ted Cobb was a

182
00:03:34,970 --> 00:03:34,980
 

183
00:03:34,980 --> 00:03:37,009
mathematician right he devised the

184
00:03:37,009 --> 00:03:37,019
 

185
00:03:37,019 --> 00:03:39,110
relational algebra and relational model

186
00:03:39,110 --> 00:03:39,120
 

187
00:03:39,120 --> 00:03:40,250
but he didn't actually define the

188
00:03:40,250 --> 00:03:40,260
 

189
00:03:40,260 --> 00:03:42,410
programming language you would use to

190
00:03:42,410 --> 00:03:42,420
 

191
00:03:42,420 --> 00:03:44,120
write queries on it I mean you can't

192
00:03:44,120 --> 00:03:44,130
 

193
00:03:44,130 --> 00:03:45,440
write queries using relational algebra

194
00:03:45,440 --> 00:03:45,450
 

195
00:03:45,450 --> 00:03:47,150
right it's sort of you know there's

196
00:03:47,150 --> 00:03:47,160
 

197
00:03:47,160 --> 00:03:48,949
there's no it's very difficult to write

198
00:03:48,949 --> 00:03:48,959
 

199
00:03:48,959 --> 00:03:51,289
that in the keyboard to do that he did

200
00:03:51,289 --> 00:03:51,299
 

201
00:03:51,299 --> 00:03:52,910
later define or come up with his own

202
00:03:52,910 --> 00:03:52,920
 

203
00:03:52,920 --> 00:03:55,460
query language called alpha but that was

204
00:03:55,460 --> 00:03:55,470
 

205
00:03:55,470 --> 00:03:57,710
much later in 1970s so back then when

206
00:03:57,710 --> 00:03:57,720
 

207
00:03:57,720 --> 00:03:59,300
people said hey there's a relational

208
00:03:59,300 --> 00:03:59,310
 

209
00:03:59,310 --> 00:04:00,470
model idea we should actually write ooh

210
00:04:00,470 --> 00:04:00,480
 

211
00:04:00,480 --> 00:04:02,600
build a system to do this people had to

212
00:04:02,600 --> 00:04:02,610
 

213
00:04:02,610 --> 00:04:03,949
come up with their own language that

214
00:04:03,949 --> 00:04:03,959
 

215
00:04:03,959 --> 00:04:05,990
could implement relational calculus or

216
00:04:05,990 --> 00:04:06,000
 

217
00:04:06,000 --> 00:04:08,840
relational algebra so at IBM they came

218
00:04:08,840 --> 00:04:08,850
 

219
00:04:08,850 --> 00:04:11,180
out with sequel this is part of the

220
00:04:11,180 --> 00:04:11,190
 

221
00:04:11,190 --> 00:04:13,490
system our project which is a sort of

222
00:04:13,490 --> 00:04:13,500
 

223
00:04:13,500 --> 00:04:14,690
one of the first relational database

224
00:04:14,690 --> 00:04:14,700
 

225
00:04:14,700 --> 00:04:16,279
systems that people were trying to build

226
00:04:16,279 --> 00:04:16,289
 

227
00:04:16,289 --> 00:04:18,770
in the 1970s the other major one was

228
00:04:18,770 --> 00:04:18,780
 

229
00:04:18,780 --> 00:04:21,199
ingress that came out of Berkeley

230
00:04:21,199 --> 00:04:21,209
 

231
00:04:21,209 --> 00:04:23,600
so you've ever heard of Postgres right

232
00:04:23,600 --> 00:04:23,610
 

233
00:04:23,610 --> 00:04:25,130
Postgres was invented by the same guy

234
00:04:25,130 --> 00:04:25,140
 

235
00:04:25,140 --> 00:04:27,529
that did ingress so it's called Postgres

236
00:04:27,529 --> 00:04:27,539
 

237
00:04:27,539 --> 00:04:28,460
as in post

238
00:04:28,460 --> 00:04:28,470

239
00:04:28,470 --> 00:04:29,900
ingress the thing that came after

240
00:04:29,900 --> 00:04:29,910
 

241
00:04:29,910 --> 00:04:31,170
ingress so

242
00:04:31,170 --> 00:04:31,180

243
00:04:31,180 --> 00:04:32,400
the ingress guys had their own language

244
00:04:32,400 --> 00:04:32,410
 

245
00:04:32,410 --> 00:04:35,550
called quell and this was developed by

246
00:04:35,550 --> 00:04:35,560
 

247
00:04:35,560 --> 00:04:37,890
one of my advisers Mike Stormbreaker he

248
00:04:37,890 --> 00:04:37,900
 

249
00:04:37,900 --> 00:04:39,630
claims it was much better than sequel

250
00:04:39,630 --> 00:04:39,640
 

251
00:04:39,640 --> 00:04:40,770
and the IBM guys didn't know what they

252
00:04:40,770 --> 00:04:40,780

253
00:04:40,780 --> 00:04:42,570
were doing of course most people have

254
00:04:42,570 --> 00:04:42,580
 

255
00:04:42,580 --> 00:04:44,700
never heard a quell right right so it

256
00:04:44,700 --> 00:04:44,710
 

257
00:04:44,710 --> 00:04:45,570
didn't actually win

258
00:04:45,570 --> 00:04:45,580
 

259
00:04:45,580 --> 00:04:49,560
IBM won so back then again it was

260
00:04:49,560 --> 00:04:49,570
 

261
00:04:49,570 --> 00:04:52,950
spelled out as eqtl IBM later got sued

262
00:04:52,950 --> 00:04:52,960
 

263
00:04:52,960 --> 00:04:55,140
for I think you know a copyright

264
00:04:55,140 --> 00:04:55,150
 

265
00:04:55,150 --> 00:04:56,190
infringement trademark infringement

266
00:04:56,190 --> 00:04:56,200
 

267
00:04:56,200 --> 00:04:57,900
there was some guy in England that had

268
00:04:57,900 --> 00:04:57,910
 

269
00:04:57,910 --> 00:05:01,080
the the term sequel spelt out in the

270
00:05:01,080 --> 00:05:01,090
 

271
00:05:01,090 --> 00:05:02,460
full English word for his programming

272
00:05:02,460 --> 00:05:02,470
 

273
00:05:02,470 --> 00:05:04,530
language so it is shortened it to be sq

274
00:05:04,530 --> 00:05:04,540
 

275
00:05:04,540 --> 00:05:09,810
SQL so what happened was the reason why

276
00:05:09,810 --> 00:05:09,820

277
00:05:09,820 --> 00:05:12,720
we use sequel today because IBM it's not

278
00:05:12,720 --> 00:05:12,730
 

279
00:05:12,730 --> 00:05:14,700
back then IBM is and what it is now

280
00:05:14,700 --> 00:05:14,710
 

281
00:05:14,710 --> 00:05:15,990
right everyone thinks the big the big

282
00:05:15,990 --> 00:05:16,000
 

283
00:05:16,000 --> 00:05:17,970
tech companies like Microsoft Amazon and

284
00:05:17,970 --> 00:05:17,980

285
00:05:17,980 --> 00:05:21,210
Google back in the 1970s 1980s IBM was

286
00:05:21,210 --> 00:05:21,220
 

287
00:05:21,220 --> 00:05:23,040
was the juggernaut so essentially

288
00:05:23,040 --> 00:05:23,050
 

289
00:05:23,050 --> 00:05:24,840
whatever IBM did or said this is the way

290
00:05:24,840 --> 00:05:24,850

291
00:05:24,850 --> 00:05:26,250
we're gonna do it that ended up being

292
00:05:26,250 --> 00:05:26,260
 

293
00:05:26,260 --> 00:05:30,180
the standard so when IBM first released

294
00:05:30,180 --> 00:05:30,190

295
00:05:30,190 --> 00:05:31,710
their first commercial relational

296
00:05:31,710 --> 00:05:31,720

297
00:05:31,720 --> 00:05:33,930
database system db2 so they never

298
00:05:33,930 --> 00:05:33,940
 

299
00:05:33,940 --> 00:05:35,700
actually released system arm it's just

300
00:05:35,700 --> 00:05:35,710
 

301
00:05:35,710 --> 00:05:37,830
sort of a research prototype but then

302
00:05:37,830 --> 00:05:37,840
 

303
00:05:37,840 --> 00:05:41,070
then finally made db2 released that db2

304
00:05:41,070 --> 00:05:41,080
 

305
00:05:41,080 --> 00:05:42,660
supported sequel so that essentially

306
00:05:42,660 --> 00:05:42,670
 

307
00:05:42,670 --> 00:05:46,470
became the standard and the reason why

308
00:05:46,470 --> 00:05:46,480
 

309
00:05:46,480 --> 00:05:48,210
Oracle sort of took off and got as big

310
00:05:48,210 --> 00:05:48,220
 

311
00:05:48,220 --> 00:05:49,830
as it is today is they were sort of

312
00:05:49,830 --> 00:05:49,840
 

313
00:05:49,840 --> 00:05:52,550
copying what IBM was doing in the 1970s

314
00:05:52,550 --> 00:05:52,560

315
00:05:52,560 --> 00:05:54,960
in more ways than one we can talk about

316
00:05:54,960 --> 00:05:54,970
 

317
00:05:54,970 --> 00:05:59,130
that later and they did they had sequel

318
00:05:59,130 --> 00:05:59,140
 

319
00:05:59,140 --> 00:06:00,840
so when IBM came out with db2 and had

320
00:06:00,840 --> 00:06:00,850
 

321
00:06:00,850 --> 00:06:02,430
sequel Oracle was right at the right

322
00:06:02,430 --> 00:06:02,440
 

323
00:06:02,440 --> 00:06:03,600
place at the right time said we now

324
00:06:03,600 --> 00:06:03,610
 

325
00:06:03,610 --> 00:06:06,630
supports we know we support sequel - so

326
00:06:06,630 --> 00:06:06,640
 

327
00:06:06,640 --> 00:06:09,600
it became an ANSI standard in 1986 and

328
00:06:09,600 --> 00:06:09,610

329
00:06:09,610 --> 00:06:11,460
became an international standard in 1987

330
00:06:11,460 --> 00:06:11,470
 

331
00:06:11,470 --> 00:06:13,500
and now the short burden just means the

332
00:06:13,500 --> 00:06:13,510

333
00:06:13,510 --> 00:06:17,430
structured query language so sequel even

334
00:06:17,430 --> 00:06:17,440
 

335
00:06:17,440 --> 00:06:20,490
though it's from 1970s it's not a dead

336
00:06:20,490 --> 00:06:20,500
 

337
00:06:20,500 --> 00:06:22,350
language it's not certainly static it's

338
00:06:22,350 --> 00:06:22,360
 

339
00:06:22,360 --> 00:06:23,970
sort of like you know C++ to keep

340
00:06:23,970 --> 00:06:23,980
 

341
00:06:23,980 --> 00:06:25,650
releasing new specifications every so

342
00:06:25,650 --> 00:06:25,660
 

343
00:06:25,660 --> 00:06:27,420
often it's the same thing in sequel

344
00:06:27,420 --> 00:06:27,430
 

345
00:06:27,430 --> 00:06:28,350
every so often there's a new

346
00:06:28,350 --> 00:06:28,360
 

347
00:06:28,360 --> 00:06:30,180
specification where they add in new

348
00:06:30,180 --> 00:06:30,190
 

349
00:06:30,190 --> 00:06:32,010
features and new functionalities - to

350
00:06:32,010 --> 00:06:32,020
 

351
00:06:32,020 --> 00:06:34,530
the basic language so the the latest

352
00:06:34,530 --> 00:06:34,540
 

353
00:06:34,540 --> 00:06:37,890
standard is defined in sequel 2016 and

354
00:06:37,890 --> 00:06:37,900

355
00:06:37,900 --> 00:06:39,780
you can see over the years at the add

356
00:06:39,780 --> 00:06:39,790
 

357
00:06:39,790 --> 00:06:41,610
new versions they add new features right

358
00:06:41,610 --> 00:06:41,620

359
00:06:41,620 --> 00:06:43,950
so 2016 they added JSON polymorphic

360
00:06:43,950 --> 00:06:43,960
 

361
00:06:43,960 --> 00:06:45,030
tables

362
00:06:45,030 --> 00:06:45,040
 

363
00:06:45,040 --> 00:06:48,030
they add XML stuff and then 2003 1999

364
00:06:48,030 --> 00:06:48,040
 

365
00:06:48,040 --> 00:06:50,970
added regex and triggers typically what

366
00:06:50,970 --> 00:06:50,980
 

367
00:06:50,980 --> 00:06:53,340
happens is there's a standards body that

368
00:06:53,340 --> 00:06:53,350
 

369
00:06:53,350 --> 00:06:55,890
the members are all from the major

370
00:06:55,890 --> 00:06:55,900
 

371
00:06:55,900 --> 00:06:57,990
database companies and major database

372
00:06:57,990 --> 00:06:58,000

373
00:06:58,000 --> 00:06:58,800
companies come up with their own

374
00:06:58,800 --> 00:06:58,810

375
00:06:58,810 --> 00:07:00,750
proprietary features and extensions and

376
00:07:00,750 --> 00:07:00,760
 

377
00:07:00,760 --> 00:07:02,070
then they go in the standards body and

378
00:07:02,070 --> 00:07:02,080

379
00:07:02,080 --> 00:07:03,750
push to try to get their version of

380
00:07:03,750 --> 00:07:03,760
 

381
00:07:03,760 --> 00:07:05,640
certain functionality as part of the

382
00:07:05,640 --> 00:07:05,650
 

383
00:07:05,650 --> 00:07:08,820
standard right so this is although there

384
00:07:08,820 --> 00:07:08,830
 

385
00:07:08,830 --> 00:07:11,070
is a sequel standard nobody actually

386
00:07:11,070 --> 00:07:11,080
 

387
00:07:11,080 --> 00:07:12,930
follows it to the T right because

388
00:07:12,930 --> 00:07:12,940
 

389
00:07:12,940 --> 00:07:13,890
everyone sort of has their own

390
00:07:13,890 --> 00:07:13,900
 

391
00:07:13,900 --> 00:07:15,450
proprietary things that got invented

392
00:07:15,450 --> 00:07:15,460

393
00:07:15,460 --> 00:07:16,890
before the standard came out said this

394
00:07:16,890 --> 00:07:16,900
 

395
00:07:16,900 --> 00:07:20,610
is how you should do things so if you're

396
00:07:20,610 --> 00:07:20,620
 

397
00:07:20,620 --> 00:07:21,870
gonna claim that your database system

398
00:07:21,870 --> 00:07:21,880
 

399
00:07:21,880 --> 00:07:24,060
supports sequel the bare minimum you

400
00:07:24,060 --> 00:07:24,070
 

401
00:07:24,070 --> 00:07:25,680
need to have is actually what is defined

402
00:07:25,680 --> 00:07:25,690
 

403
00:07:25,690 --> 00:07:28,260
in the sequel 92 standard so this is

404
00:07:28,260 --> 00:07:28,270
 

405
00:07:28,270 --> 00:07:29,790
what the basic sequel that we know about

406
00:07:29,790 --> 00:07:29,800
 

407
00:07:29,800 --> 00:07:31,680
today select insert update delete create

408
00:07:31,680 --> 00:07:31,690
 

409
00:07:31,690 --> 00:07:34,140
tables transactions things like that all

410
00:07:34,140 --> 00:07:34,150
 

411
00:07:34,150 --> 00:07:36,840
that's defined in sequel 92 so again if

412
00:07:36,840 --> 00:07:36,850
 

413
00:07:36,850 --> 00:07:38,130
someone someone says their data system

414
00:07:38,130 --> 00:07:38,140
 

415
00:07:38,140 --> 00:07:39,990
supports equal chances are they that

416
00:07:39,990 --> 00:07:40,000
 

417
00:07:40,000 --> 00:07:41,670
really mean this and then the more

418
00:07:41,670 --> 00:07:41,680
 

419
00:07:41,680 --> 00:07:44,190
advanced databases both an open source

420
00:07:44,190 --> 00:07:44,200
 

421
00:07:44,200 --> 00:07:46,320
and and the commercial ones they add

422
00:07:46,320 --> 00:07:46,330
 

423
00:07:46,330 --> 00:07:48,360
they have a bunch of more features from

424
00:07:48,360 --> 00:07:48,370
 

425
00:07:48,370 --> 00:07:52,620
from from the newer Sanders and then

426
00:07:52,620 --> 00:07:52,630
 

427
00:07:52,630 --> 00:07:53,910
there's this great website here it's a

428
00:07:53,910 --> 00:07:53,920
 

429
00:07:53,920 --> 00:07:57,240
bit dated now but it's going at its some

430
00:07:57,240 --> 00:07:57,250
 

431
00:07:57,250 --> 00:07:59,520
random dude who basically looked at sort

432
00:07:59,520 --> 00:07:59,530
 

433
00:07:59,530 --> 00:08:01,170
of the top four top five database

434
00:08:01,170 --> 00:08:01,180
 

435
00:08:01,180 --> 00:08:03,600
systems and just look to see how they

436
00:08:03,600 --> 00:08:03,610
 

437
00:08:03,610 --> 00:08:06,390
differ on various sequel features and

438
00:08:06,390 --> 00:08:06,400
 

439
00:08:06,400 --> 00:08:07,800
their compares sequel functionalities

440
00:08:07,800 --> 00:08:07,810
 

441
00:08:07,810 --> 00:08:09,750
and we'll see this as we go through

442
00:08:09,750 --> 00:08:09,760
 

443
00:08:09,760 --> 00:08:11,820
today there'll be some examples where

444
00:08:11,820 --> 00:08:11,830
 

445
00:08:11,830 --> 00:08:13,980
the standard says one thing different

446
00:08:13,980 --> 00:08:13,990
 

447
00:08:13,990 --> 00:08:15,720
database systems do other things it's

448
00:08:15,720 --> 00:08:15,730
 

449
00:08:15,730 --> 00:08:20,280
usually my sequel and this is just gonna

450
00:08:20,280 --> 00:08:20,290
 

451
00:08:20,290 --> 00:08:22,140
even though there's a standard nobody

452
00:08:22,140 --> 00:08:22,150
 

453
00:08:22,150 --> 00:08:24,420
actually follows it exactly right

454
00:08:24,420 --> 00:08:24,430
 

455
00:08:24,430 --> 00:08:25,650
there's no database system that I'm

456
00:08:25,650 --> 00:08:25,660
 

457
00:08:25,660 --> 00:08:26,970
aware of that would claim that they're

458
00:08:26,970 --> 00:08:26,980
 

459
00:08:26,980 --> 00:08:29,700
you know certify for sequel 2016 right

460
00:08:29,700 --> 00:08:29,710
 

461
00:08:29,710 --> 00:08:33,210
they had bits and pieces of things so

462
00:08:33,210 --> 00:08:33,220
 

463
00:08:33,220 --> 00:08:35,909
sequel itself technically is not a

464
00:08:35,909 --> 00:08:35,919
 

465
00:08:35,919 --> 00:08:37,740
single language it's sort of a

466
00:08:37,740 --> 00:08:37,750
 

467
00:08:37,750 --> 00:08:40,320
collection of things in a particular

468
00:08:40,320 --> 00:08:40,330
 

469
00:08:40,330 --> 00:08:42,950
collection of a DML DDL and DCO

470
00:08:42,950 --> 00:08:42,960
 

471
00:08:42,960 --> 00:08:46,680
commands so DML will be would be the

472
00:08:46,680 --> 00:08:46,690
 

473
00:08:46,690 --> 00:08:48,450
data manipulation language would be the

474
00:08:48,450 --> 00:08:48,460
 

475
00:08:48,460 --> 00:08:50,250
commands like insert update delete

476
00:08:50,250 --> 00:08:50,260

477
00:08:50,260 --> 00:08:51,810
selects like the things that actually

478
00:08:51,810 --> 00:08:51,820
 

479
00:08:51,820 --> 00:08:53,580
manipulate the data that you can store

480
00:08:53,580 --> 00:08:53,590
 

481
00:08:53,590 --> 00:08:56,370
in your database the DDL is the way you

482
00:08:56,370 --> 00:08:56,380
 

483
00:08:56,380 --> 00:08:58,530
create tables actually

484
00:08:58,530 --> 00:08:58,540

485
00:08:58,540 --> 00:09:00,780
schemas to actually store things and

486
00:09:00,780 --> 00:09:00,790

487
00:09:00,790 --> 00:09:03,450
then the D CL is the way you sort of do

488
00:09:03,450 --> 00:09:03,460
 

489
00:09:03,460 --> 00:09:05,970
security authorization to grant you know

490
00:09:05,970 --> 00:09:05,980
 

491
00:09:05,980 --> 00:09:08,480
who's allowed to read what what datum

492
00:09:08,480 --> 00:09:08,490
 

493
00:09:08,490 --> 00:09:11,250
there's a bunch of other things like how

494
00:09:11,250 --> 00:09:11,260
 

495
00:09:11,260 --> 00:09:13,080
to define views how to define integrity

496
00:09:13,080 --> 00:09:13,090
 

497
00:09:13,090 --> 00:09:15,750
constraints referential constraints as

498
00:09:15,750 --> 00:09:15,760
 

499
00:09:15,760 --> 00:09:16,800
well as transactions

500
00:09:16,800 --> 00:09:16,810
 

501
00:09:16,810 --> 00:09:18,240
rhaggy these are all part of the

502
00:09:18,240 --> 00:09:18,250
 

503
00:09:18,250 --> 00:09:21,210
umbrella of sequel right and within that

504
00:09:21,210 --> 00:09:21,220
 

505
00:09:21,220 --> 00:09:22,670
there's these different categories of

506
00:09:22,670 --> 00:09:22,680
 

507
00:09:22,680 --> 00:09:25,740
commands so the one important thing that

508
00:09:25,740 --> 00:09:25,750
 

509
00:09:25,750 --> 00:09:27,750
I want to point out here and we'll see

510
00:09:27,750 --> 00:09:27,760
 

511
00:09:27,760 --> 00:09:29,780
this throughout today's lecture is

512
00:09:29,780 --> 00:09:29,790

513
00:09:29,790 --> 00:09:32,280
unlike in relational algebra which is

514
00:09:32,280 --> 00:09:32,290

515
00:09:32,290 --> 00:09:36,030
based on set theory or sets sequel is

516
00:09:36,030 --> 00:09:36,040
 

517
00:09:36,040 --> 00:09:39,330
actually based on bag algebra so the way

518
00:09:39,330 --> 00:09:39,340

519
00:09:39,340 --> 00:09:40,380
to sort of think about this you could

520
00:09:40,380 --> 00:09:40,390
 

521
00:09:40,390 --> 00:09:43,920
have like lists sets or bags so a list

522
00:09:43,920 --> 00:09:43,930
 

523
00:09:43,930 --> 00:09:46,800
can have duplicates but there's there's

524
00:09:46,800 --> 00:09:46,810

525
00:09:46,810 --> 00:09:48,450
a defined order so if I push something

526
00:09:48,450 --> 00:09:48,460
 

527
00:09:48,460 --> 00:09:50,490
to my list that's its position in that

528
00:09:50,490 --> 00:09:50,500
 

529
00:09:50,500 --> 00:09:53,370
list a set is unordered meaning the

530
00:09:53,370 --> 00:09:53,380
 

531
00:09:53,380 --> 00:09:56,010
elements don't have a position but you

532
00:09:56,010 --> 00:09:56,020
 

533
00:09:56,020 --> 00:09:57,900
can't have duplicates if I try to insert

534
00:09:57,900 --> 00:09:57,910
 

535
00:09:57,910 --> 00:09:59,670
the same thing into a set it just gets

536
00:09:59,670 --> 00:09:59,680
 

537
00:09:59,680 --> 00:10:02,670
over the old one gets overwritten a bag

538
00:10:02,670 --> 00:10:02,680
 

539
00:10:02,680 --> 00:10:06,120
has neither a set position or ordering

540
00:10:06,120 --> 00:10:06,130
 

541
00:10:06,130 --> 00:10:10,320
but it also allows for duplicates right

542
00:10:10,320 --> 00:10:10,330
 

543
00:10:10,330 --> 00:10:12,450
and we'll see why we've got to do this

544
00:10:12,450 --> 00:10:12,460
 

545
00:10:12,460 --> 00:10:14,640
as we go along because if we want to

546
00:10:14,640 --> 00:10:14,650
 

547
00:10:14,650 --> 00:10:17,520
actually define order on our elements or

548
00:10:17,520 --> 00:10:17,530
 

549
00:10:17,530 --> 00:10:18,720
if you want to make sure that we don't

550
00:10:18,720 --> 00:10:18,730
 

551
00:10:18,730 --> 00:10:20,730
have duplicates essentially the database

552
00:10:20,730 --> 00:10:20,740
 

553
00:10:20,740 --> 00:10:23,040
system has to do extra work to provide

554
00:10:23,040 --> 00:10:23,050
 

555
00:10:23,050 --> 00:10:25,710
that for you and so the idea is that

556
00:10:25,710 --> 00:10:25,720
 

557
00:10:25,720 --> 00:10:28,140
only if you explicitly ask the database

558
00:10:28,140 --> 00:10:28,150
 

559
00:10:28,150 --> 00:10:30,000
system to provide you ordering it

560
00:10:30,000 --> 00:10:30,010
 

561
00:10:30,010 --> 00:10:32,460
provide you to remove duplicates it

562
00:10:32,460 --> 00:10:32,470
 

563
00:10:32,470 --> 00:10:34,170
won't actually do it and this actually

564
00:10:34,170 --> 00:10:34,180
 

565
00:10:34,180 --> 00:10:38,010
make things be a be more efficient all

566
00:10:38,010 --> 00:10:38,020
 

567
00:10:38,020 --> 00:10:39,510
right so the outline for today is we're

568
00:10:39,510 --> 00:10:39,520
 

569
00:10:39,520 --> 00:10:41,580
going to cover aggregations group eyes a

570
00:10:41,580 --> 00:10:41,590
 

571
00:10:41,590 --> 00:10:43,740
bunch of operations on strings dates and

572
00:10:43,740 --> 00:10:43,750
 

573
00:10:43,750 --> 00:10:45,690
times then we do have to do output

574
00:10:45,690 --> 00:10:45,700
 

575
00:10:45,700 --> 00:10:48,210
control and then the more complicated

576
00:10:48,210 --> 00:10:48,220
 

577
00:10:48,220 --> 00:10:49,860
things would be nested queries common

578
00:10:49,860 --> 00:10:49,870
 

579
00:10:49,870 --> 00:10:51,300
table expressions and window functions

580
00:10:51,300 --> 00:10:51,310
 

581
00:10:51,310 --> 00:10:55,050
so for homework one you'll need to use

582
00:10:55,050 --> 00:10:55,060
 

583
00:10:55,060 --> 00:10:56,850
all of these except for the window

584
00:10:56,850 --> 00:10:56,860
 

585
00:10:56,860 --> 00:10:58,410
functions all right because you can be

586
00:10:58,410 --> 00:10:58,420
 

587
00:10:58,420 --> 00:10:59,940
doing homework one on sequel Lite and

588
00:10:59,940 --> 00:10:59,950
 

589
00:10:59,950 --> 00:11:01,710
only actually the latest version of

590
00:11:01,710 --> 00:11:01,720
 

591
00:11:01,720 --> 00:11:04,020
sequel Lite as of last week just added

592
00:11:04,020 --> 00:11:04,030
 

593
00:11:04,030 --> 00:11:06,210
support for window functions but

594
00:11:06,210 --> 00:11:06,220
 

595
00:11:06,220 --> 00:11:07,680
everything else sequel Lite should be

596
00:11:07,680 --> 00:11:07,690
 

597
00:11:07,690 --> 00:11:11,160
able to support

598
00:11:11,160 --> 00:11:11,170


599
00:11:11,170 --> 00:11:15,340
okay alright so for this the we're needs

600
00:11:15,340 --> 00:11:15,350
 

601
00:11:15,350 --> 00:11:17,530
a sample database comprised of three

602
00:11:17,530 --> 00:11:17,540
 

603
00:11:17,540 --> 00:11:20,170
tables so sort of it's a mock University

604
00:11:20,170 --> 00:11:20,180
 

605
00:11:20,180 --> 00:11:21,730
so we're gonna have a student table

606
00:11:21,730 --> 00:11:21,740
 

607
00:11:21,740 --> 00:11:23,560
where students have student IDs names

608
00:11:23,560 --> 00:11:23,570
 

609
00:11:23,570 --> 00:11:26,170
logs and GPS will have a course table

610
00:11:26,170 --> 00:11:26,180
 

611
00:11:26,180 --> 00:11:28,510
with course IDs a name and then we'll

612
00:11:28,510 --> 00:11:28,520
 

613
00:11:28,520 --> 00:11:30,970
have an enroll table where we have a

614
00:11:30,970 --> 00:11:30,980
 

615
00:11:30,980 --> 00:11:32,710
certain foreign key reference from the

616
00:11:32,710 --> 00:11:32,720
 

617
00:11:32,720 --> 00:11:35,350
student table and the course table and

618
00:11:35,350 --> 00:11:35,360
 

619
00:11:35,360 --> 00:11:37,270
along with the grade that the student

620
00:11:37,270 --> 00:11:37,280
 

621
00:11:37,280 --> 00:11:39,760
got in the class all right we'll use

622
00:11:39,760 --> 00:11:39,770
 

623
00:11:39,770 --> 00:11:41,890
this as our running example as we go

624
00:11:41,890 --> 00:11:41,900
 

625
00:11:41,900 --> 00:11:45,250
along all right so the first thing we

626
00:11:45,250 --> 00:11:45,260
 

627
00:11:45,260 --> 00:11:47,560
talk about our aggregations right and

628
00:11:47,560 --> 00:11:47,570
 

629
00:11:47,570 --> 00:11:48,730
these are pretty simple to understand

630
00:11:48,730 --> 00:11:48,740
 

631
00:11:48,740 --> 00:11:50,830
it's basically a function that you

632
00:11:50,830 --> 00:11:50,840
 

633
00:11:50,840 --> 00:11:53,050
define in the output list of your select

634
00:11:53,050 --> 00:11:53,060
 

635
00:11:53,060 --> 00:11:56,250
statement that's going to take as input

636
00:11:56,250 --> 00:11:56,260

637
00:11:56,260 --> 00:11:59,650
multiple tuples a set of tuples and it's

638
00:11:59,650 --> 00:11:59,660
 

639
00:11:59,660 --> 00:12:01,270
going to compute some kind of

640
00:12:01,270 --> 00:12:01,280
 

641
00:12:01,280 --> 00:12:02,980
aggregation on top of that and produced

642
00:12:02,980 --> 00:12:02,990
 

643
00:12:02,990 --> 00:12:06,550
a single result right so the sequel 92

644
00:12:06,550 --> 00:12:06,560
 

645
00:12:06,560 --> 00:12:08,860
standard defines average min max sum and

646
00:12:08,860 --> 00:12:08,870
 

647
00:12:08,870 --> 00:12:11,350
count and again think of this is like in

648
00:12:11,350 --> 00:12:11,360
 

649
00:12:11,360 --> 00:12:13,120
case of count you're gonna take a bag or

650
00:12:13,120 --> 00:12:13,130

651
00:12:13,130 --> 00:12:15,250
tuples as the input and you're going to

652
00:12:15,250 --> 00:12:15,260
 

653
00:12:15,260 --> 00:12:16,660
count the number of tuples that are and

654
00:12:16,660 --> 00:12:16,670
 

655
00:12:16,670 --> 00:12:18,070
that you're a produces a single output

656
00:12:18,070 --> 00:12:18,080
 

657
00:12:18,080 --> 00:12:22,210
that has that that count right again so

658
00:12:22,210 --> 00:12:22,220
 

659
00:12:22,220 --> 00:12:24,700
this is what's in the basic standard the

660
00:12:24,700 --> 00:12:24,710
 

661
00:12:24,710 --> 00:12:27,520
the later version of the standard and in

662
00:12:27,520 --> 00:12:27,530
 

663
00:12:27,530 --> 00:12:28,780
other database systems they'll have

664
00:12:28,780 --> 00:12:28,790
 

665
00:12:28,790 --> 00:12:30,900
other things like median mode standard

666
00:12:30,900 --> 00:12:30,910

667
00:12:30,910 --> 00:12:34,870
deviation right and the github different

668
00:12:34,870 --> 00:12:34,880
 

669
00:12:34,880 --> 00:12:35,920
aggregates and some of them actually

670
00:12:35,920 --> 00:12:35,930
 

671
00:12:35,930 --> 00:12:37,060
does it allows you to find your own

672
00:12:37,060 --> 00:12:37,070
 

673
00:12:37,070 --> 00:12:39,670
aggregations as well so let's look an

674
00:12:39,670 --> 00:12:39,680
 

675
00:12:39,680 --> 00:12:42,340
example like this right so say we want

676
00:12:42,340 --> 00:12:42,350
 

677
00:12:42,350 --> 00:12:44,320
to discount the number of students in

678
00:12:44,320 --> 00:12:44,330
 

679
00:12:44,330 --> 00:12:47,680
this student table where the login ends

680
00:12:47,680 --> 00:12:47,690
 

681
00:12:47,690 --> 00:12:50,890
with at CS I'll cover what like is means

682
00:12:50,890 --> 00:12:50,900
 

683
00:12:50,900 --> 00:12:51,850
later on but essentially it's just

684
00:12:51,850 --> 00:12:51,860
 

685
00:12:51,860 --> 00:12:55,090
looking for a wild card here right so

686
00:12:55,090 --> 00:12:55,100
 

687
00:12:55,100 --> 00:12:56,530
the first thing the most important thing

688
00:12:56,530 --> 00:12:56,540
 

689
00:12:56,540 --> 00:12:58,060
to remember about aggregations is that

690
00:12:58,060 --> 00:12:58,070
 

691
00:12:58,070 --> 00:12:59,800
the aggregation can only appear in the

692
00:12:59,800 --> 00:12:59,810
 

693
00:12:59,810 --> 00:13:01,000
output list of the Select statement

694
00:13:01,000 --> 00:13:01,010
 

695
00:13:01,010 --> 00:13:03,940
right so I have it here in the in this

696
00:13:03,940 --> 00:13:03,950
 

697
00:13:03,950 --> 00:13:05,320
the same this is I want to produce at

698
00:13:05,320 --> 00:13:05,330
 

699
00:13:05,330 --> 00:13:07,060
the output I can't have it in these in

700
00:13:07,060 --> 00:13:07,070
 

701
00:13:07,070 --> 00:13:08,890
these other parts here right cuz it

702
00:13:08,890 --> 00:13:08,900
 

703
00:13:08,900 --> 00:13:09,850
doesn't really make sense right because

704
00:13:09,850 --> 00:13:09,860
 

705
00:13:09,860 --> 00:13:11,950
you're computing aggregation after

706
00:13:11,950 --> 00:13:11,960
 

707
00:13:11,960 --> 00:13:13,270
you've sort of applied a filter to

708
00:13:13,270 --> 00:13:13,280
 

709
00:13:13,280 --> 00:13:14,980
figure out what tuples actually match

710
00:13:14,980 --> 00:13:14,990

711
00:13:14,990 --> 00:13:18,640
your where clause but the same point out

712
00:13:18,640 --> 00:13:18,650
 

713
00:13:18,650 --> 00:13:21,640
here is that in case account again we

714
00:13:21,640 --> 00:13:21,650
 

715
00:13:21,650 --> 00:13:22,450
just wanna count them

716
00:13:22,450 --> 00:13:22,460
 

717
00:13:22,460 --> 00:13:25,480
tuples the logon field here doesn't

718
00:13:25,480 --> 00:13:25,490
 

719
00:13:25,490 --> 00:13:29,020
actually mean anything right cuz we're

720
00:13:29,020 --> 00:13:29,030
 

721
00:13:29,030 --> 00:13:30,490
just counting the number of tuples it

722
00:13:30,490 --> 00:13:30,500
 

723
00:13:30,500 --> 00:13:32,140
doesn't matter whether you know what the

724
00:13:32,140 --> 00:13:32,150

725
00:13:32,150 --> 00:13:33,940
login actually is at the point after we

726
00:13:33,940 --> 00:13:33,950
 

727
00:13:33,950 --> 00:13:36,400
do the filtering so we can rewrite this

728
00:13:36,400 --> 00:13:36,410
 

729
00:13:36,410 --> 00:13:39,070
just to have a star

730
00:13:39,070 --> 00:13:39,080
 

731
00:13:39,080 --> 00:13:41,830
alright the star is a special you know

732
00:13:41,830 --> 00:13:41,840
 

733
00:13:41,840 --> 00:13:43,750
special keyword in sequel the basically

734
00:13:43,750 --> 00:13:43,760

735
00:13:43,760 --> 00:13:47,050
says all attributes for the tuple we can

736
00:13:47,050 --> 00:13:47,060
 

737
00:13:47,060 --> 00:13:48,880
go even further and say we can actually

738
00:13:48,880 --> 00:13:48,890
 

739
00:13:48,890 --> 00:13:52,810
replace the star with a one right count

740
00:13:52,810 --> 00:13:52,820
 

741
00:13:52,820 --> 00:13:55,210
the number of tuples by just adding one

742
00:13:55,210 --> 00:13:55,220
 

743
00:13:55,220 --> 00:13:58,450
every single time right so this is a

744
00:13:58,450 --> 00:13:58,460
 

745
00:13:58,460 --> 00:14:00,190
good example where we have three

746
00:14:00,190 --> 00:14:00,200
 

747
00:14:00,200 --> 00:14:02,770
different queries that all produce are

748
00:14:02,770 --> 00:14:02,780
 

749
00:14:02,780 --> 00:14:04,000
semantically the same to produce the

750
00:14:04,000 --> 00:14:04,010

751
00:14:04,010 --> 00:14:06,520
same result but the data besom could

752
00:14:06,520 --> 00:14:06,530
 

753
00:14:06,530 --> 00:14:08,110
could choose different flavours or

754
00:14:08,110 --> 00:14:08,120
 

755
00:14:08,120 --> 00:14:10,660
different variations of this in order to

756
00:14:10,660 --> 00:14:10,670
 

757
00:14:10,670 --> 00:14:11,950
derive that answer and some of them may

758
00:14:11,950 --> 00:14:11,960
 

759
00:14:11,960 --> 00:14:13,270
have different performance differences

760
00:14:13,270 --> 00:14:13,280
 

761
00:14:13,280 --> 00:14:17,050
this one's pretty simple so the most of

762
00:14:17,050 --> 00:14:17,060
 

763
00:14:17,060 --> 00:14:18,430
this will be smart to realize I don't

764
00:14:18,430 --> 00:14:18,440
 

765
00:14:18,440 --> 00:14:20,470
need a copy around the login here I can

766
00:14:20,470 --> 00:14:20,480
 

767
00:14:20,480 --> 00:14:22,240
just replace that with a one right most

768
00:14:22,240 --> 00:14:22,250
 

769
00:14:22,250 --> 00:14:24,460
of them will do that but from what

770
00:14:24,460 --> 00:14:24,470
 

771
00:14:24,470 --> 00:14:25,840
complicated things and may not always

772
00:14:25,840 --> 00:14:25,850
 

773
00:14:25,850 --> 00:14:28,900
work we actually can combine the

774
00:14:28,900 --> 00:14:28,910
 

775
00:14:28,910 --> 00:14:30,190
aggregate multiple a grits together in a

776
00:14:30,190 --> 00:14:30,200
 

777
00:14:30,200 --> 00:14:32,260
single query so say for this one we want

778
00:14:32,260 --> 00:14:32,270
 

779
00:14:32,270 --> 00:14:34,030
to get the number of students and their

780
00:14:34,030 --> 00:14:34,040
 

781
00:14:34,040 --> 00:14:37,150
average GPA where their login ends with

782
00:14:37,150 --> 00:14:37,160
 

783
00:14:37,160 --> 00:14:39,610
at CS right so now you see I've combined

784
00:14:39,610 --> 00:14:39,620
 

785
00:14:39,620 --> 00:14:43,270
it average GPA and count in my output

786
00:14:43,270 --> 00:14:43,280
 

787
00:14:43,280 --> 00:14:45,430
output list for my select statement and

788
00:14:45,430 --> 00:14:45,440
 

789
00:14:45,440 --> 00:14:48,060
then it'll produce my result like that

790
00:14:48,060 --> 00:14:48,070
 

791
00:14:48,070 --> 00:14:51,460
alright pretty straightforward I can

792
00:14:51,460 --> 00:14:51,470
 

793
00:14:51,470 --> 00:14:54,490
also add the distinct keyword to tell it

794
00:14:54,490 --> 00:14:54,500
 

795
00:14:54,500 --> 00:14:56,890
to only count the distinct elements or

796
00:14:56,890 --> 00:14:56,900
 

797
00:14:56,900 --> 00:14:59,530
values of attributes for for my tuples

798
00:14:59,530 --> 00:14:59,540

799
00:14:59,540 --> 00:15:01,960
so this is saying count the number of

800
00:15:01,960 --> 00:15:01,970
 

801
00:15:01,970 --> 00:15:05,920
unique students with unique logins from

802
00:15:05,920 --> 00:15:05,930
 

803
00:15:05,930 --> 00:15:07,360
the student table where the log it ends

804
00:15:07,360 --> 00:15:07,370
 

805
00:15:07,370 --> 00:15:10,030
with at CS right and so I had the

806
00:15:10,030 --> 00:15:10,040
 

807
00:15:10,040 --> 00:15:12,220
distinct inside of account now this one

808
00:15:12,220 --> 00:15:12,230
 

809
00:15:12,230 --> 00:15:13,870
is sort of nonsensical to in some ways

810
00:15:13,870 --> 00:15:13,880
 

811
00:15:13,880 --> 00:15:17,140
because presumably no two students can

812
00:15:17,140 --> 00:15:17,150
 

813
00:15:17,150 --> 00:15:20,020
have the same login you know login

814
00:15:20,020 --> 00:15:20,030
 

815
00:15:20,030 --> 00:15:22,470
account otherwise you'd have problems

816
00:15:22,470 --> 00:15:22,480
 

817
00:15:22,480 --> 00:15:26,470
but in in other cases you know you can

818
00:15:26,470 --> 00:15:26,480
 

819
00:15:26,480 --> 00:15:27,580
apply the same kind of thing for other

820
00:15:27,580 --> 00:15:27,590
 

821
00:15:27,590 --> 00:15:29,050
scenarios and it would work the way you

822
00:15:29,050 --> 00:15:29,060
 

823
00:15:29,060 --> 00:15:31,870
wanted to work right and in this case

824
00:15:31,870 --> 00:15:31,880
 

825
00:15:31,880 --> 00:15:34,270
here we produce the same result

826
00:15:34,270 --> 00:15:34,280
 

827
00:15:34,280 --> 00:15:37,030
so the one thing that now you want to

828
00:15:37,030 --> 00:15:37,040
 

829
00:15:37,040 --> 00:15:38,590
may want to try to start doing is now

830
00:15:38,590 --> 00:15:38,600
 

831
00:15:38,600 --> 00:15:40,240
that I'm start doing aggregations I want

832
00:15:40,240 --> 00:15:40,250
 

833
00:15:40,250 --> 00:15:42,910
to get additional information about my

834
00:15:42,910 --> 00:15:42,920
 

835
00:15:42,920 --> 00:15:45,670
data outside of just what I'm computing

836
00:15:45,670 --> 00:15:45,680
 

837
00:15:45,680 --> 00:15:49,330
in my aggregate right so say that I want

838
00:15:49,330 --> 00:15:49,340
 

839
00:15:49,340 --> 00:15:53,230
to I want to get the average GPA of the

840
00:15:53,230 --> 00:15:53,240
 

841
00:15:53,240 --> 00:15:54,340
students that are rolled in the course

842
00:15:54,340 --> 00:15:54,350
 

843
00:15:54,350 --> 00:15:56,020
and I want to know what that course ID

844
00:15:56,020 --> 00:15:56,030
 

845
00:15:56,030 --> 00:15:59,380
was right so in this case here I've now

846
00:15:59,380 --> 00:15:59,390
 

847
00:15:59,390 --> 00:16:01,630
added the course ID to my output list

848
00:16:01,630 --> 00:16:01,640
 

849
00:16:01,640 --> 00:16:05,620
outside of my aggregation right didn't

850
00:16:05,620 --> 00:16:05,630
 

851
00:16:05,630 --> 00:16:10,350
take a guess what would happen here

852
00:16:10,350 --> 00:16:10,360


853
00:16:10,360 --> 00:16:16,150
would this work or not raise your hand

854
00:16:16,150 --> 00:16:16,160
 

855
00:16:16,160 --> 00:16:18,910
you think would work raise your hand if

856
00:16:18,910 --> 00:16:18,920
 

857
00:16:18,920 --> 00:16:22,000
you think it wouldn't work see of you

858
00:16:22,000 --> 00:16:22,010
 

859
00:16:22,010 --> 00:16:37,120
why correct yes so what he said is

860
00:16:37,120 --> 00:16:37,130
 

861
00:16:37,130 --> 00:16:40,960
there's not a single course ID for all

862
00:16:40,960 --> 00:16:40,970
 

863
00:16:40,970 --> 00:16:42,730
my tuples that are competing my average

864
00:16:42,730 --> 00:16:42,740
 

865
00:16:42,740 --> 00:16:44,650
on right it's all the students are

866
00:16:44,650 --> 00:16:44,660
 

867
00:16:44,660 --> 00:16:46,900
taking all the different classes what

868
00:16:46,900 --> 00:16:46,910
 

869
00:16:46,910 --> 00:16:48,220
course I need to actually put is the

870
00:16:48,220 --> 00:16:48,230
 

871
00:16:48,230 --> 00:16:52,810
output right it's the sequel standard

872
00:16:52,810 --> 00:16:52,820
 

873
00:16:52,820 --> 00:16:55,090
say this is actually undefined and in

874
00:16:55,090 --> 00:16:55,100
 

875
00:16:55,100 --> 00:16:56,590
most systems you actually will get an

876
00:16:56,590 --> 00:16:56,600
 

877
00:16:56,600 --> 00:16:59,380
error with this we can actually test

878
00:16:59,380 --> 00:16:59,390
 

879
00:16:59,390 --> 00:17:00,010
this right

880
00:17:00,010 --> 00:17:00,020

881
00:17:00,020 --> 00:17:07,540
so in this never go I have three three

882
00:17:07,540 --> 00:17:07,550
 

883
00:17:07,550 --> 00:17:08,800
terminal setup all right so this is

884
00:17:08,800 --> 00:17:08,810
 

885
00:17:08,810 --> 00:17:10,240
running the machine back in my office I

886
00:17:10,240 --> 00:17:10,250
 

887
00:17:10,250 --> 00:17:12,130
have three panels the top one is

888
00:17:12,130 --> 00:17:12,140
 

889
00:17:12,140 --> 00:17:14,260
Postgres the bottom one or the middle

890
00:17:14,260 --> 00:17:14,270
 

891
00:17:14,270 --> 00:17:15,370
ones my seagull and the bottom one is

892
00:17:15,370 --> 00:17:15,380
 

893
00:17:15,380 --> 00:17:20,199
sequel light it says much easier for you

894
00:17:20,199 --> 00:17:20,209
 

895
00:17:20,209 --> 00:17:21,910
to type from this machine here so I can

896
00:17:21,910 --> 00:17:21,920
 

897
00:17:21,920 --> 00:17:27,819
log in to that right okay so the query

898
00:17:27,819 --> 00:17:27,829
 

899
00:17:27,829 --> 00:17:33,520
was we wanted to select where was it

900
00:17:33,520 --> 00:17:33,530
 

901
00:17:33,530 --> 00:17:35,870
get the average GPA of students enrolled

902
00:17:35,870 --> 00:17:35,880
 

903
00:17:35,880 --> 00:17:38,140
in each course right

904
00:17:38,140 --> 00:17:38,150
 

905
00:17:38,150 --> 00:17:46,220
so select average sgpa eCourse ID from

906
00:17:46,220 --> 00:17:46,230
 

907
00:17:46,230 --> 00:17:53,510
enrolled as a student as s where eise to

908
00:17:53,510 --> 00:17:53,520

909
00:17:53,520 --> 00:17:58,700
deny d equals a student ID right so

910
00:17:58,700 --> 00:17:58,710
 

911
00:17:58,710 --> 00:18:00,200
Postgres says you can't do this because

912
00:18:00,200 --> 00:18:00,210
 

913
00:18:00,210 --> 00:18:05,630
as he said the course ID and i'm

914
00:18:05,630 --> 00:18:05,640
 

915
00:18:05,640 --> 00:18:06,560
highlighting here as you can see there

916
00:18:06,560 --> 00:18:06,570
 

917
00:18:06,570 --> 00:18:09,950
so the course ID is not defined it's not

918
00:18:09,950 --> 00:18:09,960
 

919
00:18:09,960 --> 00:18:12,170
part of the aggregation right so it

920
00:18:12,170 --> 00:18:12,180
 

921
00:18:12,180 --> 00:18:13,310
doesn't know which course ID you

922
00:18:13,310 --> 00:18:13,320
 

923
00:18:13,320 --> 00:18:16,100
actually want so now if we go down and

924
00:18:16,100 --> 00:18:16,110
 

925
00:18:16,110 --> 00:18:23,960
try this in my sequel my seagull gave us

926
00:18:23,960 --> 00:18:23,970
 

927
00:18:23,970 --> 00:18:32,330
an answer right but is that correct no

928
00:18:32,330 --> 00:18:32,340
 

929
00:18:32,340 --> 00:18:34,130
right because because what course ID to

930
00:18:34,130 --> 00:18:34,140
 

931
00:18:34,140 --> 00:18:36,380
the pic i picked a random one right and

932
00:18:36,380 --> 00:18:36,390
 

933
00:18:36,390 --> 00:18:39,140
then now we can try in sequel light same

934
00:18:39,140 --> 00:18:39,150
 

935
00:18:39,150 --> 00:18:43,040
thing sequel light gave us a different

936
00:18:43,040 --> 00:18:43,050

937
00:18:43,050 --> 00:18:44,420
course ID so you see they both completed

938
00:18:44,420 --> 00:18:44,430
 

939
00:18:44,430 --> 00:18:47,120
the correct average but they chose a

940
00:18:47,120 --> 00:18:47,130
 

941
00:18:47,130 --> 00:18:49,340
different course ID all right

942
00:18:49,340 --> 00:18:49,350
 

943
00:18:49,350 --> 00:18:51,110
and just because I know that my single

944
00:18:51,110 --> 00:18:51,120
 

945
00:18:51,120 --> 00:18:55,480
guys watch these videos and complain I

946
00:18:55,480 --> 00:18:55,490
 

947
00:18:55,490 --> 00:18:58,370
will say that so this is running my

948
00:18:58,370 --> 00:18:58,380
 

949
00:18:58,380 --> 00:19:01,070
sequel in and so my sequel traditionally

950
00:19:01,070 --> 00:19:01,080
 

951
00:19:01,080 --> 00:19:02,330
allowed you to do loosey goosey things

952
00:19:02,330 --> 00:19:02,340
 

953
00:19:02,340 --> 00:19:04,190
like this right so this would be running

954
00:19:04,190 --> 00:19:04,200
 

955
00:19:04,200 --> 00:19:05,690
it what they would call a traditional

956
00:19:05,690 --> 00:19:05,700
 

957
00:19:05,700 --> 00:19:08,690
mode but you can set the sequel mode to

958
00:19:08,690 --> 00:19:08,700
 

959
00:19:08,700 --> 00:19:11,330
be more strict so now if I run that same

960
00:19:11,330 --> 00:19:11,340
 

961
00:19:11,340 --> 00:19:13,550
query it froze the same error that

962
00:19:13,550 --> 00:19:13,560
 

963
00:19:13,560 --> 00:19:16,760
Postgres did so by default these my

964
00:19:16,760 --> 00:19:16,770
 

965
00:19:16,770 --> 00:19:19,040
sequel 5,7 would now throw errors in

966
00:19:19,040 --> 00:19:19,050
 

967
00:19:19,050 --> 00:19:23,170
older versions they didn't do that right

968
00:19:23,170 --> 00:19:23,180
 

969
00:19:23,180 --> 00:19:28,760
okay so a way to fix this is to do group

970
00:19:28,760 --> 00:19:28,770
 

971
00:19:28,770 --> 00:19:31,880
I so with group I what's gonna happen is

972
00:19:31,880 --> 00:19:31,890
 

973
00:19:31,890 --> 00:19:34,370
now we're gonna define how we want to

974
00:19:34,370 --> 00:19:34,380

975
00:19:34,380 --> 00:19:38,510
essentially bucket together the tuples

976
00:19:38,510 --> 00:19:38,520
 

977
00:19:38,520 --> 00:19:41,750
in our output based on one attribute and

978
00:19:41,750 --> 00:19:41,760
 

979
00:19:41,760 --> 00:19:43,340
then now we can then compute the

980
00:19:43,340 --> 00:19:43,350
 

981
00:19:43,350 --> 00:19:46,000
aggregation on the tuples in each bucket

982
00:19:46,000 --> 00:19:46,010
 

983
00:19:46,010 --> 00:19:47,190
right

984
00:19:47,190 --> 00:19:47,200
 

985
00:19:47,200 --> 00:19:48,840
so again what I wanted to do was get the

986
00:19:48,840 --> 00:19:48,850

987
00:19:48,850 --> 00:19:52,139
average GPA per course if I add now in

988
00:19:52,139 --> 00:19:52,149
 

989
00:19:52,149 --> 00:19:54,180
my group by clause I add the the course

990
00:19:54,180 --> 00:19:54,190

991
00:19:54,190 --> 00:19:57,090
ID what will happen is when I first

992
00:19:57,090 --> 00:19:57,100
 

993
00:19:57,100 --> 00:20:00,210
execute the query this is essentially

994
00:20:00,210 --> 00:20:00,220
 

995
00:20:00,220 --> 00:20:02,549
what I would see after the join but now

996
00:20:02,549 --> 00:20:02,559
 

997
00:20:02,559 --> 00:20:04,529
with the group by clause I'll combine

998
00:20:04,529 --> 00:20:04,539
 

999
00:20:04,539 --> 00:20:08,070
together the the tuples based on the

1000
00:20:08,070 --> 00:20:08,080
 

1001
00:20:08,080 --> 00:20:10,799
course ID and then for each of these now

1002
00:20:10,799 --> 00:20:10,809
 

1003
00:20:10,809 --> 00:20:14,430
I'll compute my aggregate right and now

1004
00:20:14,430 --> 00:20:14,440
 

1005
00:20:14,440 --> 00:20:16,019
I can group them by course ID and that

1006
00:20:16,019 --> 00:20:16,029
 

1007
00:20:16,029 --> 00:20:17,580
corresponds to the buckets I generated

1008
00:20:17,580 --> 00:20:17,590
 

1009
00:20:17,590 --> 00:20:21,870
from before right so we have to use

1010
00:20:21,870 --> 00:20:21,880
 

1011
00:20:21,880 --> 00:20:23,159
group I if we want to extract

1012
00:20:23,159 --> 00:20:23,169
 

1013
00:20:23,169 --> 00:20:25,470
information about the aggregations we're

1014
00:20:25,470 --> 00:20:25,480
 

1015
00:20:25,480 --> 00:20:28,649
computing right and so just like before

1016
00:20:28,649 --> 00:20:28,659
 

1017
00:20:28,659 --> 00:20:31,860
any time we have a attribute that we

1018
00:20:31,860 --> 00:20:31,870
 

1019
00:20:31,870 --> 00:20:33,389
won't appear in our output select Clause

1020
00:20:33,389 --> 00:20:33,399
 

1021
00:20:33,399 --> 00:20:36,029
it has to appear in the group ID so here

1022
00:20:36,029 --> 00:20:36,039
 

1023
00:20:36,039 --> 00:20:37,590
the student name we're trying to throw

1024
00:20:37,590 --> 00:20:37,600

1025
00:20:37,600 --> 00:20:39,690
that in in our output Clause it won't

1026
00:20:39,690 --> 00:20:39,700

1027
00:20:39,700 --> 00:20:42,570
work because it has to be in our group

1028
00:20:42,570 --> 00:20:42,580
 

1029
00:20:42,580 --> 00:20:45,029
by clause now this one is sorted to get

1030
00:20:45,029 --> 00:20:45,039
 

1031
00:20:45,039 --> 00:20:47,190
a nonsensical a technically correct

1032
00:20:47,190 --> 00:20:47,200
 

1033
00:20:47,200 --> 00:20:48,810
sequel it produced a result but from a

1034
00:20:48,810 --> 00:20:48,820
 

1035
00:20:48,820 --> 00:20:50,039
human standpoint we know doesn't mean

1036
00:20:50,039 --> 00:20:50,049
 

1037
00:20:50,049 --> 00:20:51,509
anything but like what does it mean to

1038
00:20:51,509 --> 00:20:51,519
 

1039
00:20:51,519 --> 00:20:53,820
group by course ID and then the student

1040
00:20:53,820 --> 00:20:53,830
 

1041
00:20:53,830 --> 00:20:56,399
name to compute the average GPA right

1042
00:20:56,399 --> 00:20:56,409
 

1043
00:20:56,409 --> 00:21:00,110
the student's GPA is gonna be their GPA

1044
00:21:00,110 --> 00:21:00,120
 

1045
00:21:00,120 --> 00:21:03,029
okay so now you may think alright well

1046
00:21:03,029 --> 00:21:03,039
 

1047
00:21:03,039 --> 00:21:04,440
maybe I want to do them with some more

1048
00:21:04,440 --> 00:21:04,450
 

1049
00:21:04,450 --> 00:21:07,019
some additional filtering all my

1050
00:21:07,019 --> 00:21:07,029
 

1051
00:21:07,029 --> 00:21:10,049
aggregations so that I don't look at you

1052
00:21:10,049 --> 00:21:10,059
 

1053
00:21:10,059 --> 00:21:11,810
know I don't produce every single result

1054
00:21:11,810 --> 00:21:11,820
 

1055
00:21:11,820 --> 00:21:14,759
as part of the output so you may think

1056
00:21:14,759 --> 00:21:14,769
 

1057
00:21:14,769 --> 00:21:16,879
that you out want to put it

1058
00:21:16,879 --> 00:21:16,889
 

1059
00:21:16,889 --> 00:21:18,930
use the aggregations in your where

1060
00:21:18,930 --> 00:21:18,940

1061
00:21:18,940 --> 00:21:21,000
clause so here now I'm now I'm computing

1062
00:21:21,000 --> 00:21:21,010
 

1063
00:21:21,010 --> 00:21:23,370
every GPA but I'm added in my where

1064
00:21:23,370 --> 00:21:23,380
 

1065
00:21:23,380 --> 00:21:26,039
clause something that says filter out

1066
00:21:26,039 --> 00:21:26,049
 

1067
00:21:26,049 --> 00:21:29,460
anything where the GPA is is not you

1068
00:21:29,460 --> 00:21:29,470

1069
00:21:29,470 --> 00:21:31,680
know greater than 3,9 this is look only

1070
00:21:31,680 --> 00:21:31,690
 

1071
00:21:31,690 --> 00:21:32,669
trying to look at the courses with

1072
00:21:32,669 --> 00:21:32,679
 

1073
00:21:32,679 --> 00:21:35,279
average GPA is greater than 3,9 right so

1074
00:21:35,279 --> 00:21:35,289
 

1075
00:21:35,289 --> 00:21:37,980
this doesn't work because in our we

1076
00:21:37,980 --> 00:21:37,990
 

1077
00:21:37,990 --> 00:21:39,450
can't access anything in our

1078
00:21:39,450 --> 00:21:39,460
 

1079
00:21:39,460 --> 00:21:41,789
aggregations in our where clause because

1080
00:21:41,789 --> 00:21:41,799
 

1081
00:21:41,799 --> 00:21:43,409
we don't have them yet in our where

1082
00:21:43,409 --> 00:21:43,419
 

1083
00:21:43,419 --> 00:21:46,529
clause right so again the way to figure

1084
00:21:46,529 --> 00:21:46,539
 

1085
00:21:46,539 --> 00:21:48,210
out this is the where clause is

1086
00:21:48,210 --> 00:21:48,220
 

1087
00:21:48,220 --> 00:21:49,799
filtering tuples as we go along and

1088
00:21:49,799 --> 00:21:49,809
 

1089
00:21:49,809 --> 00:21:51,899
after we do our filtering then we can

1090
00:21:51,899 --> 00:21:51,909

1091
00:21:51,909 --> 00:21:54,120
actually then computer aggregation so we

1092
00:21:54,120 --> 00:21:54,130
 

1093
00:21:54,130 --> 00:21:55,830
can't compute we can't use an

1094
00:21:55,830 --> 00:21:55,840

1095
00:21:55,840 --> 00:21:59,279
aggregation to filter tuples because we

1096
00:21:59,279 --> 00:21:59,289
 

1097
00:21:59,289 --> 00:22:01,580
have a computer the aggregation yet

1098
00:22:01,580 --> 00:22:01,590

1099
00:22:01,590 --> 00:22:03,900
right so the way to get around this is

1100
00:22:03,900 --> 00:22:03,910
 

1101
00:22:03,910 --> 00:22:06,660
use the having clause it's essentially

1102
00:22:06,660 --> 00:22:06,670
 

1103
00:22:06,670 --> 00:22:08,430
like a where clause but now you can

1104
00:22:08,430 --> 00:22:08,440
 

1105
00:22:08,440 --> 00:22:10,410
reference anything in your output list

1106
00:22:10,410 --> 00:22:10,420
 

1107
00:22:10,420 --> 00:22:13,290
so I've taken my average GPA and I've

1108
00:22:13,290 --> 00:22:13,300
 

1109
00:22:13,300 --> 00:22:15,990
aliased it to AVG GPA and I can

1110
00:22:15,990 --> 00:22:16,000
 

1111
00:22:16,000 --> 00:22:18,690
represent down in here and this will

1112
00:22:18,690 --> 00:22:18,700
 

1113
00:22:18,700 --> 00:22:20,670
produce the answer that I want right

1114
00:22:20,670 --> 00:22:20,680
 

1115
00:22:20,680 --> 00:22:22,320
capice the aggregation is just like

1116
00:22:22,320 --> 00:22:22,330
 

1117
00:22:22,330 --> 00:22:23,760
before and then it applies additional

1118
00:22:23,760 --> 00:22:23,770
 

1119
00:22:23,770 --> 00:22:27,300
filtering on it so now not in this

1120
00:22:27,300 --> 00:22:27,310
 

1121
00:22:27,310 --> 00:22:29,550
example but there's other examples where

1122
00:22:29,550 --> 00:22:29,560
 

1123
00:22:29,560 --> 00:22:31,530
you can do certain optimizations in the

1124
00:22:31,530 --> 00:22:31,540
 

1125
00:22:31,540 --> 00:22:34,470
system based on what you know is in your

1126
00:22:34,470 --> 00:22:34,480
 

1127
00:22:34,480 --> 00:22:36,690
having clause again this is the great

1128
00:22:36,690 --> 00:22:36,700
 

1129
00:22:36,700 --> 00:22:37,980
thing about declarative language you

1130
00:22:37,980 --> 00:22:37,990
 

1131
00:22:37,990 --> 00:22:40,260
know everything all ahead of time what

1132
00:22:40,260 --> 00:22:40,270
 

1133
00:22:40,270 --> 00:22:41,850
the you know what the programmer the

1134
00:22:41,850 --> 00:22:41,860
 

1135
00:22:41,860 --> 00:22:44,640
person wants in their answer so you can

1136
00:22:44,640 --> 00:22:44,650
 

1137
00:22:44,650 --> 00:22:47,070
use hints about what you knows could

1138
00:22:47,070 --> 00:22:47,080
 

1139
00:22:47,080 --> 00:22:49,500
come later in the query plan to help you

1140
00:22:49,500 --> 00:22:49,510
 

1141
00:22:49,510 --> 00:22:51,480
do certain refinements or reduce the

1142
00:22:51,480 --> 00:22:51,490
 

1143
00:22:51,490 --> 00:22:52,740
amount of work you have to do as you run

1144
00:22:52,740 --> 00:22:52,750
 

1145
00:22:52,750 --> 00:22:55,890
the query so instead of using average

1146
00:22:55,890 --> 00:22:55,900

1147
00:22:55,900 --> 00:22:59,610
GPA say I wanted to do a count where the

1148
00:22:59,610 --> 00:22:59,620
 

1149
00:22:59,620 --> 00:23:02,280
number of tuples are less than some you

1150
00:23:02,280 --> 00:23:02,290
 

1151
00:23:02,290 --> 00:23:03,630
know first each group less than some

1152
00:23:03,630 --> 00:23:03,640
 

1153
00:23:03,640 --> 00:23:06,330
value so that as I'm going along as I'm

1154
00:23:06,330 --> 00:23:06,340
 

1155
00:23:06,340 --> 00:23:08,430
computing my aggregate if I then

1156
00:23:08,430 --> 00:23:08,440

1157
00:23:08,440 --> 00:23:11,160
recognize that oh my having Clause says

1158
00:23:11,160 --> 00:23:11,170

1159
00:23:11,170 --> 00:23:12,930
filter anything less than ten two pools

1160
00:23:12,930 --> 00:23:12,940
 

1161
00:23:12,940 --> 00:23:15,240
if not if I now hit tuple number eleven

1162
00:23:15,240 --> 00:23:15,250
 

1163
00:23:15,250 --> 00:23:17,400
for a group I know that I never need to

1164
00:23:17,400 --> 00:23:17,410
 

1165
00:23:17,410 --> 00:23:19,890
count anything else for that for that

1166
00:23:19,890 --> 00:23:19,900
 

1167
00:23:19,900 --> 00:23:22,110
two plus that come later because it'll

1168
00:23:22,110 --> 00:23:22,120
 

1169
00:23:22,120 --> 00:23:24,420
never pass that having falls so I can

1170
00:23:24,420 --> 00:23:24,430
 

1171
00:23:24,430 --> 00:23:25,830
just throw away there's tuples as I go

1172
00:23:25,830 --> 00:23:25,840
 

1173
00:23:25,840 --> 00:23:29,430
along because it's wasted work right if

1174
00:23:29,430 --> 00:23:29,440
 

1175
00:23:29,440 --> 00:23:30,720
you're writing this in a procedural

1176
00:23:30,720 --> 00:23:30,730
 

1177
00:23:30,730 --> 00:23:32,910
language like Python alright well you

1178
00:23:32,910 --> 00:23:32,920
 

1179
00:23:32,920 --> 00:23:34,740
had to write these steps but it's you

1180
00:23:34,740 --> 00:23:34,750

1181
00:23:34,750 --> 00:23:37,470
know by by yourself the you know the

1182
00:23:37,470 --> 00:23:37,480
 

1183
00:23:37,480 --> 00:23:38,640
Davidson is not gonna know what's gonna

1184
00:23:38,640 --> 00:23:38,650
 

1185
00:23:38,650 --> 00:23:39,870
come later on because it can't peek

1186
00:23:39,870 --> 00:23:39,880
 

1187
00:23:39,880 --> 00:23:41,910
ahead right but in a declarative

1188
00:23:41,910 --> 00:23:41,920
 

1189
00:23:41,920 --> 00:23:46,410
language like C code we can do that so

1190
00:23:46,410 --> 00:23:46,420
 

1191
00:23:46,420 --> 00:23:47,400
the next thing we want to talk about is

1192
00:23:47,400 --> 00:23:47,410
 

1193
00:23:47,410 --> 00:23:51,630
how to handle strings so this is a table

1194
00:23:51,630 --> 00:23:51,640
 

1195
00:23:51,640 --> 00:23:55,260
that sort of summarizes the the

1196
00:23:55,260 --> 00:23:55,270
 

1197
00:23:55,270 --> 00:23:56,850
different variations of how strings are

1198
00:23:56,850 --> 00:23:56,860
 

1199
00:23:56,860 --> 00:23:59,310
handled in different database systems so

1200
00:23:59,310 --> 00:23:59,320
 

1201
00:23:59,320 --> 00:24:02,460
the the Seacoast a nurse best says that

1202
00:24:02,460 --> 00:24:02,470

1203
00:24:02,470 --> 00:24:06,510
all strings like sub varchars chars text

1204
00:24:06,510 --> 00:24:06,520
 

1205
00:24:06,520 --> 00:24:08,550
fields they have to be case sensitive

1206
00:24:08,550 --> 00:24:08,560
 

1207
00:24:08,560 --> 00:24:11,250
and the way you declare them is with

1208
00:24:11,250 --> 00:24:11,260
 

1209
00:24:11,260 --> 00:24:13,240
single quotes

1210
00:24:13,240 --> 00:24:13,250

1211
00:24:13,250 --> 00:24:15,520
and most systems follow this right the

1212
00:24:15,520 --> 00:24:15,530
 

1213
00:24:15,530 --> 00:24:17,320
red herrings of the oddballs are both my

1214
00:24:17,320 --> 00:24:17,330
 

1215
00:24:17,330 --> 00:24:20,110
sequel and sequel light so in TECO light

1216
00:24:20,110 --> 00:24:20,120
 

1217
00:24:20,120 --> 00:24:23,230
the strings are sensitive but you can

1218
00:24:23,230 --> 00:24:23,240
 

1219
00:24:23,240 --> 00:24:25,570
have both single and double double

1220
00:24:25,570 --> 00:24:25,580

1221
00:24:25,580 --> 00:24:29,710
quotes - to mark them in my sequel it's

1222
00:24:29,710 --> 00:24:29,720
 

1223
00:24:29,720 --> 00:24:32,590
case insensitive and you can use either

1224
00:24:32,590 --> 00:24:32,600
 

1225
00:24:32,600 --> 00:24:35,380
single or double quotes now my problem

1226
00:24:35,380 --> 00:24:35,390
 

1227
00:24:35,390 --> 00:24:37,480
is that when I spur started using data

1228
00:24:37,480 --> 00:24:37,490
 

1229
00:24:37,490 --> 00:24:39,940
systems back in like 2000 I was using my

1230
00:24:39,940 --> 00:24:39,950
 

1231
00:24:39,950 --> 00:24:44,110
seagull 3 and it's like it's like you

1232
00:24:44,110 --> 00:24:44,120
 

1233
00:24:44,120 --> 00:24:45,880
know ingrained in my memory to just use

1234
00:24:45,880 --> 00:24:45,890
 

1235
00:24:45,890 --> 00:24:47,290
double quotes cuz that's what we use

1236
00:24:47,290 --> 00:24:47,300
 

1237
00:24:47,300 --> 00:24:48,790
back then so I'm always had to correct

1238
00:24:48,790 --> 00:24:48,800

1239
00:24:48,800 --> 00:24:49,960
myself every time I switch over another

1240
00:24:49,960 --> 00:24:49,970
 

1241
00:24:49,970 --> 00:24:52,390
data system to go always go back and use

1242
00:24:52,390 --> 00:24:52,400
 

1243
00:24:52,400 --> 00:24:55,780
single quotes my Seco again has the mode

1244
00:24:55,780 --> 00:24:55,790
 

1245
00:24:55,790 --> 00:24:57,580
you can say - follow the standard a bit

1246
00:24:57,580 --> 00:24:57,590
 

1247
00:24:57,590 --> 00:25:00,280
better and they then enforce the single

1248
00:25:00,280 --> 00:25:00,290

1249
00:25:00,290 --> 00:25:01,960
quote requirement but I think by default

1250
00:25:01,960 --> 00:25:01,970
 

1251
00:25:01,970 --> 00:25:04,900
you don't get that right so in the

1252
00:25:04,900 --> 00:25:04,910
 

1253
00:25:04,910 --> 00:25:06,130
seagull standards say you want to take

1254
00:25:06,130 --> 00:25:06,140
 

1255
00:25:06,140 --> 00:25:09,160
the name you want to take the you know

1256
00:25:09,160 --> 00:25:09,170
 

1257
00:25:09,170 --> 00:25:12,300
the name of Kanye and have it match with

1258
00:25:12,300 --> 00:25:12,310
 

1259
00:25:12,310 --> 00:25:17,110
Kanye with you know mixed case in in in

1260
00:25:17,110 --> 00:25:17,120
 

1261
00:25:17,120 --> 00:25:18,340
the sequel standard you had the upper

1262
00:25:18,340 --> 00:25:18,350
 

1263
00:25:18,350 --> 00:25:20,230
case using the upper you know the upper

1264
00:25:20,230 --> 00:25:20,240
 

1265
00:25:20,240 --> 00:25:22,600
function to make this match work in my

1266
00:25:22,600 --> 00:25:22,610
 

1267
00:25:22,610 --> 00:25:24,430
sequel you don't have to do that right

1268
00:25:24,430 --> 00:25:24,440

1269
00:25:24,440 --> 00:25:25,960
because all all the strings are matching

1270
00:25:25,960 --> 00:25:25,970
 

1271
00:25:25,970 --> 00:25:29,560
or case insensitive now I showed this

1272
00:25:29,560 --> 00:25:29,570
 

1273
00:25:29,570 --> 00:25:31,540
before how to do light claws but I think

1274
00:25:31,540 --> 00:25:31,550
 

1275
00:25:31,550 --> 00:25:33,580
really it's a lies you do the first

1276
00:25:33,580 --> 00:25:33,590
 

1277
00:25:33,590 --> 00:25:36,400
string matching alright so like is

1278
00:25:36,400 --> 00:25:36,410
 

1279
00:25:36,410 --> 00:25:38,440
basically doing you know trying to match

1280
00:25:38,440 --> 00:25:38,450
 

1281
00:25:38,450 --> 00:25:42,130
some wild card in your string with with

1282
00:25:42,130 --> 00:25:42,140

1283
00:25:42,140 --> 00:25:44,920
another string so for whatever reason

1284
00:25:44,920 --> 00:25:44,930

1285
00:25:44,930 --> 00:25:46,720
instead of using star like most other

1286
00:25:46,720 --> 00:25:46,730

1287
00:25:46,730 --> 00:25:48,640
things they use the print throughout %

1288
00:25:48,640 --> 00:25:48,650
 

1289
00:25:48,650 --> 00:25:53,440
so % means any one or more strings and

1290
00:25:53,440 --> 00:25:53,450
 

1291
00:25:53,450 --> 00:25:55,330
then the underscore means exactly match

1292
00:25:55,330 --> 00:25:55,340
 

1293
00:25:55,340 --> 00:25:57,730
one character alright so say I want to

1294
00:25:57,730 --> 00:25:57,740
 

1295
00:25:57,740 --> 00:25:59,710
get all the course or the course IDs

1296
00:25:59,710 --> 00:25:59,720
 

1297
00:25:59,720 --> 00:26:03,220
from the roll table that start with 15

1298
00:26:03,220 --> 00:26:03,230
 

1299
00:26:03,230 --> 00:26:07,300
to 15 for 45 7 21 I would use the the

1300
00:26:07,300 --> 00:26:07,310
 

1301
00:26:07,310 --> 00:26:09,850
Amber's the % like that and say if I

1302
00:26:09,850 --> 00:26:09,860
 

1303
00:26:09,860 --> 00:26:11,800
want to get all the students where the

1304
00:26:11,800 --> 00:26:11,810
 

1305
00:26:11,810 --> 00:26:14,920
the login ends with at C and then some

1306
00:26:14,920 --> 00:26:14,930
 

1307
00:26:14,930 --> 00:26:16,540
wild card I would use a single

1308
00:26:16,540 --> 00:26:16,550
 

1309
00:26:16,550 --> 00:26:21,310
underscore for that so the sequel

1310
00:26:21,310 --> 00:26:21,320

1311
00:26:21,320 --> 00:26:22,840
standard also defines a bunch of string

1312
00:26:22,840 --> 00:26:22,850
 

1313
00:26:22,850 --> 00:26:26,230
functions there's a again the standard

1314
00:26:26,230 --> 00:26:26,240
 

1315
00:26:26,240 --> 00:26:26,830
things you

1316
00:26:26,830 --> 00:26:26,840

1317
00:26:26,840 --> 00:26:30,700
expect like substring upper/lower trim

1318
00:26:30,700 --> 00:26:30,710
 

1319
00:26:30,710 --> 00:26:32,560
our these are all part of the sequel 92

1320
00:26:32,560 --> 00:26:32,570
 

1321
00:26:32,570 --> 00:26:33,910
standards and move systems will have

1322
00:26:33,910 --> 00:26:33,920
 

1323
00:26:33,920 --> 00:26:35,590
this but of course there's me a bunch of

1324
00:26:35,590 --> 00:26:35,600
 

1325
00:26:35,600 --> 00:26:38,320
other stuff that are proprietary in each

1326
00:26:38,320 --> 00:26:38,330
 

1327
00:26:38,330 --> 00:26:41,140
different database system so the thing

1328
00:26:41,140 --> 00:26:41,150
 

1329
00:26:41,150 --> 00:26:42,940
to point out unlike aggregation

1330
00:26:42,940 --> 00:26:42,950
 

1331
00:26:42,950 --> 00:26:45,490
functions with string functions and you

1332
00:26:45,490 --> 00:26:45,500
 

1333
00:26:45,500 --> 00:26:46,900
know mathematical functions and date

1334
00:26:46,900 --> 00:26:46,910

1335
00:26:46,910 --> 00:26:48,940
functions they can appear anywhere in

1336
00:26:48,940 --> 00:26:48,950
 

1337
00:26:48,950 --> 00:26:51,640
the in your in your queries so they can

1338
00:26:51,640 --> 00:26:51,650
 

1339
00:26:51,650 --> 00:26:52,930
mean the Select output list it could be

1340
00:26:52,930 --> 00:26:52,940
 

1341
00:26:52,940 --> 00:26:53,680
in your predicate s--

1342
00:26:53,680 --> 00:26:53,690
 

1343
00:26:53,690 --> 00:26:55,600
alright they don't always have to be in

1344
00:26:55,600 --> 00:26:55,610
 

1345
00:26:55,610 --> 00:26:58,060
the in the select portion they can be in

1346
00:26:58,060 --> 00:26:58,070
 

1347
00:26:58,070 --> 00:27:01,600
your having clauses so here we have you

1348
00:27:01,600 --> 00:27:01,610
 

1349
00:27:01,610 --> 00:27:03,160
know the first guy first query is gonna

1350
00:27:03,160 --> 00:27:03,170
 

1351
00:27:03,170 --> 00:27:05,560
take the name and take a substring and

1352
00:27:05,560 --> 00:27:05,570
 

1353
00:27:05,570 --> 00:27:06,850
just get just get the first five

1354
00:27:06,850 --> 00:27:06,860
 

1355
00:27:06,860 --> 00:27:08,860
characters and then the second one we

1356
00:27:08,860 --> 00:27:08,870
 

1357
00:27:08,870 --> 00:27:10,030
did is to be show before of doing

1358
00:27:10,030 --> 00:27:10,040
 

1359
00:27:10,040 --> 00:27:14,140
matching where the the uppercase version

1360
00:27:14,140 --> 00:27:14,150
 

1361
00:27:14,150 --> 00:27:18,550
of the student name is begins with K ka

1362
00:27:18,550 --> 00:27:18,560
 

1363
00:27:18,560 --> 00:27:21,700
n so again string functions are for the

1364
00:27:21,700 --> 00:27:21,710
 

1365
00:27:21,710 --> 00:27:23,380
most part the basic ones will be pretty

1366
00:27:23,380 --> 00:27:23,390
 

1367
00:27:23,390 --> 00:27:24,550
much standardized across all systems

1368
00:27:24,550 --> 00:27:24,560
 

1369
00:27:24,560 --> 00:27:26,950
where things get weird as when you want

1370
00:27:26,950 --> 00:27:26,960
 

1371
00:27:26,960 --> 00:27:29,200
to start doing a concatenation so The

1372
00:27:29,200 --> 00:27:29,210
 

1373
00:27:29,210 --> 00:27:30,940
Seagull standard says that you use two

1374
00:27:30,940 --> 00:27:30,950
 

1375
00:27:30,950 --> 00:27:33,400
double bars to concatenate two strings

1376
00:27:33,400 --> 00:27:33,410
 

1377
00:27:33,410 --> 00:27:37,930
together and most systems follow this in

1378
00:27:37,930 --> 00:27:37,940
 

1379
00:27:37,940 --> 00:27:39,250
my opinion I would say Postgres in

1380
00:27:39,250 --> 00:27:39,260
 

1381
00:27:39,260 --> 00:27:40,780
Oracle probably follow the sequel

1382
00:27:40,780 --> 00:27:40,790
 

1383
00:27:40,790 --> 00:27:43,020
standard the best out of all the systems

1384
00:27:43,020 --> 00:27:43,030
 

1385
00:27:43,030 --> 00:27:46,320
sequel server and db2 are probably next

1386
00:27:46,320 --> 00:27:46,330
 

1387
00:27:46,330 --> 00:27:48,790
sequel Lite then probably my sequels the

1388
00:27:48,790 --> 00:27:48,800
 

1389
00:27:48,800 --> 00:27:52,720
worst so you want to say to concatenate

1390
00:27:52,720 --> 00:27:52,730
 

1391
00:27:52,730 --> 00:27:56,260
the student name and add at CS to it do

1392
00:27:56,260 --> 00:27:56,270
 

1393
00:27:56,270 --> 00:27:58,750
use double bar in the sequel standard in

1394
00:27:58,750 --> 00:27:58,760

1395
00:27:58,760 --> 00:28:00,850
sequel server from Microsoft you use the

1396
00:28:00,850 --> 00:28:00,860
 

1397
00:28:00,860 --> 00:28:03,700
plus sign in my sequel they don't have a

1398
00:28:03,700 --> 00:28:03,710

1399
00:28:03,710 --> 00:28:05,650
plus sign they don't have the double bar

1400
00:28:05,650 --> 00:28:05,660

1401
00:28:05,660 --> 00:28:09,820
they only have this concat function were

1402
00:28:09,820 --> 00:28:09,830
 

1403
00:28:09,830 --> 00:28:11,320
you basically defined as the input

1404
00:28:11,320 --> 00:28:11,330
 

1405
00:28:11,330 --> 00:28:12,640
parameters the things you want to

1406
00:28:12,640 --> 00:28:12,650
 

1407
00:28:12,650 --> 00:28:14,560
concatenate together they have something

1408
00:28:14,560 --> 00:28:14,570
 

1409
00:28:14,570 --> 00:28:16,150
else that's kind of weird to where you

1410
00:28:16,150 --> 00:28:16,160
 

1411
00:28:16,160 --> 00:28:18,760
can actually have if you don't put

1412
00:28:18,760 --> 00:28:18,770
 

1413
00:28:18,770 --> 00:28:20,230
anything between two string literals

1414
00:28:20,230 --> 00:28:20,240

1415
00:28:20,240 --> 00:28:22,780
that'll concatenate them together so to

1416
00:28:22,780 --> 00:28:22,790
 

1417
00:28:22,790 --> 00:28:25,450
show you what I mean by that so here we

1418
00:28:25,450 --> 00:28:25,460
 

1419
00:28:25,460 --> 00:28:26,920
have my siegel so i can do something

1420
00:28:26,920 --> 00:28:26,930
 

1421
00:28:26,930 --> 00:28:39,249
like this a n dy space PA VLO right

1422
00:28:39,249 --> 00:28:39,259


1423
00:28:39,259 --> 00:28:41,239
nobody else does this as far as I know

1424
00:28:41,239 --> 00:28:41,249
 

1425
00:28:41,249 --> 00:28:43,070
let me double check that before I lie to

1426
00:28:43,070 --> 00:28:43,080
 

1427
00:28:43,080 --> 00:28:47,779
you let's try it in huh

1428
00:28:47,779 --> 00:28:47,789
 

1429
00:28:47,789 --> 00:28:51,340
yeah toca Paris Chris doesn't like it

1430
00:28:51,340 --> 00:28:51,350
 

1431
00:28:51,350 --> 00:28:53,060
sequence over doesn't like it either

1432
00:28:53,060 --> 00:28:53,070
 

1433
00:28:53,070 --> 00:28:57,139
right only my seagull does that all

1434
00:28:57,139 --> 00:28:57,149
 

1435
00:28:57,149 --> 00:28:58,909
right so now we're things get really

1436
00:28:58,909 --> 00:28:58,919
 

1437
00:28:58,919 --> 00:29:01,639
really bad is when you have date and

1438
00:29:01,639 --> 00:29:01,649
 

1439
00:29:01,649 --> 00:29:04,759
time functions right so a date basically

1440
00:29:04,759 --> 00:29:04,769
 

1441
00:29:04,769 --> 00:29:06,349
chicken just records the time stamp

1442
00:29:06,349 --> 00:29:06,359
 

1443
00:29:06,359 --> 00:29:08,570
without the time time stamp is is the

1444
00:29:08,570 --> 00:29:08,580
 

1445
00:29:08,580 --> 00:29:11,299
time now they vary on the granularity of

1446
00:29:11,299 --> 00:29:11,309
 

1447
00:29:11,309 --> 00:29:13,399
the time they may be tracking sometimes

1448
00:29:13,399 --> 00:29:13,409
 

1449
00:29:13,409 --> 00:29:15,229
in seconds sometimes it's a milliseconds

1450
00:29:15,229 --> 00:29:15,239
 

1451
00:29:15,239 --> 00:29:16,729
or something even more fine-grained than

1452
00:29:16,729 --> 00:29:16,739

1453
00:29:16,739 --> 00:29:20,509
that but where things get get wonky is

1454
00:29:20,509 --> 00:29:20,519
 

1455
00:29:20,519 --> 00:29:22,669
how you actually start manipulating them

1456
00:29:22,669 --> 00:29:22,679
 

1457
00:29:22,679 --> 00:29:24,440
and extracting them extracting

1458
00:29:24,440 --> 00:29:24,450
 

1459
00:29:24,450 --> 00:29:27,649
information from them right and so the

1460
00:29:27,649 --> 00:29:27,659
 

1461
00:29:27,659 --> 00:29:29,239
syntax for all these different systems

1462
00:29:29,239 --> 00:29:29,249
 

1463
00:29:29,249 --> 00:29:31,999
can can can vary wildly so for this

1464
00:29:31,999 --> 00:29:32,009
 

1465
00:29:32,009 --> 00:29:33,529
example we want to do is I want to show

1466
00:29:33,529 --> 00:29:33,539
 

1467
00:29:33,539 --> 00:29:36,049
you how to do what I consider a

1468
00:29:36,049 --> 00:29:36,059

1469
00:29:36,059 --> 00:29:38,180
seemingly easy function or easy

1470
00:29:38,180 --> 00:29:38,190
 

1471
00:29:38,190 --> 00:29:41,769
operation get the number days from today

1472
00:29:41,769 --> 00:29:41,779
 

1473
00:29:41,779 --> 00:29:45,349
to since the beginning of the year and

1474
00:29:45,349 --> 00:29:45,359
 

1475
00:29:45,359 --> 00:29:46,669
we'll see how to try to do this and on

1476
00:29:46,669 --> 00:29:46,679
 

1477
00:29:46,679 --> 00:29:49,849
these three different systems okay so

1478
00:29:49,849 --> 00:29:49,859
 

1479
00:29:49,859 --> 00:29:51,739
the first thing is that we want to get

1480
00:29:51,739 --> 00:29:51,749
 

1481
00:29:51,749 --> 00:30:02,259
maybe what the current time is now I

1482
00:30:02,259 --> 00:30:02,269


1483
00:30:02,269 --> 00:30:16,820
just kill my Wi-Fi back okay all right

1484
00:30:16,820 --> 00:30:16,830
 

1485
00:30:16,830 --> 00:30:21,080
so the seco standard defines a now

1486
00:30:21,080 --> 00:30:21,090
 

1487
00:30:21,090 --> 00:30:23,359
function can everyone see that or now in

1488
00:30:23,359 --> 00:30:23,369
 

1489
00:30:23,369 --> 00:30:25,460
the back guys can you see it okay cool

1490
00:30:25,460 --> 00:30:25,470
 

1491
00:30:25,470 --> 00:30:29,389
so you call now and it gives you the

1492
00:30:29,389 --> 00:30:29,399
 

1493
00:30:29,399 --> 00:30:32,409
current timestamp so we can do that in

1494
00:30:32,409 --> 00:30:32,419
 

1495
00:30:32,419 --> 00:30:38,330
in my sequel and we can do this in

1496
00:30:38,330 --> 00:30:38,340
 

1497
00:30:38,340 --> 00:30:43,609
sequel light what you can't do in a

1498
00:30:43,609 --> 00:30:43,619
 

1499
00:30:43,619 --> 00:30:45,690
single vibe all right

1500
00:30:45,690 --> 00:30:45,700
 

1501
00:30:45,700 --> 00:30:48,090
all right so there's another way to do

1502
00:30:48,090 --> 00:30:48,100
 

1503
00:30:48,100 --> 00:30:50,820
this they have another function called a

1504
00:30:50,820 --> 00:30:50,830
 

1505
00:30:50,830 --> 00:30:55,380
current timestamp right except Postgres

1506
00:30:55,380 --> 00:30:55,390
 

1507
00:30:55,390 --> 00:30:57,300
doesn't have it but they had the keyword

1508
00:30:57,300 --> 00:30:57,310
 

1509
00:30:57,310 --> 00:30:58,610
current timestamp

1510
00:30:58,610 --> 00:30:58,620
 

1511
00:30:58,620 --> 00:31:04,280
my sequel has the function and it has

1512
00:31:04,280 --> 00:31:04,290
 

1513
00:31:04,290 --> 00:31:08,100
the keyword all right see collate who

1514
00:31:08,100 --> 00:31:08,110
 

1515
00:31:08,110 --> 00:31:11,810
says it has the function raise your hand

1516
00:31:11,810 --> 00:31:11,820


1517
00:31:11,820 --> 00:31:15,320
some who says it says it has the keyword

1518
00:31:15,320 --> 00:31:15,330
 

1519
00:31:15,330 --> 00:31:18,300
alright it's mixed alright they don't

1520
00:31:18,300 --> 00:31:18,310
 

1521
00:31:18,310 --> 00:31:20,490
have the function they have the keyword

1522
00:31:20,490 --> 00:31:20,500
 

1523
00:31:20,500 --> 00:31:22,980
alright again simple thing like what's

1524
00:31:22,980 --> 00:31:22,990
 

1525
00:31:22,990 --> 00:31:25,430
the current time it varies

1526
00:31:25,430 --> 00:31:25,440
 

1527
00:31:25,440 --> 00:31:27,690
alright so now again what we want to do

1528
00:31:27,690 --> 00:31:27,700
 

1529
00:31:27,700 --> 00:31:29,100
is we want to count the number of days

1530
00:31:29,100 --> 00:31:29,110
 

1531
00:31:29,110 --> 00:31:32,610
since the since the beginning of the

1532
00:31:32,610 --> 00:31:32,620
 

1533
00:31:32,620 --> 00:31:38,310
year all right so as a building block

1534
00:31:38,310 --> 00:31:38,320
 

1535
00:31:38,320 --> 00:31:41,130
what we can try to do is maybe just get

1536
00:31:41,130 --> 00:31:41,140
 

1537
00:31:41,140 --> 00:31:43,050
what the number of days is from from

1538
00:31:43,050 --> 00:31:43,060
 

1539
00:31:43,060 --> 00:31:45,530
today so in this query what I'm doing is

1540
00:31:45,530 --> 00:31:45,540
 

1541
00:31:45,540 --> 00:31:48,450
I'm taking a date listed here is a

1542
00:31:48,450 --> 00:31:48,460
 

1543
00:31:48,460 --> 00:31:50,820
string right so I'm taking the string

1544
00:31:50,820 --> 00:31:50,830

1545
00:31:50,830 --> 00:31:52,710
for today's date and converting it into

1546
00:31:52,710 --> 00:31:52,720
 

1547
00:31:52,720 --> 00:31:54,780
a date and then I have the extract

1548
00:31:54,780 --> 00:31:54,790

1549
00:31:54,790 --> 00:31:58,080
function which will extract out the the

1550
00:31:58,080 --> 00:31:58,090

1551
00:31:58,090 --> 00:32:01,110
day field of the date right so as

1552
00:32:01,110 --> 00:32:01,120

1553
00:32:01,120 --> 00:32:04,500
expected you get you get 29 all right we

1554
00:32:04,500 --> 00:32:04,510
 

1555
00:32:04,510 --> 00:32:06,770
can try that in the and the other guys

1556
00:32:06,770 --> 00:32:06,780
 

1557
00:32:06,780 --> 00:32:11,100
it gives you 29 they don't have it all

1558
00:32:11,100 --> 00:32:11,110

1559
00:32:11,110 --> 00:32:12,120
right

1560
00:32:12,120 --> 00:32:12,130

1561
00:32:12,130 --> 00:32:16,539
so but now we can see that like alright

1562
00:32:16,539 --> 00:32:16,549
 

1563
00:32:16,549 --> 00:32:20,500
well if I can if I can cast a string for

1564
00:32:20,500 --> 00:32:20,510
 

1565
00:32:20,510 --> 00:32:23,320
the date into a date what happens if I

1566
00:32:23,320 --> 00:32:23,330
 

1567
00:32:23,330 --> 00:32:27,009
do subtract them right right I'll take

1568
00:32:27,009 --> 00:32:27,019
 

1569
00:32:27,019 --> 00:32:29,560
today's date and subtract the it from

1570
00:32:29,560 --> 00:32:29,570

1571
00:32:29,570 --> 00:32:31,509
the the the date from the beginning of

1572
00:32:31,509 --> 00:32:31,519
 

1573
00:32:31,519 --> 00:32:35,200
the year and in Postgres we get it 240

1574
00:32:35,200 --> 00:32:35,210
 

1575
00:32:35,210 --> 00:32:37,019
days all right

1576
00:32:37,019 --> 00:32:37,029
 

1577
00:32:37,029 --> 00:32:44,080
my sequel 728 I don't know what that

1578
00:32:44,080 --> 00:32:44,090
 

1579
00:32:44,090 --> 00:32:47,080
means right like it's not like 240 times

1580
00:32:47,080 --> 00:32:47,090
 

1581
00:32:47,090 --> 00:32:48,789
2 or some you know some multiple there

1582
00:32:48,789 --> 00:32:48,799
 

1583
00:32:48,799 --> 00:32:51,370
right it's it's a number right it ran

1584
00:32:51,370 --> 00:32:51,380
 

1585
00:32:51,380 --> 00:32:55,120
but it's not what we want right so now

1586
00:32:55,120 --> 00:32:55,130
 

1587
00:32:55,130 --> 00:32:58,210
let's try it in in sequel Lite sequel

1588
00:32:58,210 --> 00:32:58,220
 

1589
00:32:58,220 --> 00:33:03,610
like give us 0 ok so it works in

1590
00:33:03,610 --> 00:33:03,620
 

1591
00:33:03,620 --> 00:33:04,690
Postgres and now we got to figure how to

1592
00:33:04,690 --> 00:33:04,700
 

1593
00:33:04,700 --> 00:33:09,190
do this in my sequel well so what we can

1594
00:33:09,190 --> 00:33:09,200
 

1595
00:33:09,200 --> 00:33:14,889
do is we we try to extract the the the

1596
00:33:14,889 --> 00:33:14,899
 

1597
00:33:14,899 --> 00:33:17,289
day from so maybe we take what we can at

1598
00:33:17,289 --> 00:33:17,299
 

1599
00:33:17,299 --> 00:33:20,860
728 we have before right and we extract

1600
00:33:20,860 --> 00:33:20,870
 

1601
00:33:20,870 --> 00:33:22,990
the day from and see what that means all

1602
00:33:22,990 --> 00:33:23,000
 

1603
00:33:23,000 --> 00:33:24,700
right it came back with 28 so that's not

1604
00:33:24,700 --> 00:33:24,710
 

1605
00:33:24,710 --> 00:33:27,850
really what we want so the way to do it

1606
00:33:27,850 --> 00:33:27,860
 

1607
00:33:27,860 --> 00:33:32,230
actually is a bit complicated what we're

1608
00:33:32,230 --> 00:33:32,240
 

1609
00:33:32,240 --> 00:33:34,180
gonna do is we're going to convert the

1610
00:33:34,180 --> 00:33:34,190
 

1611
00:33:34,190 --> 00:33:36,879
dates into UNIX timestamp which is the

1612
00:33:36,879 --> 00:33:36,889
 

1613
00:33:36,889 --> 00:33:38,320
number of seconds since the unit's to

1614
00:33:38,320 --> 00:33:38,330
 

1615
00:33:38,330 --> 00:33:39,850
epoch which is like some January 1st

1616
00:33:39,850 --> 00:33:39,860

1617
00:33:39,860 --> 00:33:42,940
1970 right and now we're gonna have the

1618
00:33:42,940 --> 00:33:42,950
 

1619
00:33:42,950 --> 00:33:44,860
number of seconds from from the current

1620
00:33:44,860 --> 00:33:44,870
 

1621
00:33:44,870 --> 00:33:46,360
date number seconds since beginning the

1622
00:33:46,360 --> 00:33:46,370

1623
00:33:46,370 --> 00:33:49,240
day we subtract them right and that

1624
00:33:49,240 --> 00:33:49,250
 

1625
00:33:49,250 --> 00:33:50,680
gives us the number of seconds between

1626
00:33:50,680 --> 00:33:50,690
 

1627
00:33:50,690 --> 00:33:52,659
now and the beginning of the year and

1628
00:33:52,659 --> 00:33:52,669
 

1629
00:33:52,669 --> 00:33:55,629
then we're gonna divide that by 60

1630
00:33:55,629 --> 00:33:55,639
 

1631
00:33:55,639 --> 00:33:57,870
seconds times 60 minutes times 24 days

1632
00:33:57,870 --> 00:33:57,880
 

1633
00:33:57,880 --> 00:34:03,460
right we got 240 all right turns out

1634
00:34:03,460 --> 00:34:03,470
 

1635
00:34:03,470 --> 00:34:04,810
though after I did this the first time

1636
00:34:04,810 --> 00:34:04,820
 

1637
00:34:04,820 --> 00:34:08,050
there's actually even easier way in my

1638
00:34:08,050 --> 00:34:08,060
 

1639
00:34:08,060 --> 00:34:09,970
sequel they have a simple function

1640
00:34:09,970 --> 00:34:09,980
 

1641
00:34:09,980 --> 00:34:13,089
called date div and that produces you

1642
00:34:13,089 --> 00:34:13,099
 

1643
00:34:13,099 --> 00:34:15,960
know the same answer all right

1644
00:34:15,960 --> 00:34:15,970
 

1645
00:34:15,970 --> 00:34:24,639
single light uh-huh for Brianna I think

1646
00:34:24,639 --> 00:34:24,649
 

1647
00:34:24,649 --> 00:34:25,899
let me try Nicky's a little bigger there

1648
00:34:25,899 --> 00:34:25,909
 

1649
00:34:25,909 --> 00:34:29,559
you go in single light they don't have

1650
00:34:29,559 --> 00:34:29,569
 

1651
00:34:29,569 --> 00:34:31,659
date if you can't subtract the age with

1652
00:34:31,659 --> 00:34:31,669

1653
00:34:31,669 --> 00:34:34,359
each other the the way I figured out to

1654
00:34:34,359 --> 00:34:34,369
 

1655
00:34:34,369 --> 00:34:36,550
do it was convert the current timestamp

1656
00:34:36,550 --> 00:34:36,560
 

1657
00:34:36,560 --> 00:34:39,819
into the to the Julian calendar which is

1658
00:34:39,819 --> 00:34:39,829
 

1659
00:34:39,829 --> 00:34:44,589
the number of days since for 37 BC or

1660
00:34:44,589 --> 00:34:44,599
 

1661
00:34:44,599 --> 00:34:50,139
for 4370 BC and so you subtract the the

1662
00:34:50,139 --> 00:34:50,149
 

1663
00:34:50,149 --> 00:34:52,089
noir days since that time the number

1664
00:34:52,089 --> 00:34:52,099
 

1665
00:34:52,099 --> 00:34:54,879
days beginning the year and you get

1666
00:34:54,879 --> 00:34:54,889
 

1667
00:34:54,889 --> 00:34:59,380
roughly 240 right alright and we get we

1668
00:34:59,380 --> 00:34:59,390
 

1669
00:34:59,390 --> 00:35:02,829
can cast it to an int and we get 240

1670
00:35:02,829 --> 00:35:02,839
 

1671
00:35:02,839 --> 00:35:07,780
right so these are three super super

1672
00:35:07,780 --> 00:35:07,790
 

1673
00:35:07,790 --> 00:35:10,030
widely used database systems that all

1674
00:35:10,030 --> 00:35:10,040
 

1675
00:35:10,040 --> 00:35:11,980
differ on some basic functionality of

1676
00:35:11,980 --> 00:35:11,990
 

1677
00:35:11,990 --> 00:35:14,109
doing date and time right

1678
00:35:14,109 --> 00:35:14,119

1679
00:35:14,119 --> 00:35:16,120
actually quick show of hands who think

1680
00:35:16,120 --> 00:35:16,130
 

1681
00:35:16,130 --> 00:35:17,680
of these three ones which one do you

1682
00:35:17,680 --> 00:35:17,690
 

1683
00:35:17,690 --> 00:35:19,120
think is the most popular miss widely

1684
00:35:19,120 --> 00:35:19,130
 

1685
00:35:19,130 --> 00:35:21,220
deployed database system raise your hand

1686
00:35:21,220 --> 00:35:21,230

1687
00:35:21,230 --> 00:35:25,240
you think my sequel but about a quarter

1688
00:35:25,240 --> 00:35:25,250
 

1689
00:35:25,250 --> 00:35:28,329
raise your name think Postgres even less

1690
00:35:28,329 --> 00:35:28,339
 

1691
00:35:28,339 --> 00:35:33,370
ready Tim thinks egalit even less the

1692
00:35:33,370 --> 00:35:33,380
 

1693
00:35:33,380 --> 00:35:37,750
answer sequel light so a few years ago

1694
00:35:37,750 --> 00:35:37,760
 

1695
00:35:37,760 --> 00:35:39,370
we had Richard hippie invent our sequel

1696
00:35:39,370 --> 00:35:39,380
 

1697
00:35:39,380 --> 00:35:41,380
light so see the light is amazing it's

1698
00:35:41,380 --> 00:35:41,390
 

1699
00:35:41,390 --> 00:35:45,849
written by three dudes right there they

1700
00:35:45,849 --> 00:35:45,859
 

1701
00:35:45,859 --> 00:35:48,700
is he approximate that it's been

1702
00:35:48,700 --> 00:35:48,710

1703
00:35:48,710 --> 00:35:51,760
deployed on 10 billion devices everyone

1704
00:35:51,760 --> 00:35:51,770
 

1705
00:35:51,770 --> 00:35:53,470
here who has a cell phone right that

1706
00:35:53,470 --> 00:35:53,480
 

1707
00:35:53,480 --> 00:35:55,180
isn't a flip phone or an old person

1708
00:35:55,180 --> 00:35:55,190
 

1709
00:35:55,190 --> 00:35:57,280
phone is running sequel light on it

1710
00:35:57,280 --> 00:35:57,290

1711
00:35:57,290 --> 00:35:57,670
right now

1712
00:35:57,670 --> 00:35:57,680

1713
00:35:57,680 --> 00:36:01,180
right a lot of desktop applications like

1714
00:36:01,180 --> 00:36:01,190
 

1715
00:36:01,190 --> 00:36:03,010
Photoshop and illustrator they run

1716
00:36:03,010 --> 00:36:03,020
 

1717
00:36:03,020 --> 00:36:05,109
sequel light on the inside right sequel

1718
00:36:05,109 --> 00:36:05,119
 

1719
00:36:05,119 --> 00:36:07,450
light is everywhere he said that also to

1720
00:36:07,450 --> 00:36:07,460
 

1721
00:36:07,460 --> 00:36:09,220
every single AOL CD if you know what

1722
00:36:09,220 --> 00:36:09,230

1723
00:36:09,230 --> 00:36:10,900
that is all right back in the early

1724
00:36:10,900 --> 00:36:10,910
 

1725
00:36:10,910 --> 00:36:12,910
2000s when the internet was sort of new

1726
00:36:12,910 --> 00:36:12,920

1727
00:36:12,920 --> 00:36:15,010
in the u.s. there was a company called

1728
00:36:15,010 --> 00:36:15,020
 

1729
00:36:15,020 --> 00:36:17,559
America Online and they would every mail

1730
00:36:17,559 --> 00:36:17,569
 

1731
00:36:17,569 --> 00:36:19,780
everyone CDs for ten hours free on the

1732
00:36:19,780 --> 00:36:19,790
 

1733
00:36:19,790 --> 00:36:21,819
internet right every CD that they mailed

1734
00:36:21,819 --> 00:36:21,829
 

1735
00:36:21,829 --> 00:36:23,620
out you know hundreds of millions of

1736
00:36:23,620 --> 00:36:23,630
 

1737
00:36:23,630 --> 00:36:25,599
them had sequel light running on it

1738
00:36:25,599 --> 00:36:25,609
 

1739
00:36:25,609 --> 00:36:27,940
right sequel a is most widely deployed

1740
00:36:27,940 --> 00:36:27,950
 

1741
00:36:27,950 --> 00:36:28,990
Davis isn't

1742
00:36:28,990 --> 00:36:29,000
 

1743
00:36:29,000 --> 00:36:30,160
everywhere and here's the most crazy

1744
00:36:30,160 --> 00:36:30,170
 

1745
00:36:30,170 --> 00:36:32,530
part it's public domain he gives it away

1746
00:36:32,530 --> 00:36:32,540
 

1747
00:36:32,540 --> 00:36:35,620
for free right I mean Postgres and my

1748
00:36:35,620 --> 00:36:35,630
 

1749
00:36:35,630 --> 00:36:37,510
Segal are open-source but like hey for

1750
00:36:37,510 --> 00:36:37,520
 

1751
00:36:37,520 --> 00:36:39,790
my sequel Oracle owns it Orca owns the

1752
00:36:39,790 --> 00:36:39,800
 

1753
00:36:39,800 --> 00:36:42,280
copyright there's no copyright on sequel

1754
00:36:42,280 --> 00:36:42,290
 

1755
00:36:42,290 --> 00:36:44,740
white right it's an amazing piece of

1756
00:36:44,740 --> 00:36:44,750
 

1757
00:36:44,750 --> 00:36:48,850
software okay alright so just again the

1758
00:36:48,850 --> 00:36:48,860
 

1759
00:36:48,860 --> 00:36:51,040
main takeaway here was that simple

1760
00:36:51,040 --> 00:36:51,050
 

1761
00:36:51,050 --> 00:36:53,200
things are hard to do because there's no

1762
00:36:53,200 --> 00:36:53,210
 

1763
00:36:53,210 --> 00:36:54,610
stamp you know there's no standard way

1764
00:36:54,610 --> 00:36:54,620
 

1765
00:36:54,620 --> 00:36:55,780
to do things even though there is a

1766
00:36:55,780 --> 00:36:55,790
 

1767
00:36:55,790 --> 00:36:59,650
standard specification all right so now

1768
00:36:59,650 --> 00:36:59,660
 

1769
00:36:59,660 --> 00:37:01,210
maybe what we want to do is instead of

1770
00:37:01,210 --> 00:37:01,220
 

1771
00:37:01,220 --> 00:37:04,300
having the you know in my examples I had

1772
00:37:04,300 --> 00:37:04,310
 

1773
00:37:04,310 --> 00:37:06,460
the terminal open every time I ran a

1774
00:37:06,460 --> 00:37:06,470
 

1775
00:37:06,470 --> 00:37:08,560
query that the output got printed back

1776
00:37:08,560 --> 00:37:08,570
 

1777
00:37:08,570 --> 00:37:10,780
to me in my terminal but maybe what you

1778
00:37:10,780 --> 00:37:10,790
 

1779
00:37:10,790 --> 00:37:12,670
want to do is keep all the data you you

1780
00:37:12,670 --> 00:37:12,680
 

1781
00:37:12,680 --> 00:37:14,770
you generate from a query keep that

1782
00:37:14,770 --> 00:37:14,780
 

1783
00:37:14,780 --> 00:37:16,570
inside the database system so you can

1784
00:37:16,570 --> 00:37:16,580
 

1785
00:37:16,580 --> 00:37:18,670
use it in subsequent queries right this

1786
00:37:18,670 --> 00:37:18,680
 

1787
00:37:18,680 --> 00:37:19,780
is way more efficient if you're if

1788
00:37:19,780 --> 00:37:19,790
 

1789
00:37:19,790 --> 00:37:21,400
you're if your queries generating a lot

1790
00:37:21,400 --> 00:37:21,410
 

1791
00:37:21,410 --> 00:37:23,830
of output you don't have everything sim

1792
00:37:23,830 --> 00:37:23,840
 

1793
00:37:23,840 --> 00:37:25,420
down to your laptop and then push it

1794
00:37:25,420 --> 00:37:25,430
 

1795
00:37:25,430 --> 00:37:27,730
back up to do more queries on it so you

1796
00:37:27,730 --> 00:37:27,740
 

1797
00:37:27,740 --> 00:37:29,230
can do output redirection to tell it to

1798
00:37:29,230 --> 00:37:29,240
 

1799
00:37:29,240 --> 00:37:31,120
say hey don't print it out to me write

1800
00:37:31,120 --> 00:37:31,130
 

1801
00:37:31,130 --> 00:37:34,060
it out to this location so one thing you

1802
00:37:34,060 --> 00:37:34,070
 

1803
00:37:34,070 --> 00:37:35,050
can do is you can take the output or

1804
00:37:35,050 --> 00:37:35,060
 

1805
00:37:35,060 --> 00:37:37,210
query and you can write it into another

1806
00:37:37,210 --> 00:37:37,220
 

1807
00:37:37,220 --> 00:37:41,140
table right and so you in the sequel

1808
00:37:41,140 --> 00:37:41,150
 

1809
00:37:41,150 --> 00:37:43,000
standard you can use into and this will

1810
00:37:43,000 --> 00:37:43,010
 

1811
00:37:43,010 --> 00:37:45,370
actually will create the table for you

1812
00:37:45,370 --> 00:37:45,380
 

1813
00:37:45,380 --> 00:37:47,920
on the fly so whatever is produces the

1814
00:37:47,920 --> 00:37:47,930
 

1815
00:37:47,930 --> 00:37:51,130
output of the query right again this is

1816
00:37:51,130 --> 00:37:51,140
 

1817
00:37:51,140 --> 00:37:53,050
declarative the David isn't already

1818
00:37:53,050 --> 00:37:53,060
 

1819
00:37:53,060 --> 00:37:54,580
knows what the schema is of the table so

1820
00:37:54,580 --> 00:37:54,590
 

1821
00:37:54,590 --> 00:37:56,650
it knows in this case here what the type

1822
00:37:56,650 --> 00:37:56,660
 

1823
00:37:56,660 --> 00:37:58,120
is that this output is going to be so he

1824
00:37:58,120 --> 00:37:58,130
 

1825
00:37:58,130 --> 00:38:00,400
knows how to define a table that has

1826
00:38:00,400 --> 00:38:00,410
 

1827
00:38:00,410 --> 00:38:03,130
that that can handle those types right

1828
00:38:03,130 --> 00:38:03,140
 

1829
00:38:03,140 --> 00:38:04,510
so into basically takes the output of

1830
00:38:04,510 --> 00:38:04,520
 

1831
00:38:04,520 --> 00:38:06,820
select and writes it into a table and in

1832
00:38:06,820 --> 00:38:06,830
 

1833
00:38:06,830 --> 00:38:08,200
my sequel you have to use the create

1834
00:38:08,200 --> 00:38:08,210

1835
00:38:08,210 --> 00:38:10,060
table and then inside of it you define

1836
00:38:10,060 --> 00:38:10,070
 

1837
00:38:10,070 --> 00:38:14,860
your Select statement you can also have

1838
00:38:14,860 --> 00:38:14,870
 

1839
00:38:14,870 --> 00:38:17,160
it output data into an existing table

1840
00:38:17,160 --> 00:38:17,170
 

1841
00:38:17,170 --> 00:38:21,040
and for this you use insert into which

1842
00:38:21,040 --> 00:38:21,050
 

1843
00:38:21,050 --> 00:38:22,660
looks a lot like we create into the

1844
00:38:22,660 --> 00:38:22,670
 

1845
00:38:22,670 --> 00:38:24,520
create table from from before and then

1846
00:38:24,520 --> 00:38:24,530

1847
00:38:24,530 --> 00:38:26,080
set instead of having the value Clause

1848
00:38:26,080 --> 00:38:26,090
 

1849
00:38:26,090 --> 00:38:27,520
you actually just have a select

1850
00:38:27,520 --> 00:38:27,530
 

1851
00:38:27,530 --> 00:38:29,500
statement just to tell it hey get this

1852
00:38:29,500 --> 00:38:29,510
 

1853
00:38:29,510 --> 00:38:31,510
data aren't right into here so the

1854
00:38:31,510 --> 00:38:31,520
 

1855
00:38:31,520 --> 00:38:33,490
important thing about this example

1856
00:38:33,490 --> 00:38:33,500
 

1857
00:38:33,500 --> 00:38:35,320
versus the previous slide this is about

1858
00:38:35,320 --> 00:38:35,330
 

1859
00:38:35,330 --> 00:38:37,660
writing tables into tuples into tables

1860
00:38:37,660 --> 00:38:37,670

1861
00:38:37,670 --> 00:38:39,940
that already exist so that means that

1862
00:38:39,940 --> 00:38:39,950
 

1863
00:38:39,950 --> 00:38:42,579
whatever be whatever

1864
00:38:42,579 --> 00:38:42,589
 

1865
00:38:42,589 --> 00:38:44,380
the type the number attributes and their

1866
00:38:44,380 --> 00:38:44,390
 

1867
00:38:44,390 --> 00:38:46,180
types that are produced by the Select

1868
00:38:46,180 --> 00:38:46,190
 

1869
00:38:46,190 --> 00:38:48,069
statement whatever table you're writing

1870
00:38:48,069 --> 00:38:48,079
 

1871
00:38:48,079 --> 00:38:51,489
it into has to match that right if the

1872
00:38:51,489 --> 00:38:51,499
 

1873
00:38:51,499 --> 00:38:54,069
the Select statement has 44 columns and

1874
00:38:54,069 --> 00:38:54,079
 

1875
00:38:54,079 --> 00:38:55,749
your table you're writing into as three

1876
00:38:55,749 --> 00:38:55,759
 

1877
00:38:55,759 --> 00:38:57,489
the daisen will throw an air it says

1878
00:38:57,489 --> 00:38:57,499
 

1879
00:38:57,499 --> 00:38:58,809
like I can't write into that because it

1880
00:38:58,809 --> 00:38:58,819
 

1881
00:38:58,819 --> 00:39:01,749
the Astor's don't match up now where

1882
00:39:01,749 --> 00:39:01,759
 

1883
00:39:01,759 --> 00:39:03,370
things get weird is when you start

1884
00:39:03,370 --> 00:39:03,380

1885
00:39:03,380 --> 00:39:06,579
having constraints that are on the table

1886
00:39:06,579 --> 00:39:06,589
 

1887
00:39:06,589 --> 00:39:08,709
you're trying to write into and the

1888
00:39:08,709 --> 00:39:08,719
 

1889
00:39:08,719 --> 00:39:11,170
Select statement actually violates those

1890
00:39:11,170 --> 00:39:11,180

1891
00:39:11,180 --> 00:39:13,719
constraints so let's say that I have a

1892
00:39:13,719 --> 00:39:13,729
 

1893
00:39:13,729 --> 00:39:15,549
primary key on my table it says I can't

1894
00:39:15,549 --> 00:39:15,559
 

1895
00:39:15,559 --> 00:39:18,130
have any duplicate student IDs and then

1896
00:39:18,130 --> 00:39:18,140

1897
00:39:18,140 --> 00:39:20,739
my insert query here tries to start and

1898
00:39:20,739 --> 00:39:20,749
 

1899
00:39:20,749 --> 00:39:23,680
start inserting duplicates some database

1900
00:39:23,680 --> 00:39:23,690
 

1901
00:39:23,690 --> 00:39:25,200
system will throw an error immediately

1902
00:39:25,200 --> 00:39:25,210
 

1903
00:39:25,210 --> 00:39:27,969
as soon as it sees the duplicate and no

1904
00:39:27,969 --> 00:39:27,979
 

1905
00:39:27,979 --> 00:39:29,709
tuples get written some of them will

1906
00:39:29,709 --> 00:39:29,719
 

1907
00:39:29,719 --> 00:39:31,359
just keep going and ignore the ones that

1908
00:39:31,359 --> 00:39:31,369
 

1909
00:39:31,369 --> 00:39:34,509
that failed other ones will will insert

1910
00:39:34,509 --> 00:39:34,519
 

1911
00:39:34,519 --> 00:39:36,339
the ones that succeeded and just ignore

1912
00:39:36,339 --> 00:39:36,349
 

1913
00:39:36,349 --> 00:39:38,079
the ones that failed or me these just

1914
00:39:38,079 --> 00:39:38,089
 

1915
00:39:38,089 --> 00:39:40,930
crash right away right so again the

1916
00:39:40,930 --> 00:39:40,940
 

1917
00:39:40,940 --> 00:39:42,249
sequel standard says this is the syntax

1918
00:39:42,249 --> 00:39:42,259
 

1919
00:39:42,259 --> 00:39:44,829
that to use but how the systems actually

1920
00:39:44,829 --> 00:39:44,839
 

1921
00:39:44,839 --> 00:39:49,349
implement it will vary widely in

1922
00:39:49,349 --> 00:39:49,359


1923
00:39:49,359 --> 00:39:51,849
addition to redirection we can all sleep

1924
00:39:51,849 --> 00:39:51,859
 

1925
00:39:51,859 --> 00:39:53,950
output control remember I said the

1926
00:39:53,950 --> 00:39:53,960
 

1927
00:39:53,960 --> 00:39:56,769
beginning Seco is based on bag algebra I

1928
00:39:56,769 --> 00:39:56,779
 

1929
00:39:56,779 --> 00:39:58,569
mean it's unordered but there's many

1930
00:39:58,569 --> 00:39:58,579
 

1931
00:39:58,579 --> 00:40:01,120
times where you want the ordering in

1932
00:40:01,120 --> 00:40:01,130
 

1933
00:40:01,130 --> 00:40:03,489
your Apple cause and so to do this you

1934
00:40:03,489 --> 00:40:03,499

1935
00:40:03,499 --> 00:40:05,589
add the order by clause I assume is

1936
00:40:05,589 --> 00:40:05,599
 

1937
00:40:05,599 --> 00:40:08,620
basically specifying how to sort the

1938
00:40:08,620 --> 00:40:08,630

1939
00:40:08,630 --> 00:40:10,809
results that are being generated by by

1940
00:40:10,809 --> 00:40:10,819
 

1941
00:40:10,819 --> 00:40:14,440
this query so in this example here I'm

1942
00:40:14,440 --> 00:40:14,450
 

1943
00:40:14,450 --> 00:40:16,359
gonna sort the tuple I started sort of

1944
00:40:16,359 --> 00:40:16,369
 

1945
00:40:16,369 --> 00:40:19,660
the tuple main role table based on their

1946
00:40:19,660 --> 00:40:19,670
 

1947
00:40:19,670 --> 00:40:24,130
grade and by default even though I don't

1948
00:40:24,130 --> 00:40:24,140
 

1949
00:40:24,140 --> 00:40:26,319
specify whether I wanted ascending in or

1950
00:40:26,319 --> 00:40:26,329
 

1951
00:40:26,329 --> 00:40:28,630
descending the default in sequel is that

1952
00:40:28,630 --> 00:40:28,640
 

1953
00:40:28,640 --> 00:40:30,640
you get ascending right you get output

1954
00:40:30,640 --> 00:40:30,650
 

1955
00:40:30,650 --> 00:40:33,450
like this but I also can add additional

1956
00:40:33,450 --> 00:40:33,460
 

1957
00:40:33,460 --> 00:40:36,430
attributes to my order by clause do more

1958
00:40:36,430 --> 00:40:36,440
 

1959
00:40:36,440 --> 00:40:38,469
complicated things so in this case here

1960
00:40:38,469 --> 00:40:38,479
 

1961
00:40:38,479 --> 00:40:40,870
I want to do my order by by grade in

1962
00:40:40,870 --> 00:40:40,880
 

1963
00:40:40,880 --> 00:40:42,729
descending order and then after that I

1964
00:40:42,729 --> 00:40:42,739
 

1965
00:40:42,739 --> 00:40:45,789
sort them based on the student ID in

1966
00:40:45,789 --> 00:40:45,799

1967
00:40:45,799 --> 00:40:46,630
ascending order

1968
00:40:46,630 --> 00:40:46,640

1969
00:40:46,640 --> 00:40:49,420
all right and I would get output like

1970
00:40:49,420 --> 00:40:49,430
 

1971
00:40:49,430 --> 00:40:51,849
this now the one thing to point out here

1972
00:40:51,849 --> 00:40:51,859
 

1973
00:40:51,859 --> 00:40:54,430
also too is that unlike there in the

1974
00:40:54,430 --> 00:40:54,440
 

1975
00:40:54,440 --> 00:40:56,039
group by clause

1976
00:40:56,039 --> 00:40:56,049
 

1977
00:40:56,049 --> 00:40:58,169
where any attribute that I wanted my

1978
00:40:58,169 --> 00:40:58,179
 

1979
00:40:58,179 --> 00:41:00,390
output list had to appear in the group

1980
00:41:00,390 --> 00:41:00,400
 

1981
00:41:00,400 --> 00:41:02,249
by clause in order by you don't have

1982
00:41:02,249 --> 00:41:02,259
 

1983
00:41:02,259 --> 00:41:04,559
that restriction right it actually goes

1984
00:41:04,559 --> 00:41:04,569
 

1985
00:41:04,569 --> 00:41:06,900
both ways in this case here I'm sorting

1986
00:41:06,900 --> 00:41:06,910

1987
00:41:06,910 --> 00:41:09,239
by the grade but the grade isn't part of

1988
00:41:09,239 --> 00:41:09,249
 

1989
00:41:09,249 --> 00:41:12,539
the output right it doesn't matter right

1990
00:41:12,539 --> 00:41:12,549
 

1991
00:41:12,549 --> 00:41:14,729
and it knows how to how to how to find

1992
00:41:14,729 --> 00:41:14,739
 

1993
00:41:14,739 --> 00:41:16,769
the data that it needs as its processing

1994
00:41:16,769 --> 00:41:16,779
 

1995
00:41:16,779 --> 00:41:19,079
the query and do whatever sorting

1996
00:41:19,079 --> 00:41:19,089
 

1997
00:41:19,089 --> 00:41:20,429
operation that you want to do on it I

1998
00:41:20,429 --> 00:41:20,439
 

1999
00:41:20,439 --> 00:41:22,469
can also do more complicated things I

2000
00:41:22,469 --> 00:41:22,479
 

2001
00:41:22,479 --> 00:41:24,870
can put any arbitrary expression in my

2002
00:41:24,870 --> 00:41:24,880
 

2003
00:41:24,880 --> 00:41:26,489
order by Clause as well so I can do

2004
00:41:26,489 --> 00:41:26,499
 

2005
00:41:26,499 --> 00:41:29,549
order by 1 plus 1 right and that's still

2006
00:41:29,549 --> 00:41:29,559
 

2007
00:41:29,559 --> 00:41:33,169
valid it knows how to handle that

2008
00:41:33,169 --> 00:41:33,179


2009
00:41:33,179 --> 00:41:35,219
another common thing you want to do is

2010
00:41:35,219 --> 00:41:35,229
 

2011
00:41:35,229 --> 00:41:37,319
is limit the number of tuples that are

2012
00:41:37,319 --> 00:41:37,329
 

2013
00:41:37,329 --> 00:41:39,059
producing your output right and of

2014
00:41:39,059 --> 00:41:39,069
 

2015
00:41:39,069 --> 00:41:40,319
course there's a there's a limit clause

2016
00:41:40,319 --> 00:41:40,329
 

2017
00:41:40,329 --> 00:41:42,599
for this you basically specifies says I

2018
00:41:42,599 --> 00:41:42,609
 

2019
00:41:42,609 --> 00:41:45,599
for all the results that you of Mike my

2020
00:41:45,599 --> 00:41:45,609
 

2021
00:41:45,609 --> 00:41:47,999
query only and provide me back some

2022
00:41:47,999 --> 00:41:48,009

2023
00:41:48,009 --> 00:41:51,299
number of them like 10 right and this is

2024
00:41:51,299 --> 00:41:51,309
 

2025
00:41:51,309 --> 00:41:53,309
very common for things like you know say

2026
00:41:53,309 --> 00:41:53,319
 

2027
00:41:53,319 --> 00:41:55,229
like search results you'll see it show

2028
00:41:55,229 --> 00:41:55,239
 

2029
00:41:55,239 --> 00:41:56,640
just 10 and then you click the next

2030
00:41:56,640 --> 00:41:56,650
 

2031
00:41:56,650 --> 00:41:58,439
button to go see the next 10 alright

2032
00:41:58,439 --> 00:41:58,449
 

2033
00:41:58,449 --> 00:42:00,089
this is being controlled by it by limit

2034
00:42:00,089 --> 00:42:00,099
 

2035
00:42:00,099 --> 00:42:02,880
and actually all set so limit just says

2036
00:42:02,880 --> 00:42:02,890
 

2037
00:42:02,890 --> 00:42:05,429
limit the number of tuples all set is

2038
00:42:05,429 --> 00:42:05,439
 

2039
00:42:05,439 --> 00:42:10,229
going to tell you that and what all set

2040
00:42:10,229 --> 00:42:10,239
 

2041
00:42:10,239 --> 00:42:11,669
of the number of the tuples you're

2042
00:42:11,669 --> 00:42:11,679
 

2043
00:42:11,679 --> 00:42:14,339
producing as your output should you skip

2044
00:42:14,339 --> 00:42:14,349
 

2045
00:42:14,349 --> 00:42:15,989
before you start figuring out how many

2046
00:42:15,989 --> 00:42:15,999
 

2047
00:42:15,999 --> 00:42:18,299
you should limit right again if you

2048
00:42:18,299 --> 00:42:18,309
 

2049
00:42:18,309 --> 00:42:19,499
think of a webpage to show you 10

2050
00:42:19,499 --> 00:42:19,509
 

2051
00:42:19,509 --> 00:42:20,910
results you click Next to see the next

2052
00:42:20,910 --> 00:42:20,920
 

2053
00:42:20,920 --> 00:42:23,279
10 there using a limit with an offset to

2054
00:42:23,279 --> 00:42:23,289
 

2055
00:42:23,289 --> 00:42:27,269
make that work now because it's unsorted

2056
00:42:27,269 --> 00:42:27,279
 

2057
00:42:27,279 --> 00:42:29,609
again is no guarantee that when you

2058
00:42:29,609 --> 00:42:29,619
 

2059
00:42:29,619 --> 00:42:32,219
click Next if you're using offset you're

2060
00:42:32,219 --> 00:42:32,229
 

2061
00:42:32,229 --> 00:42:34,620
going to see you know you're definitely

2062
00:42:34,620 --> 00:42:34,630
 

2063
00:42:34,630 --> 00:42:36,179
gonna see different tuples because

2064
00:42:36,179 --> 00:42:36,189
 

2065
00:42:36,189 --> 00:42:37,529
that's another invocation of the query

2066
00:42:37,529 --> 00:42:37,539
 

2067
00:42:37,539 --> 00:42:39,390
and the results may be different in

2068
00:42:39,390 --> 00:42:39,400
 

2069
00:42:39,400 --> 00:42:41,339
different order the second time so in

2070
00:42:41,339 --> 00:42:41,349

2071
00:42:41,349 --> 00:42:42,630
this case here you would combine that

2072
00:42:42,630 --> 00:42:42,640
 

2073
00:42:42,640 --> 00:42:44,789
with an order by clause so that you're

2074
00:42:44,789 --> 00:42:44,799
 

2075
00:42:44,799 --> 00:42:46,890
guaranteed to go you know see the first

2076
00:42:46,890 --> 00:42:46,900
 

2077
00:42:46,900 --> 00:42:48,299
10 followed by the second 10 and so

2078
00:42:48,299 --> 00:42:48,309

2079
00:42:48,309 --> 00:42:51,150
forth right and there's optimizations

2080
00:42:51,150 --> 00:42:51,160
 

2081
00:42:51,160 --> 00:42:54,150
you can apply whether you're not you

2082
00:42:54,150 --> 00:42:54,160
 

2083
00:42:54,160 --> 00:42:55,410
have an order by Clause if you have a

2084
00:42:55,410 --> 00:42:55,420
 

2085
00:42:55,420 --> 00:42:57,539
limit clause so if I don't have an order

2086
00:42:57,539 --> 00:42:57,549
 

2087
00:42:57,549 --> 00:42:59,759
by clause and I have a limit I know that

2088
00:42:59,759 --> 00:42:59,769
 

2089
00:42:59,769 --> 00:43:01,949
as soon as I see sent 10 to polls I'm

2090
00:43:01,949 --> 00:43:01,959
 

2091
00:43:01,959 --> 00:43:03,839
done I don't need to go look at anything

2092
00:43:03,839 --> 00:43:03,849
 

2093
00:43:03,849 --> 00:43:05,699
else if you have an order by then you

2094
00:43:05,699 --> 00:43:05,709
 

2095
00:43:05,709 --> 00:43:06,779
have to sort you have to see everything

2096
00:43:06,779 --> 00:43:06,789
 

2097
00:43:06,789 --> 00:43:08,609
ahead of time to sort it then you can

2098
00:43:08,609 --> 00:43:08,619
 

2099
00:43:08,619 --> 00:43:09,599
apply your limit and your

2100
00:43:09,599 --> 00:43:09,609
 

2101
00:43:09,609 --> 00:43:14,249
all set ice again I considered that

2102
00:43:14,249 --> 00:43:14,259
 

2103
00:43:14,259 --> 00:43:17,279
somewhat basic sequel in previous years

2104
00:43:17,279 --> 00:43:17,289
 

2105
00:43:17,289 --> 00:43:19,319
I actually skipped all this but I I

2106
00:43:19,319 --> 00:43:19,329
 

2107
00:43:19,329 --> 00:43:21,180
think it's important maybe to go go over

2108
00:43:21,180 --> 00:43:21,190
 

2109
00:43:21,190 --> 00:43:21,930
it a little bit because you have to

2110
00:43:21,930 --> 00:43:21,940
 

2111
00:43:21,940 --> 00:43:23,640
understand this for the homework but now

2112
00:43:23,640 --> 00:43:23,650
 

2113
00:43:23,650 --> 00:43:24,900
we want to talk about more complicated

2114
00:43:24,900 --> 00:43:24,910
 

2115
00:43:24,910 --> 00:43:26,190
things this is what I would consider

2116
00:43:26,190 --> 00:43:26,200
 

2117
00:43:26,200 --> 00:43:29,940
advanced sequel so the first thing we'll

2118
00:43:29,940 --> 00:43:29,950
 

2119
00:43:29,950 --> 00:43:32,880
talk about is is nested queries so the

2120
00:43:32,880 --> 00:43:32,890

2121
00:43:32,890 --> 00:43:33,839
way thing about nested query it's

2122
00:43:33,839 --> 00:43:33,849
 

2123
00:43:33,849 --> 00:43:35,970
basically allowing you to specify

2124
00:43:35,970 --> 00:43:35,980
 

2125
00:43:35,980 --> 00:43:39,509
queries inside of queries right and you

2126
00:43:39,509 --> 00:43:39,519
 

2127
00:43:39,519 --> 00:43:41,309
can take the output of one query and use

2128
00:43:41,309 --> 00:43:41,319
 

2129
00:43:41,319 --> 00:43:44,430
that as the input of another query all

2130
00:43:44,430 --> 00:43:44,440
 

2131
00:43:44,440 --> 00:43:48,150
right so a simple example like this I'm

2132
00:43:48,150 --> 00:43:48,160
 

2133
00:43:48,160 --> 00:43:50,339
doing a select I want to get all the

2134
00:43:50,339 --> 00:43:50,349
 

2135
00:43:50,349 --> 00:43:51,420
names of the students that are enrolled

2136
00:43:51,420 --> 00:43:51,430
 

2137
00:43:51,430 --> 00:43:54,180
in least one course so I have my outer

2138
00:43:54,180 --> 00:43:54,190

2139
00:43:54,190 --> 00:43:56,309
query is defined based on the student

2140
00:43:56,309 --> 00:43:56,319
 

2141
00:43:56,319 --> 00:43:58,380
table and then the side of that I have

2142
00:43:58,380 --> 00:43:58,390
 

2143
00:43:58,390 --> 00:43:59,579
an inner query that's and this going to

2144
00:43:59,579 --> 00:43:59,589
 

2145
00:43:59,589 --> 00:44:01,640
get the student IDs from the role table

2146
00:44:01,640 --> 00:44:01,650
 

2147
00:44:01,650 --> 00:44:02,910
all right

2148
00:44:02,910 --> 00:44:02,920
 

2149
00:44:02,920 --> 00:44:05,220
so we could write this as a join this is

2150
00:44:05,220 --> 00:44:05,230

2151
00:44:05,230 --> 00:44:06,479
sort of sudden another way to actually

2152
00:44:06,479 --> 00:44:06,489
 

2153
00:44:06,489 --> 00:44:08,609
do this and in actuality when it comes

2154
00:44:08,609 --> 00:44:08,619
 

2155
00:44:08,619 --> 00:44:10,289
time to actually implement this inside

2156
00:44:10,289 --> 00:44:10,299
 

2157
00:44:10,299 --> 00:44:12,690
the system most query optimizer will try

2158
00:44:12,690 --> 00:44:12,700

2159
00:44:12,700 --> 00:44:15,239
to rewrite this as a join right because

2160
00:44:15,239 --> 00:44:15,249
 

2161
00:44:15,249 --> 00:44:17,099
it the worst way to actually execute

2162
00:44:17,099 --> 00:44:17,109
 

2163
00:44:17,109 --> 00:44:19,440
this is to basically have two for loops

2164
00:44:19,440 --> 00:44:19,450
 

2165
00:44:19,450 --> 00:44:21,150
where you loop over every single tuple

2166
00:44:21,150 --> 00:44:21,160
 

2167
00:44:21,160 --> 00:44:23,609
in the student table and for every

2168
00:44:23,609 --> 00:44:23,619
 

2169
00:44:23,619 --> 00:44:24,779
single two but you've been invoked the

2170
00:44:24,779 --> 00:44:24,789
 

2171
00:44:24,789 --> 00:44:26,400
same query over and over and over again

2172
00:44:26,400 --> 00:44:26,410
 

2173
00:44:26,410 --> 00:44:29,910
my sequel used to do this more primitive

2174
00:44:29,910 --> 00:44:29,920
 

2175
00:44:29,920 --> 00:44:31,650
David system you should do this but the

2176
00:44:31,650 --> 00:44:31,660
 

2177
00:44:31,660 --> 00:44:33,120
right way to do is actually just rewrite

2178
00:44:33,120 --> 00:44:33,130

2179
00:44:33,130 --> 00:44:35,819
this as a join all right so you can sort

2180
00:44:35,819 --> 00:44:35,829
 

2181
00:44:35,829 --> 00:44:37,319
of think of this inner query as like a

2182
00:44:37,319 --> 00:44:37,329
 

2183
00:44:37,329 --> 00:44:39,690
function that can produce some set of

2184
00:44:39,690 --> 00:44:39,700
 

2185
00:44:39,700 --> 00:44:41,489
tuples as your output and then you can

2186
00:44:41,489 --> 00:44:41,499
 

2187
00:44:41,499 --> 00:44:42,779
apply whatever predicate you want on

2188
00:44:42,779 --> 00:44:42,789
 

2189
00:44:42,789 --> 00:44:45,420
that in the outer query so we'll walk

2190
00:44:45,420 --> 00:44:45,430
 

2191
00:44:45,430 --> 00:44:46,829
through a bunch of examples of this and

2192
00:44:46,829 --> 00:44:46,839
 

2193
00:44:46,839 --> 00:44:48,799
see how it works

2194
00:44:48,799 --> 00:44:48,809
 

2195
00:44:48,809 --> 00:44:52,140
so the alright so the first example one

2196
00:44:52,140 --> 00:44:52,150
 

2197
00:44:52,150 --> 00:44:53,579
is maybe I want to get the names of all

2198
00:44:53,579 --> 00:44:53,589
 

2199
00:44:53,589 --> 00:44:56,009
the students exist in that enrolled in

2200
00:44:56,009 --> 00:44:56,019
 

2201
00:44:56,019 --> 00:44:59,339
15 for 45 so the way to construct a

2202
00:44:59,339 --> 00:44:59,349
 

2203
00:44:59,349 --> 00:45:00,839
nested query is I think is always

2204
00:45:00,839 --> 00:45:00,849
 

2205
00:45:00,849 --> 00:45:01,859
important to start maybe with the outer

2206
00:45:01,859 --> 00:45:01,869
 

2207
00:45:01,869 --> 00:45:04,200
query and think about what's the actual

2208
00:45:04,200 --> 00:45:04,210
 

2209
00:45:04,210 --> 00:45:05,910
answer you want to produce like what are

2210
00:45:05,910 --> 00:45:05,920
 

2211
00:45:05,920 --> 00:45:07,529
the actual attributes you want to see

2212
00:45:07,529 --> 00:45:07,539
 

2213
00:45:07,539 --> 00:45:09,420
and then you worry about how you're

2214
00:45:09,420 --> 00:45:09,430
 

2215
00:45:09,430 --> 00:45:10,950
actually gonna filter them and get what

2216
00:45:10,950 --> 00:45:10,960
 

2217
00:45:10,960 --> 00:45:13,559
you want so the outer query we know that

2218
00:45:13,559 --> 00:45:13,569
 

2219
00:45:13,569 --> 00:45:15,120
we want the name from the student table

2220
00:45:15,120 --> 00:45:15,130
 

2221
00:45:15,130 --> 00:45:18,210
and then where we get those values we'll

2222
00:45:18,210 --> 00:45:18,220
 

2223
00:45:18,220 --> 00:45:21,450
figure it out so in the inner query we

2224
00:45:21,450 --> 00:45:21,460
 

2225
00:45:21,460 --> 00:45:23,249
can write it as English is the student

2226
00:45:23,249 --> 00:45:23,259
 

2227
00:45:23,259 --> 00:45:24,270
ID

2228
00:45:24,270 --> 00:45:24,280

2229
00:45:24,280 --> 00:45:26,700
and the set of people about take 4:15

2230
00:45:26,700 --> 00:45:26,710
 

2231
00:45:26,710 --> 00:45:31,050
4:45 right so for that part we know how

2232
00:45:31,050 --> 00:45:31,060
 

2233
00:45:31,060 --> 00:45:33,630
to write that query pretty easily right

2234
00:45:33,630 --> 00:45:33,640
 

2235
00:45:33,640 --> 00:45:35,940
we just filter out all the tuples from

2236
00:45:35,940 --> 00:45:35,950
 

2237
00:45:35,950 --> 00:45:37,860
enroll table or the course ID he goes 15

2238
00:45:37,860 --> 00:45:37,870
 

2239
00:45:37,870 --> 00:45:40,500
for 45 so now the question is how do we

2240
00:45:40,500 --> 00:45:40,510
 

2241
00:45:40,510 --> 00:45:43,830
combine them with the the outer query

2242
00:45:43,830 --> 00:45:43,840
 

2243
00:45:43,840 --> 00:45:45,720
with the inner query again we can

2244
00:45:45,720 --> 00:45:45,730
 

2245
00:45:45,730 --> 00:45:47,630
rewrite this very easily with the join

2246
00:45:47,630 --> 00:45:47,640
 

2247
00:45:47,640 --> 00:45:50,160
but for our purposes here we want to see

2248
00:45:50,160 --> 00:45:50,170
 

2249
00:45:50,170 --> 00:45:52,860
how to do it as a nested function so for

2250
00:45:52,860 --> 00:45:52,870
 

2251
00:45:52,870 --> 00:45:56,670
this we can use the in operator and we

2252
00:45:56,670 --> 00:45:56,680
 

2253
00:45:56,680 --> 00:45:58,670
do a matching on the student student ID

2254
00:45:58,670 --> 00:45:58,680
 

2255
00:45:58,680 --> 00:46:01,500
so a way to now read this is that the

2256
00:46:01,500 --> 00:46:01,510
 

2257
00:46:01,510 --> 00:46:04,320
for every single student in the student

2258
00:46:04,320 --> 00:46:04,330
 

2259
00:46:04,330 --> 00:46:04,770
table

2260
00:46:04,770 --> 00:46:04,780
 

2261
00:46:04,780 --> 00:46:06,750
so this first student ID is matching up

2262
00:46:06,750 --> 00:46:06,760
 

2263
00:46:06,760 --> 00:46:09,420
with a student table I want to see

2264
00:46:09,420 --> 00:46:09,430
 

2265
00:46:09,430 --> 00:46:11,880
whether there's a match of that student

2266
00:46:11,880 --> 00:46:11,890
 

2267
00:46:11,890 --> 00:46:14,820
ID in the set of all student IDs that

2268
00:46:14,820 --> 00:46:14,830

2269
00:46:14,830 --> 00:46:17,670
are in the role table that take the

2270
00:46:17,670 --> 00:46:17,680
 

2271
00:46:17,680 --> 00:46:20,700
course 15 for 45 so we exit the inner

2272
00:46:20,700 --> 00:46:20,710
 

2273
00:46:20,710 --> 00:46:22,920
query we produce the set of all student

2274
00:46:22,920 --> 00:46:22,930
 

2275
00:46:22,930 --> 00:46:25,230
IDs and then for every single tuple in

2276
00:46:25,230 --> 00:46:25,240
 

2277
00:46:25,240 --> 00:46:27,210
the outer query we check to see whether

2278
00:46:27,210 --> 00:46:27,220
 

2279
00:46:27,220 --> 00:46:31,260
it exists in that set right now this

2280
00:46:31,260 --> 00:46:31,270
 

2281
00:46:31,270 --> 00:46:33,690
visit shows you why it's saying before

2282
00:46:33,690 --> 00:46:33,700
 

2283
00:46:33,700 --> 00:46:34,950
the stupid way to execute this is for

2284
00:46:34,950 --> 00:46:34,960
 

2285
00:46:34,960 --> 00:46:36,720
every single tuple in the outer query we

2286
00:46:36,720 --> 00:46:36,730
 

2287
00:46:36,730 --> 00:46:39,120
execute the inner query over and over

2288
00:46:39,120 --> 00:46:39,130
 

2289
00:46:39,130 --> 00:46:41,880
again like that's stupid because we only

2290
00:46:41,880 --> 00:46:41,890
 

2291
00:46:41,890 --> 00:46:43,650
need to produce the inner query once and

2292
00:46:43,650 --> 00:46:43,660
 

2293
00:46:43,660 --> 00:46:45,090
then we can reuse it for every single

2294
00:46:45,090 --> 00:46:45,100
 

2295
00:46:45,100 --> 00:46:49,740
tuple and in the outer query so I show

2296
00:46:49,740 --> 00:46:49,750
 

2297
00:46:49,750 --> 00:46:51,570
it how to in the Attic see if I used in

2298
00:46:51,570 --> 00:46:51,580
 

2299
00:46:51,580 --> 00:46:54,990
those other operators you can use so all

2300
00:46:54,990 --> 00:46:55,000
 

2301
00:46:55,000 --> 00:46:57,210
basically says that every single tuple

2302
00:46:57,210 --> 00:46:57,220
 

2303
00:46:57,220 --> 00:46:59,190
that's in my inner query must must

2304
00:46:59,190 --> 00:46:59,200
 

2305
00:46:59,200 --> 00:47:01,620
satisfy my predicate any means at least

2306
00:47:01,620 --> 00:47:01,630
 

2307
00:47:01,630 --> 00:47:04,560
one of them needs to alright so in is

2308
00:47:04,560 --> 00:47:04,570
 

2309
00:47:04,570 --> 00:47:06,270
essentially the same thing as equals any

2310
00:47:06,270 --> 00:47:06,280
 

2311
00:47:06,280 --> 00:47:08,780
right is there any tuple that it equals

2312
00:47:08,780 --> 00:47:08,790
 

2313
00:47:08,790 --> 00:47:11,550
what my predicate or about my tuple

2314
00:47:11,550 --> 00:47:11,560
 

2315
00:47:11,560 --> 00:47:14,010
attribute is checking and then exists

2316
00:47:14,010 --> 00:47:14,020
 

2317
00:47:14,020 --> 00:47:15,750
says at least one rows returned and

2318
00:47:15,750 --> 00:47:15,760
 

2319
00:47:15,760 --> 00:47:16,950
actually I don't care where that matches

2320
00:47:16,950 --> 00:47:16,960
 

2321
00:47:16,960 --> 00:47:18,870
I just care what I see whether a tuple

2322
00:47:18,870 --> 00:47:18,880
 

2323
00:47:18,880 --> 00:47:24,990
got produces as a result so we can

2324
00:47:24,990 --> 00:47:25,000
 

2325
00:47:25,000 --> 00:47:26,730
rewrite our table for getting all the

2326
00:47:26,730 --> 00:47:26,740
 

2327
00:47:26,740 --> 00:47:29,550
students in 15 for 45 like this by

2328
00:47:29,550 --> 00:47:29,560
 

2329
00:47:29,560 --> 00:47:32,070
instead of using in we say equals any so

2330
00:47:32,070 --> 00:47:32,080
 

2331
00:47:32,080 --> 00:47:34,530
now you read this as the student ID from

2332
00:47:34,530 --> 00:47:34,540
 

2333
00:47:34,540 --> 00:47:36,990
the student table check to see whether

2334
00:47:36,990 --> 00:47:37,000
 

2335
00:47:37,000 --> 00:47:37,770
it

2336
00:47:37,770 --> 00:47:37,780

2337
00:47:37,780 --> 00:47:40,410
any tool that exists in the set of

2338
00:47:40,410 --> 00:47:40,420
 

2339
00:47:40,420 --> 00:47:42,210
student IDs that are produced by from

2340
00:47:42,210 --> 00:47:42,220
 

2341
00:47:42,220 --> 00:47:47,070
from the enroll table right now the

2342
00:47:47,070 --> 00:47:47,080
 

2343
00:47:47,080 --> 00:47:49,080
energy the nested queries don't have to

2344
00:47:49,080 --> 00:47:49,090
 

2345
00:47:49,090 --> 00:47:50,580
only appear in the where clause they

2346
00:47:50,580 --> 00:47:50,590
 

2347
00:47:50,590 --> 00:47:53,040
actually can appear anywhere right so I

2348
00:47:53,040 --> 00:47:53,050
 

2349
00:47:53,050 --> 00:47:55,550
can rewrite the same query like this

2350
00:47:55,550 --> 00:47:55,560
 

2351
00:47:55,560 --> 00:47:57,960
where now I have my nested query in the

2352
00:47:57,960 --> 00:47:57,970
 

2353
00:47:57,970 --> 00:48:00,330
output of the Select statement so this

2354
00:48:00,330 --> 00:48:00,340
 

2355
00:48:00,340 --> 00:48:02,280
is a good example of this is reversing

2356
00:48:02,280 --> 00:48:02,290
 

2357
00:48:02,290 --> 00:48:04,650
what I did before in terms of what

2358
00:48:04,650 --> 00:48:04,660
 

2359
00:48:04,660 --> 00:48:06,780
tables were going to access so now the

2360
00:48:06,780 --> 00:48:06,790
 

2361
00:48:06,790 --> 00:48:09,060
way to read this is that for every

2362
00:48:09,060 --> 00:48:09,070
 

2363
00:48:09,070 --> 00:48:11,849
single tuple in the enrolled table where

2364
00:48:11,849 --> 00:48:11,859
 

2365
00:48:11,859 --> 00:48:14,820
the course ID equals 15 45 54 45 I'm

2366
00:48:14,820 --> 00:48:14,830
 

2367
00:48:14,830 --> 00:48:19,020
gonna then do a match up in the student

2368
00:48:19,020 --> 00:48:19,030

2369
00:48:19,030 --> 00:48:21,589
table where the student IDs are the same

2370
00:48:21,589 --> 00:48:21,599
 

2371
00:48:21,599 --> 00:48:24,680
right this is essentially doing a join

2372
00:48:24,680 --> 00:48:24,690
 

2373
00:48:24,690 --> 00:48:27,000
inside my output of my select statement

2374
00:48:27,000 --> 00:48:27,010
 

2375
00:48:27,010 --> 00:48:29,190
right because now this student ID is

2376
00:48:29,190 --> 00:48:29,200
 

2377
00:48:29,200 --> 00:48:30,870
being referenced here from the student

2378
00:48:30,870 --> 00:48:30,880
 

2379
00:48:30,880 --> 00:48:32,580
table and that student ID is being

2380
00:48:32,580 --> 00:48:32,590
 

2381
00:48:32,590 --> 00:48:35,580
referenced in there hey this is another

2382
00:48:35,580 --> 00:48:35,590
 

2383
00:48:35,590 --> 00:48:37,140
good example again I essentially

2384
00:48:37,140 --> 00:48:37,150
 

2385
00:48:37,150 --> 00:48:39,030
reversing the order of how I process my

2386
00:48:39,030 --> 00:48:39,040
 

2387
00:48:39,040 --> 00:48:42,300
tables right and they produce the exact

2388
00:48:42,300 --> 00:48:42,310
 

2389
00:48:42,310 --> 00:48:43,770
same result but they may have different

2390
00:48:43,770 --> 00:48:43,780
 

2391
00:48:43,780 --> 00:48:45,570
performance characteristics based on

2392
00:48:45,570 --> 00:48:45,580
 

2393
00:48:45,580 --> 00:48:47,670
what my data actually looks like it may

2394
00:48:47,670 --> 00:48:47,680

2395
00:48:47,680 --> 00:48:49,079
be the case that this is actually faster

2396
00:48:49,079 --> 00:48:49,089
 

2397
00:48:49,089 --> 00:48:50,250
to go through the role table first

2398
00:48:50,250 --> 00:48:50,260
 

2399
00:48:50,260 --> 00:48:53,310
instead of the student table and

2400
00:48:53,310 --> 00:48:53,320
 

2401
00:48:53,320 --> 00:48:55,170
therefore we could rewrite it if we

2402
00:48:55,170 --> 00:48:55,180
 

2403
00:48:55,180 --> 00:48:57,900
wanted to to choose one versus the other

2404
00:48:57,900 --> 00:48:57,910
 

2405
00:48:57,910 --> 00:49:00,300
and a good optimizer could do this for

2406
00:49:00,300 --> 00:49:00,310
 

2407
00:49:00,310 --> 00:49:04,770
you okay all right let's look at

2408
00:49:04,770 --> 00:49:04,780
 

2409
00:49:04,780 --> 00:49:06,960
something any more complicated now all

2410
00:49:06,960 --> 00:49:06,970
 

2411
00:49:06,970 --> 00:49:08,400
right say we want to find the student

2412
00:49:08,400 --> 00:49:08,410
 

2413
00:49:08,410 --> 00:49:10,890
record with the highest ID that enrolled

2414
00:49:10,890 --> 00:49:10,900

2415
00:49:10,900 --> 00:49:13,950
in at least one course right seems

2416
00:49:13,950 --> 00:49:13,960
 

2417
00:49:13,960 --> 00:49:15,329
pretty simple but let's think we

2418
00:49:15,329 --> 00:49:15,339
 

2419
00:49:15,339 --> 00:49:19,500
actually do this so the first

2420
00:49:19,500 --> 00:49:19,510
 

2421
00:49:19,510 --> 00:49:21,240
approximation would be something like

2422
00:49:21,240 --> 00:49:21,250
 

2423
00:49:21,250 --> 00:49:21,950
this

2424
00:49:21,950 --> 00:49:21,960

2425
00:49:21,960 --> 00:49:25,530
select the max a student ID along with

2426
00:49:25,530 --> 00:49:25,540
 

2427
00:49:25,540 --> 00:49:27,960
the student name from from the join and

2428
00:49:27,960 --> 00:49:27,970
 

2429
00:49:27,970 --> 00:49:30,359
rolled and student table where the

2430
00:49:30,359 --> 00:49:30,369

2431
00:49:30,369 --> 00:49:32,190
student ID in the role table equals the

2432
00:49:32,190 --> 00:49:32,200
 

2433
00:49:32,200 --> 00:49:34,349
student ID in the student table will

2434
00:49:34,349 --> 00:49:34,359
 

2435
00:49:34,359 --> 00:49:43,890
this work why why not

2436
00:49:43,890 --> 00:49:43,900


2437
00:49:43,900 --> 00:49:49,270
what's that yeah there's an aggregation

2438
00:49:49,270 --> 00:49:49,280

2439
00:49:49,280 --> 00:49:51,730
function without a group I and we're

2440
00:49:51,730 --> 00:49:51,740
 

2441
00:49:51,740 --> 00:49:53,560
referencing a column that's not in the

2442
00:49:53,560 --> 00:49:53,570

2443
00:49:53,570 --> 00:49:59,350
aggregation right so again the sequel

2444
00:49:59,350 --> 00:49:59,360

2445
00:49:59,360 --> 00:50:00,400
standard says that this shouldn't work

2446
00:50:00,400 --> 00:50:00,410
 

2447
00:50:00,410 --> 00:50:14,500
let's find out alright so again we have

2448
00:50:14,500 --> 00:50:14,510
 

2449
00:50:14,510 --> 00:50:21,580
not gonna disconnect first course at the

2450
00:50:21,580 --> 00:50:21,590
 

2451
00:50:21,590 --> 00:50:28,600
top so we've run our query here and

2452
00:50:28,600 --> 00:50:28,610

2453
00:50:28,610 --> 00:50:30,640
Postgres and here's the standard it says

2454
00:50:30,640 --> 00:50:30,650
 

2455
00:50:30,650 --> 00:50:33,040
get as exactly as he said so you have

2456
00:50:33,040 --> 00:50:33,050
 

2457
00:50:33,050 --> 00:50:35,410
student ID student name appears but it's

2458
00:50:35,410 --> 00:50:35,420
 

2459
00:50:35,420 --> 00:50:36,880
not a part of a group I so you can't use

2460
00:50:36,880 --> 00:50:36,890
 

2461
00:50:36,890 --> 00:50:45,400
it right in my sequel same thing it

2462
00:50:45,400 --> 00:50:45,410
 

2463
00:50:45,410 --> 00:50:48,460
produces that error but if we now run it

2464
00:50:48,460 --> 00:50:48,470
 

2465
00:50:48,470 --> 00:50:50,860
in what they call traditional mode right

2466
00:50:50,860 --> 00:50:50,870
 

2467
00:50:50,870 --> 00:50:52,540
so older versions of my sequel will do

2468
00:50:52,540 --> 00:50:52,550
 

2469
00:50:52,550 --> 00:50:55,870
this now we run this query and we get an

2470
00:50:55,870 --> 00:50:55,880
 

2471
00:50:55,880 --> 00:50:58,690
answer right we have the max student ID

2472
00:50:58,690 --> 00:50:58,700
 

2473
00:50:58,700 --> 00:51:00,430
and then we say that the name best

2474
00:51:00,430 --> 00:51:00,440
 

2475
00:51:00,440 --> 00:51:04,990
student is Tupac all right let's try it

2476
00:51:04,990 --> 00:51:05,000
 

2477
00:51:05,000 --> 00:51:13,630
in sequel light front one it produces an

2478
00:51:13,630 --> 00:51:13,640
 

2479
00:51:13,640 --> 00:51:16,180
answer it also produces 50 3 6 8 8 as

2480
00:51:16,180 --> 00:51:16,190
 

2481
00:51:16,190 --> 00:51:18,790
the next to 90 but it says the that

2482
00:51:18,790 --> 00:51:18,800
 

2483
00:51:18,800 --> 00:51:21,070
student belongs to Justin Bieber right

2484
00:51:21,070 --> 00:51:21,080

2485
00:51:21,080 --> 00:51:23,230
and actually I don't know what the right

2486
00:51:23,230 --> 00:51:23,240
 

2487
00:51:23,240 --> 00:51:30,339
answer is let's see here

2488
00:51:30,339 --> 00:51:30,349


2489
00:51:30,349 --> 00:51:32,370
so Justin Bieber is the right one right

2490
00:51:32,370 --> 00:51:32,380
 

2491
00:51:32,380 --> 00:51:35,019
whereas my sequel make sure I'm giving

2492
00:51:35,019 --> 00:51:35,029
 

2493
00:51:35,029 --> 00:51:42,219
you the same data right Tupac is

2494
00:51:42,219 --> 00:51:42,229
 

2495
00:51:42,229 --> 00:51:44,019
actually the lowest all right so you got

2496
00:51:44,019 --> 00:51:44,029
 

2497
00:51:44,029 --> 00:51:48,779
it completely wrong all right so the

2498
00:51:48,779 --> 00:51:48,789
 

2499
00:51:48,789 --> 00:51:51,489
right so this doesn't work in the sequel

2500
00:51:51,489 --> 00:51:51,499
 

2501
00:51:51,499 --> 00:51:54,130
standard it runs a single byte and and

2502
00:51:54,130 --> 00:51:54,140
 

2503
00:51:54,140 --> 00:51:56,259
and my SIBO if we turn off that strict

2504
00:51:56,259 --> 00:51:56,269
 

2505
00:51:56,269 --> 00:51:59,410
mode thing so way we can do this is a

2506
00:51:59,410 --> 00:51:59,420
 

2507
00:51:59,420 --> 00:52:01,209
nested function again let's build it

2508
00:52:01,209 --> 00:52:01,219
 

2509
00:52:01,219 --> 00:52:03,130
constructively so we know there you want

2510
00:52:03,130 --> 00:52:03,140

2511
00:52:03,140 --> 00:52:04,390
the student ID and the name as the

2512
00:52:04,390 --> 00:52:04,400
 

2513
00:52:04,400 --> 00:52:06,009
output but it's the where clause that

2514
00:52:06,009 --> 00:52:06,019
 

2515
00:52:06,019 --> 00:52:08,349
thing we have to figure out and this one

2516
00:52:08,349 --> 00:52:08,359
 

2517
00:52:08,359 --> 00:52:10,029
basically says that we want to get a

2518
00:52:10,029 --> 00:52:10,039
 

2519
00:52:10,039 --> 00:52:12,880
matching tuple that is greater than

2520
00:52:12,880 --> 00:52:12,890
 

2521
00:52:12,890 --> 00:52:14,890
every other student ID that that's

2522
00:52:14,890 --> 00:52:14,900
 

2523
00:52:14,900 --> 00:52:18,489
that's in our table right so we know the

2524
00:52:18,489 --> 00:52:18,499
 

2525
00:52:18,499 --> 00:52:20,259
inner query shall should be basically

2526
00:52:20,259 --> 00:52:20,269
 

2527
00:52:20,269 --> 00:52:22,539
the student ID from the role table we

2528
00:52:22,539 --> 00:52:22,549
 

2529
00:52:22,549 --> 00:52:24,339
can be the more more sophisticated maybe

2530
00:52:24,339 --> 00:52:24,349
 

2531
00:52:24,349 --> 00:52:25,900
put two distinct there but it's all the

2532
00:52:25,900 --> 00:52:25,910

2533
00:52:25,910 --> 00:52:27,609
same but now we need to figure out how

2534
00:52:27,609 --> 00:52:27,619
 

2535
00:52:27,619 --> 00:52:29,709
to match the student ID from the student

2536
00:52:29,709 --> 00:52:29,719
 

2537
00:52:29,719 --> 00:52:31,719
and an outer query the student ID from

2538
00:52:31,719 --> 00:52:31,729
 

2539
00:52:31,729 --> 00:52:35,109
from the inner query and for this we can

2540
00:52:35,109 --> 00:52:35,119

2541
00:52:35,119 --> 00:52:37,749
use greater than equal to all right it

2542
00:52:37,749 --> 00:52:37,759
 

2543
00:52:37,759 --> 00:52:39,069
has to be greater than equal to because

2544
00:52:39,069 --> 00:52:39,079
 

2545
00:52:39,079 --> 00:52:41,259
we make sure that we match ourselves the

2546
00:52:41,259 --> 00:52:41,269
 

2547
00:52:41,269 --> 00:52:42,549
student that actually is that does

2548
00:52:42,549 --> 00:52:42,559
 

2549
00:52:42,559 --> 00:52:45,449
actually have that the highest one right

2550
00:52:45,449 --> 00:52:45,459
 

2551
00:52:45,459 --> 00:52:47,799
you can rewrite this in other ways as

2552
00:52:47,799 --> 00:52:47,809
 

2553
00:52:47,809 --> 00:52:49,479
expected right we can rewrite it with

2554
00:52:49,479 --> 00:52:49,489
 

2555
00:52:49,489 --> 00:52:51,130
the in clause like that and actually

2556
00:52:51,130 --> 00:52:51,140
 

2557
00:52:51,140 --> 00:52:53,079
compute the max student ID and the inner

2558
00:52:53,079 --> 00:52:53,089
 

2559
00:52:53,089 --> 00:52:55,059
query right now basically this is saying

2560
00:52:55,059 --> 00:52:55,069
 

2561
00:52:55,069 --> 00:52:57,640
match the student ID that is the max

2562
00:52:57,640 --> 00:52:57,650
 

2563
00:52:57,650 --> 00:52:59,410
student ID produced from from the enroll

2564
00:52:59,410 --> 00:52:59,420

2565
00:52:59,420 --> 00:53:02,529
table right we can go even further we

2566
00:53:02,529 --> 00:53:02,539
 

2567
00:53:02,539 --> 00:53:03,759
can rewrite the inner God be like this

2568
00:53:03,759 --> 00:53:03,769
 

2569
00:53:03,769 --> 00:53:05,739
right we do an order by the student ID

2570
00:53:05,739 --> 00:53:05,749
 

2571
00:53:05,749 --> 00:53:08,890
and just rank them in descending order

2572
00:53:08,890 --> 00:53:08,900
 

2573
00:53:08,900 --> 00:53:12,309
and then do a limit one so some systems

2574
00:53:12,309 --> 00:53:12,319
 

2575
00:53:12,319 --> 00:53:14,469
will actually just rewrite this one to

2576
00:53:14,469 --> 00:53:14,479
 

2577
00:53:14,479 --> 00:53:16,150
be a max anyway just scan everything

2578
00:53:16,150 --> 00:53:16,160
 

2579
00:53:16,160 --> 00:53:17,829
keep track which one's the max and then

2580
00:53:17,829 --> 00:53:17,839
 

2581
00:53:17,839 --> 00:53:18,849
produce that's the final output

2582
00:53:18,849 --> 00:53:18,859
 

2583
00:53:18,859 --> 00:53:21,569
don't even bother doing sorting right

2584
00:53:21,569 --> 00:53:21,579
 

2585
00:53:21,579 --> 00:53:24,009
again same query rewritten in different

2586
00:53:24,009 --> 00:53:24,019
 

2587
00:53:24,019 --> 00:53:29,049
ways one more example we're gonna find

2588
00:53:29,049 --> 00:53:29,059

2589
00:53:29,059 --> 00:53:30,999
all the courses that have no students

2590
00:53:30,999 --> 00:53:31,009
 

2591
00:53:31,009 --> 00:53:33,579
enrolled in them so we take our outer

2592
00:53:33,579 --> 00:53:33,589
 

2593
00:53:33,589 --> 00:53:35,319
query as a Select on the courses and

2594
00:53:35,319 --> 00:53:35,329
 

2595
00:53:35,329 --> 00:53:37,089
then we know our inner query basically

2596
00:53:37,089 --> 00:53:37,099
 

2597
00:53:37,099 --> 00:53:38,559
says when a find note where they have no

2598
00:53:38,559 --> 00:53:38,569

2599
00:53:38,569 --> 00:53:41,709
tuples in the enroll table so for this

2600
00:53:41,709 --> 00:53:41,719
 

2601
00:53:41,719 --> 00:53:43,569
one we want to use not exists basically

2602
00:53:43,569 --> 00:53:43,579
 

2603
00:53:43,579 --> 00:53:44,370
says we don't want to

2604
00:53:44,370 --> 00:53:44,380
 

2605
00:53:44,380 --> 00:53:47,670
match anything in our inner query and

2606
00:53:47,670 --> 00:53:47,680
 

2607
00:53:47,680 --> 00:53:49,470
all we need to do that for the inner

2608
00:53:49,470 --> 00:53:49,480
 

2609
00:53:49,480 --> 00:53:52,559
queries is just just grab every single

2610
00:53:52,559 --> 00:53:52,569

2611
00:53:52,569 --> 00:53:53,880
tuple and here now we're actually

2612
00:53:53,880 --> 00:53:53,890
 

2613
00:53:53,890 --> 00:53:56,970
matching up the the course ID in the

2614
00:53:56,970 --> 00:53:56,980
 

2615
00:53:56,980 --> 00:53:59,160
inner query with the course ID from the

2616
00:53:59,160 --> 00:53:59,170
 

2617
00:53:59,170 --> 00:54:01,380
outer query so you can only do this in

2618
00:54:01,380 --> 00:54:01,390
 

2619
00:54:01,390 --> 00:54:02,670
one direction so if you're the inner

2620
00:54:02,670 --> 00:54:02,680
 

2621
00:54:02,680 --> 00:54:03,990
query you can represent the outer query

2622
00:54:03,990 --> 00:54:04,000
 

2623
00:54:04,000 --> 00:54:05,940
if you're in the outer query you can't

2624
00:54:05,940 --> 00:54:05,950
 

2625
00:54:05,950 --> 00:54:08,849
reference the inner query right unless

2626
00:54:08,849 --> 00:54:08,859
 

2627
00:54:08,859 --> 00:54:10,829
you pipe it out or redirect it to a

2628
00:54:10,829 --> 00:54:10,839
 

2629
00:54:10,839 --> 00:54:14,039
table so any questions about nested

2630
00:54:14,039 --> 00:54:14,049

2631
00:54:14,049 --> 00:54:18,180
queries again they're very powerful many

2632
00:54:18,180 --> 00:54:18,190
 

2633
00:54:18,190 --> 00:54:20,249
tens you cannot write what you want to

2634
00:54:20,249 --> 00:54:20,259
 

2635
00:54:20,259 --> 00:54:24,480
write in in in a single query without

2636
00:54:24,480 --> 00:54:24,490
 

2637
00:54:24,490 --> 00:54:34,230
using nested queries yes her question is

2638
00:54:34,230 --> 00:54:34,240
 

2639
00:54:34,240 --> 00:54:35,759
can you think of an inner query as a

2640
00:54:35,759 --> 00:54:35,769
 

2641
00:54:35,769 --> 00:54:43,759
nested for them yes but no so we'll see

2642
00:54:43,759 --> 00:54:43,769


2643
00:54:43,769 --> 00:54:46,589
for loop has a notion of like ordering

2644
00:54:46,589 --> 00:54:46,599
 

2645
00:54:46,599 --> 00:54:50,160
it's it's really a set right so all

2646
00:54:50,160 --> 00:54:50,170
 

2647
00:54:50,170 --> 00:54:53,370
those operators like in X exists any

2648
00:54:53,370 --> 00:54:53,380
 

2649
00:54:53,380 --> 00:54:55,319
those are just trying to say for the

2650
00:54:55,319 --> 00:54:55,329
 

2651
00:54:55,329 --> 00:54:57,180
entire set of tuples that are in the

2652
00:54:57,180 --> 00:54:57,190
 

2653
00:54:57,190 --> 00:54:59,130
inner query check to see whether any of

2654
00:54:59,130 --> 00:54:59,140
 

2655
00:54:59,140 --> 00:55:00,870
em matches you're not you're not really

2656
00:55:00,870 --> 00:55:00,880
 

2657
00:55:00,880 --> 00:55:03,539
iterating over every single one if you

2658
00:55:03,539 --> 00:55:03,549
 

2659
00:55:03,549 --> 00:55:04,859
think of the outer query sort of as a

2660
00:55:04,859 --> 00:55:04,869
 

2661
00:55:04,869 --> 00:55:07,109
for debating every single tuple but then

2662
00:55:07,109 --> 00:55:07,119
 

2663
00:55:07,119 --> 00:55:10,049
the set portion the evaluation of the

2664
00:55:10,049 --> 00:55:10,059
 

2665
00:55:10,059 --> 00:55:11,940
inner query is always at server at a bag

2666
00:55:11,940 --> 00:55:11,950
 

2667
00:55:11,950 --> 00:55:19,410
or set set level make sense ok window

2668
00:55:19,410 --> 00:55:19,420
 

2669
00:55:19,420 --> 00:55:21,930
functions so window functions are I

2670
00:55:21,930 --> 00:55:21,940

2671
00:55:21,940 --> 00:55:23,809
would say they're new but they're like

2672
00:55:23,809 --> 00:55:23,819
 

2673
00:55:23,819 --> 00:55:26,460
15 10 years old now so they're not like

2674
00:55:26,460 --> 00:55:26,470
 

2675
00:55:26,470 --> 00:55:28,950
not brand new a lot of systems don't

2676
00:55:28,950 --> 00:55:28,960
 

2677
00:55:28,960 --> 00:55:32,519
support them but the major ones do so a

2678
00:55:32,519 --> 00:55:32,529
 

2679
00:55:32,529 --> 00:55:33,839
window function is sort of like an

2680
00:55:33,839 --> 00:55:33,849
 

2681
00:55:33,849 --> 00:55:36,690
aggregation where you're going to

2682
00:55:36,690 --> 00:55:36,700
 

2683
00:55:36,700 --> 00:55:40,079
compute some some function on on tuples

2684
00:55:40,079 --> 00:55:40,089

2685
00:55:40,089 --> 00:55:43,490
but rather than doing it on you know a

2686
00:55:43,490 --> 00:55:43,500
 

2687
00:55:43,500 --> 00:55:46,170
subset of the tuples and collapsing them

2688
00:55:46,170 --> 00:55:46,180
 

2689
00:55:46,180 --> 00:55:48,569
down into a single result you sort of do

2690
00:55:48,569 --> 00:55:48,579
 

2691
00:55:48,579 --> 00:55:50,849
this in a incremental fashion or on a

2692
00:55:50,849 --> 00:55:50,859
 

2693
00:55:50,859 --> 00:55:53,880
moving fashion and then you still

2694
00:55:53,880 --> 00:55:53,890
 

2695
00:55:53,890 --> 00:55:55,710
produce the tuple as the output but

2696
00:55:55,710 --> 00:55:55,720
 

2697
00:55:55,720 --> 00:55:58,110
along with the value that it produced

2698
00:55:58,110 --> 00:55:58,120
 

2699
00:55:58,120 --> 00:56:02,130
the window function right so the basic

2700
00:56:02,130 --> 00:56:02,140
 

2701
00:56:02,140 --> 00:56:03,930
syntax is like this you have the

2702
00:56:03,930 --> 00:56:03,940
 

2703
00:56:03,940 --> 00:56:05,310
function name and then you have an over

2704
00:56:05,310 --> 00:56:05,320
 

2705
00:56:05,320 --> 00:56:05,820
clause

2706
00:56:05,820 --> 00:56:05,830
 

2707
00:56:05,830 --> 00:56:07,080
so the function name will be our

2708
00:56:07,080 --> 00:56:07,090

2709
00:56:07,090 --> 00:56:08,520
aggregation functions and other special

2710
00:56:08,520 --> 00:56:08,530
 

2711
00:56:08,530 --> 00:56:09,810
window functions we have which I'll show

2712
00:56:09,810 --> 00:56:09,820
 

2713
00:56:09,820 --> 00:56:12,360
the next slide and then the over the

2714
00:56:12,360 --> 00:56:12,370
 

2715
00:56:12,370 --> 00:56:14,580
over Clause defines how we actually want

2716
00:56:14,580 --> 00:56:14,590
 

2717
00:56:14,590 --> 00:56:16,710
to slice up the data right this is sort

2718
00:56:16,710 --> 00:56:16,720
 

2719
00:56:16,720 --> 00:56:18,180
of like combining together the

2720
00:56:18,180 --> 00:56:18,190
 

2721
00:56:18,190 --> 00:56:20,910
aggregation and the group by but in a

2722
00:56:20,910 --> 00:56:20,920
 

2723
00:56:20,920 --> 00:56:22,950
single clause so the function is like

2724
00:56:22,950 --> 00:56:22,960
 

2725
00:56:22,960 --> 00:56:24,840
the aggregation function the over is

2726
00:56:24,840 --> 00:56:24,850
 

2727
00:56:24,850 --> 00:56:28,650
like the group line so the aggregation

2728
00:56:28,650 --> 00:56:28,660
 

2729
00:56:28,660 --> 00:56:30,480
functions would be all the things in the

2730
00:56:30,480 --> 00:56:30,490
 

2731
00:56:30,490 --> 00:56:31,500
sequel standard that we talked before

2732
00:56:31,500 --> 00:56:31,510
 

2733
00:56:31,510 --> 00:56:35,100
min max average count some the special

2734
00:56:35,100 --> 00:56:35,110
 

2735
00:56:35,110 --> 00:56:36,470
wind functions could do things like

2736
00:56:36,470 --> 00:56:36,480

2737
00:56:36,480 --> 00:56:38,850
introduce a row number to the current

2738
00:56:38,850 --> 00:56:38,860
 

2739
00:56:38,860 --> 00:56:41,130
row so to keep track as the tuples as

2740
00:56:41,130 --> 00:56:41,140
 

2741
00:56:41,140 --> 00:56:43,020
being output and it marks them with what

2742
00:56:43,020 --> 00:56:43,030

2743
00:56:43,030 --> 00:56:45,480
order they they're coming out and then

2744
00:56:45,480 --> 00:56:45,490
 

2745
00:56:45,490 --> 00:56:47,700
rank would be the order of the position

2746
00:56:47,700 --> 00:56:47,710
 

2747
00:56:47,710 --> 00:56:49,910
of a tuple if we're doing sorting

2748
00:56:49,910 --> 00:56:49,920
 

2749
00:56:49,920 --> 00:56:52,320
alright so say what I want to do is I

2750
00:56:52,320 --> 00:56:52,330
 

2751
00:56:52,330 --> 00:56:54,060
want to go do a select over the enroll

2752
00:56:54,060 --> 00:56:54,070
 

2753
00:56:54,070 --> 00:56:56,310
table and I want to produce all the

2754
00:56:56,310 --> 00:56:56,320
 

2755
00:56:56,320 --> 00:56:58,860
tuples as my output but I want to just

2756
00:56:58,860 --> 00:56:58,870
 

2757
00:56:58,870 --> 00:57:00,840
mark them with the row number of the

2758
00:57:00,840 --> 00:57:00,850
 

2759
00:57:00,850 --> 00:57:03,300
output right so I have my row number a

2760
00:57:03,300 --> 00:57:03,310
 

2761
00:57:03,310 --> 00:57:05,730
row number function and then for my over

2762
00:57:05,730 --> 00:57:05,740
 

2763
00:57:05,740 --> 00:57:07,980
Clause I just leave that blank and then

2764
00:57:07,980 --> 00:57:07,990
 

2765
00:57:07,990 --> 00:57:09,780
what I end up with is a result that

2766
00:57:09,780 --> 00:57:09,790
 

2767
00:57:09,790 --> 00:57:11,370
looks like this alright I have all the

2768
00:57:11,370 --> 00:57:11,380
 

2769
00:57:11,380 --> 00:57:13,380
data that had before but now I had this

2770
00:57:13,380 --> 00:57:13,390
 

2771
00:57:13,390 --> 00:57:16,470
special column here row num that's just

2772
00:57:16,470 --> 00:57:16,480

2773
00:57:16,480 --> 00:57:18,470
again the order of the tuple that that

2774
00:57:18,470 --> 00:57:18,480
 

2775
00:57:18,480 --> 00:57:22,590
that it was produced in the output so

2776
00:57:22,590 --> 00:57:22,600
 

2777
00:57:22,600 --> 00:57:24,390
sort of like I compute my entire query

2778
00:57:24,390 --> 00:57:24,400
 

2779
00:57:24,400 --> 00:57:25,890
and then I do my window function to go

2780
00:57:25,890 --> 00:57:25,900
 

2781
00:57:25,900 --> 00:57:27,800
over the results and I and then I add in

2782
00:57:27,800 --> 00:57:27,810
 

2783
00:57:27,810 --> 00:57:29,940
whatever the computation that I want to

2784
00:57:29,940 --> 00:57:29,950
 

2785
00:57:29,950 --> 00:57:34,860
generate so just like a group are so

2786
00:57:34,860 --> 00:57:34,870
 

2787
00:57:34,870 --> 00:57:36,480
aggregations we can we can combine

2788
00:57:36,480 --> 00:57:36,490

2789
00:57:36,490 --> 00:57:37,740
things together or group them together

2790
00:57:37,740 --> 00:57:37,750
 

2791
00:57:37,750 --> 00:57:39,540
and this is what the over keyword does

2792
00:57:39,540 --> 00:57:39,550
 

2793
00:57:39,550 --> 00:57:41,910
for us so for this we would use

2794
00:57:41,910 --> 00:57:41,920
 

2795
00:57:41,920 --> 00:57:44,460
partition by to specify how we want to

2796
00:57:44,460 --> 00:57:44,470

2797
00:57:44,470 --> 00:57:46,380
group things all right so in this query

2798
00:57:46,380 --> 00:57:46,390
 

2799
00:57:46,390 --> 00:57:47,850
here I'm doing the same thing as before

2800
00:57:47,850 --> 00:57:47,860
 

2801
00:57:47,860 --> 00:57:49,950
where I want to combine them together

2802
00:57:49,950 --> 00:57:49,960
 

2803
00:57:49,960 --> 00:57:53,790
based on the generate the row number and

2804
00:57:53,790 --> 00:57:53,800
 

2805
00:57:53,800 --> 00:57:55,440
for how they produced in their output

2806
00:57:55,440 --> 00:57:55,450

2807
00:57:55,450 --> 00:57:56,910
but then I'm gonna group them together

2808
00:57:56,910 --> 00:57:56,920

2809
00:57:56,920 --> 00:58:00,300
based on the course ID all right so my

2810
00:58:00,300 --> 00:58:00,310
 

2811
00:58:00,310 --> 00:58:04,170
output would look like this right and so

2812
00:58:04,170 --> 00:58:04,180
 

2813
00:58:04,180 --> 00:58:05,190
now again it looks just like the

2814
00:58:05,190 --> 00:58:05,200
 

2815
00:58:05,200 --> 00:58:07,700
aviation where now I'm grouped together

2816
00:58:07,700 --> 00:58:07,710

2817
00:58:07,710 --> 00:58:11,579
based on the order

2818
00:58:11,579 --> 00:58:11,589

2819
00:58:11,589 --> 00:58:15,449
right pretty simple so let's look at

2820
00:58:15,449 --> 00:58:15,459
 

2821
00:58:15,459 --> 00:58:18,120
something more complicated so I can also

2822
00:58:18,120 --> 00:58:18,130
 

2823
00:58:18,130 --> 00:58:20,489
order by these I can order them instead

2824
00:58:20,489 --> 00:58:20,499
 

2825
00:58:20,499 --> 00:58:23,279
of partitioning them and this is

2826
00:58:23,279 --> 00:58:23,289
 

2827
00:58:23,289 --> 00:58:24,989
essentially defining how we want to do

2828
00:58:24,989 --> 00:58:24,999
 

2829
00:58:24,999 --> 00:58:27,029
our ordering produced to produce our

2830
00:58:27,029 --> 00:58:27,039
 

2831
00:58:27,039 --> 00:58:29,489
outputs if we do this ordering then we

2832
00:58:29,489 --> 00:58:29,499
 

2833
00:58:29,499 --> 00:58:30,569
compute whatever this the window

2834
00:58:30,569 --> 00:58:30,579
 

2835
00:58:30,579 --> 00:58:31,890
function is that we want to compute on

2836
00:58:31,890 --> 00:58:31,900

2837
00:58:31,900 --> 00:58:34,380
that so in this case here this is a

2838
00:58:34,380 --> 00:58:34,390
 

2839
00:58:34,390 --> 00:58:35,459
sense you can do the same thing I did in

2840
00:58:35,459 --> 00:58:35,469
 

2841
00:58:35,469 --> 00:58:38,339
the previous slide where it's going to

2842
00:58:38,339 --> 00:58:38,349
 

2843
00:58:38,349 --> 00:58:40,049
more or less group them based on the

2844
00:58:40,049 --> 00:58:40,059
 

2845
00:58:40,059 --> 00:58:42,269
course ID but this is doing this by

2846
00:58:42,269 --> 00:58:42,279

2847
00:58:42,279 --> 00:58:48,019
using ordering rather than partitioning

2848
00:58:48,019 --> 00:58:48,029


2849
00:58:48,029 --> 00:58:50,130
all right so let's say we want to

2850
00:58:50,130 --> 00:58:50,140
 

2851
00:58:50,140 --> 00:58:51,660
compute we're going to find the student

2852
00:58:51,660 --> 00:58:51,670
 

2853
00:58:51,670 --> 00:58:53,209
with the highest grade for each course

2854
00:58:53,209 --> 00:58:53,219
 

2855
00:58:53,219 --> 00:58:55,559
so what we have here is now we have

2856
00:58:55,559 --> 00:58:55,569
 

2857
00:58:55,569 --> 00:58:59,370
nested query so in the outer query we're

2858
00:58:59,370 --> 00:58:59,380
 

2859
00:58:59,380 --> 00:59:02,969
just going to well in the outer query is

2860
00:59:02,969 --> 00:59:02,979

2861
00:59:02,979 --> 00:59:05,429
a server in the inner query we're going

2862
00:59:05,429 --> 00:59:05,439

2863
00:59:05,439 --> 00:59:08,009
to produce some table result but now

2864
00:59:08,009 --> 00:59:08,019

2865
00:59:08,019 --> 00:59:09,299
this is a good example we're having a

2866
00:59:09,299 --> 00:59:09,309
 

2867
00:59:09,309 --> 00:59:10,769
nested query inside of the from clause

2868
00:59:10,769 --> 00:59:10,779
 

2869
00:59:10,779 --> 00:59:13,829
so I have from here and then I'm taking

2870
00:59:13,829 --> 00:59:13,839
 

2871
00:59:13,839 --> 00:59:16,289
the output of this inner query and I'm

2872
00:59:16,289 --> 00:59:16,299
 

2873
00:59:16,299 --> 00:59:19,229
gonna map that into a sort of a

2874
00:59:19,229 --> 00:59:19,239
 

2875
00:59:19,239 --> 00:59:21,179
temporary virtual table called ranking

2876
00:59:21,179 --> 00:59:21,189

2877
00:59:21,189 --> 00:59:24,749
that only exists for this tuple right so

2878
00:59:24,749 --> 00:59:24,759
 

2879
00:59:24,759 --> 00:59:26,009
stead of writing it to a table that are

2880
00:59:26,009 --> 00:59:26,019
 

2881
00:59:26,019 --> 00:59:27,499
exist we're writing into a temporary

2882
00:59:27,499 --> 00:59:27,509
 

2883
00:59:27,509 --> 00:59:29,759
table I don't say in memory because it

2884
00:59:29,759 --> 00:59:29,769
 

2885
00:59:29,769 --> 00:59:31,140
may actually go out the disk but a

2886
00:59:31,140 --> 00:59:31,150
 

2887
00:59:31,150 --> 00:59:33,390
temporary tuple table for this to this

2888
00:59:33,390 --> 00:59:33,400
 

2889
00:59:33,400 --> 00:59:36,569
query that then gets discarded when the

2890
00:59:36,569 --> 00:59:36,579
 

2891
00:59:36,579 --> 00:59:39,479
query is over so in the inner query what

2892
00:59:39,479 --> 00:59:39,489
 

2893
00:59:39,489 --> 00:59:41,959
we're gonna do is we're going to go over

2894
00:59:41,959 --> 00:59:41,969

2895
00:59:41,969 --> 00:59:45,269
the enrolled table and for every single

2896
00:59:45,269 --> 00:59:45,279
 

2897
00:59:45,279 --> 00:59:45,870
tuple

2898
00:59:45,870 --> 00:59:45,880
 

2899
00:59:45,880 --> 00:59:48,749
we're gonna split them up based on the

2900
00:59:48,749 --> 00:59:48,759
 

2901
00:59:48,759 --> 00:59:50,279
course ID that's the partition clause

2902
00:59:50,279 --> 00:59:50,289
 

2903
00:59:50,289 --> 00:59:53,130
and then we're gonna sort them by their

2904
00:59:53,130 --> 00:59:53,140
 

2905
00:59:53,140 --> 00:59:56,130
grade in ascending order and then what

2906
00:59:56,130 --> 00:59:56,140
 

2907
00:59:56,140 --> 00:59:59,939
we produce the window function we invoke

2908
00:59:59,939 --> 00:59:59,949

2909
00:59:59,949 --> 01:00:01,799
is rank which is the order that they

2910
01:00:01,799 --> 01:00:01,809
 

2911
01:00:01,809 --> 01:00:06,650
exist in the in the sort of ranking and

2912
01:00:06,650 --> 01:00:06,660
 

2913
01:00:06,660 --> 01:00:09,569
then we take that output write it out to

2914
01:00:09,569 --> 01:00:09,579
 

2915
01:00:09,579 --> 01:00:12,089
the ranking table and then in the outer

2916
01:00:12,089 --> 01:00:12,099
 

2917
01:00:12,099 --> 01:00:14,429
query we can then do additional

2918
01:00:14,429 --> 01:00:14,439
 

2919
01:00:14,439 --> 01:00:17,459
filtering based on the their rank so

2920
01:00:17,459 --> 01:00:17,469
 

2921
01:00:17,469 --> 01:00:19,169
this is only produced the tuples that

2922
01:00:19,169 --> 01:00:19,179

2923
01:00:19,179 --> 01:00:22,410
are that are ranked first right so this

2924
01:00:22,410 --> 01:00:22,420
 

2925
01:00:22,420 --> 01:00:23,579
is defining the students the highest

2926
01:00:23,579 --> 01:00:23,589
 

2927
01:00:23,589 --> 01:00:25,359
grade for each course

2928
01:00:25,359 --> 01:00:25,369
 

2929
01:00:25,369 --> 01:00:26,769
right so the thing to point out here is

2930
01:00:26,769 --> 01:00:26,779
 

2931
01:00:26,779 --> 01:00:29,620
I have I'm referencing in my outer query

2932
01:00:29,620 --> 01:00:29,630
 

2933
01:00:29,630 --> 01:00:32,200
this ranked attribute here which

2934
01:00:32,200 --> 01:00:32,210
 

2935
01:00:32,210 --> 01:00:33,489
actually doesn't really exist in the

2936
01:00:33,489 --> 01:00:33,499
 

2937
01:00:33,499 --> 01:00:35,319
database again it only exists within

2938
01:00:35,319 --> 01:00:35,329
 

2939
01:00:35,329 --> 01:00:40,630
this query I'm seeing a lot of blank

2940
01:00:40,630 --> 01:00:40,640
 

2941
01:00:40,640 --> 01:00:43,660
faces so let's maybe pop up in the

2942
01:00:43,660 --> 01:00:43,670
 

2943
01:00:43,670 --> 01:00:44,829
database and see we can do all right so

2944
01:00:44,829 --> 01:00:44,839
 

2945
01:00:44,839 --> 01:00:53,170
for this so Postgres is the only one

2946
01:00:53,170 --> 01:00:53,180
 

2947
01:00:53,180 --> 01:00:56,410
that actually supports this my sequel

2948
01:00:56,410 --> 01:00:56,420
 

2949
01:00:56,420 --> 01:01:00,999
eight supports window functions and the

2950
01:01:00,999 --> 01:01:01,009
 

2951
01:01:01,009 --> 01:01:02,289
newer version sequel Lite support window

2952
01:01:02,289 --> 01:01:02,299
 

2953
01:01:02,299 --> 01:01:04,769
functions but for simplicity

2954
01:01:04,769 --> 01:01:04,779
 

2955
01:01:04,779 --> 01:01:08,200
what does do my and Postgres alright so

2956
01:01:08,200 --> 01:01:08,210
 

2957
01:01:08,210 --> 01:01:09,849
this is the query that we had before

2958
01:01:09,849 --> 01:01:09,859
 

2959
01:01:09,859 --> 01:01:17,079
right let's break it up and make it and

2960
01:01:17,079 --> 01:01:17,089
 

2961
01:01:17,089 --> 01:01:19,150
just do the inner query first and that

2962
01:01:19,150 --> 01:01:19,160
 

2963
01:01:19,160 --> 01:01:21,719
way it'll be sort of easy to understand

2964
01:01:21,719 --> 01:01:21,729
 

2965
01:01:21,729 --> 01:01:30,089
right so we'll just go back and run this

2966
01:01:30,089 --> 01:01:30,099


2967
01:01:30,099 --> 01:01:32,620
so again what this is going to do is

2968
01:01:32,620 --> 01:01:32,630
 

2969
01:01:32,630 --> 01:01:38,170
going to go over the enroll table it's

2970
01:01:38,170 --> 01:01:38,180
 

2971
01:01:38,180 --> 01:01:41,529
going to partition each record based on

2972
01:01:41,529 --> 01:01:41,539
 

2973
01:01:41,539 --> 01:01:44,249
the course ID so you see that here we're

2974
01:01:44,249 --> 01:01:44,259
 

2975
01:01:44,259 --> 01:01:47,529
for 15 for 45 appears first then 7 21

2976
01:01:47,529 --> 01:01:47,539
 

2977
01:01:47,539 --> 01:01:51,489
then 8 26 and then now within each of

2978
01:01:51,489 --> 01:01:51,499
 

2979
01:01:51,499 --> 01:01:54,489
these partitions it's the end going to

2980
01:01:54,489 --> 01:01:54,499
 

2981
01:01:54,499 --> 01:01:58,779
sort the tuples based on their grade in

2982
01:01:58,779 --> 01:01:58,789
 

2983
01:01:58,789 --> 01:02:01,059
descending order or sorry in in

2984
01:02:01,059 --> 01:02:01,069
 

2985
01:02:01,069 --> 01:02:04,059
ascending order so be pump comes for see

2986
01:02:04,059 --> 01:02:04,069
 

2987
01:02:04,069 --> 01:02:07,059
Abe you'll come from C and then there's

2988
01:02:07,059 --> 01:02:07,069
 

2989
01:02:07,069 --> 01:02:09,370
nobody else taking a 26 so the bees by

2990
01:02:09,370 --> 01:02:09,380
 

2991
01:02:09,380 --> 01:02:13,170
itself right so that's how we got that

2992
01:02:13,170 --> 01:02:13,180
 

2993
01:02:13,180 --> 01:02:17,650
output in the form that we redefined so

2994
01:02:17,650 --> 01:02:17,660
 

2995
01:02:17,660 --> 01:02:20,079
now the rank function is gonna be

2996
01:02:20,079 --> 01:02:20,089
 

2997
01:02:20,089 --> 01:02:22,239
computed based on where each tuple

2998
01:02:22,239 --> 01:02:22,249
 

2999
01:02:22,249 --> 01:02:27,519
appears in the sorted output list so in

3000
01:02:27,519 --> 01:02:27,529
 

3001
01:02:27,529 --> 01:02:29,200
this case here this first tuple and

3002
01:02:29,200 --> 01:02:29,210
 

3003
01:02:29,210 --> 01:02:31,839
within this partition this guy came

3004
01:02:31,839 --> 01:02:31,849
 

3005
01:02:31,849 --> 01:02:33,910
first so he gets Rank 1 this guy came

3006
01:02:33,910 --> 01:02:33,920
 

3007
01:02:33,920 --> 01:02:38,999
second so he gets ranked 2 right

3008
01:02:38,999 --> 01:02:39,009
 

3009
01:02:39,009 --> 01:02:41,679
if I change this now to be in descending

3010
01:02:41,679 --> 01:02:41,689

3011
01:02:41,689 --> 01:02:44,249
order

3012
01:02:44,249 --> 01:02:44,259


3013
01:02:44,259 --> 01:02:47,109
it doesn't still does the same thing but

3014
01:02:47,109 --> 01:02:47,119
 

3015
01:02:47,119 --> 01:02:53,589
I could do an order by again and now I

3016
01:02:53,589 --> 01:02:53,599
 

3017
01:02:53,599 --> 01:02:58,299
want to go in descending order right

3018
01:02:58,299 --> 01:02:58,309
 

3019
01:02:58,309 --> 01:02:59,709
well this is this this is doing the

3020
01:02:59,709 --> 01:02:59,719
 

3021
01:02:59,719 --> 01:03:02,769
order by this did the order by after I

3022
01:03:02,769 --> 01:03:02,779
 

3023
01:03:02,779 --> 01:03:04,269
did my window function so it doesn't

3024
01:03:04,269 --> 01:03:04,279
 

3025
01:03:04,279 --> 01:03:06,729
make sense but the the the main thing of

3026
01:03:06,729 --> 01:03:06,739
 

3027
01:03:06,739 --> 01:03:08,349
the the rank is different the row number

3028
01:03:08,349 --> 01:03:08,359
 

3029
01:03:08,359 --> 01:03:09,429
cuz the row number two says where do you

3030
01:03:09,429 --> 01:03:09,439
 

3031
01:03:09,439 --> 01:03:11,229
appear in the output the rank is where

3032
01:03:11,229 --> 01:03:11,239
 

3033
01:03:11,239 --> 01:03:15,599
do you appear in the sorted order okay

3034
01:03:15,599 --> 01:03:15,609
 

3035
01:03:15,609 --> 01:03:30,249
yes say it again sorry he says if you

3036
01:03:30,249 --> 01:03:30,259
 

3037
01:03:30,259 --> 01:03:31,599
have a rank without an order by will

3038
01:03:31,599 --> 01:03:31,609
 

3039
01:03:31,609 --> 01:03:33,819
just return a random order well you'll

3040
01:03:33,819 --> 01:03:33,829
 

3041
01:03:33,829 --> 01:03:37,239
still get it ordered by what you have

3042
01:03:37,239 --> 01:03:37,249
 

3043
01:03:37,249 --> 01:03:38,890
until get them probably split by

3044
01:03:38,890 --> 01:03:38,900
 

3045
01:03:38,900 --> 01:03:41,079
partitions it doesn't have to be because

3046
01:03:41,079 --> 01:03:41,089
 

3047
01:03:41,089 --> 01:03:45,539
it's unsorted but that's what you'll get

3048
01:03:45,539 --> 01:03:45,549
 

3049
01:03:45,549 --> 01:03:47,529
but now here yet

3050
01:03:47,529 --> 01:03:47,539

3051
01:03:47,539 --> 01:03:49,829
so there in this case here there is no

3052
01:03:49,829 --> 01:03:49,839
 

3053
01:03:49,839 --> 01:03:51,939
sort ordering anymore so everyone has

3054
01:03:51,939 --> 01:03:51,949
 

3055
01:03:51,949 --> 01:03:56,410
the rank of one right but it still group

3056
01:03:56,410 --> 01:03:56,420
 

3057
01:03:56,420 --> 01:03:58,179
them up together based on what I'd find

3058
01:03:58,179 --> 01:03:58,189
 

3059
01:03:58,189 --> 01:04:00,069
it as my partition and that's more of an

3060
01:04:00,069 --> 01:04:00,079
 

3061
01:04:00,079 --> 01:04:02,949
artifact of how the database system

3062
01:04:02,949 --> 01:04:02,959
 

3063
01:04:02,959 --> 01:04:04,809
actually execute the query rather than

3064
01:04:04,809 --> 01:04:04,819
 

3065
01:04:04,819 --> 01:04:11,259
the semantics of the query itself his

3066
01:04:11,259 --> 01:04:11,269
 

3067
01:04:11,269 --> 01:04:12,579
question is what is the rank function do

3068
01:04:12,579 --> 01:04:12,589
 

3069
01:04:12,589 --> 01:04:14,979
the rank is the rank of the rank

3070
01:04:14,979 --> 01:04:14,989
 

3071
01:04:14,989 --> 01:04:16,630
function produces the rank of the sort

3072
01:04:16,630 --> 01:04:16,640
 

3073
01:04:16,640 --> 01:04:19,749
order right so if I change my window

3074
01:04:19,749 --> 01:04:19,759
 

3075
01:04:19,759 --> 01:04:26,469
function to be row number okay I have my

3076
01:04:26,469 --> 01:04:26,479

3077
01:04:26,479 --> 01:04:30,729
partition but but it's one to one to one

3078
01:04:30,729 --> 01:04:30,739
 

3079
01:04:30,739 --> 01:04:32,349
right because within each partition

3080
01:04:32,349 --> 01:04:32,359
 

3081
01:04:32,359 --> 01:04:34,089
that's what I read peer so I've removed

3082
01:04:34,089 --> 01:04:34,099
 

3083
01:04:34,099 --> 01:04:36,759
actually the partition by then it should

3084
01:04:36,759 --> 01:04:36,769
 

3085
01:04:36,769 --> 01:04:39,160
go through one through five right like

3086
01:04:39,160 --> 01:04:39,170
 

3087
01:04:39,170 --> 01:04:41,699
that if I change this now to rank

3088
01:04:41,699 --> 01:04:41,709

3089
01:04:41,709 --> 01:04:44,890
everything should be one one one right

3090
01:04:44,890 --> 01:04:44,900
 

3091
01:04:44,900 --> 01:04:46,269
because there is no soil order

3092
01:04:46,269 --> 01:04:46,279
 

3093
01:04:46,279 --> 01:04:50,060
everyone's first

3094
01:04:50,060 --> 01:04:50,070


3095
01:04:50,070 --> 01:04:57,200
yes our question is a point of view

3096
01:04:57,200 --> 01:04:57,210
 

3097
01:04:57,210 --> 01:04:59,120
ranked without an order by yes because

3098
01:04:59,120 --> 01:04:59,130
 

3099
01:04:59,130 --> 01:05:00,890
there's no there's no sort order so

3100
01:05:00,890 --> 01:05:00,900
 

3101
01:05:00,900 --> 01:05:09,490
there's no ranking all right cool

3102
01:05:09,490 --> 01:05:09,500


3103
01:05:09,500 --> 01:05:11,420
all right so the last thing we wanna

3104
01:05:11,420 --> 01:05:11,430
 

3105
01:05:11,430 --> 01:05:13,790
talk about is si si es complex table

3106
01:05:13,790 --> 01:05:13,800
 

3107
01:05:13,800 --> 01:05:16,100
expressions so this is Polly again Mike

3108
01:05:16,100 --> 01:05:16,110
 

3109
01:05:16,110 --> 01:05:18,320
this is I find this very interesting

3110
01:05:18,320 --> 01:05:18,330
 

3111
01:05:18,330 --> 01:05:19,820
this is probably one more complicated

3112
01:05:19,820 --> 01:05:19,830
 

3113
01:05:19,830 --> 01:05:22,490
things that you can do in sequel and

3114
01:05:22,490 --> 01:05:22,500
 

3115
01:05:22,500 --> 01:05:24,170
it's gonna look a lot like nested

3116
01:05:24,170 --> 01:05:24,180
 

3117
01:05:24,180 --> 01:05:26,120
queries in that you're taking the output

3118
01:05:26,120 --> 01:05:26,130
 

3119
01:05:26,130 --> 01:05:27,800
of a query I'm using as the input for

3120
01:05:27,800 --> 01:05:27,810
 

3121
01:05:27,810 --> 01:05:29,510
another query but we'll see in a second

3122
01:05:29,510 --> 01:05:29,520
 

3123
01:05:29,520 --> 01:05:31,010
what you can do with CT ease that you

3124
01:05:31,010 --> 01:05:31,020
 

3125
01:05:31,020 --> 01:05:43,790
can't do in Anessa queries yes so her

3126
01:05:43,790 --> 01:05:43,800
 

3127
01:05:43,800 --> 01:05:46,760
question is in the case of this is it

3128
01:05:46,760 --> 01:05:46,770
 

3129
01:05:46,770 --> 01:05:48,440
this particular query or it is in

3130
01:05:48,440 --> 01:05:48,450
 

3131
01:05:48,450 --> 01:05:54,980
general so a question is is there a

3132
01:05:54,980 --> 01:05:54,990
 

3133
01:05:54,990 --> 01:05:58,460
particular advantage of using rank with

3134
01:05:58,460 --> 01:05:58,470
 

3135
01:05:58,470 --> 01:06:01,880
a window function over using a group I

3136
01:06:01,880 --> 01:06:01,890
 

3137
01:06:01,890 --> 01:06:04,730
so again if you use a group by that's

3138
01:06:04,730 --> 01:06:04,740
 

3139
01:06:04,740 --> 01:06:06,680
not going to generate the same you're

3140
01:06:06,680 --> 01:06:06,690
 

3141
01:06:06,690 --> 01:06:08,240
not going to get the tuples as part of

3142
01:06:08,240 --> 01:06:08,250
 

3143
01:06:08,250 --> 01:06:09,800
the output anymore right

3144
01:06:09,800 --> 01:06:09,810

3145
01:06:09,810 --> 01:06:15,140
so if I go back so say I do this one

3146
01:06:15,140 --> 01:06:15,150
 

3147
01:06:15,150 --> 01:06:19,250
here right row number by partition by so

3148
01:06:19,250 --> 01:06:19,260
 

3149
01:06:19,260 --> 01:06:21,200
if I go back and I say I want to compute

3150
01:06:21,200 --> 01:06:21,210
 

3151
01:06:21,210 --> 01:06:34,180
now like the the max grade some enrolled

3152
01:06:34,180 --> 01:06:34,190


3153
01:06:34,190 --> 01:06:40,340
group by course ID like I no longer see

3154
01:06:40,340 --> 01:06:40,350
 

3155
01:06:40,350 --> 01:06:41,990
what the original tuples were because

3156
01:06:41,990 --> 01:06:42,000

3157
01:06:42,000 --> 01:06:43,220
they get collapse together in the

3158
01:06:43,220 --> 01:06:43,230
 

3159
01:06:43,230 --> 01:06:45,110
aggregate function the window function

3160
01:06:45,110 --> 01:06:45,120
 

3161
01:06:45,120 --> 01:06:46,790
still produces all the tuples that were

3162
01:06:46,790 --> 01:06:46,800
 

3163
01:06:46,800 --> 01:06:50,210
in your output but I can now see them as

3164
01:06:50,210 --> 01:06:50,220
 

3165
01:06:50,220 --> 01:06:53,960
I can still see them as the output so if

3166
01:06:53,960 --> 01:06:53,970
 

3167
01:06:53,970 --> 01:06:56,510
I go back here and if I this may or may

3168
01:06:56,510 --> 01:06:56,520
 

3169
01:06:56,520 --> 01:06:59,800
not work but let's see so maybe I try

3170
01:06:59,800 --> 01:06:59,810
 

3171
01:06:59,810 --> 01:07:02,480
max grade

3172
01:07:02,480 --> 01:07:02,490
 

3173
01:07:02,490 --> 01:07:07,040
petition my course ID yeah so here that

3174
01:07:07,040 --> 01:07:07,050
 

3175
01:07:07,050 --> 01:07:17,599
didn't quite work either with that stick

3176
01:07:17,599 --> 01:07:17,609
 

3177
01:07:17,609 --> 01:07:29,299
oh you know what it might be now they

3178
01:07:29,299 --> 01:07:29,309
 

3179
01:07:29,309 --> 01:07:33,700
didn't like it

3180
01:07:33,700 --> 01:07:33,710


3181
01:07:33,710 --> 01:07:38,569
there's the rank oh yeah because I'm an

3182
01:07:38,569 --> 01:07:38,579
 

3183
01:07:38,579 --> 01:07:41,720
idiot sorry yes it did work I was what I

3184
01:07:41,720 --> 01:07:41,730
 

3185
01:07:41,730 --> 01:07:44,960
wanted min yeah so the highest grade at

3186
01:07:44,960 --> 01:07:44,970
 

3187
01:07:44,970 --> 01:07:49,670
15 for 45 is was was it be right so I

3188
01:07:49,670 --> 01:07:49,680
 

3189
01:07:49,680 --> 01:07:51,290
still see my original to both I still

3190
01:07:51,290 --> 01:07:51,300
 

3191
01:07:51,300 --> 01:07:53,690
see one student got to see one student

3192
01:07:53,690 --> 01:07:53,700
 

3193
01:07:53,700 --> 01:07:56,620
got a B but the max for that group was B

3194
01:07:56,620 --> 01:07:56,630
 

3195
01:07:56,630 --> 01:08:00,079
so I didn't lose the original tuples now

3196
01:08:00,079 --> 01:08:00,089
 

3197
01:08:00,089 --> 01:08:01,609
you and your application code have to

3198
01:08:01,609 --> 01:08:01,619

3199
01:08:01,619 --> 01:08:03,620
derive meanings from this output you

3200
01:08:03,620 --> 01:08:03,630
 

3201
01:08:03,630 --> 01:08:06,020
know get the one field that you won but

3202
01:08:06,020 --> 01:08:06,030
 

3203
01:08:06,030 --> 01:08:07,099
this has allows you to get and still

3204
01:08:07,099 --> 01:08:07,109
 

3205
01:08:07,109 --> 01:08:09,799
keep the tuples in a way you can't with

3206
01:08:09,799 --> 01:08:09,809
 

3207
01:08:09,809 --> 01:08:17,470
a group I that's a good question yes

3208
01:08:17,470 --> 01:08:17,480


3209
01:08:17,480 --> 01:08:19,939
this question is can you use row number

3210
01:08:19,939 --> 01:08:19,949
 

3211
01:08:19,949 --> 01:08:23,419
after use an order by so something like

3212
01:08:23,419 --> 01:08:23,429
 

3213
01:08:23,429 --> 01:08:32,050
this right and then maybe order by oh

3214
01:08:32,050 --> 01:08:32,060


3215
01:08:32,060 --> 01:08:34,669
yeah there yeah sorry that's why there's

3216
01:08:34,669 --> 01:08:34,679
 

3217
01:08:34,679 --> 01:08:38,590
the as rank so let's do this row numb oh

3218
01:08:38,590 --> 01:08:38,600
 

3219
01:08:38,600 --> 01:08:41,229
I'm an idiot sorry no one can see this

3220
01:08:41,229 --> 01:08:41,239
 

3221
01:08:41,239 --> 01:08:45,410
how can you yeah sorry my screen shows

3222
01:08:45,410 --> 01:08:45,420

3223
01:08:45,420 --> 01:08:46,610
one thing this shows another and that

3224
01:08:46,610 --> 01:08:46,620
 

3225
01:08:46,620 --> 01:08:53,410
shows this okay we're good right right

3226
01:08:53,410 --> 01:08:53,420


3227
01:08:53,420 --> 01:08:58,969
now if we if we remove the partition by

3228
01:08:58,969 --> 01:08:58,979


3229
01:08:58,979 --> 01:09:00,979
and now we can maybe put descending

3230
01:09:00,979 --> 01:09:00,989

3231
01:09:00,989 --> 01:09:03,199
right so now we'll get 5 4 3 2 1

3232
01:09:03,199 --> 01:09:03,209
 

3233
01:09:03,209 --> 01:09:13,759
right the plate replace the rank with

3234
01:09:13,759 --> 01:09:13,769
 

3235
01:09:13,769 --> 01:09:26,569
the row number what do you mean let's do

3236
01:09:26,569 --> 01:09:26,579
 

3237
01:09:26,579 --> 01:09:28,099
this online because I want to get to see

3238
01:09:28,099 --> 01:09:28,109
 

3239
01:09:28,109 --> 01:09:29,239
two E's because he knew it for the

3240
01:09:29,239 --> 01:09:29,249
 

3241
01:09:29,249 --> 01:09:31,039
homework before we keep going okay we

3242
01:09:31,039 --> 01:09:31,049
 

3243
01:09:31,049 --> 01:09:35,749
can try it afterwards okay all right so

3244
01:09:35,749 --> 01:09:35,759
 

3245
01:09:35,759 --> 01:09:37,999
see T's the way basically is gonna work

3246
01:09:37,999 --> 01:09:38,009
 

3247
01:09:38,009 --> 01:09:40,009
is that you have introduced with his wif

3248
01:09:40,009 --> 01:09:40,019
 

3249
01:09:40,019 --> 01:09:43,160
claws his wif falls it's like a query

3250
01:09:43,160 --> 01:09:43,170
 

3251
01:09:43,170 --> 01:09:44,539
that's gonna actually before your your

3252
01:09:44,539 --> 01:09:44,549
 

3253
01:09:44,549 --> 01:09:47,809
regular query so we have wif and we're

3254
01:09:47,809 --> 01:09:47,819
 

3255
01:09:47,819 --> 01:09:50,329
defining the name or a CTE and then we

3256
01:09:50,329 --> 01:09:50,339

3257
01:09:50,339 --> 01:09:51,949
have our ask clause and whatever is

3258
01:09:51,949 --> 01:09:51,959
 

3259
01:09:51,959 --> 01:09:54,219
inside of the parenthesis after the as

3260
01:09:54,219 --> 01:09:54,229
 

3261
01:09:54,229 --> 01:09:57,169
the output of that query would then get

3262
01:09:57,169 --> 01:09:57,179
 

3263
01:09:57,179 --> 01:10:00,199
some maps to this are the name for a CTE

3264
01:10:00,199 --> 01:10:00,209
 

3265
01:10:00,209 --> 01:10:02,660
and then in the Select query that comes

3266
01:10:02,660 --> 01:10:02,670
 

3267
01:10:02,670 --> 01:10:05,180
below it can reference it does just as

3268
01:10:05,180 --> 01:10:05,190
 

3269
01:10:05,190 --> 01:10:11,029
if it was a an existing table right so

3270
01:10:11,029 --> 01:10:11,039
 

3271
01:10:11,039 --> 01:10:13,479
in this case here what will happen is I

3272
01:10:13,479 --> 01:10:13,489
 

3273
01:10:13,489 --> 01:10:16,549
see te that invokes the query select one

3274
01:10:16,549 --> 01:10:16,559
 

3275
01:10:16,559 --> 01:10:18,680
right so let's don't have to have a from

3276
01:10:18,680 --> 01:10:18,690

3277
01:10:18,690 --> 01:10:20,359
clause this just a pollutes this

3278
01:10:20,359 --> 01:10:20,369
 

3279
01:10:20,369 --> 01:10:22,969
produces a single tuple with a single

3280
01:10:22,969 --> 01:10:22,979
 

3281
01:10:22,979 --> 01:10:25,189
attribute with the value one and then

3282
01:10:25,189 --> 01:10:25,199
 

3283
01:10:25,199 --> 01:10:27,259
this other query the bottom to select

3284
01:10:27,259 --> 01:10:27,269

3285
01:10:27,269 --> 01:10:28,879
star on it and there's outputs that

3286
01:10:28,879 --> 01:10:28,889

3287
01:10:28,889 --> 01:10:32,600
single tuple so I can start doing more

3288
01:10:32,600 --> 01:10:32,610
 

3289
01:10:32,610 --> 01:10:34,310
complicated things I can now bind the

3290
01:10:34,310 --> 01:10:34,320
 

3291
01:10:34,320 --> 01:10:37,399
the name or the output columns from the

3292
01:10:37,399 --> 01:10:37,409
 

3293
01:10:37,409 --> 01:10:40,250
queries inside of the CTE to given names

3294
01:10:40,250 --> 01:10:40,260
 

3295
01:10:40,260 --> 01:10:41,989
and then I can reference them by that

3296
01:10:41,989 --> 01:10:41,999

3297
01:10:41,999 --> 01:10:46,160
name down below in my in my statement at

3298
01:10:46,160 --> 01:10:46,170
 

3299
01:10:46,170 --> 01:10:49,219
the bottom so this this CTE produces a

3300
01:10:49,219 --> 01:10:49,229
 

3301
01:10:49,229 --> 01:10:51,770
single tuple with two attributes with

3302
01:10:51,770 --> 01:10:51,780
 

3303
01:10:51,780 --> 01:10:53,989
the values one and two and then these

3304
01:10:53,989 --> 01:10:53,999
 

3305
01:10:53,999 --> 01:10:56,149
get mapped to the name column 1 column 2

3306
01:10:56,149 --> 01:10:56,159
 

3307
01:10:56,159 --> 01:10:58,520
and then in the Select statement below I

3308
01:10:58,520 --> 01:10:58,530
 

3309
01:10:58,530 --> 01:11:01,939
can just add them together right pretty

3310
01:11:01,939 --> 01:11:01,949
 

3311
01:11:01,949 --> 01:11:03,890
straightforward

3312
01:11:03,890 --> 01:11:03,900
 

3313
01:11:03,900 --> 01:11:05,000
so let's go back and try to do that

3314
01:11:05,000 --> 01:11:05,010
 

3315
01:11:05,010 --> 01:11:06,770
example we did before where we want to

3316
01:11:06,770 --> 01:11:06,780
 

3317
01:11:06,780 --> 01:11:09,080
find the name of the student with the

3318
01:11:09,080 --> 01:11:09,090
 

3319
01:11:09,090 --> 01:11:10,730
highest high student ID that's enrolled

3320
01:11:10,730 --> 01:11:10,740
 

3321
01:11:10,740 --> 01:11:14,450
at least one course so for this I have

3322
01:11:14,450 --> 01:11:14,460
 

3323
01:11:14,460 --> 01:11:16,970
my CTE and the side of that I'll do my

3324
01:11:16,970 --> 01:11:16,980
 

3325
01:11:16,980 --> 01:11:18,470
max on the student ID on the enroll

3326
01:11:18,470 --> 01:11:18,480

3327
01:11:18,480 --> 01:11:22,100
table again that produces one tuple with

3328
01:11:22,100 --> 01:11:22,110
 

3329
01:11:22,110 --> 01:11:24,710
that max student ID and then down below

3330
01:11:24,710 --> 01:11:24,720
 

3331
01:11:24,720 --> 01:11:26,540
I can do a join where I'm gonna

3332
01:11:26,540 --> 01:11:26,550
 

3333
01:11:26,550 --> 01:11:30,680
reference the the CTE that was generated

3334
01:11:30,680 --> 01:11:30,690
 

3335
01:11:30,690 --> 01:11:32,600
above me and I just combined together

3336
01:11:32,600 --> 01:11:32,610
 

3337
01:11:32,610 --> 01:11:34,760
the max ID that came out of this which

3338
01:11:34,760 --> 01:11:34,770
 

3339
01:11:34,770 --> 01:11:37,310
is defined here with my student ID and

3340
01:11:37,310 --> 01:11:37,320
 

3341
01:11:37,320 --> 01:11:39,530
then that produces that produces the one

3342
01:11:39,530 --> 01:11:39,540
 

3343
01:11:39,540 --> 01:11:42,650
tuple that I want right again this is

3344
01:11:42,650 --> 01:11:42,660
 

3345
01:11:42,660 --> 01:11:44,030
another example of how to do the same

3346
01:11:44,030 --> 01:11:44,040
 

3347
01:11:44,040 --> 01:11:45,680
query the same at a high level

3348
01:11:45,680 --> 01:11:45,690
 

3349
01:11:45,690 --> 01:11:47,300
semantically the same query just written

3350
01:11:47,300 --> 01:11:47,310
 

3351
01:11:47,310 --> 01:11:49,700
in different ways so now you may be

3352
01:11:49,700 --> 01:11:49,710
 

3353
01:11:49,710 --> 01:11:50,660
saying well how is this any different

3354
01:11:50,660 --> 01:11:50,670
 

3355
01:11:50,670 --> 01:11:54,620
than a nested query right the answer is

3356
01:11:54,620 --> 01:11:54,630
 

3357
01:11:54,630 --> 01:11:57,170
you can do recursion in a common table

3358
01:11:57,170 --> 01:11:57,180
 

3359
01:11:57,180 --> 01:11:59,870
expression that you can't do in a nested

3360
01:11:59,870 --> 01:11:59,880

3361
01:11:59,880 --> 01:12:03,380
query so bear with me here but this

3362
01:12:03,380 --> 01:12:03,390
 

3363
01:12:03,390 --> 01:12:05,450
query is going to produce a sequence of

3364
01:12:05,450 --> 01:12:05,460
 

3365
01:12:05,460 --> 01:12:07,460
numbers from from 1 to 10 like a for

3366
01:12:07,460 --> 01:12:07,470
 

3367
01:12:07,470 --> 01:12:10,640
loop alright so now we have with

3368
01:12:10,640 --> 01:12:10,650
 

3369
01:12:10,650 --> 01:12:13,370
recursive we have a keyword and then

3370
01:12:13,370 --> 01:12:13,380
 

3371
01:12:13,380 --> 01:12:15,980
inside of our CTE definition we're gonna

3372
01:12:15,980 --> 01:12:15,990
 

3373
01:12:15,990 --> 01:12:19,250
do a union between a single query that

3374
01:12:19,250 --> 01:12:19,260
 

3375
01:12:19,260 --> 01:12:22,190
produces the value 1 alright a single

3376
01:12:22,190 --> 01:12:22,200
 

3377
01:12:22,200 --> 01:12:24,590
tuple with a single attribute 1 and then

3378
01:12:24,590 --> 01:12:24,600
 

3379
01:12:24,600 --> 01:12:27,470
we're gonna then Union that with another

3380
01:12:27,470 --> 01:12:27,480
 

3381
01:12:27,480 --> 01:12:29,600
query that actually references ourselves

3382
01:12:29,600 --> 01:12:29,610

3383
01:12:29,610 --> 01:12:31,670
so that seeing here we're gonna vote on

3384
01:12:31,670 --> 01:12:31,680
 

3385
01:12:31,680 --> 01:12:34,370
our own CTE and then we're gonna take

3386
01:12:34,370 --> 01:12:34,380
 

3387
01:12:34,380 --> 01:12:35,840
whatever the counter is I've produced by

3388
01:12:35,840 --> 01:12:35,850
 

3389
01:12:35,850 --> 01:12:38,480
this and add one to it and produce that

3390
01:12:38,480 --> 01:12:38,490
 

3391
01:12:38,490 --> 01:12:43,610
as the output alright and we keep

3392
01:12:43,610 --> 01:12:43,620
 

3393
01:12:43,620 --> 01:12:45,380
running this until our where Clause

3394
01:12:45,380 --> 01:12:45,390
 

3395
01:12:45,390 --> 01:12:49,070
actually gets tripped up where we try to

3396
01:12:49,070 --> 01:12:49,080
 

3397
01:12:49,080 --> 01:12:51,140
go above 10 and then now we stop

3398
01:12:51,140 --> 01:12:51,150
 

3399
01:12:51,150 --> 01:12:52,550
producing 2 pools so now we have the

3400
01:12:52,550 --> 01:12:52,560
 

3401
01:12:52,560 --> 01:12:53,750
answer that we want that we can then

3402
01:12:53,750 --> 01:12:53,760
 

3403
01:12:53,760 --> 01:12:59,690
reference below in our CTE yes you know

3404
01:12:59,690 --> 01:12:59,700
 

3405
01:12:59,700 --> 01:13:02,660
it's basically a union right it's Union

3406
01:13:02,660 --> 01:13:02,670
 

3407
01:13:02,670 --> 01:13:08,660
with you know with duplicates Union

3408
01:13:08,660 --> 01:13:08,670
 

3409
01:13:08,670 --> 01:13:08,930
buddy

3410
01:13:08,930 --> 01:13:08,940
 

3411
01:13:08,940 --> 01:13:11,209
for Terry you need sir Union without

3412
01:13:11,209 --> 01:13:11,219
 

3413
01:13:11,219 --> 01:13:15,500
duplicates Union with duplicates Union

3414
01:13:15,500 --> 01:13:15,510
 

3415
01:13:15,510 --> 01:13:17,600
without all strips keeps duplicates

3416
01:13:17,600 --> 01:13:17,610
 

3417
01:13:17,610 --> 01:13:21,160
Union with with out all removes that

3418
01:13:21,160 --> 01:13:21,170
 

3419
01:13:21,170 --> 01:13:23,680
might be the way we can test that though

3420
01:13:23,680 --> 01:13:23,690
 

3421
01:13:23,690 --> 01:13:30,560
okay so let's do this in Postgres so for

3422
01:13:30,560 --> 01:13:30,570
 

3423
01:13:30,570 --> 01:13:35,209
the alright so this is this is the one

3424
01:13:35,209 --> 01:13:35,219
 

3425
01:13:35,219 --> 01:13:36,979
query that this is the query that I

3426
01:13:36,979 --> 01:13:36,989
 

3427
01:13:36,989 --> 01:13:40,070
showed you right and we produce the the

3428
01:13:40,070 --> 01:13:40,080
 

3429
01:13:40,080 --> 01:13:42,590
list of tuples right with a single value

3430
01:13:42,590 --> 01:13:42,600
 

3431
01:13:42,600 --> 01:13:48,470
one dn't one this hat right let me try

3432
01:13:48,470 --> 01:13:48,480
 

3433
01:13:48,480 --> 01:13:55,120
to kill this alright that better alright

3434
01:13:55,120 --> 01:13:55,130
 

3435
01:13:55,130 --> 01:14:00,350
but it be careful about CTE s with

3436
01:14:00,350 --> 01:14:00,360
 

3437
01:14:00,360 --> 01:14:04,310
recursive because again net because you

3438
01:14:04,310 --> 01:14:04,320
 

3439
01:14:04,320 --> 01:14:06,290
can essentially have infinite loose so

3440
01:14:06,290 --> 01:14:06,300
 

3441
01:14:06,300 --> 01:14:08,660
in this query here I no longer have that

3442
01:14:08,660 --> 01:14:08,670
 

3443
01:14:08,670 --> 01:14:11,360
counter where it's greater than ten or

3444
01:14:11,360 --> 01:14:11,370
 

3445
01:14:11,370 --> 01:14:13,490
produced check any tuples where they're

3446
01:14:13,490 --> 01:14:13,500
 

3447
01:14:13,500 --> 01:14:15,229
less than ten this will run actually

3448
01:14:15,229 --> 01:14:15,239
 

3449
01:14:15,239 --> 01:14:17,270
forever but what I did first was I

3450
01:14:17,270 --> 01:14:17,280
 

3451
01:14:17,280 --> 01:14:21,500
define a told Postgres to again I'm

3452
01:14:21,500 --> 01:14:21,510
 

3453
01:14:21,510 --> 01:14:22,490
highlighting here and you can't see it

3454
01:14:22,490 --> 01:14:22,500
 

3455
01:14:22,500 --> 01:14:24,890
at all post grass that any query that

3456
01:14:24,890 --> 01:14:24,900
 

3457
01:14:24,900 --> 01:14:25,970
runs longer than 10 seconds

3458
01:14:25,970 --> 01:14:25,980

3459
01:14:25,980 --> 01:14:28,580
automatically kill it so when I ran this

3460
01:14:28,580 --> 01:14:28,590
 

3461
01:14:28,590 --> 01:14:31,250
query now it no longer has the where

3462
01:14:31,250 --> 01:14:31,260
 

3463
01:14:31,260 --> 01:14:33,200
clause to prevent it from going you know

3464
01:14:33,200 --> 01:14:33,210
 

3465
01:14:33,210 --> 01:14:35,900
looking at tuples beyond 10 and so

3466
01:14:35,900 --> 01:14:35,910
 

3467
01:14:35,910 --> 01:14:37,280
essentially runs forever

3468
01:14:37,280 --> 01:14:37,290
 

3469
01:14:37,290 --> 01:14:39,470
Postgres recognizes that we're stuck in

3470
01:14:39,470 --> 01:14:39,480
 

3471
01:14:39,480 --> 01:14:41,479
a query that's taking too long and a go

3472
01:14:41,479 --> 01:14:41,489
 

3473
01:14:41,489 --> 01:14:46,080
goes head and automatically kills it yes

3474
01:14:46,080 --> 01:14:46,090
 

3475
01:14:46,090 --> 01:14:48,400
[Music]

3476
01:14:48,400 --> 01:14:48,410

3477
01:14:48,410 --> 01:14:51,650
so sorry so select one just does this

3478
01:14:51,650 --> 01:14:51,660

3479
01:14:51,660 --> 01:14:57,740
right so now if i do select one Union

3480
01:14:57,740 --> 01:14:57,750
 

3481
01:14:57,750 --> 01:15:04,770
all select one right I get like that

3482
01:15:04,770 --> 01:15:04,780


3483
01:15:04,780 --> 01:15:07,770
so if I think I remove that all yeah you

3484
01:15:07,770 --> 01:15:07,780
 

3485
01:15:07,780 --> 01:15:10,250
get it's a without it removes duplicates

3486
01:15:10,250 --> 01:15:10,260

3487
01:15:10,260 --> 01:15:13,620
right so you know will give me

3488
01:15:13,620 --> 01:15:13,630
 

3489
01:15:13,630 --> 01:15:16,260
everything so essentially what's

3490
01:15:16,260 --> 01:15:16,270

3491
01:15:16,270 --> 01:15:21,270
happening now is I'm calling my CTE say

3492
01:15:21,270 --> 01:15:21,280
 

3493
01:15:21,280 --> 01:15:22,560
whatever the whatever tools you have in

3494
01:15:22,560 --> 01:15:22,570
 

3495
01:15:22,570 --> 01:15:26,190
the current value take take the output

3496
01:15:26,190 --> 01:15:26,200
 

3497
01:15:26,200 --> 01:15:32,970
and then add one to it here right the

3498
01:15:32,970 --> 01:15:32,980
 

3499
01:15:32,980 --> 01:15:35,790
the plus one there so this is invoking

3500
01:15:35,790 --> 01:15:35,800
 

3501
01:15:35,800 --> 01:15:42,300
on on our our our source CTE called

3502
01:15:42,300 --> 01:15:42,310
 

3503
01:15:42,310 --> 01:15:44,370
source for every single to one there

3504
01:15:44,370 --> 01:15:44,380
 

3505
01:15:44,380 --> 01:15:47,070
take its output add one to it so in

3506
01:15:47,070 --> 01:15:47,080
 

3507
01:15:47,080 --> 01:15:48,300
order to get that to pool it has to go

3508
01:15:48,300 --> 01:15:48,310
 

3509
01:15:48,310 --> 01:15:49,920
then invoke that CTE which then produces

3510
01:15:49,920 --> 01:15:49,930

3511
01:15:49,930 --> 01:16:03,570
back one yeah it won't let you in bogey

3512
01:16:03,570 --> 01:16:03,580
 

3513
01:16:03,580 --> 01:16:04,380
because then he knows you're trying to

3514
01:16:04,380 --> 01:16:04,390
 

3515
01:16:04,390 --> 01:16:06,660
reference yourself so it's question is

3516
01:16:06,660 --> 01:16:06,670
 

3517
01:16:06,670 --> 01:16:09,030
what happens if you if you try to remove

3518
01:16:09,030 --> 01:16:09,040
 

3519
01:16:09,040 --> 01:16:12,030
the recursive calls again its sequel its

3520
01:16:12,030 --> 01:16:12,040
 

3521
01:16:12,040 --> 01:16:13,410
declared net we know everything you're

3522
01:16:13,410 --> 01:16:13,420
 

3523
01:16:13,420 --> 01:16:14,460
trying to do so you're trying to access

3524
01:16:14,460 --> 01:16:14,470
 

3525
01:16:14,470 --> 01:16:18,480
a CTE table that's defined by yourself

3526
01:16:18,480 --> 01:16:18,490
 

3527
01:16:18,490 --> 01:16:20,070
and it doesn't let you do that

3528
01:16:20,070 --> 01:16:20,080
 

3529
01:16:20,080 --> 01:16:24,510
recursive let you do that so let's try

3530
01:16:24,510 --> 01:16:24,520

3531
01:16:24,520 --> 01:16:31,350
it now also with let's try it by

3532
01:16:31,350 --> 01:16:31,360
 

3533
01:16:31,360 --> 01:16:33,660
removing the Union all and see what

3534
01:16:33,660 --> 01:16:33,670
 

3535
01:16:33,670 --> 01:16:37,980
happens a big all apartment and it still

3536
01:16:37,980 --> 01:16:37,990
 

3537
01:16:37,990 --> 01:16:40,740
produces the correct answer yes you

3538
01:16:40,740 --> 01:16:40,750
 

3539
01:16:40,750 --> 01:16:42,780
don't you don't need the Union all right

3540
01:16:42,780 --> 01:16:42,790
 

3541
01:16:42,790 --> 01:16:44,700
so in this example here again I'm

3542
01:16:44,700 --> 01:16:44,710
 

3543
01:16:44,710 --> 01:16:47,040
synthetically generating a two table

3544
01:16:47,040 --> 01:16:47,050
 

3545
01:16:47,050 --> 01:16:50,580
that has a single value of one and then

3546
01:16:50,580 --> 01:16:50,590
 

3547
01:16:50,590 --> 01:16:54,150
I invoke a query to get that tuple and

3548
01:16:54,150 --> 01:16:54,160
 

3549
01:16:54,160 --> 01:16:56,040
add one to it but then generates a new

3550
01:16:56,040 --> 01:16:56,050
 

3551
01:16:56,050 --> 01:16:57,390
tuple which and that can then invoke

3552
01:16:57,390 --> 01:16:57,400
 

3553
01:16:57,400 --> 01:16:59,220
again and add one to that and I keep

3554
01:16:59,220 --> 01:16:59,230
 

3555
01:16:59,230 --> 01:17:00,810
doing that until I don't produce any

3556
01:17:00,810 --> 01:17:00,820
 

3557
01:17:00,820 --> 01:17:02,490
more matches right because any the

3558
01:17:02,490 --> 01:17:02,500
 

3559
01:17:02,500 --> 01:17:05,370
recursion ends because I've reached my

3560
01:17:05,370 --> 01:17:05,380
 

3561
01:17:05,380 --> 01:17:24,739
limit of ten yes

3562
01:17:24,739 --> 01:17:24,749


3563
01:17:24,749 --> 01:17:27,330
this question is why why are there not

3564
01:17:27,330 --> 01:17:27,340

3565
01:17:27,340 --> 01:17:29,549
duplicates because the first time you

3566
01:17:29,549 --> 01:17:29,559
 

3567
01:17:29,559 --> 01:17:31,889
devoted you had one six second time you

3568
01:17:31,889 --> 01:17:31,899
 

3569
01:17:31,899 --> 01:17:38,520
invoke you would have one and two let's

3570
01:17:38,520 --> 01:17:38,530
 

3571
01:17:38,530 --> 01:17:41,120
do this offline let's walk through it

3572
01:17:41,120 --> 01:17:41,130
 

3573
01:17:41,130 --> 01:17:43,229
because again we have it we're out of

3574
01:17:43,229 --> 01:17:43,239
 

3575
01:17:43,239 --> 01:17:46,500
time all right

3576
01:17:46,500 --> 01:17:46,510

3577
01:17:46,510 --> 01:17:53,219
yes quick this question is do people use

3578
01:17:53,219 --> 01:17:53,229
 

3579
01:17:53,229 --> 01:17:54,989
for Krista see T's is ever a comment yes

3580
01:17:54,989 --> 01:17:54,999
 

3581
01:17:54,999 --> 01:17:58,709
absolutely yes so this is actually

3582
01:17:58,709 --> 01:17:58,719
 

3583
01:17:58,719 --> 01:18:02,639
finished up very nicely so the the

3584
01:18:02,639 --> 01:18:02,649
 

3585
01:18:02,649 --> 01:18:03,779
second point I'm trying to make here is

3586
01:18:03,779 --> 01:18:03,789
 

3587
01:18:03,789 --> 01:18:07,020
that in an ideal scenario you always

3588
01:18:07,020 --> 01:18:07,030
 

3589
01:18:07,030 --> 01:18:10,919
want to have to be able to compute an

3590
01:18:10,919 --> 01:18:10,929
 

3591
01:18:10,929 --> 01:18:14,219
entire query without having to bring any

3592
01:18:14,219 --> 01:18:14,229
 

3593
01:18:14,229 --> 01:18:16,770
data locally or not having to go back

3594
01:18:16,770 --> 01:18:16,780
 

3595
01:18:16,780 --> 01:18:20,520
and forth right so in a it also provides

3596
01:18:20,520 --> 01:18:20,530
 

3597
01:18:20,530 --> 01:18:21,870
by burning as a single query

3598
01:18:21,870 --> 01:18:21,880

3599
01:18:21,880 --> 01:18:23,909
although the complexity it makes it hard

3600
01:18:23,909 --> 01:18:23,919
 

3601
01:18:23,919 --> 01:18:26,520
to do query optimization but if you tell

3602
01:18:26,520 --> 01:18:26,530

3603
01:18:26,530 --> 01:18:28,319
the David system everything you want to

3604
01:18:28,319 --> 01:18:28,329
 

3605
01:18:28,329 --> 01:18:30,929
do with this sort of piece of data then

3606
01:18:30,929 --> 01:18:30,939
 

3607
01:18:30,939 --> 01:18:32,939
they can do a global optimization on

3608
01:18:32,939 --> 01:18:32,949
 

3609
01:18:32,949 --> 01:18:35,669
that so by having a CTE you're not

3610
01:18:35,669 --> 01:18:35,679
 

3611
01:18:35,679 --> 01:18:37,169
having to have additional logic be

3612
01:18:37,169 --> 01:18:37,179
 

3613
01:18:37,179 --> 01:18:38,459
somewhere salicin outside the David

3614
01:18:38,459 --> 01:18:38,469
 

3615
01:18:38,469 --> 01:18:39,929
system or go back and forth you're

3616
01:18:39,929 --> 01:18:39,939
 

3617
01:18:39,939 --> 01:18:42,299
saying here's everything I want to do so

3618
01:18:42,299 --> 01:18:42,309
 

3619
01:18:42,309 --> 01:18:44,159
CTS are actually very common especially

3620
01:18:44,159 --> 01:18:44,169
 

3621
01:18:44,169 --> 01:18:47,569
in newer applications for cursive CDs

3622
01:18:47,569 --> 01:18:47,579
 

3623
01:18:47,579 --> 01:18:50,850
maybe less so but definitely C T's but

3624
01:18:50,850 --> 01:18:50,860
 

3625
01:18:50,860 --> 01:18:51,989
again it's another way to write in it

3626
01:18:51,989 --> 01:18:51,999
 

3627
01:18:51,999 --> 01:18:55,259
nested query all right the other major

3628
01:18:55,259 --> 01:18:55,269
 

3629
01:18:55,269 --> 01:18:56,639
thing that I want to point out is that

3630
01:18:56,639 --> 01:18:56,649
 

3631
01:18:56,649 --> 01:19:00,350
again the language is from 1973 or 1974

3632
01:19:00,350 --> 01:19:00,360
 

3633
01:19:00,360 --> 01:19:03,239
but it's still widely comment you're

3634
01:19:03,239 --> 01:19:03,249
 

3635
01:19:03,249 --> 01:19:05,729
commonly used it's being updated all the

3636
01:19:05,729 --> 01:19:05,739
 

3637
01:19:05,739 --> 01:19:08,850
time and learning sequel is important

3638
01:19:08,850 --> 01:19:08,860

3639
01:19:08,860 --> 01:19:09,839
because you're gonna see this again

3640
01:19:09,839 --> 01:19:09,849
 

3641
01:19:09,849 --> 01:19:11,580
throughout your entire life pretty much

3642
01:19:11,580 --> 01:19:11,590
 

3643
01:19:11,590 --> 01:19:13,699
every single system database system that

3644
01:19:13,699 --> 01:19:13,709
 

3645
01:19:13,709 --> 01:19:16,589
you know it with some minor exceptions

3646
01:19:16,589 --> 01:19:16,599
 

3647
01:19:16,599 --> 01:19:18,089
is going to support some variant of

3648
01:19:18,089 --> 01:19:18,099
 

3649
01:19:18,099 --> 01:19:22,609
sequel okay so real quick homework one

3650
01:19:22,609 --> 01:19:22,619
 

3651
01:19:22,619 --> 01:19:24,100
media after class

3652
01:19:24,100 --> 01:19:24,110
 

3653
01:19:24,110 --> 01:19:25,890
I will upload it it'll now be available

3654
01:19:25,890 --> 01:19:25,900

3655
01:19:25,900 --> 01:19:28,060
basically we're giving you a sample

3656
01:19:28,060 --> 01:19:28,070
 

3657
01:19:28,070 --> 01:19:30,760
dataset of his bike share application

3658
01:19:30,760 --> 01:19:30,770
 

3659
01:19:30,770 --> 01:19:34,090
from San Francisco it has a few number

3660
01:19:34,090 --> 01:19:34,100
 

3661
01:19:34,100 --> 01:19:35,649
tables on it and we're asking you to

3662
01:19:35,649 --> 01:19:35,659
 

3663
01:19:35,659 --> 01:19:37,899
write queries on them so for this you

3664
01:19:37,899 --> 01:19:37,909
 

3665
01:19:37,909 --> 01:19:39,879
can view everything else galit you

3666
01:19:39,879 --> 01:19:39,889
 

3667
01:19:39,889 --> 01:19:41,439
everybody's laptop should already have

3668
01:19:41,439 --> 01:19:41,449
 

3669
01:19:41,449 --> 01:19:42,760
sequel light installed otherwise it's

3670
01:19:42,760 --> 01:19:42,770
 

3671
01:19:42,770 --> 01:19:45,430
free it's not hard to get so you write

3672
01:19:45,430 --> 01:19:45,440
 

3673
01:19:45,440 --> 01:19:46,540
all your queries with sequel light

3674
01:19:46,540 --> 01:19:46,550
 

3675
01:19:46,550 --> 01:19:48,010
locally and then you upload them the

3676
01:19:48,010 --> 01:19:48,020
 

3677
01:19:48,020 --> 01:19:49,570
grey scope and a run single light there

3678
01:19:49,570 --> 01:19:49,580
 

3679
01:19:49,580 --> 01:19:50,890
and do a diff to check them whether you

3680
01:19:50,890 --> 01:19:50,900
 

3681
01:19:50,900 --> 01:19:58,870
have the result okay guys I'll see you

3682
01:19:58,870 --> 01:19:58,880
 

3683
01:19:58,880 --> 01:20:42,700
Wednesday next week Monday put your

3684
01:20:42,700 --> 01:20:42,710
 

3685
01:20:42,710 --> 01:20:46,620
trinket 12 they say we'll make sure

3686
01:20:46,620 --> 01:20:46,630
 

3687
01:20:46,630 --> 01:20:48,390
Thayne eyes are straight so it really

3688
01:20:48,390 --> 01:20:48,400
 

3689
01:20:48,400 --> 01:20:50,850
don't matter

