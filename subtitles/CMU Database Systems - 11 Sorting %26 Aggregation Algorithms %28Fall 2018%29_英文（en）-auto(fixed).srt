1
00:00:00,730 --> 00:00:10,680
[Music]

2
00:00:10,680 --> 00:00:10,690


3
00:00:10,690 --> 00:00:17,920
maybe sorting an aggregator so this sort

4
00:00:17,920 --> 00:00:17,930
 

5
00:00:17,930 --> 00:00:20,410
of goes without saying you know it

6
00:00:20,410 --> 00:00:20,420
 

7
00:00:20,420 --> 00:00:21,970
should be sort of obvious why we need to

8
00:00:21,970 --> 00:00:21,980
 

9
00:00:21,980 --> 00:00:25,630
sort you know the relational model has

10
00:00:25,630 --> 00:00:25,640

11
00:00:25,640 --> 00:00:29,259
no ordering so so the the user might say

12
00:00:29,259 --> 00:00:29,269
 

13
00:00:29,269 --> 00:00:31,300
in their sequel query give me an order

14
00:00:31,300 --> 00:00:31,310
 

15
00:00:31,310 --> 00:00:33,580
by and therefore we have to sort of bow

16
00:00:33,580 --> 00:00:33,590
 

17
00:00:33,590 --> 00:00:35,229
as I see it as we go along

18
00:00:35,229 --> 00:00:35,239
 

19
00:00:35,239 --> 00:00:37,420
there me other scenarios where certain

20
00:00:37,420 --> 00:00:37,430
 

21
00:00:37,430 --> 00:00:38,770
algorithms or operators can be

22
00:00:38,770 --> 00:00:38,780

23
00:00:38,780 --> 00:00:41,380
implemented more efficiently by sorting

24
00:00:41,380 --> 00:00:41,390

25
00:00:41,390 --> 00:00:42,640
even though the user didn't ask us to

26
00:00:42,640 --> 00:00:42,650
 

27
00:00:42,650 --> 00:00:44,680
sort so you know there was an explicit

28
00:00:44,680 --> 00:00:44,690
 

29
00:00:44,690 --> 00:00:47,799
order by clause if we sort our tuples as

30
00:00:47,799 --> 00:00:47,809
 

31
00:00:47,809 --> 00:00:49,479
we're processing them we may end up with

32
00:00:49,479 --> 00:00:49,489
 

33
00:00:49,489 --> 00:00:51,189
they may provide us an additional

34
00:00:51,189 --> 00:00:51,199
 

35
00:00:51,199 --> 00:00:54,130
benefits and some of the things we'll be

36
00:00:54,130 --> 00:00:54,140
 

37
00:00:54,140 --> 00:00:55,630
able to do are things like we're moving

38
00:00:55,630 --> 00:00:55,640
 

39
00:00:55,640 --> 00:00:59,049
duplicates doing aggregations with group

40
00:00:59,049 --> 00:00:59,059
 

41
00:00:59,059 --> 00:01:02,950
eyes and then also bulk loading bulk

42
00:01:02,950 --> 00:01:02,960

43
00:01:02,960 --> 00:01:08,170
loading keys into an index so why am I

44
00:01:08,170 --> 00:01:08,180
 

45
00:01:08,180 --> 00:01:09,370
even bother talk about sorting right

46
00:01:09,370 --> 00:01:09,380
 

47
00:01:09,380 --> 00:01:10,570
because everyone here is basically

48
00:01:10,570 --> 00:01:10,580
 

49
00:01:10,580 --> 00:01:12,280
taking CS 101 or whatever the clothing

50
00:01:12,280 --> 00:01:12,290
 

51
00:01:12,290 --> 00:01:14,530
is at your undergrad institution right

52
00:01:14,530 --> 00:01:14,540
 

53
00:01:14,540 --> 00:01:18,880
if everything fits in memory we can use

54
00:01:18,880 --> 00:01:18,890
 

55
00:01:18,890 --> 00:01:20,860
quicksort heapsort merge sort whatever

56
00:01:20,860 --> 00:01:20,870
 

57
00:01:20,870 --> 00:01:22,360
your favorite sword is and we're done

58
00:01:22,360 --> 00:01:22,370
 

59
00:01:22,370 --> 00:01:25,090
right there's nothing you know there's

60
00:01:25,090 --> 00:01:25,100
 

61
00:01:25,100 --> 00:01:26,230
nothing magic and a database system

62
00:01:26,230 --> 00:01:26,240
 

63
00:01:26,240 --> 00:01:28,630
that'll make one sorting algorithm for

64
00:01:28,630 --> 00:01:28,640

65
00:01:28,640 --> 00:01:30,460
an in-memory workload be better than

66
00:01:30,460 --> 00:01:30,470
 

67
00:01:30,470 --> 00:01:33,430
another all right the thing that we're

68
00:01:33,430 --> 00:01:33,440
 

69
00:01:33,440 --> 00:01:35,410
gonna focus on is when a doesn't fit

70
00:01:35,410 --> 00:01:35,420
 

71
00:01:35,420 --> 00:01:37,240
memory all right that's the thing that

72
00:01:37,240 --> 00:01:37,250
 

73
00:01:37,250 --> 00:01:39,460
they don't teach you in like in intro CS

74
00:01:39,460 --> 00:01:39,470
 

75
00:01:39,470 --> 00:01:41,399
class of when you have to spilt a disk

76
00:01:41,399 --> 00:01:41,409
 

77
00:01:41,409 --> 00:01:43,690
because that's now these certain

78
00:01:43,690 --> 00:01:43,700
 

79
00:01:43,700 --> 00:01:45,190
algorithms like quicksort for example is

80
00:01:45,190 --> 00:01:45,200

81
00:01:45,200 --> 00:01:46,330
not actually what you're gonna want to

82
00:01:46,330 --> 00:01:46,340
 

83
00:01:46,340 --> 00:01:49,210
use because quicksort is all about doing

84
00:01:49,210 --> 00:01:49,220
 

85
00:01:49,220 --> 00:01:50,649
random access assumes everything in

86
00:01:50,649 --> 00:01:50,659
 

87
00:01:50,659 --> 00:01:52,899
memory so you can swap things and who

88
00:01:52,899 --> 00:01:52,909
 

89
00:01:52,909 --> 00:01:56,500
cares right if you you know if you

90
00:01:56,500 --> 00:01:56,510
 

91
00:01:56,510 --> 00:01:57,340
assume there's no i/o

92
00:01:57,340 --> 00:01:57,350
 

93
00:01:57,350 --> 00:01:59,110
but now in a database system we need to

94
00:01:59,110 --> 00:01:59,120
 

95
00:01:59,120 --> 00:02:00,460
be mindful of this because we need may

96
00:02:00,460 --> 00:02:00,470
 

97
00:02:00,470 --> 00:02:02,710
have to spilt a disk so that's all we're

98
00:02:02,710 --> 00:02:02,720
 

99
00:02:02,720 --> 00:02:05,260
gonna focus on today and so the

100
00:02:05,260 --> 00:02:05,270
 

101
00:02:05,270 --> 00:02:07,149
particular album we're gonna focus on is

102
00:02:07,149 --> 00:02:07,159
 

103
00:02:07,159 --> 00:02:09,279
called external merge sort so this is

104
00:02:09,279 --> 00:02:09,289
 

105
00:02:09,289 --> 00:02:11,410
the most frequently used external

106
00:02:11,410 --> 00:02:11,420
 

107
00:02:11,420 --> 00:02:12,550
sorting algorithm and every single

108
00:02:12,550 --> 00:02:12,560
 

109
00:02:12,560 --> 00:02:14,830
database system the may be the exact

110
00:02:14,830 --> 00:02:14,840
 

111
00:02:14,840 --> 00:02:16,530
naming of the phases or the exact

112
00:02:16,530 --> 00:02:16,540
 

113
00:02:16,540 --> 00:02:17,620
protocol

114
00:02:17,620 --> 00:02:17,630

115
00:02:17,630 --> 00:02:19,540
our methods for each step may be

116
00:02:19,540 --> 00:02:19,550
 

117
00:02:19,550 --> 00:02:22,060
different per system but a high level to

118
00:02:22,060 --> 00:02:22,070
 

119
00:02:22,070 --> 00:02:25,270
all be doing basically the same thing so

120
00:02:25,270 --> 00:02:25,280
 

121
00:02:25,280 --> 00:02:28,720
it's a sort of hybrid strategy where in

122
00:02:28,720 --> 00:02:28,730
 

123
00:02:28,730 --> 00:02:31,920
the first phase we're gonna sort the

124
00:02:31,920 --> 00:02:31,930
 

125
00:02:31,930 --> 00:02:35,590
sort our input sequence of keys into

126
00:02:35,590 --> 00:02:35,600

127
00:02:35,600 --> 00:02:37,780
small sort of runs that can fit in

128
00:02:37,780 --> 00:02:37,790
 

129
00:02:37,790 --> 00:02:40,870
memory and then we may spill in the disk

130
00:02:40,870 --> 00:02:40,880
 

131
00:02:40,880 --> 00:02:42,730
because we may not not have enough space

132
00:02:42,730 --> 00:02:42,740
 

133
00:02:42,740 --> 00:02:45,220
and then in the merge base we start

134
00:02:45,220 --> 00:02:45,230
 

135
00:02:45,230 --> 00:02:47,740
combining these sort of runs into

136
00:02:47,740 --> 00:02:47,750
 

137
00:02:47,750 --> 00:02:49,390
progressively larger and larger file

138
00:02:49,390 --> 00:02:49,400

139
00:02:49,400 --> 00:02:52,030
sizes that skin could get spilled to

140
00:02:52,030 --> 00:02:52,040
 

141
00:02:52,040 --> 00:02:54,010
disk and at some point we repeat this

142
00:02:54,010 --> 00:02:54,020
 

143
00:02:54,020 --> 00:02:56,590
merging process until we have the entire

144
00:02:56,590 --> 00:02:56,600
 

145
00:02:56,600 --> 00:03:00,460
sequence sorted right again think of

146
00:03:00,460 --> 00:03:00,470

147
00:03:00,470 --> 00:03:02,500
like where we talked about before in

148
00:03:02,500 --> 00:03:02,510
 

149
00:03:02,510 --> 00:03:06,730
that the the database system is gonna

150
00:03:06,730 --> 00:03:06,740
 

151
00:03:06,740 --> 00:03:08,770
try to maximize the amount of scrunch

152
00:03:08,770 --> 00:03:08,780
 

153
00:03:08,780 --> 00:03:10,210
will access it can do to read and write

154
00:03:10,210 --> 00:03:10,220
 

155
00:03:10,220 --> 00:03:13,090
data because you know it's assumed that

156
00:03:13,090 --> 00:03:13,100
 

157
00:03:13,100 --> 00:03:14,920
sequential access is much faster on a

158
00:03:14,920 --> 00:03:14,930
 

159
00:03:14,930 --> 00:03:16,900
disk store system so the algorithms

160
00:03:16,900 --> 00:03:16,910
 

161
00:03:16,910 --> 00:03:19,390
gonna favor doing schedule access doing

162
00:03:19,390 --> 00:03:19,400
 

163
00:03:19,400 --> 00:03:21,250
versus random writes which is what the

164
00:03:21,250 --> 00:03:21,260

165
00:03:21,260 --> 00:03:25,120
quicksort would actually we do so we're

166
00:03:25,120 --> 00:03:25,130
 

167
00:03:25,130 --> 00:03:26,560
to start off talking about the the

168
00:03:26,560 --> 00:03:26,570
 

169
00:03:26,570 --> 00:03:28,210
simple example of what's called a to

170
00:03:28,210 --> 00:03:28,220
 

171
00:03:28,220 --> 00:03:30,760
wage two-way merge sort so to a would

172
00:03:30,760 --> 00:03:30,770
 

173
00:03:30,770 --> 00:03:32,350
mean there's two sort of runs we're

174
00:03:32,350 --> 00:03:32,360

175
00:03:32,360 --> 00:03:35,590
going to merge together so well later

176
00:03:35,590 --> 00:03:35,600
 

177
00:03:35,600 --> 00:03:37,690
generalize this to okay way schirmer's

178
00:03:37,690 --> 00:03:37,700
 

179
00:03:37,700 --> 00:03:40,150
or B we can merge K different runs

180
00:03:40,150 --> 00:03:40,160
 

181
00:03:40,160 --> 00:03:41,890
together but it's easier to start off

182
00:03:41,890 --> 00:03:41,900
 

183
00:03:41,900 --> 00:03:44,140
with just two so we're going to do is we

184
00:03:44,140 --> 00:03:44,150
 

185
00:03:44,150 --> 00:03:46,030
say our file or key sequence the things

186
00:03:46,030 --> 00:03:46,040

187
00:03:46,040 --> 00:03:48,460
we want to sort will be stored broken up

188
00:03:48,460 --> 00:03:48,470
 

189
00:03:48,470 --> 00:03:50,980
into n pages and that we're gonna

190
00:03:50,980 --> 00:03:50,990
 

191
00:03:50,990 --> 00:03:52,540
restrict the database system to only

192
00:03:52,540 --> 00:03:52,550
 

193
00:03:52,550 --> 00:03:55,960
have B number of fixed size buffers that

194
00:03:55,960 --> 00:03:55,970
 

195
00:03:55,970 --> 00:03:58,690
it can use to store store these sorted

196
00:03:58,690 --> 00:03:58,700
 

197
00:03:58,700 --> 00:04:02,140
pages so again think about the reputable

198
00:04:02,140 --> 00:04:02,150
 

199
00:04:02,150 --> 00:04:04,300
assignment you guys built you can't

200
00:04:04,300 --> 00:04:04,310

201
00:04:04,310 --> 00:04:06,520
store everything in your buffer would

202
00:04:06,520 --> 00:04:06,530
 

203
00:04:06,530 --> 00:04:08,380
you run out of space so you want to

204
00:04:08,380 --> 00:04:08,390
 

205
00:04:08,390 --> 00:04:10,570
restrict how much memory you're allowing

206
00:04:10,570 --> 00:04:10,580
 

207
00:04:10,580 --> 00:04:13,840
the system to do to do these sorting so

208
00:04:13,840 --> 00:04:13,850

209
00:04:13,850 --> 00:04:15,040
that it doesn't blow away the buffer

210
00:04:15,040 --> 00:04:15,050
 

211
00:04:15,050 --> 00:04:16,330
flow every single time you need to do a

212
00:04:16,330 --> 00:04:16,340
 

213
00:04:16,340 --> 00:04:19,870
sort so the high-level algum looks like

214
00:04:19,870 --> 00:04:19,880
 

215
00:04:19,880 --> 00:04:22,510
this so in past zero we're just going to

216
00:04:22,510 --> 00:04:22,520
 

217
00:04:22,520 --> 00:04:27,040
scan through all our pages every B pages

218
00:04:27,040 --> 00:04:27,050
 

219
00:04:27,050 --> 00:04:29,110
into memory and for each page we're

220
00:04:29,110 --> 00:04:29,120
 

221
00:04:29,120 --> 00:04:31,350
going to sort them just just that page

222
00:04:31,350 --> 00:04:31,360
 

223
00:04:31,360 --> 00:04:33,360
just the values in that page and we're

224
00:04:33,360 --> 00:04:33,370
 

225
00:04:33,370 --> 00:04:36,270
gonna write that out the disk right and

226
00:04:36,270 --> 00:04:36,280
 

227
00:04:36,280 --> 00:04:39,990
so these sorted pages like what we call

228
00:04:39,990 --> 00:04:40,000
 

229
00:04:40,000 --> 00:04:42,839
it runs or sort of runs so at first the

230
00:04:42,839 --> 00:04:42,849
 

231
00:04:42,849 --> 00:04:45,929
size of the of the that's the first pass

232
00:04:45,929 --> 00:04:45,939
 

233
00:04:45,939 --> 00:04:48,540
the size of the runs will be one page

234
00:04:48,540 --> 00:04:48,550
 

235
00:04:48,550 --> 00:04:50,520
because I took a page into memory did

236
00:04:50,520 --> 00:04:50,530
 

237
00:04:50,530 --> 00:04:53,219
quicksort the sort that then wrote it

238
00:04:53,219 --> 00:04:53,229
 

239
00:04:53,229 --> 00:04:56,100
out then in the subsequent passes we're

240
00:04:56,100 --> 00:04:56,110

241
00:04:56,110 --> 00:04:57,270
going to go back and were to recursively

242
00:04:57,270 --> 00:04:57,280

243
00:04:57,280 --> 00:05:00,209
merge pairs of sort of runs together

244
00:05:00,209 --> 00:05:00,219
 

245
00:05:00,219 --> 00:05:02,909
doesn't matter which which ones we we're

246
00:05:02,909 --> 00:05:02,919

247
00:05:02,919 --> 00:05:04,800
gonna pick right you can try to be

248
00:05:04,800 --> 00:05:04,810

249
00:05:04,810 --> 00:05:06,629
intelligent and we'll see an example but

250
00:05:06,629 --> 00:05:06,639
 

251
00:05:06,639 --> 00:05:08,010
in practice I don't think nobody

252
00:05:08,010 --> 00:05:08,020
 

253
00:05:08,020 --> 00:05:11,100
actually does this and we're gonna merge

254
00:05:11,100 --> 00:05:11,110

255
00:05:11,110 --> 00:05:12,990
them together and produce a new sort of

256
00:05:12,990 --> 00:05:13,000
 

257
00:05:13,000 --> 00:05:15,240
run that's twice as big as the input

258
00:05:15,240 --> 00:05:15,250
 

259
00:05:15,250 --> 00:05:17,850
runs that we merge together and then we

260
00:05:17,850 --> 00:05:17,860
 

261
00:05:17,860 --> 00:05:20,610
keep doing this until we know the whole

262
00:05:20,610 --> 00:05:20,620
 

263
00:05:20,620 --> 00:05:23,999
thing is sort of so for this algorithm

264
00:05:23,999 --> 00:05:24,009
 

265
00:05:24,009 --> 00:05:25,800
we're only going to need three buffer

266
00:05:25,800 --> 00:05:25,810
 

267
00:05:25,810 --> 00:05:28,950
pool pages we need one page two pages

268
00:05:28,950 --> 00:05:28,960
 

269
00:05:28,960 --> 00:05:32,010
for the input for our two runs and then

270
00:05:32,010 --> 00:05:32,020
 

271
00:05:32,020 --> 00:05:33,510
one page for the output because we have

272
00:05:33,510 --> 00:05:33,520

273
00:05:33,520 --> 00:05:36,779
to always write it out so again at a

274
00:05:36,779 --> 00:05:36,789
 

275
00:05:36,789 --> 00:05:38,459
high level sort of looks like this say

276
00:05:38,459 --> 00:05:38,469
 

277
00:05:38,469 --> 00:05:40,559
that we have our database on disk and we

278
00:05:40,559 --> 00:05:40,569
 

279
00:05:40,569 --> 00:05:42,450
have two two pages and they're unsorted

280
00:05:42,450 --> 00:05:42,460

281
00:05:42,460 --> 00:05:45,089
when I fetch the first page store it

282
00:05:45,089 --> 00:05:45,099
 

283
00:05:45,099 --> 00:05:47,490
write it back out the disk fetch the

284
00:05:47,490 --> 00:05:47,500
 

285
00:05:47,500 --> 00:05:49,980
next page sort it write it out the disk

286
00:05:49,980 --> 00:05:49,990
 

287
00:05:49,990 --> 00:05:52,200
and then we'll fetch the two pages

288
00:05:52,200 --> 00:05:52,210
 

289
00:05:52,210 --> 00:05:54,869
together and then write the first you

290
00:05:54,869 --> 00:05:54,879
 

291
00:05:54,879 --> 00:05:57,180
know combine the first combine the two

292
00:05:57,180 --> 00:05:57,190
 

293
00:05:57,190 --> 00:05:59,040
together to make a new page then combine

294
00:05:59,040 --> 00:05:59,050
 

295
00:05:59,050 --> 00:06:00,480
the second page two together and make

296
00:06:00,480 --> 00:06:00,490
 

297
00:06:00,490 --> 00:06:03,240
the second page write the high/low this

298
00:06:03,240 --> 00:06:03,250
 

299
00:06:03,250 --> 00:06:07,709
is what we're doing so it's a this is

300
00:06:07,709 --> 00:06:07,719
 

301
00:06:07,719 --> 00:06:09,649
considered a divide-and-conquer strategy

302
00:06:09,649 --> 00:06:09,659
 

303
00:06:09,659 --> 00:06:12,300
right because what we're doing is rather

304
00:06:12,300 --> 00:06:12,310
 

305
00:06:12,310 --> 00:06:13,649
than trying to merge sort everything

306
00:06:13,649 --> 00:06:13,659
 

307
00:06:13,659 --> 00:06:14,969
which is what quicksort do want to do

308
00:06:14,969 --> 00:06:14,979
 

309
00:06:14,979 --> 00:06:17,369
order some more sort smaller chunks and

310
00:06:17,369 --> 00:06:17,379

311
00:06:17,379 --> 00:06:19,589
then we're gonna combine it together as

312
00:06:19,589 --> 00:06:19,599
 

313
00:06:19,599 --> 00:06:22,019
we go along and being smart about how we

314
00:06:22,019 --> 00:06:22,029
 

315
00:06:22,029 --> 00:06:25,649
read and ready data it up is our input

316
00:06:25,649 --> 00:06:25,659
 

317
00:06:25,659 --> 00:06:27,899
sequence I mean a little marker here at

318
00:06:27,899 --> 00:06:27,909
 

319
00:06:27,909 --> 00:06:29,420
the end they say we have the end of file

320
00:06:29,420 --> 00:06:29,430
 

321
00:06:29,430 --> 00:06:32,490
so in the first pass we're just gonna

322
00:06:32,490 --> 00:06:32,500
 

323
00:06:32,500 --> 00:06:35,640
take each page and just run quicksort on

324
00:06:35,640 --> 00:06:35,650
 

325
00:06:35,650 --> 00:06:37,800
it and sort that and then write each of

326
00:06:37,800 --> 00:06:37,810
 

327
00:06:37,810 --> 00:06:41,610
those pages out then in the second pass

328
00:06:41,610 --> 00:06:41,620
 

329
00:06:41,620 --> 00:06:44,939
we take two adjacent pages combine them

330
00:06:44,939 --> 00:06:44,949
 

331
00:06:44,949 --> 00:06:45,510
together

332
00:06:45,510 --> 00:06:45,520

333
00:06:45,520 --> 00:06:48,270
and then write those out so again what

334
00:06:48,270 --> 00:06:48,280
 

335
00:06:48,280 --> 00:06:50,159
I'm saying before the we're not we don't

336
00:06:50,159 --> 00:06:50,169
 

337
00:06:50,169 --> 00:06:52,260
need to be smart and say like oh well I

338
00:06:52,260 --> 00:06:52,270
 

339
00:06:52,270 --> 00:06:54,240
know that this one starts to the three

340
00:06:54,240 --> 00:06:54,250
 

341
00:06:54,250 --> 00:06:56,010
and this one starts for the one so maybe

342
00:06:56,010 --> 00:06:56,020
 

343
00:06:56,020 --> 00:06:57,839
I want to merge these two guys together

344
00:06:57,839 --> 00:06:57,849
 

345
00:06:57,849 --> 00:06:59,730
you don't have to do that I don't know

346
00:06:59,730 --> 00:06:59,740
 

347
00:06:59,740 --> 00:07:01,350
if anybody actually does that and

348
00:07:01,350 --> 00:07:01,360
 

349
00:07:01,360 --> 00:07:03,240
practice the algorithm just works okay

350
00:07:03,240 --> 00:07:03,250
 

351
00:07:03,250 --> 00:07:05,309
as it is you can say all right just

352
00:07:05,309 --> 00:07:05,319
 

353
00:07:05,319 --> 00:07:06,659
these two guys are nexted together I'm

354
00:07:06,659 --> 00:07:06,669
 

355
00:07:06,669 --> 00:07:09,770
just gonna merge them together all right

356
00:07:09,770 --> 00:07:09,780
 

357
00:07:09,780 --> 00:07:12,360
and what will happen is the reason why

358
00:07:12,360 --> 00:07:12,370
 

359
00:07:12,370 --> 00:07:15,839
you we only need three pages to do this

360
00:07:15,839 --> 00:07:15,849
 

361
00:07:15,849 --> 00:07:19,800
is because as I as I say it start with

362
00:07:19,800 --> 00:07:19,810
 

363
00:07:19,810 --> 00:07:22,469
these two guys here as I'm scanning them

364
00:07:22,469 --> 00:07:22,479
 

365
00:07:22,479 --> 00:07:26,070
I just do a you know a comparison versus

366
00:07:26,070 --> 00:07:26,080
 

367
00:07:26,080 --> 00:07:27,450
wherever my cursor is in the first page

368
00:07:27,450 --> 00:07:27,460
 

369
00:07:27,460 --> 00:07:29,219
where my cursor is in the second page

370
00:07:29,219 --> 00:07:29,229
 

371
00:07:29,229 --> 00:07:31,950
and then whatever one is is less gets

372
00:07:31,950 --> 00:07:31,960
 

373
00:07:31,960 --> 00:07:33,600
written out and then that cursor moves

374
00:07:33,600 --> 00:07:33,610
 

375
00:07:33,610 --> 00:07:36,480
down and I never have to backtrack all

376
00:07:36,480 --> 00:07:36,490
 

377
00:07:36,490 --> 00:07:37,740
right so I never have maybe scanned down

378
00:07:37,740 --> 00:07:37,750
 

379
00:07:37,750 --> 00:07:40,140
one page and then had to go back and

380
00:07:40,140 --> 00:07:40,150
 

381
00:07:40,150 --> 00:07:43,140
fetch it again as I'm doing my

382
00:07:43,140 --> 00:07:43,150
 

383
00:07:43,150 --> 00:07:44,460
comparisons and my cursors are moving

384
00:07:44,460 --> 00:07:44,470
 

385
00:07:44,470 --> 00:07:46,469
down and I'm writing those pages out I'd

386
00:07:46,469 --> 00:07:46,479
 

387
00:07:46,479 --> 00:07:48,570
never have to go back so I only need two

388
00:07:48,570 --> 00:07:48,580
 

389
00:07:48,580 --> 00:07:50,610
pages or two pages for input one page

390
00:07:50,610 --> 00:07:50,620
 

391
00:07:50,620 --> 00:07:53,010
for output and at the the page I'm

392
00:07:53,010 --> 00:07:53,020
 

393
00:07:53,020 --> 00:07:54,240
running or is my output it gets to its

394
00:07:54,240 --> 00:07:54,250
 

395
00:07:54,250 --> 00:07:56,550
you know is full then that gets written

396
00:07:56,550 --> 00:07:56,560
 

397
00:07:56,560 --> 00:07:57,870
out the disk and I just start start a

398
00:07:57,870 --> 00:07:57,880
 

399
00:07:57,880 --> 00:08:01,770
new page continue down the third past

400
00:08:01,770 --> 00:08:01,780
 

401
00:08:01,780 --> 00:08:03,689
same thing we could bind them again and

402
00:08:03,689 --> 00:08:03,699
 

403
00:08:03,699 --> 00:08:05,339
then we get down to the bottom here and

404
00:08:05,339 --> 00:08:05,349
 

405
00:08:05,349 --> 00:08:08,700
we have our completely sorted sorted

406
00:08:08,700 --> 00:08:08,710

407
00:08:08,710 --> 00:08:11,820
sequence so for the two way merge sort

408
00:08:11,820 --> 00:08:11,830
 

409
00:08:11,830 --> 00:08:14,189
the the algorithm for determining the

410
00:08:14,189 --> 00:08:14,199

411
00:08:14,199 --> 00:08:15,510
number passes we're gonna need to do is

412
00:08:15,510 --> 00:08:15,520
 

413
00:08:15,520 --> 00:08:19,379
one plus this the ceiling of log to n so

414
00:08:19,379 --> 00:08:19,389
 

415
00:08:19,389 --> 00:08:22,649
the total IO cost the number page you

416
00:08:22,649 --> 00:08:22,659
 

417
00:08:22,659 --> 00:08:24,659
get the read and write compute this

418
00:08:24,659 --> 00:08:24,669
 

419
00:08:24,669 --> 00:08:27,570
algorithm to this this sort of sequence

420
00:08:27,570 --> 00:08:27,580
 

421
00:08:27,580 --> 00:08:31,140
it's 2 n times n of our passes right for

422
00:08:31,140 --> 00:08:31,150
 

423
00:08:31,150 --> 00:08:33,510
each pass we gotta do one for every page

424
00:08:33,510 --> 00:08:33,520
 

425
00:08:33,520 --> 00:08:35,610
we add weight to read it in and write it

426
00:08:35,610 --> 00:08:35,620
 

427
00:08:35,620 --> 00:08:38,430
out so that's why it's 2 n the first n

428
00:08:38,430 --> 00:08:38,440
 

429
00:08:38,440 --> 00:08:40,290
is for the read for the second animal is

430
00:08:40,290 --> 00:08:40,300

431
00:08:40,300 --> 00:08:42,209
for the right and we do this times a

432
00:08:42,209 --> 00:08:42,219
 

433
00:08:42,219 --> 00:08:45,960
number of passes that we have pretty

434
00:08:45,960 --> 00:08:45,970
 

435
00:08:45,970 --> 00:08:52,560
straightforward right yes

436
00:08:52,560 --> 00:08:52,570


437
00:08:52,570 --> 00:08:54,280
this question is what happens to

438
00:08:54,280 --> 00:08:54,290
 

439
00:08:54,290 --> 00:08:55,660
intermediate pages so say you're like

440
00:08:55,660 --> 00:08:55,670

441
00:08:55,670 --> 00:09:00,010
here and I I combine these two guys and

442
00:09:00,010 --> 00:09:00,020
 

443
00:09:00,020 --> 00:09:03,130
I sort them like again think of it like

444
00:09:03,130 --> 00:09:03,140
 

445
00:09:03,140 --> 00:09:05,320
it you have a cursor here and a cursor

446
00:09:05,320 --> 00:09:05,330
 

447
00:09:05,330 --> 00:09:07,110
there and they're saying all right

448
00:09:07,110 --> 00:09:07,120
 

449
00:09:07,120 --> 00:09:09,220
what's what's the first two keys I want

450
00:09:09,220 --> 00:09:09,230
 

451
00:09:09,230 --> 00:09:11,440
to compare across these two runs so this

452
00:09:11,440 --> 00:09:11,450
 

453
00:09:11,450 --> 00:09:13,690
one would be 2 and this one would be 4 2

454
00:09:13,690 --> 00:09:13,700
 

455
00:09:13,700 --> 00:09:14,710
is less than 4

456
00:09:14,710 --> 00:09:14,720
 

457
00:09:14,720 --> 00:09:16,240
so I write that out to my output page

458
00:09:16,240 --> 00:09:16,250
 

459
00:09:16,250 --> 00:09:18,610
then the cursor moves down by one so

460
00:09:18,610 --> 00:09:18,620
 

461
00:09:18,620 --> 00:09:20,410
then I compare 3 and 4

462
00:09:20,410 --> 00:09:20,420
 

463
00:09:20,420 --> 00:09:22,960
well 3 is less than 4 so 3 gets written

464
00:09:22,960 --> 00:09:22,970
 

465
00:09:22,970 --> 00:09:24,790
out and that cursor moves down now we

466
00:09:24,790 --> 00:09:24,800
 

467
00:09:24,800 --> 00:09:27,580
get for 4 and then you flip a coin to be

468
00:09:27,580 --> 00:09:27,590
 

469
00:09:27,590 --> 00:09:29,170
one or the other doesn't matter so

470
00:09:29,170 --> 00:09:29,180
 

471
00:09:29,180 --> 00:09:31,330
you're sort of you're populating one

472
00:09:31,330 --> 00:09:31,340

473
00:09:31,340 --> 00:09:33,520
output page at a time and then when it's

474
00:09:33,520 --> 00:09:33,530
 

475
00:09:33,530 --> 00:09:35,500
full it gets written out the disk and

476
00:09:35,500 --> 00:09:35,510
 

477
00:09:35,510 --> 00:09:36,880
you just start with a new fresh page and

478
00:09:36,880 --> 00:09:36,890
 

479
00:09:36,890 --> 00:09:39,130
then you can you maintain some internal

480
00:09:39,130 --> 00:09:39,140

481
00:09:39,140 --> 00:09:40,510
metadata to say all right for this

482
00:09:40,510 --> 00:09:40,520
 

483
00:09:40,520 --> 00:09:43,240
sorted run page one two three and four

484
00:09:43,240 --> 00:09:43,250
 

485
00:09:43,250 --> 00:09:45,850
it can be found here all right going

486
00:09:45,850 --> 00:09:45,860
 

487
00:09:45,860 --> 00:09:47,200
that sequence they may not may not be

488
00:09:47,200 --> 00:09:47,210
 

489
00:09:47,210 --> 00:09:49,210
contiguous in memory but all right so

490
00:09:49,210 --> 00:09:49,220
 

491
00:09:49,220 --> 00:09:50,860
own disk but in practice you would want

492
00:09:50,860 --> 00:09:50,870
 

493
00:09:50,870 --> 00:09:59,890
them to be yes where's the what sorry so

494
00:09:59,890 --> 00:09:59,900
 

495
00:09:59,900 --> 00:10:01,120
where's that one come from

496
00:10:01,120 --> 00:10:01,130

497
00:10:01,130 --> 00:10:05,770
oh there's number of passes because you

498
00:10:05,770 --> 00:10:05,780

499
00:10:05,780 --> 00:10:07,000
always think you always need the first

500
00:10:07,000 --> 00:10:07,010
 

501
00:10:07,010 --> 00:10:08,110
pass you always have to go through at

502
00:10:08,110 --> 00:10:08,120
 

503
00:10:08,120 --> 00:10:19,660
once that's unavoidable right like it

504
00:10:19,660 --> 00:10:19,670
 

505
00:10:19,670 --> 00:10:22,980
and this is just dividing it by you know

506
00:10:22,980 --> 00:10:22,990
 

507
00:10:22,990 --> 00:10:25,690
you're having the having the number of

508
00:10:25,690 --> 00:10:25,700
 

509
00:10:25,700 --> 00:10:29,230
sort of runs you have as you go down so

510
00:10:29,230 --> 00:10:29,240

511
00:10:29,240 --> 00:10:30,640
you need one one pass as always to go

512
00:10:30,640 --> 00:10:30,650
 

513
00:10:30,650 --> 00:10:33,750
through it first time question here no

514
00:10:33,750 --> 00:10:33,760
 

515
00:10:33,760 --> 00:10:39,610
okay all right so again this particular

516
00:10:39,610 --> 00:10:39,620
 

517
00:10:39,620 --> 00:10:42,130
album only requires three buffer pages

518
00:10:42,130 --> 00:10:42,140
 

519
00:10:42,140 --> 00:10:44,230
it turns out if you have more than three

520
00:10:44,230 --> 00:10:44,240
 

521
00:10:44,240 --> 00:10:46,120
buffer pages you actually not going to

522
00:10:46,120 --> 00:10:46,130
 

523
00:10:46,130 --> 00:10:48,550
get a good performance because you're

524
00:10:48,550 --> 00:10:48,560
 

525
00:10:48,560 --> 00:10:50,760
not gonna effectively be utilizing them

526
00:10:50,760 --> 00:10:50,770
 

527
00:10:50,770 --> 00:10:54,310
so I don't go into details of the the

528
00:10:54,310 --> 00:10:54,320
 

529
00:10:54,320 --> 00:10:56,320
general merge sort algorithm other than

530
00:10:56,320 --> 00:10:56,330
 

531
00:10:56,330 --> 00:10:58,690
to say that the peers what the math

532
00:10:58,690 --> 00:10:58,700
 

533
00:10:58,700 --> 00:11:01,120
looks like the basic idea is that you

534
00:11:01,120 --> 00:11:01,130
 

535
00:11:01,130 --> 00:11:02,950
instead of computing the the number of

536
00:11:02,950 --> 00:11:02,960
 

537
00:11:02,960 --> 00:11:04,700
passes based on

538
00:11:04,700 --> 00:11:04,710

539
00:11:04,710 --> 00:11:07,610
to you you base it on the number of runs

540
00:11:07,610 --> 00:11:07,620
 

541
00:11:07,620 --> 00:11:09,470
that you have now such of what you're

542
00:11:09,470 --> 00:11:09,480
 

543
00:11:09,480 --> 00:11:10,910
doing is for every single pass instead

544
00:11:10,910 --> 00:11:10,920
 

545
00:11:10,920 --> 00:11:12,230
of merging just tooth and runs together

546
00:11:12,230 --> 00:11:12,240
 

547
00:11:12,240 --> 00:11:14,390
now you're merging K runs together and

548
00:11:14,390 --> 00:11:14,400
 

549
00:11:14,400 --> 00:11:15,950
the algorithm says works the same way

550
00:11:15,950 --> 00:11:15,960
 

551
00:11:15,960 --> 00:11:17,930
every run you're combining together you

552
00:11:17,930 --> 00:11:17,940
 

553
00:11:17,940 --> 00:11:19,490
have a cursor you do comparison across

554
00:11:19,490 --> 00:11:19,500
 

555
00:11:19,500 --> 00:11:20,810
all of them and then which when everyone

556
00:11:20,810 --> 00:11:20,820
 

557
00:11:20,820 --> 00:11:22,790
is the smallest that gets put in the

558
00:11:22,790 --> 00:11:22,800
 

559
00:11:22,800 --> 00:11:23,930
output buffer and you move that cursor

560
00:11:23,930 --> 00:11:23,940
 

561
00:11:23,940 --> 00:11:28,190
down by one and so in general the the

562
00:11:28,190 --> 00:11:28,200
 

563
00:11:28,200 --> 00:11:29,270
formula for determining the number

564
00:11:29,270 --> 00:11:29,280
 

565
00:11:29,280 --> 00:11:31,850
passes you have to do is one plus the

566
00:11:31,850 --> 00:11:31,860
 

567
00:11:31,860 --> 00:11:33,920
ceiling of log B B minus 1 and the

568
00:11:33,920 --> 00:11:33,930
 

569
00:11:33,930 --> 00:11:36,800
ceiling over B and the total cost of

570
00:11:36,800 --> 00:11:36,810
 

571
00:11:36,810 --> 00:11:38,390
that again it's two times and rep asses

572
00:11:38,390 --> 00:11:38,400
 

573
00:11:38,400 --> 00:11:45,910
that's always gonna be the same okay

574
00:11:45,910 --> 00:11:45,920


575
00:11:45,920 --> 00:11:47,990
again this is almost a plug and chug

576
00:11:47,990 --> 00:11:48,000
 

577
00:11:48,000 --> 00:11:51,860
kind of thing doing a civil example I'm

578
00:11:51,860 --> 00:11:51,870
 

579
00:11:51,870 --> 00:11:52,910
not gonna go through all icky all of

580
00:11:52,910 --> 00:11:52,920
 

581
00:11:52,920 --> 00:11:54,140
this but this this will just walk you

582
00:11:54,140 --> 00:11:54,150
 

583
00:11:54,150 --> 00:11:58,880
through how the math works out okay and

584
00:11:58,880 --> 00:11:58,890
 

585
00:11:58,890 --> 00:12:00,950
I think there's a homework that it

586
00:12:00,950 --> 00:12:00,960
 

587
00:12:00,960 --> 00:12:09,590
basically does the same thing okay so we

588
00:12:09,590 --> 00:12:09,600
 

589
00:12:09,600 --> 00:12:11,030
can actually use B trees to speed things

590
00:12:11,030 --> 00:12:11,040
 

591
00:12:11,040 --> 00:12:13,220
up but we have the same distinction that

592
00:12:13,220 --> 00:12:13,230
 

593
00:12:13,230 --> 00:12:14,510
we have before whether you have a

594
00:12:14,510 --> 00:12:14,520
 

595
00:12:14,520 --> 00:12:16,160
clustered index or a none clustered

596
00:12:16,160 --> 00:12:16,170
 

597
00:12:16,170 --> 00:12:21,290
index the in general if you need to do

598
00:12:21,290 --> 00:12:21,300

599
00:12:21,300 --> 00:12:24,500
sorting and you have a B+ tree available

600
00:12:24,500 --> 00:12:24,510
 

601
00:12:24,510 --> 00:12:27,890
to you that is that is indexed on the

602
00:12:27,890 --> 00:12:27,900
 

603
00:12:27,900 --> 00:12:31,190
key you want to sort by then the every

604
00:12:31,190 --> 00:12:31,200
 

605
00:12:31,200 --> 00:12:32,900
dataset is always gonna try to use that

606
00:12:32,900 --> 00:12:32,910
 

607
00:12:32,910 --> 00:12:34,940
instead of doing the the external merge

608
00:12:34,940 --> 00:12:34,950
 

609
00:12:34,950 --> 00:12:39,170
sort right because the way you think

610
00:12:39,170 --> 00:12:39,180
 

611
00:12:39,180 --> 00:12:40,460
about this you're paying an upfront cost

612
00:12:40,460 --> 00:12:40,470
 

613
00:12:40,470 --> 00:12:43,460
of maintaining the indexes Internode's

614
00:12:43,460 --> 00:12:43,470
 

615
00:12:43,470 --> 00:12:47,450
to mate to sort of baked into the index

616
00:12:47,450 --> 00:12:47,460
 

617
00:12:47,460 --> 00:12:49,190
the the sort order along the leaf nodes

618
00:12:49,190 --> 00:12:49,200
 

619
00:12:49,200 --> 00:12:50,870
you're already paying that cost to

620
00:12:50,870 --> 00:12:50,880
 

621
00:12:50,880 --> 00:12:52,550
maintain that sort ordering in the index

622
00:12:52,550 --> 00:12:52,560
 

623
00:12:52,560 --> 00:12:54,950
and so that's why it's gonna be faster

624
00:12:54,950 --> 00:12:54,960
 

625
00:12:54,960 --> 00:12:56,060
to use that instead of instead of

626
00:12:56,060 --> 00:12:56,070
 

627
00:12:56,070 --> 00:12:57,590
actually computing the the sort order on

628
00:12:57,590 --> 00:12:57,600
 

629
00:12:57,600 --> 00:13:00,380
the fly with external merge sort so in

630
00:13:00,380 --> 00:13:00,390
 

631
00:13:00,390 --> 00:13:01,700
general the optimizer is gonna be smart

632
00:13:01,700 --> 00:13:01,710
 

633
00:13:01,710 --> 00:13:03,380
enough to recognize oh I have an index

634
00:13:03,380 --> 00:13:03,390
 

635
00:13:03,390 --> 00:13:05,300
on the thing I want to order by let me

636
00:13:05,300 --> 00:13:05,310
 

637
00:13:05,310 --> 00:13:07,480
use that instead of actually doing the

638
00:13:07,480 --> 00:13:07,490
 

639
00:13:07,490 --> 00:13:09,770
they were doing the merge sort manually

640
00:13:09,770 --> 00:13:09,780

641
00:13:09,780 --> 00:13:11,570
but again they can only do this if you

642
00:13:11,570 --> 00:13:11,580
 

643
00:13:11,580 --> 00:13:13,190
have a clustered index so this is what

644
00:13:13,190 --> 00:13:13,200
 

645
00:13:13,200 --> 00:13:17,490
we talked about before right so if the

646
00:13:17,490 --> 00:13:17,500
 

647
00:13:17,500 --> 00:13:19,110
if the records we need to read are

648
00:13:19,110 --> 00:13:19,120
 

649
00:13:19,120 --> 00:13:21,060
sorted in the order that are specified

650
00:13:21,060 --> 00:13:21,070
 

651
00:13:21,070 --> 00:13:24,210
by the index then we just jump to where

652
00:13:24,210 --> 00:13:24,220
 

653
00:13:24,220 --> 00:13:26,010
we need to based on the leaf page and

654
00:13:26,010 --> 00:13:26,020
 

655
00:13:26,020 --> 00:13:29,070
just scan across and we're good to go we

656
00:13:29,070 --> 00:13:29,080
 

657
00:13:29,080 --> 00:13:30,630
know the output is already sorted in the

658
00:13:30,630 --> 00:13:30,640
 

659
00:13:30,640 --> 00:13:32,190
order that we want alright there's not

660
00:13:32,190 --> 00:13:32,200
 

661
00:13:32,200 --> 00:13:33,780
there's no extra step we have to do in

662
00:13:33,780 --> 00:13:33,790
 

663
00:13:33,790 --> 00:13:37,080
the case of the on clustered B+ treating

664
00:13:37,080 --> 00:13:37,090
 

665
00:13:37,090 --> 00:13:39,510
like a secondary index like these sort

666
00:13:39,510 --> 00:13:39,520
 

667
00:13:39,520 --> 00:13:42,450
ordering is all over the map so we may

668
00:13:42,450 --> 00:13:42,460
 

669
00:13:42,460 --> 00:13:46,080
not doing more i/o you know then we

670
00:13:46,080 --> 00:13:46,090
 

671
00:13:46,090 --> 00:13:47,490
would have it we just did our external

672
00:13:47,490 --> 00:13:47,500
 

673
00:13:47,500 --> 00:13:50,310
merge sort so these kind of forms that

674
00:13:50,310 --> 00:13:50,320
 

675
00:13:50,320 --> 00:13:51,900
I'm showing here this is essentially

676
00:13:51,900 --> 00:13:51,910
 

677
00:13:51,910 --> 00:13:53,430
what the query optimizer is gonna do in

678
00:13:53,430 --> 00:13:53,440
 

679
00:13:53,440 --> 00:13:54,660
the database system it's gonna recognize

680
00:13:54,660 --> 00:13:54,670
 

681
00:13:54,670 --> 00:13:56,820
oh I have an index but it might might

682
00:13:56,820 --> 00:13:56,830
 

683
00:13:56,830 --> 00:14:00,210
it's it's uncluttered and I have this

684
00:14:00,210 --> 00:14:00,220
 

685
00:14:00,220 --> 00:14:01,920
amount of memory I can use from to my

686
00:14:01,920 --> 00:14:01,930
 

687
00:14:01,930 --> 00:14:03,540
sorting it can use that to make

688
00:14:03,540 --> 00:14:03,550
 

689
00:14:03,550 --> 00:14:04,950
trade-off decisions about whether it's

690
00:14:04,950 --> 00:14:04,960

691
00:14:04,960 --> 00:14:06,930
better to do the index scan on the

692
00:14:06,930 --> 00:14:06,940
 

693
00:14:06,940 --> 00:14:08,400
uncluttered index or just do the

694
00:14:08,400 --> 00:14:08,410
 

695
00:14:08,410 --> 00:14:10,920
external merge sort and this is the

696
00:14:10,920 --> 00:14:10,930
 

697
00:14:10,930 --> 00:14:12,120
beauty of sequel or declarative

698
00:14:12,120 --> 00:14:12,130
 

699
00:14:12,130 --> 00:14:13,920
languages this is not something you as

700
00:14:13,920 --> 00:14:13,930
 

701
00:14:13,930 --> 00:14:15,180
the programmer have to know about the

702
00:14:15,180 --> 00:14:15,190

703
00:14:15,190 --> 00:14:15,990
system just does it for you

704
00:14:15,990 --> 00:14:16,000
 

705
00:14:16,000 --> 00:14:17,550
automatically it's not gonna always get

706
00:14:17,550 --> 00:14:17,560
 

707
00:14:17,560 --> 00:14:19,740
it right but in general its me better

708
00:14:19,740 --> 00:14:19,750
 

709
00:14:19,750 --> 00:14:23,040
than what any human can do right so in

710
00:14:23,040 --> 00:14:23,050
 

711
00:14:23,050 --> 00:14:25,850
this example here we talked about how to

712
00:14:25,850 --> 00:14:25,860
 

713
00:14:25,860 --> 00:14:27,840
when we talked about the query

714
00:14:27,840 --> 00:14:27,850
 

715
00:14:27,850 --> 00:14:29,610
processing stuff how if I could

716
00:14:29,610 --> 00:14:29,620

717
00:14:29,620 --> 00:14:31,230
recognize that oh I'm gonna fetch these

718
00:14:31,230 --> 00:14:31,240
 

719
00:14:31,240 --> 00:14:33,750
pages these tuples need different pages

720
00:14:33,750 --> 00:14:33,760
 

721
00:14:33,760 --> 00:14:36,210
maybe sort them by their page ID so I'm

722
00:14:36,210 --> 00:14:36,220
 

723
00:14:36,220 --> 00:14:38,760
having you know reusing every page I

724
00:14:38,760 --> 00:14:38,770
 

725
00:14:38,770 --> 00:14:40,830
fetch fetch in but if you do that now

726
00:14:40,830 --> 00:14:40,840
 

727
00:14:40,840 --> 00:14:43,190
you ruined the the sort order

728
00:14:43,190 --> 00:14:43,200
 

729
00:14:43,200 --> 00:14:45,120
so you defecating at the maintain some

730
00:14:45,120 --> 00:14:45,130
 

731
00:14:45,130 --> 00:14:46,710
an extra metadata to put it all back in

732
00:14:46,710 --> 00:14:46,720
 

733
00:14:46,720 --> 00:14:47,880
the correct order when you're done and

734
00:14:47,880 --> 00:14:47,890
 

735
00:14:47,890 --> 00:14:49,860
at that point you might just be again

736
00:14:49,860 --> 00:14:49,870
 

737
00:14:49,870 --> 00:14:51,240
better off just doing the external merge

738
00:14:51,240 --> 00:14:51,250
 

739
00:14:51,250 --> 00:14:53,720
sort

740
00:14:53,720 --> 00:14:53,730


741
00:14:53,730 --> 00:14:58,830
alright so now we know how to sort what

742
00:14:58,830 --> 00:14:58,840
 

743
00:14:58,840 --> 00:15:01,200
can we do with it right obviously again

744
00:15:01,200 --> 00:15:01,210
 

745
00:15:01,210 --> 00:15:03,210
order by is easy if the user asks for

746
00:15:03,210 --> 00:15:03,220
 

747
00:15:03,220 --> 00:15:06,690
that we have to sort it so we can use

748
00:15:06,690 --> 00:15:06,700
 

749
00:15:06,700 --> 00:15:08,580
that algorithm but we can use it for

750
00:15:08,580 --> 00:15:08,590
 

751
00:15:08,590 --> 00:15:11,190
aggregations as well so how would you

752
00:15:11,190 --> 00:15:11,200

753
00:15:11,200 --> 00:15:13,710
use it for the aggregation it's pretty

754
00:15:13,710 --> 00:15:13,720
 

755
00:15:13,720 --> 00:15:15,660
straightforward right so say I'm doing a

756
00:15:15,660 --> 00:15:15,670
 

757
00:15:15,670 --> 00:15:18,810
distinct on the course ID here if it is

758
00:15:18,810 --> 00:15:18,820

759
00:15:18,820 --> 00:15:21,330
query so the query plan would first go

760
00:15:21,330 --> 00:15:21,340

761
00:15:21,340 --> 00:15:23,790
do a central scan on the table apply the

762
00:15:23,790 --> 00:15:23,800
 

763
00:15:23,800 --> 00:15:25,590
filter on that's in the where clause

764
00:15:25,590 --> 00:15:25,600

765
00:15:25,600 --> 00:15:27,870
then do a projection to remove any

766
00:15:27,870 --> 00:15:27,880
 

767
00:15:27,880 --> 00:15:29,760
column so we don't want and then now do

768
00:15:29,760 --> 00:15:29,770
 

769
00:15:29,770 --> 00:15:31,350
our sorting

770
00:15:31,350 --> 00:15:31,360
 

771
00:15:31,360 --> 00:15:33,840
to sort the keys that they want in the

772
00:15:33,840 --> 00:15:33,850
 

773
00:15:33,850 --> 00:15:35,970
output and now we just have a cursor

774
00:15:35,970 --> 00:15:35,980
 

775
00:15:35,980 --> 00:15:37,850
walk through this sort of output and

776
00:15:37,850 --> 00:15:37,860
 

777
00:15:37,860 --> 00:15:41,610
maintain the little buffer that says

778
00:15:41,610 --> 00:15:41,620
 

779
00:15:41,620 --> 00:15:43,530
what's the last value that I looked at

780
00:15:43,530 --> 00:15:43,540
 

781
00:15:43,540 --> 00:15:45,810
so that if I come across a value that

782
00:15:45,810 --> 00:15:45,820
 

783
00:15:45,820 --> 00:15:47,819
I've seen before then I know it's a

784
00:15:47,819 --> 00:15:47,829
 

785
00:15:47,829 --> 00:15:49,860
duplicate and I can just skip it and not

786
00:15:49,860 --> 00:15:49,870
 

787
00:15:49,870 --> 00:15:52,410
include it in my output here so this is

788
00:15:52,410 --> 00:15:52,420
 

789
00:15:52,420 --> 00:15:53,430
advantage again this is another example

790
00:15:53,430 --> 00:15:53,440
 

791
00:15:53,440 --> 00:15:55,889
of where sorting can be used for

792
00:15:55,889 --> 00:15:55,899
 

793
00:15:55,899 --> 00:15:57,389
something not just for order by queries

794
00:15:57,389 --> 00:15:57,399
 

795
00:15:57,399 --> 00:15:59,220
you can do it for - making eternal

796
00:15:59,220 --> 00:15:59,230
 

797
00:15:59,230 --> 00:16:04,009
operations go much much more quickly so

798
00:16:04,009 --> 00:16:04,019
 

799
00:16:04,019 --> 00:16:06,540
this is pretty common a bunch of systems

800
00:16:06,540 --> 00:16:06,550
 

801
00:16:06,550 --> 00:16:09,090
will actually support this but actually

802
00:16:09,090 --> 00:16:09,100
 

803
00:16:09,100 --> 00:16:10,920
the most common way to do aggregations

804
00:16:10,920 --> 00:16:10,930
 

805
00:16:10,930 --> 00:16:16,410
is to do hashing so if you don't care

806
00:16:16,410 --> 00:16:16,420
 

807
00:16:16,420 --> 00:16:20,190
about things being ordered then running

808
00:16:20,190 --> 00:16:20,200
 

809
00:16:20,200 --> 00:16:21,569
maybe the external merge sort algorithm

810
00:16:21,569 --> 00:16:21,579
 

811
00:16:21,579 --> 00:16:23,579
that would be just too expensive and a

812
00:16:23,579 --> 00:16:23,589
 

813
00:16:23,589 --> 00:16:24,840
cheaper thing to do is actually just do

814
00:16:24,840 --> 00:16:24,850
 

815
00:16:24,850 --> 00:16:26,220
hashing so we can use the hash table

816
00:16:26,220 --> 00:16:26,230

817
00:16:26,230 --> 00:16:28,259
stuff we talked about before and use

818
00:16:28,259 --> 00:16:28,269
 

819
00:16:28,269 --> 00:16:32,009
that to compute our aggregations so way

820
00:16:32,009 --> 00:16:32,019
 

821
00:16:32,019 --> 00:16:33,930
to think about this is like say in this

822
00:16:33,930 --> 00:16:33,940
 

823
00:16:33,940 --> 00:16:36,389
example here if I had an order by clause

824
00:16:36,389 --> 00:16:36,399
 

825
00:16:36,399 --> 00:16:38,850
on course ID then it'd be a no brainer

826
00:16:38,850 --> 00:16:38,860
 

827
00:16:38,860 --> 00:16:40,740
to do sorting for this because I need to

828
00:16:40,740 --> 00:16:40,750
 

829
00:16:40,750 --> 00:16:42,870
get it sorted anyway and I can just

830
00:16:42,870 --> 00:16:42,880
 

831
00:16:42,880 --> 00:16:45,630
reuse the sort order to then eliminate

832
00:16:45,630 --> 00:16:45,640
 

833
00:16:45,640 --> 00:16:47,850
the duplicates but if I don't care about

834
00:16:47,850 --> 00:16:47,860
 

835
00:16:47,860 --> 00:16:50,460
about sorting then I may want to use

836
00:16:50,460 --> 00:16:50,470
 

837
00:16:50,470 --> 00:16:52,740
hashing right hashing hashing is gonna

838
00:16:52,740 --> 00:16:52,750

839
00:16:52,750 --> 00:16:55,710
be is gonna add some randomness to our

840
00:16:55,710 --> 00:16:55,720
 

841
00:16:55,720 --> 00:16:57,780
output because every time we hash a key

842
00:16:57,780 --> 00:16:57,790
 

843
00:16:57,790 --> 00:16:59,610
and put it into a hash table you know

844
00:16:59,610 --> 00:16:59,620
 

845
00:16:59,620 --> 00:17:01,259
you remove all sense of ordering that

846
00:17:01,259 --> 00:17:01,269

847
00:17:01,269 --> 00:17:03,060
that from-from the data that it came

848
00:17:03,060 --> 00:17:03,070
 

849
00:17:03,070 --> 00:17:05,250
from so we don't care about the sort

850
00:17:05,250 --> 00:17:05,260
 

851
00:17:05,260 --> 00:17:07,079
ordering then hashing is always almost

852
00:17:07,079 --> 00:17:07,089

853
00:17:07,089 --> 00:17:10,710
always gonna be superior so the way

854
00:17:10,710 --> 00:17:10,720
 

855
00:17:10,720 --> 00:17:12,539
we're going to compute aggregates with

856
00:17:12,539 --> 00:17:12,549
 

857
00:17:12,549 --> 00:17:15,720
hashing is that we're gonna populate

858
00:17:15,720 --> 00:17:15,730
 

859
00:17:15,730 --> 00:17:17,730
this ephemeral hash table this in memory

860
00:17:17,730 --> 00:17:17,740
 

861
00:17:17,740 --> 00:17:19,079
hash deferred or not in memory I'm a

862
00:17:19,079 --> 00:17:19,089
 

863
00:17:19,089 --> 00:17:20,309
populate this hash table if it only

864
00:17:20,309 --> 00:17:20,319
 

865
00:17:20,319 --> 00:17:23,120
lives for the execution of that query

866
00:17:23,120 --> 00:17:23,130
 

867
00:17:23,130 --> 00:17:25,079
memory talked about data structures

868
00:17:25,079 --> 00:17:25,089
 

869
00:17:25,089 --> 00:17:26,640
earlier we said that can be used in

870
00:17:26,640 --> 00:17:26,650
 

871
00:17:26,650 --> 00:17:28,079
different ways used for table indexes

872
00:17:28,079 --> 00:17:28,089
 

873
00:17:28,089 --> 00:17:30,510
you user metadata and using transient

874
00:17:30,510 --> 00:17:30,520
 

875
00:17:30,520 --> 00:17:32,820
data structures so this is an example of

876
00:17:32,820 --> 00:17:32,830
 

877
00:17:32,830 --> 00:17:34,680
a transient data structure for our one

878
00:17:34,680 --> 00:17:34,690
 

879
00:17:34,690 --> 00:17:36,140
query we're gonna build a hash table

880
00:17:36,140 --> 00:17:36,150

881
00:17:36,150 --> 00:17:38,520
populate it compute our aggregate and

882
00:17:38,520 --> 00:17:38,530
 

883
00:17:38,530 --> 00:17:41,130
then throw it away and every we exit the

884
00:17:41,130 --> 00:17:41,140
 

885
00:17:41,140 --> 00:17:42,120
same query over and again we're gonna

886
00:17:42,120 --> 00:17:42,130

887
00:17:42,130 --> 00:17:43,409
rebuild that hash table every single

888
00:17:43,409 --> 00:17:43,419
 

889
00:17:43,419 --> 00:17:45,210
time

890
00:17:45,210 --> 00:17:45,220
 

891
00:17:45,220 --> 00:17:47,310
so we built we're gonna pop it in this

892
00:17:47,310 --> 00:17:47,320
 

893
00:17:47,320 --> 00:17:49,830
hash table and then depending on what

894
00:17:49,830 --> 00:17:49,840
 

895
00:17:49,840 --> 00:17:51,390
the aggregation we're trying to compute

896
00:17:51,390 --> 00:17:51,400

897
00:17:51,400 --> 00:17:53,910
we'll do different things with what the

898
00:17:53,910 --> 00:17:53,920
 

899
00:17:53,920 --> 00:17:55,530
value is restoring in the buckets so

900
00:17:55,530 --> 00:17:55,540
 

901
00:17:55,540 --> 00:17:57,870
we're doing distinct we see it we have a

902
00:17:57,870 --> 00:17:57,880
 

903
00:17:57,880 --> 00:17:58,470
match

904
00:17:58,470 --> 00:17:58,480

905
00:17:58,480 --> 00:18:00,390
duplicate we just throw away ignore the

906
00:18:00,390 --> 00:18:00,400

907
00:18:00,400 --> 00:18:02,250
weather we just put it put in we're

908
00:18:02,250 --> 00:18:02,260
 

909
00:18:02,260 --> 00:18:04,170
trying to do a group by with an

910
00:18:04,170 --> 00:18:04,180
 

911
00:18:04,180 --> 00:18:05,640
aggregation function then we can

912
00:18:05,640 --> 00:18:05,650

913
00:18:05,650 --> 00:18:07,980
summarize the value on the fly as we go

914
00:18:07,980 --> 00:18:07,990
 

915
00:18:07,990 --> 00:18:10,640
so again just like in sorting if

916
00:18:10,640 --> 00:18:10,650
 

917
00:18:10,650 --> 00:18:13,260
everything fits in memory then we can

918
00:18:13,260 --> 00:18:13,270
 

919
00:18:13,270 --> 00:18:14,790
use any of the hash table as we talked

920
00:18:14,790 --> 00:18:14,800
 

921
00:18:14,800 --> 00:18:16,790
about before and we're done

922
00:18:16,790 --> 00:18:16,800
 

923
00:18:16,800 --> 00:18:19,590
right the the linear leaner probational

924
00:18:19,590 --> 00:18:19,600
 

925
00:18:19,600 --> 00:18:22,530
hashing the cuckoo hashing all those

926
00:18:22,530 --> 00:18:22,540
 

927
00:18:22,540 --> 00:18:24,570
were in memory data structures so if our

928
00:18:24,570 --> 00:18:24,580
 

929
00:18:24,580 --> 00:18:26,640
data set fits in memory then we're we're

930
00:18:26,640 --> 00:18:26,650
 

931
00:18:26,650 --> 00:18:28,740
fine we're easy but it's a really large

932
00:18:28,740 --> 00:18:28,750
 

933
00:18:28,750 --> 00:18:30,000
data set that's not gonna fit in memory

934
00:18:30,000 --> 00:18:30,010
 

935
00:18:30,010 --> 00:18:32,610
then we need to be smarter just like in

936
00:18:32,610 --> 00:18:32,620
 

937
00:18:32,620 --> 00:18:36,330
the sorting case so the hashing

938
00:18:36,330 --> 00:18:36,340

939
00:18:36,340 --> 00:18:38,840
aggregate it's gonna have a two phases

940
00:18:38,840 --> 00:18:38,850
 

941
00:18:38,850 --> 00:18:41,100
first days we're going to partition the

942
00:18:41,100 --> 00:18:41,110
 

943
00:18:41,110 --> 00:18:42,660
tuples into buckets right there's out

944
00:18:42,660 --> 00:18:42,670
 

945
00:18:42,670 --> 00:18:44,730
the disk and in the second phase we're

946
00:18:44,730 --> 00:18:44,740
 

947
00:18:44,740 --> 00:18:46,170
gonna bring those buckets back in and

948
00:18:46,170 --> 00:18:46,180

949
00:18:46,180 --> 00:18:48,510
then populate an a memory hash table for

950
00:18:48,510 --> 00:18:48,520
 

951
00:18:48,520 --> 00:18:50,250
just that partition or just that bucket

952
00:18:50,250 --> 00:18:50,260
 

953
00:18:50,260 --> 00:18:51,990
and then compute whatever it is the

954
00:18:51,990 --> 00:18:52,000
 

955
00:18:52,000 --> 00:18:56,250
aggregate that we want all right again

956
00:18:56,250 --> 00:18:56,260
 

957
00:18:56,260 --> 00:18:57,900
we have to split a disk we have to do

958
00:18:57,900 --> 00:18:57,910
 

959
00:18:57,910 --> 00:19:00,690
this if we're in memory then we don't so

960
00:19:00,690 --> 00:19:00,700
 

961
00:19:00,700 --> 00:19:03,060
in the first phase when user we use one

962
00:19:03,060 --> 00:19:03,070
 

963
00:19:03,070 --> 00:19:05,130
hash function it doesn't matter what it

964
00:19:05,130 --> 00:19:05,140
 

965
00:19:05,140 --> 00:19:07,080
is remember hash a CD hash doesn't

966
00:19:07,080 --> 00:19:07,090
 

967
00:19:07,090 --> 00:19:10,110
matter and then we're gonna do our scan

968
00:19:10,110 --> 00:19:10,120
 

969
00:19:10,120 --> 00:19:12,720
or input tuples and then whatever key we

970
00:19:12,720 --> 00:19:12,730
 

971
00:19:12,730 --> 00:19:14,730
want I'm going to group by we hash that

972
00:19:14,730 --> 00:19:14,740
 

973
00:19:14,740 --> 00:19:16,580
and that tells us what partition that

974
00:19:16,580 --> 00:19:16,590

975
00:19:16,590 --> 00:19:19,560
we're gonna write into out on disk so

976
00:19:19,560 --> 00:19:19,570
 

977
00:19:19,570 --> 00:19:21,450
we're not writing into a hash table at

978
00:19:21,450 --> 00:19:21,460
 

979
00:19:21,460 --> 00:19:22,560
this point we're just writing into

980
00:19:22,560 --> 00:19:22,570
 

981
00:19:22,570 --> 00:19:24,420
output buffers that get written out the

982
00:19:24,420 --> 00:19:24,430
 

983
00:19:24,430 --> 00:19:27,390
disk so the idea here is by pre

984
00:19:27,390 --> 00:19:27,400
 

985
00:19:27,400 --> 00:19:30,030
partitioning is that we know that when

986
00:19:30,030 --> 00:19:30,040
 

987
00:19:30,040 --> 00:19:31,650
we come back and read things back into

988
00:19:31,650 --> 00:19:31,660
 

989
00:19:31,660 --> 00:19:33,720
memory it's computer to computer

990
00:19:33,720 --> 00:19:33,730
 

991
00:19:33,730 --> 00:19:35,700
aggregation there's never gonna be a

992
00:19:35,700 --> 00:19:35,710
 

993
00:19:35,710 --> 00:19:37,380
time where we have to go get data from

994
00:19:37,380 --> 00:19:37,390
 

995
00:19:37,390 --> 00:19:38,490
another partition to compute the

996
00:19:38,490 --> 00:19:38,500
 

997
00:19:38,500 --> 00:19:39,900
aggregate because everyone's gonna get

998
00:19:39,900 --> 00:19:39,910
 

999
00:19:39,910 --> 00:19:42,060
put into the same same location that

1000
00:19:42,060 --> 00:19:42,070
 

1001
00:19:42,070 --> 00:19:46,260
that had the same values so to go to our

1002
00:19:46,260 --> 00:19:46,270
 

1003
00:19:46,270 --> 00:19:47,700
example here right

1004
00:19:47,700 --> 00:19:47,710
 

1005
00:19:47,710 --> 00:19:50,370
same queries before we do our filter we

1006
00:19:50,370 --> 00:19:50,380
 

1007
00:19:50,380 --> 00:19:52,350
do remove the columns and then now at

1008
00:19:52,350 --> 00:19:52,360
 

1009
00:19:52,360 --> 00:19:54,690
this point here we're gonna go scan

1010
00:19:54,690 --> 00:19:54,700
 

1011
00:19:54,700 --> 00:19:56,640
through these values take our hash

1012
00:19:56,640 --> 00:19:56,650

1013
00:19:56,650 --> 00:19:58,110
function apply it and then write out

1014
00:19:58,110 --> 00:19:58,120
 

1015
00:19:58,120 --> 00:19:59,340
whatever the batteries are

1016
00:19:59,340 --> 00:19:59,350

1017
00:19:59,350 --> 00:20:03,060
to our buckets Here I am be a little

1018
00:20:03,060 --> 00:20:03,070
 

1019
00:20:03,070 --> 00:20:05,490
smart and recognize that actually in

1020
00:20:05,490 --> 00:20:05,500
 

1021
00:20:05,500 --> 00:20:08,010
this case here you for 4:45 there should

1022
00:20:08,010 --> 00:20:08,020
 

1023
00:20:08,020 --> 00:20:09,240
be duplicates you're not doing anything

1024
00:20:09,240 --> 00:20:09,250
 

1025
00:20:09,250 --> 00:20:11,640
smart here just taking the values just

1026
00:20:11,640 --> 00:20:11,650
 

1027
00:20:11,650 --> 00:20:13,320
writing them out because it may be the

1028
00:20:13,320 --> 00:20:13,330
 

1029
00:20:13,330 --> 00:20:16,010
case again if I have a billion tuples I

1030
00:20:16,010 --> 00:20:16,020
 

1031
00:20:16,020 --> 00:20:18,570
may not you know the first tuple that

1032
00:20:18,570 --> 00:20:18,580
 

1033
00:20:18,580 --> 00:20:19,799
goes in this bucket maybe fifteen four

1034
00:20:19,799 --> 00:20:19,809
 

1035
00:20:19,809 --> 00:20:21,810
forty five and then a thousand tuples

1036
00:20:21,810 --> 00:20:21,820
 

1037
00:20:21,820 --> 00:20:23,130
later I see another fifteen for forty

1038
00:20:23,130 --> 00:20:23,140
 

1039
00:20:23,140 --> 00:20:25,110
five that want to write out but I don't

1040
00:20:25,110 --> 00:20:25,120
 

1041
00:20:25,120 --> 00:20:26,370
know about the other one because I'm not

1042
00:20:26,370 --> 00:20:26,380
 

1043
00:20:26,380 --> 00:20:28,080
maintaining any metadata about what I've

1044
00:20:28,080 --> 00:20:28,090
 

1045
00:20:28,090 --> 00:20:32,310
seen in the past to make decisions about

1046
00:20:32,310 --> 00:20:32,320
 

1047
00:20:32,320 --> 00:20:35,549
what the filter out so all these buckets

1048
00:20:35,549 --> 00:20:35,559
 

1049
00:20:35,559 --> 00:20:37,680
now get written out right and they sort

1050
00:20:37,680 --> 00:20:37,690
 

1051
00:20:37,690 --> 00:20:38,909
of grouped together in partitions and

1052
00:20:38,909 --> 00:20:38,919
 

1053
00:20:38,919 --> 00:20:40,680
then for each of these partitions we're

1054
00:20:40,680 --> 00:20:40,690
 

1055
00:20:40,690 --> 00:20:42,299
gonna bring it back into memory and

1056
00:20:42,299 --> 00:20:42,309
 

1057
00:20:42,309 --> 00:20:43,470
we're gonna build an in-memory hash

1058
00:20:43,470 --> 00:20:43,480

1059
00:20:43,480 --> 00:20:44,909
table it can be any whatever your

1060
00:20:44,909 --> 00:20:44,919
 

1061
00:20:44,919 --> 00:20:46,980
favorite hash table is by extendable

1062
00:20:46,980 --> 00:20:46,990
 

1063
00:20:46,990 --> 00:20:49,470
linear kuku doesn't matter and then

1064
00:20:49,470 --> 00:20:49,480
 

1065
00:20:49,480 --> 00:20:50,760
we're to use another hash function to

1066
00:20:50,760 --> 00:20:50,770

1067
00:20:50,770 --> 00:20:52,950
hash it into the hash table and then do

1068
00:20:52,950 --> 00:20:52,960
 

1069
00:20:52,960 --> 00:20:54,419
whatever operation we need to do based

1070
00:20:54,419 --> 00:20:54,429
 

1071
00:20:54,429 --> 00:20:56,700
on what our aggregation is right if it's

1072
00:20:56,700 --> 00:20:56,710
 

1073
00:20:56,710 --> 00:20:58,560
a distinct we filter out duplicates if

1074
00:20:58,560 --> 00:20:58,570
 

1075
00:20:58,570 --> 00:21:01,020
it's a group by aggregation function

1076
00:21:01,020 --> 00:21:01,030
 

1077
00:21:01,030 --> 00:21:04,140
then we compute that so this we're gonna

1078
00:21:04,140 --> 00:21:04,150
 

1079
00:21:04,150 --> 00:21:06,240
assume that the partitions as we bring

1080
00:21:06,240 --> 00:21:06,250
 

1081
00:21:06,250 --> 00:21:08,370
them in will fit in memory it's not

1082
00:21:08,370 --> 00:21:08,380
 

1083
00:21:08,380 --> 00:21:10,380
always the case either but we'll see how

1084
00:21:10,380 --> 00:21:10,390
 

1085
00:21:10,390 --> 00:21:11,789
to handle that when we talk about hash

1086
00:21:11,789 --> 00:21:11,799
 

1087
00:21:11,799 --> 00:21:14,490
joins next class so for the way to think

1088
00:21:14,490 --> 00:21:14,500
 

1089
00:21:14,500 --> 00:21:16,440
about this is we're assuming that our

1090
00:21:16,440 --> 00:21:16,450
 

1091
00:21:16,450 --> 00:21:18,810
input data doesn't fit memory but as we

1092
00:21:18,810 --> 00:21:18,820
 

1093
00:21:18,820 --> 00:21:20,250
partition it then each partition will

1094
00:21:20,250 --> 00:21:20,260
 

1095
00:21:20,260 --> 00:21:22,620
fit in memory and is obviously assumes

1096
00:21:22,620 --> 00:21:22,630
 

1097
00:21:22,630 --> 00:21:23,430
that we have a uniform distribution

1098
00:21:23,430 --> 00:21:23,440
 

1099
00:21:23,440 --> 00:21:25,140
after hashing which is not always true

1100
00:21:25,140 --> 00:21:25,150
 

1101
00:21:25,150 --> 00:21:27,120
either but for simplicity we just assume

1102
00:21:27,120 --> 00:21:27,130
 

1103
00:21:27,130 --> 00:21:29,669
this is the case so here we're back now

1104
00:21:29,669 --> 00:21:29,679
 

1105
00:21:29,679 --> 00:21:31,799
in phase two these are the partitions

1106
00:21:31,799 --> 00:21:31,809
 

1107
00:21:31,809 --> 00:21:34,020
that we generated from the last time and

1108
00:21:34,020 --> 00:21:34,030
 

1109
00:21:34,030 --> 00:21:35,880
for simplicity we're just gonna combine

1110
00:21:35,880 --> 00:21:35,890
 

1111
00:21:35,890 --> 00:21:37,320
them into a single hash function like

1112
00:21:37,320 --> 00:21:37,330

1113
00:21:37,330 --> 00:21:40,080
this right and the Hat the keys or is

1114
00:21:40,080 --> 00:21:40,090
 

1115
00:21:40,090 --> 00:21:41,730
the hash keys and then since we're doing

1116
00:21:41,730 --> 00:21:41,740
 

1117
00:21:41,740 --> 00:21:43,320
distinct we're just maintaining the

1118
00:21:43,320 --> 00:21:43,330
 

1119
00:21:43,330 --> 00:21:45,990
values inside of it the hash table so as

1120
00:21:45,990 --> 00:21:46,000
 

1121
00:21:46,000 --> 00:21:47,460
we're scanning along if we see that we

1122
00:21:47,460 --> 00:21:47,470
 

1123
00:21:47,470 --> 00:21:50,130
have a duplicate alright we can just

1124
00:21:50,130 --> 00:21:50,140
 

1125
00:21:50,140 --> 00:21:51,720
throw it away and then the final result

1126
00:21:51,720 --> 00:21:51,730
 

1127
00:21:51,730 --> 00:21:53,700
we need to produce for the query it's

1128
00:21:53,700 --> 00:21:53,710
 

1129
00:21:53,710 --> 00:21:55,200
just the values that are stored in the

1130
00:21:55,200 --> 00:21:55,210
 

1131
00:21:55,210 --> 00:22:00,360
hash table itself right so again what

1132
00:22:00,360 --> 00:22:00,370
 

1133
00:22:00,370 --> 00:22:01,799
would happen is as we go along this

1134
00:22:01,799 --> 00:22:01,809
 

1135
00:22:01,809 --> 00:22:03,930
phase we hash fifteen fourteen forty

1136
00:22:03,930 --> 00:22:03,940
 

1137
00:22:03,940 --> 00:22:05,730
five we see that there's already a tuple

1138
00:22:05,730 --> 00:22:05,740
 

1139
00:22:05,740 --> 00:22:07,140
here with the same value we can just

1140
00:22:07,140 --> 00:22:07,150
 

1141
00:22:07,150 --> 00:22:09,990
discard it so we're doing a linear scan

1142
00:22:09,990 --> 00:22:10,000
 

1143
00:22:10,000 --> 00:22:11,700
inside the value list for it for that

1144
00:22:11,700 --> 00:22:11,710
 

1145
00:22:11,710 --> 00:22:13,110
particular key

1146
00:22:13,110 --> 00:22:13,120
 

1147
00:22:13,120 --> 00:22:16,890
which we know how to do crash tables for

1148
00:22:16,890 --> 00:22:16,900

1149
00:22:16,900 --> 00:22:19,350
summarization the idea is that you can

1150
00:22:19,350 --> 00:22:19,360
 

1151
00:22:19,360 --> 00:22:20,880
maintain a running total as you go along

1152
00:22:20,880 --> 00:22:20,890

1153
00:22:20,890 --> 00:22:24,120
and store that as as your as your value

1154
00:22:24,120 --> 00:22:24,130
 

1155
00:22:24,130 --> 00:22:26,460
in your hash table rather than just the

1156
00:22:26,460 --> 00:22:26,470
 

1157
00:22:26,470 --> 00:22:29,760
existence of the key so again the idea

1158
00:22:29,760 --> 00:22:29,770
 

1159
00:22:29,770 --> 00:22:32,310
is that in the second phase and when I

1160
00:22:32,310 --> 00:22:32,320
 

1161
00:22:32,320 --> 00:22:35,670
rehash if I do my hashing and I see that

1162
00:22:35,670 --> 00:22:35,680
 

1163
00:22:35,680 --> 00:22:38,550
I do a hash on the grip key I land to a

1164
00:22:38,550 --> 00:22:38,560
 

1165
00:22:38,560 --> 00:22:40,590
bucket and I find the entry that

1166
00:22:40,590 --> 00:22:40,600
 

1167
00:22:40,600 --> 00:22:42,990
corresponds to my group I key and then I

1168
00:22:42,990 --> 00:22:43,000
 

1169
00:22:43,000 --> 00:22:44,460
just do whatever operations need to do

1170
00:22:44,460 --> 00:22:44,470
 

1171
00:22:44,470 --> 00:22:46,230
to update the total for that that

1172
00:22:46,230 --> 00:22:46,240
 

1173
00:22:46,240 --> 00:22:48,690
function so again the same would go back

1174
00:22:48,690 --> 00:22:48,700
 

1175
00:22:48,700 --> 00:22:50,610
to this query a different query we're

1176
00:22:50,610 --> 00:22:50,620
 

1177
00:22:50,620 --> 00:22:52,530
doing a join on student enrolled and

1178
00:22:52,530 --> 00:22:52,540

1179
00:22:52,540 --> 00:22:53,970
we're getting the average GPA of the

1180
00:22:53,970 --> 00:22:53,980
 

1181
00:22:53,980 --> 00:22:55,650
students in the course ID for each

1182
00:22:55,650 --> 00:22:55,660

1183
00:22:55,660 --> 00:22:59,070
course ID so now when I in the rehash

1184
00:22:59,070 --> 00:22:59,080
 

1185
00:22:59,080 --> 00:23:01,890
phase when I build my hash table in the

1186
00:23:01,890 --> 00:23:01,900
 

1187
00:23:01,900 --> 00:23:04,740
value list I'm gonna have a mapping from

1188
00:23:04,740 --> 00:23:04,750
 

1189
00:23:04,750 --> 00:23:06,720
the group by key because we're grouping

1190
00:23:06,720 --> 00:23:06,730
 

1191
00:23:06,730 --> 00:23:09,570
by a course ID to some running total we

1192
00:23:09,570 --> 00:23:09,580
 

1193
00:23:09,580 --> 00:23:11,430
have to do to compute the function so

1194
00:23:11,430 --> 00:23:11,440
 

1195
00:23:11,440 --> 00:23:13,440
the the table sort of looks like this

1196
00:23:13,440 --> 00:23:13,450
 

1197
00:23:13,450 --> 00:23:14,820
what you actually need to maintain so if

1198
00:23:14,820 --> 00:23:14,830
 

1199
00:23:14,830 --> 00:23:16,740
you're doing average it's a pair of

1200
00:23:16,740 --> 00:23:16,750
 

1201
00:23:16,750 --> 00:23:19,500
count and some because at the end you

1202
00:23:19,500 --> 00:23:19,510
 

1203
00:23:19,510 --> 00:23:20,940
just take the sum divided by the count

1204
00:23:20,940 --> 00:23:20,950

1205
00:23:20,950 --> 00:23:22,650
and that gives you the average from

1206
00:23:22,650 --> 00:23:22,660
 

1207
00:23:22,660 --> 00:23:24,300
min/max it's sort of obvious to maintain

1208
00:23:24,300 --> 00:23:24,310
 

1209
00:23:24,310 --> 00:23:27,060
the largest value you've seen for exam

1210
00:23:27,060 --> 00:23:27,070
 

1211
00:23:27,070 --> 00:23:29,190
is just adding adding it to it count

1212
00:23:29,190 --> 00:23:29,200
 

1213
00:23:29,200 --> 00:23:31,530
just adding one so this is how the day's

1214
00:23:31,530 --> 00:23:31,540
 

1215
00:23:31,540 --> 00:23:34,260
gonna maintain inside the hash table the

1216
00:23:34,260 --> 00:23:34,270
 

1217
00:23:34,270 --> 00:23:35,760
aggregation function as it goes along

1218
00:23:35,760 --> 00:23:35,770
 

1219
00:23:35,770 --> 00:23:38,190
and then as it scans through each of

1220
00:23:38,190 --> 00:23:38,200
 

1221
00:23:38,200 --> 00:23:40,950
these and populates bits and then when

1222
00:23:40,950 --> 00:23:40,960
 

1223
00:23:40,960 --> 00:23:42,660
it's done that's the answer that it

1224
00:23:42,660 --> 00:23:42,670
 

1225
00:23:42,670 --> 00:23:47,880
produces as the final output so is this

1226
00:23:47,880 --> 00:23:47,890
 

1227
00:23:47,890 --> 00:23:51,180
clear right again pretty straightforward

1228
00:23:51,180 --> 00:23:51,190
 

1229
00:23:51,190 --> 00:23:52,140
but it's kind of cool that we're

1230
00:23:52,140 --> 00:23:52,150
 

1231
00:23:52,150 --> 00:23:53,580
building on the crap we did before right

1232
00:23:53,580 --> 00:23:53,590
 

1233
00:23:53,590 --> 00:23:55,310
we talked about how to build hash tables

1234
00:23:55,310 --> 00:23:55,320
 

1235
00:23:55,320 --> 00:23:57,240
now we can use our hash tables new

1236
00:23:57,240 --> 00:23:57,250
 

1237
00:23:57,250 --> 00:23:59,670
aggregations or we can do use use

1238
00:23:59,670 --> 00:23:59,680
 

1239
00:23:59,680 --> 00:24:01,200
sorting to build aggregations do

1240
00:24:01,200 --> 00:24:01,210

1241
00:24:01,210 --> 00:24:04,200
aggregations right sort of building the

1242
00:24:04,200 --> 00:24:04,210
 

1243
00:24:04,210 --> 00:24:05,580
layers of the system on top of each

1244
00:24:05,580 --> 00:24:05,590
 

1245
00:24:05,590 --> 00:24:09,090
other so the cost analysis for this is

1246
00:24:09,090 --> 00:24:09,100
 

1247
00:24:09,100 --> 00:24:13,530
essentially if you have B be buffer

1248
00:24:13,530 --> 00:24:13,540
 

1249
00:24:13,540 --> 00:24:15,420
blocks you can build then in the first

1250
00:24:15,420 --> 00:24:15,430
 

1251
00:24:15,430 --> 00:24:17,310
phase you can always fill out B minus 1

1252
00:24:17,310 --> 00:24:17,320
 

1253
00:24:17,320 --> 00:24:19,200
right because you always need one

1254
00:24:19,200 --> 00:24:19,210
 

1255
00:24:19,210 --> 00:24:21,240
partition to be or you know use the

1256
00:24:21,240 --> 00:24:21,250
 

1257
00:24:21,250 --> 00:24:25,110
buffer to write out two and then on the

1258
00:24:25,110 --> 00:24:25,120
 

1259
00:24:25,120 --> 00:24:26,910
coming back in

1260
00:24:26,910 --> 00:24:26,920

1261
00:24:26,920 --> 00:24:28,590
the total amount I owe you have to deal

1262
00:24:28,590 --> 00:24:28,600
 

1263
00:24:28,600 --> 00:24:30,630
with B times B minus one because for

1264
00:24:30,630 --> 00:24:30,640
 

1265
00:24:30,640 --> 00:24:33,660
every single paid B you have to read it

1266
00:24:33,660 --> 00:24:33,670
 

1267
00:24:33,670 --> 00:24:35,270
back in write it out and read it back in

1268
00:24:35,270 --> 00:24:35,280
 

1269
00:24:35,280 --> 00:24:37,770
so I don't talk about the fudge factor

1270
00:24:37,770 --> 00:24:37,780
 

1271
00:24:37,780 --> 00:24:39,150
here but the game the big assumption

1272
00:24:39,150 --> 00:24:39,160

1273
00:24:39,160 --> 00:24:43,020
we're making is that the keys are hash

1274
00:24:43,020 --> 00:24:43,030
 

1275
00:24:43,030 --> 00:24:44,850
uniformly so each bucket has the same

1276
00:24:44,850 --> 00:24:44,860
 

1277
00:24:44,860 --> 00:24:46,650
amount of data in practice that's not

1278
00:24:46,650 --> 00:24:46,660
 

1279
00:24:46,660 --> 00:24:48,270
always the case right there's more

1280
00:24:48,270 --> 00:24:48,280
 

1281
00:24:48,280 --> 00:24:49,890
people live in Pennsylvania that people

1282
00:24:49,890 --> 00:24:49,900
 

1283
00:24:49,900 --> 00:24:52,170
live in Alaska so if you hatch on the

1284
00:24:52,170 --> 00:24:52,180
 

1285
00:24:52,180 --> 00:24:54,060
state you know the the Pennsylvania

1286
00:24:54,060 --> 00:24:54,070
 

1287
00:24:54,070 --> 00:24:57,000
buckets gonna be overflowing we'll cover

1288
00:24:57,000 --> 00:24:57,010
 

1289
00:24:57,010 --> 00:24:58,650
that next class we talk about hash joins

1290
00:24:58,650 --> 00:24:58,660
 

1291
00:24:58,660 --> 00:24:59,520
because this is the big problem that

1292
00:24:59,520 --> 00:24:59,530
 

1293
00:24:59,530 --> 00:25:00,600
these guys are gonna have to deal with

1294
00:25:00,600 --> 00:25:00,610
 

1295
00:25:00,610 --> 00:25:03,650
in their environment of how to deal with

1296
00:25:03,650 --> 00:25:03,660
 

1297
00:25:03,660 --> 00:25:06,210
joins when everything isn't uniformly

1298
00:25:06,210 --> 00:25:06,220
 

1299
00:25:06,220 --> 00:25:13,920
distributed okay all right so the the

1300
00:25:13,920 --> 00:25:13,930
 

1301
00:25:13,930 --> 00:25:15,450
main takeaway when you get from this and

1302
00:25:15,450 --> 00:25:15,460
 

1303
00:25:15,460 --> 00:25:17,910
we'll see more about this on on Monday

1304
00:25:17,910 --> 00:25:17,920
 

1305
00:25:17,920 --> 00:25:20,850
next week is that then the data system

1306
00:25:20,850 --> 00:25:20,860
 

1307
00:25:20,860 --> 00:25:22,410
has had to maintain is trade-off making

1308
00:25:22,410 --> 00:25:22,420
 

1309
00:25:22,420 --> 00:25:24,540
this decision about whether you're

1310
00:25:24,540 --> 00:25:24,550
 

1311
00:25:24,550 --> 00:25:26,460
sorting or hashing and depends on what

1312
00:25:26,460 --> 00:25:26,470
 

1313
00:25:26,470 --> 00:25:28,170
index you have available what the data

1314
00:25:28,170 --> 00:25:28,180
 

1315
00:25:28,180 --> 00:25:29,840
looks like what your query looks like

1316
00:25:29,840 --> 00:25:29,850
 

1317
00:25:29,850 --> 00:25:32,700
and and then uses that to figure out

1318
00:25:32,700 --> 00:25:32,710
 

1319
00:25:32,710 --> 00:25:33,810
whether one choice is better than

1320
00:25:33,810 --> 00:25:33,820
 

1321
00:25:33,820 --> 00:25:36,510
another I love say the spoiler is for if

1322
00:25:36,510 --> 00:25:36,520
 

1323
00:25:36,520 --> 00:25:38,190
you take the advanced class is that

1324
00:25:38,190 --> 00:25:38,200
 

1325
00:25:38,200 --> 00:25:40,050
hashing those are almost always going to

1326
00:25:40,050 --> 00:25:40,060
 

1327
00:25:40,060 --> 00:25:42,660
be the better approach unless you have

1328
00:25:42,660 --> 00:25:42,670
 

1329
00:25:42,670 --> 00:25:44,280
an order by that explicitly wants your

1330
00:25:44,280 --> 00:25:44,290

1331
00:25:44,290 --> 00:25:46,410
data sorted hashing whether it's hash

1332
00:25:46,410 --> 00:25:46,420
 

1333
00:25:46,420 --> 00:25:47,910
one and hash aggregations is almost

1334
00:25:47,910 --> 00:25:47,920
 

1335
00:25:47,920 --> 00:25:48,480
always better

1336
00:25:48,480 --> 00:25:48,490

1337
00:25:48,490 --> 00:25:50,940
all right sorting is just it's just more

1338
00:25:50,940 --> 00:25:50,950
 

1339
00:25:50,950 --> 00:25:53,820
work there's a bunch of other

1340
00:25:53,820 --> 00:25:53,830
 

1341
00:25:53,830 --> 00:25:55,410
optimizations we talked about before

1342
00:25:55,410 --> 00:25:55,420
 

1343
00:25:55,420 --> 00:25:59,130
about prefetching and and and trying to

1344
00:25:59,130 --> 00:25:59,140

1345
00:25:59,140 --> 00:26:00,510
do as much work as you can for every IO

1346
00:26:00,510 --> 00:26:00,520
 

1347
00:26:00,520 --> 00:26:04,410
you have to do the main takeaway from

1348
00:26:04,410 --> 00:26:04,420
 

1349
00:26:04,420 --> 00:26:06,530
all this it would be that

1350
00:26:06,530 --> 00:26:06,540
 

1351
00:26:06,540 --> 00:26:08,400
everything all the optimizations we

1352
00:26:08,400 --> 00:26:08,410
 

1353
00:26:08,410 --> 00:26:10,050
focused on we're all about how to reduce

1354
00:26:10,050 --> 00:26:10,060
 

1355
00:26:10,060 --> 00:26:12,480
IO once I got the thing in memory I

1356
00:26:12,480 --> 00:26:12,490
 

1357
00:26:12,490 --> 00:26:14,070
didn't you know I don't really care you

1358
00:26:14,070 --> 00:26:14,080
 

1359
00:26:14,080 --> 00:26:15,120
know what

1360
00:26:15,120 --> 00:26:15,130
 

1361
00:26:15,130 --> 00:26:16,830
you know sorting algorithm using or you

1362
00:26:16,830 --> 00:26:16,840

1363
00:26:16,840 --> 00:26:19,680
know how how will cache friendly

1364
00:26:19,680 --> 00:26:19,690
 

1365
00:26:19,690 --> 00:26:21,090
approach I'm using to compute my hashes

1366
00:26:21,090 --> 00:26:21,100
 

1367
00:26:21,100 --> 00:26:23,190
I don't care because the disk IO is

1368
00:26:23,190 --> 00:26:23,200
 

1369
00:26:23,200 --> 00:26:24,810
always missed expensive thing so that's

1370
00:26:24,810 --> 00:26:24,820
 

1371
00:26:24,820 --> 00:26:27,030
what I want to minimize in the advanced

1372
00:26:27,030 --> 00:26:27,040
 

1373
00:26:27,040 --> 00:26:29,970
class or in an in-memory database disk

1374
00:26:29,970 --> 00:26:29,980
 

1375
00:26:29,980 --> 00:26:32,160
IO is no longer the issue so now we

1376
00:26:32,160 --> 00:26:32,170
 

1377
00:26:32,170 --> 00:26:34,680
start caring about things like CPU

1378
00:26:34,680 --> 00:26:34,690
 

1379
00:26:34,690 --> 00:26:37,350
register usage cache utilization and

1380
00:26:37,350 --> 00:26:37,360
 

1381
00:26:37,360 --> 00:26:40,050
other things for this and you

1382
00:26:40,050 --> 00:26:40,060
 

1383
00:26:40,060 --> 00:26:41,280
come up with a better hash table that

1384
00:26:41,280 --> 00:26:41,290
 

1385
00:26:41,290 --> 00:26:44,610
sketch friendly but for the IO is always

1386
00:26:44,610 --> 00:26:44,620
 

1387
00:26:44,620 --> 00:26:46,020
me the biggest problem we don't care

1388
00:26:46,020 --> 00:26:46,030
 

1389
00:26:46,030 --> 00:26:48,000
about that for this class okay

1390
00:26:48,000 --> 00:26:48,010
 

1391
00:26:48,010 --> 00:26:50,940
I so any questions about sorting or

1392
00:26:50,940 --> 00:26:50,950
 

1393
00:26:50,950 --> 00:26:55,440
aggregations all right cool

1394
00:26:55,440 --> 00:26:55,450
 

1395
00:26:55,450 --> 00:26:57,150
all right so next class again we'll be

1396
00:26:57,150 --> 00:26:57,160
 

1397
00:26:57,160 --> 00:26:59,910
focusing on joins so we'll start of the

1398
00:26:59,910 --> 00:26:59,920
 

1399
00:26:59,920 --> 00:27:01,950
basicness look joins and just get more

1400
00:27:01,950 --> 00:27:01,960
 

1401
00:27:01,960 --> 00:27:03,690
complicated complicated and then we have

1402
00:27:03,690 --> 00:27:03,700
 

1403
00:27:03,700 --> 00:27:05,160
time we'll talk about what I call exotic

1404
00:27:05,160 --> 00:27:05,170
 

1405
00:27:05,170 --> 00:27:07,890
Joan joins lateral joins aunty join semi

1406
00:27:07,890 --> 00:27:07,900
 

1407
00:27:07,900 --> 00:27:56,730
joins at the end okay 43 which are

1408
00:27:56,730 --> 00:27:56,740
 

1409
00:27:56,740 --> 00:28:00,659
drinking 12 they say we'll make sure

1410
00:28:00,659 --> 00:28:00,669
 

1411
00:28:00,669 --> 00:28:02,430
Thayne eyes are straight so it really

1412
00:28:02,430 --> 00:28:02,440
 

1413
00:28:02,440 --> 00:28:04,859
don't matter

