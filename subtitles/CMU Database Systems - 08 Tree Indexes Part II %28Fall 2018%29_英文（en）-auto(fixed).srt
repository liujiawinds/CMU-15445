1
00:00:00,730 --> 00:00:10,720
[Music]

2
00:00:10,720 --> 00:00:10,730


3
00:00:10,730 --> 00:00:12,530
maybe on the Jill's

4
00:00:12,530 --> 00:00:12,540
 

5
00:00:12,540 --> 00:00:15,589
today is the second part electric you're

6
00:00:15,589 --> 00:00:15,599
 

7
00:00:15,599 --> 00:00:19,339
doing on tree indexes is real quick go

8
00:00:19,339 --> 00:00:19,349
 

9
00:00:19,349 --> 00:00:21,109
through what's on the schedule for you

10
00:00:21,109 --> 00:00:21,119

11
00:00:21,119 --> 00:00:22,790
guys coming up right I want you know

12
00:00:22,790 --> 00:00:22,800
 

13
00:00:22,800 --> 00:00:25,160
that project one is due on Wednesday

14
00:00:25,160 --> 00:00:25,170
 

15
00:00:25,170 --> 00:00:28,180
who here is done project one already

16
00:00:28,180 --> 00:00:28,190

17
00:00:28,190 --> 00:00:30,260
it's got a 1% rage man

18
00:00:30,260 --> 00:00:30,270
 

19
00:00:30,270 --> 00:00:32,810
alright small spattering who here has

20
00:00:32,810 --> 00:00:32,820
 

21
00:00:32,820 --> 00:00:35,930
not started at all in the back really

22
00:00:35,930 --> 00:00:35,940
 

23
00:00:35,940 --> 00:00:37,940
you know what kudos are admitting this

24
00:00:37,940 --> 00:00:37,950
 

25
00:00:37,950 --> 00:00:39,350
right cuz I asked every year and I was

26
00:00:39,350 --> 00:00:39,360
 

27
00:00:39,360 --> 00:00:41,959
like no right nice nice

28
00:00:41,959 --> 00:00:41,969
 

29
00:00:41,969 --> 00:00:46,490
ok so homework 2 again it was really

30
00:00:46,490 --> 00:00:46,500
 

31
00:00:46,500 --> 00:00:48,350
dude this Wednesday has been bumped out

32
00:00:48,350 --> 00:00:48,360
 

33
00:00:48,360 --> 00:00:52,220
to be due on on Friday at midnight and

34
00:00:52,220 --> 00:00:52,230
 

35
00:00:52,230 --> 00:00:55,279
then project 2 will be announced on

36
00:00:55,279 --> 00:00:55,289
 

37
00:00:55,289 --> 00:00:58,190
Wednesday in class this week and then

38
00:00:58,190 --> 00:00:58,200
 

39
00:00:58,200 --> 00:01:00,020
what we're doing is for project two

40
00:01:00,020 --> 00:01:00,030
 

41
00:01:00,030 --> 00:01:02,840
because everyone can last year assume

42
00:01:02,840 --> 00:01:02,850
 

43
00:01:02,850 --> 00:01:04,459
project tools can be as easy as project

44
00:01:04,459 --> 00:01:04,469
 

45
00:01:04,469 --> 00:01:07,520
one and maybe that I you heard me say

46
00:01:07,520 --> 00:01:07,530
 

47
00:01:07,530 --> 00:01:08,660
it's easy that's why she hasn't started

48
00:01:08,660 --> 00:01:08,670

49
00:01:08,670 --> 00:01:12,769
yet more new checkpoints in the first

50
00:01:12,769 --> 00:01:12,779
 

51
00:01:12,779 --> 00:01:14,179
week and a half you'll have to submit

52
00:01:14,179 --> 00:01:14,189
 

53
00:01:14,189 --> 00:01:15,379
something on grade scope to get further

54
00:01:15,379 --> 00:01:15,389
 

55
00:01:15,389 --> 00:01:17,269
sort of the first half the project done

56
00:01:17,269 --> 00:01:17,279
 

57
00:01:17,279 --> 00:01:20,209
and then the final grade will be due a

58
00:01:20,209 --> 00:01:20,219
 

59
00:01:20,219 --> 00:01:21,859
week a nap after that so sort again it's

60
00:01:21,859 --> 00:01:21,869
 

61
00:01:21,869 --> 00:01:23,300
a it's a checkpoint halfway through to

62
00:01:23,300 --> 00:01:23,310
 

63
00:01:23,310 --> 00:01:24,319
make sure you least have started and

64
00:01:24,319 --> 00:01:24,329
 

65
00:01:24,329 --> 00:01:25,309
look at the projects so that way you're

66
00:01:25,309 --> 00:01:25,319
 

67
00:01:25,319 --> 00:01:28,069
not trying to build a B+ tree in 24

68
00:01:28,069 --> 00:01:28,079
 

69
00:01:28,079 --> 00:01:29,929
hours which is gonna be a bad bad time

70
00:01:29,929 --> 00:01:29,939
 

71
00:01:29,939 --> 00:01:32,059
for everyone okay so any questions about

72
00:01:32,059 --> 00:01:32,069
 

73
00:01:32,069 --> 00:01:37,730
project one at a high level okay okay

74
00:01:37,730 --> 00:01:37,740
 

75
00:01:37,740 --> 00:01:39,649
so again post any technical questions

76
00:01:39,649 --> 00:01:39,659
 

77
00:01:39,659 --> 00:01:41,719
about great scope or other aspects of

78
00:01:41,719 --> 00:01:41,729
 

79
00:01:41,729 --> 00:01:45,230
the coding assignment on Piazza and then

80
00:01:45,230 --> 00:01:45,240
 

81
00:01:45,240 --> 00:01:46,909
the TAS will be able to answer it for

82
00:01:46,909 --> 00:01:46,919
 

83
00:01:46,919 --> 00:01:49,580
you alright so today's agenda we're

84
00:01:49,580 --> 00:01:49,590
 

85
00:01:49,590 --> 00:01:51,440
going to focus on sort of sort of split

86
00:01:51,440 --> 00:01:51,450
 

87
00:01:51,450 --> 00:01:54,139
into three parts so in beginning I want

88
00:01:54,139 --> 00:01:54,149
 

89
00:01:54,149 --> 00:01:56,389
to talk about other ways you can use

90
00:01:56,389 --> 00:01:56,399
 

91
00:01:56,399 --> 00:01:58,249
table indexes in a database system that

92
00:01:58,249 --> 00:01:58,259
 

93
00:01:58,259 --> 00:02:00,229
go beyond what we've mostly been

94
00:02:00,229 --> 00:02:00,239
 

95
00:02:00,239 --> 00:02:02,359
assuming or talked about so far and then

96
00:02:02,359 --> 00:02:02,369
 

97
00:02:02,369 --> 00:02:03,949
I want to talk about two alternative

98
00:02:03,949 --> 00:02:03,959
 

99
00:02:03,959 --> 00:02:07,159
tree based data structures for for

100
00:02:07,159 --> 00:02:07,169

101
00:02:07,169 --> 00:02:10,550
building a table index as an examples of

102
00:02:10,550 --> 00:02:10,560
 

103
00:02:10,560 --> 00:02:13,009
other options beyond a P plus tree the

104
00:02:13,009 --> 00:02:13,019
 

105
00:02:13,019 --> 00:02:14,509
spoiler would be to be plus tree is

106
00:02:14,509 --> 00:02:14,519
 

107
00:02:14,519 --> 00:02:16,670
still superior in some cases to these

108
00:02:16,670 --> 00:02:16,680
 

109
00:02:16,680 --> 00:02:18,710
other two

110
00:02:18,710 --> 00:02:18,720
 

111
00:02:18,720 --> 00:02:20,450
so but I still think it's useful for you

112
00:02:20,450 --> 00:02:20,460
 

113
00:02:20,460 --> 00:02:22,190
guys be aware of them and understand how

114
00:02:22,190 --> 00:02:22,200
 

115
00:02:22,200 --> 00:02:24,080
they work and then we'll finish all

116
00:02:24,080 --> 00:02:24,090
 

117
00:02:24,090 --> 00:02:27,230
talking about at a high level another

118
00:02:27,230 --> 00:02:27,240
 

119
00:02:27,240 --> 00:02:30,080
example of a non exactly tree based data

120
00:02:30,080 --> 00:02:30,090
 

121
00:02:30,090 --> 00:02:31,640
structure but an example of another kind

122
00:02:31,640 --> 00:02:31,650
 

123
00:02:31,650 --> 00:02:32,870
of index you can have in your database

124
00:02:32,870 --> 00:02:32,880
 

125
00:02:32,880 --> 00:02:35,660
system called an inverted indexes and we

126
00:02:35,660 --> 00:02:35,670
 

127
00:02:35,670 --> 00:02:37,550
see how we do full-text search on these

128
00:02:37,550 --> 00:02:37,560

129
00:02:37,560 --> 00:02:42,590
ok alright so there the there was

130
00:02:42,590 --> 00:02:42,600
 

131
00:02:42,600 --> 00:02:43,610
somebody had a question at the end of

132
00:02:43,610 --> 00:02:43,620
 

133
00:02:43,620 --> 00:02:47,180
last class and about how the database

134
00:02:47,180 --> 00:02:47,190
 

135
00:02:47,190 --> 00:02:49,580
system was was actually building these

136
00:02:49,580 --> 00:02:49,590
 

137
00:02:49,590 --> 00:02:51,710
indexes and I don't mean so much like

138
00:02:51,710 --> 00:02:51,720
 

139
00:02:51,720 --> 00:02:53,060
most the process actually taking the

140
00:02:53,060 --> 00:02:53,070
 

141
00:02:53,070 --> 00:02:56,240
keys and populating index more about are

142
00:02:56,240 --> 00:02:56,250
 

143
00:02:56,250 --> 00:02:57,680
there cases where the Davises would

144
00:02:57,680 --> 00:02:57,690
 

145
00:02:57,690 --> 00:02:59,330
automatically build indexes in order in

146
00:02:59,330 --> 00:02:59,340

147
00:02:59,340 --> 00:03:00,830
order to do certain things and answer is

148
00:03:00,830 --> 00:03:00,840
 

149
00:03:00,840 --> 00:03:03,470
yes so most database systems will

150
00:03:03,470 --> 00:03:03,480
 

151
00:03:03,480 --> 00:03:05,300
automatically create indexes to enforce

152
00:03:05,300 --> 00:03:05,310

153
00:03:05,310 --> 00:03:07,160
different kind of constraints so

154
00:03:07,160 --> 00:03:07,170
 

155
00:03:07,170 --> 00:03:09,560
integrity constraints and possibly also

156
00:03:09,560 --> 00:03:09,570
 

157
00:03:09,570 --> 00:03:12,770
referential constraints so integrity

158
00:03:12,770 --> 00:03:12,780

159
00:03:12,780 --> 00:03:14,090
trait would be like a primary key or

160
00:03:14,090 --> 00:03:14,100
 

161
00:03:14,100 --> 00:03:16,940
unique constraint right so like if I

162
00:03:16,940 --> 00:03:16,950
 

163
00:03:16,950 --> 00:03:19,670
call create table like this and I define

164
00:03:19,670 --> 00:03:19,680
 

165
00:03:19,680 --> 00:03:24,199
a primary key and a unique key then

166
00:03:24,199 --> 00:03:24,209
 

167
00:03:24,209 --> 00:03:26,240
implicitly what this means is that the

168
00:03:26,240 --> 00:03:26,250

169
00:03:26,250 --> 00:03:27,590
database system is going to centrally in

170
00:03:27,590 --> 00:03:27,600
 

171
00:03:27,600 --> 00:03:29,930
a book these sequel commands to create

172
00:03:29,930 --> 00:03:29,940
 

173
00:03:29,940 --> 00:03:33,140
these two indexes for you right so for

174
00:03:33,140 --> 00:03:33,150
 

175
00:03:33,150 --> 00:03:34,400
the primary key it'll automatically

176
00:03:34,400 --> 00:03:34,410
 

177
00:03:34,410 --> 00:03:36,650
create the unique index on on the ID and

178
00:03:36,650 --> 00:03:36,660
 

179
00:03:36,660 --> 00:03:38,930
then for the second value the bar chart

180
00:03:38,930 --> 00:03:38,940
 

181
00:03:38,940 --> 00:03:40,670
it'll create a unique index on that

182
00:03:40,670 --> 00:03:40,680
 

183
00:03:40,680 --> 00:03:42,650
because it has unique key word and when

184
00:03:42,650 --> 00:03:42,660
 

185
00:03:42,660 --> 00:03:43,610
you think about it this makes sense

186
00:03:43,610 --> 00:03:43,620
 

187
00:03:43,620 --> 00:03:46,340
right because what's how else would the

188
00:03:46,340 --> 00:03:46,350
 

189
00:03:46,350 --> 00:03:47,930
database database system actually

190
00:03:47,930 --> 00:03:47,940
 

191
00:03:47,940 --> 00:03:49,789
enforce these constraints right how's

192
00:03:49,789 --> 00:03:49,799
 

193
00:03:49,799 --> 00:03:51,289
gonna know that nobody else tries to

194
00:03:51,289 --> 00:03:51,299
 

195
00:03:51,299 --> 00:03:54,110
insert the key with the same primary key

196
00:03:54,110 --> 00:03:54,120
 

197
00:03:54,120 --> 00:03:57,259
or to point the same primary key the as

198
00:03:57,259 --> 00:03:57,269
 

199
00:03:57,269 --> 00:03:59,780
always in data systems the fallback

200
00:03:59,780 --> 00:03:59,790
 

201
00:03:59,790 --> 00:04:01,280
option is just to do a sequential scan

202
00:04:01,280 --> 00:04:01,290
 

203
00:04:01,290 --> 00:04:03,620
and look at every single tuple to see

204
00:04:03,620 --> 00:04:03,630
 

205
00:04:03,630 --> 00:04:05,449
whether you have the same key already

206
00:04:05,449 --> 00:04:05,459
 

207
00:04:05,459 --> 00:04:07,640
but of course now if I we have 1 billion

208
00:04:07,640 --> 00:04:07,650
 

209
00:04:07,650 --> 00:04:09,800
tuples in our in our table every single

210
00:04:09,800 --> 00:04:09,810

211
00:04:09,810 --> 00:04:11,390
time we insert insert something at the

212
00:04:11,390 --> 00:04:11,400
 

213
00:04:11,400 --> 00:04:14,240
scan through 1 billion tuples so we can

214
00:04:14,240 --> 00:04:14,250

215
00:04:14,250 --> 00:04:16,280
build it we can build an index to do

216
00:04:16,280 --> 00:04:16,290
 

217
00:04:16,290 --> 00:04:17,599
this very quickly for us and doesn't

218
00:04:17,599 --> 00:04:17,609
 

219
00:04:17,609 --> 00:04:19,670
matter whether it's a B+ tree or a hash

220
00:04:19,670 --> 00:04:19,680
 

221
00:04:19,680 --> 00:04:22,280
table right the same idea at a high

222
00:04:22,280 --> 00:04:22,290
 

223
00:04:22,290 --> 00:04:23,570
level the same thing right we want

224
00:04:23,570 --> 00:04:23,580
 

225
00:04:23,580 --> 00:04:24,710
something we can check very quickly to

226
00:04:24,710 --> 00:04:24,720
 

227
00:04:24,720 --> 00:04:26,690
see whether there's a conflict and if

228
00:04:26,690 --> 00:04:26,700
 

229
00:04:26,700 --> 00:04:28,760
yes then we know we should not insert it

230
00:04:28,760 --> 00:04:28,770
 

231
00:04:28,770 --> 00:04:31,690
if no then it's okay for us to insert it

232
00:04:31,690 --> 00:04:31,700
 

233
00:04:31,700 --> 00:04:34,160
so this is mr. du integrity constraints

234
00:04:34,160 --> 00:04:34,170
 

235
00:04:34,170 --> 00:04:36,800
I also thought it would do the same

236
00:04:36,800 --> 00:04:36,810
 

237
00:04:36,810 --> 00:04:39,290
thing for referential entrants or

238
00:04:39,290 --> 00:04:39,300
 

239
00:04:39,300 --> 00:04:42,020
foreign key constraints right so let's

240
00:04:42,020 --> 00:04:42,030

241
00:04:42,030 --> 00:04:44,330
say I have a second table here bar and

242
00:04:44,330 --> 00:04:44,340

243
00:04:44,340 --> 00:04:46,580
this ID field has a foreign key

244
00:04:46,580 --> 00:04:46,590
 

245
00:04:46,590 --> 00:04:49,670
reference on the value 1 in the food

246
00:04:49,670 --> 00:04:49,680
 

247
00:04:49,680 --> 00:04:54,770
table so at this point here the the

248
00:04:54,770 --> 00:04:54,780
 

249
00:04:54,780 --> 00:04:57,500
value 1 in the food table is not unique

250
00:04:57,500 --> 00:04:57,510
 

251
00:04:57,510 --> 00:04:59,930
so there isn't an index already built

252
00:04:59,930 --> 00:04:59,940
 

253
00:04:59,940 --> 00:05:02,210
for it and I thought actually the data

254
00:05:02,210 --> 00:05:02,220

255
00:05:02,220 --> 00:05:03,920
system would automatically recognize oh

256
00:05:03,920 --> 00:05:03,930

257
00:05:03,930 --> 00:05:06,380
I'm having a foreign key reference from

258
00:05:06,380 --> 00:05:06,390

259
00:05:06,390 --> 00:05:08,600
this table to that table I don't already

260
00:05:08,600 --> 00:05:08,610
 

261
00:05:08,610 --> 00:05:10,280
have an index over here I thought it

262
00:05:10,280 --> 00:05:10,290
 

263
00:05:10,290 --> 00:05:11,990
would actually they were all gonna go

264
00:05:11,990 --> 00:05:12,000
 

265
00:05:12,000 --> 00:05:14,750
ahead and create one automatically for

266
00:05:14,750 --> 00:05:14,760
 

267
00:05:14,760 --> 00:05:18,020
you turns out I try this my sequel in

268
00:05:18,020 --> 00:05:18,030
 

269
00:05:18,030 --> 00:05:19,670
Postgres they don't actually do this at

270
00:05:19,670 --> 00:05:19,680
 

271
00:05:19,680 --> 00:05:21,410
all actually they won't even let you

272
00:05:21,410 --> 00:05:21,420
 

273
00:05:21,420 --> 00:05:23,300
create the foreign key unless you're

274
00:05:23,300 --> 00:05:23,310
 

275
00:05:23,310 --> 00:05:24,860
pointing something in the parent table

276
00:05:24,860 --> 00:05:24,870
 

277
00:05:24,870 --> 00:05:28,930
that already has a unique index for you

278
00:05:28,930 --> 00:05:28,940
 

279
00:05:28,940 --> 00:05:31,700
again it's the reason why you need index

280
00:05:31,700 --> 00:05:31,710
 

281
00:05:31,710 --> 00:05:33,200
is the same reason we need it for the

282
00:05:33,200 --> 00:05:33,210
 

283
00:05:33,210 --> 00:05:35,120
primary key and unique constraint right

284
00:05:35,120 --> 00:05:35,130
 

285
00:05:35,130 --> 00:05:36,950
every single time you wouldn't insert

286
00:05:36,950 --> 00:05:36,960
 

287
00:05:36,960 --> 00:05:38,900
something into bar the foreign key says

288
00:05:38,900 --> 00:05:38,910

289
00:05:38,910 --> 00:05:40,400
whatever you're in storing for value

290
00:05:40,400 --> 00:05:40,410
 

291
00:05:40,410 --> 00:05:42,290
sorry for the ID field since it has a

292
00:05:42,290 --> 00:05:42,300
 

293
00:05:42,300 --> 00:05:43,580
foreign key preference on the food table

294
00:05:43,580 --> 00:05:43,590
 

295
00:05:43,590 --> 00:05:46,100
there must be a key that exists in the

296
00:05:46,100 --> 00:05:46,110
 

297
00:05:46,110 --> 00:05:47,450
food table that matches what I'm trying

298
00:05:47,450 --> 00:05:47,460
 

299
00:05:47,460 --> 00:05:49,250
to insert in this table so again you

300
00:05:49,250 --> 00:05:49,260
 

301
00:05:49,260 --> 00:05:50,630
would use an index to make sure you

302
00:05:50,630 --> 00:05:50,640
 

303
00:05:50,640 --> 00:05:52,250
didn't have to scan everything to find a

304
00:05:52,250 --> 00:05:52,260
 

305
00:05:52,260 --> 00:05:55,010
match so turns out in Postgres in my

306
00:05:55,010 --> 00:05:55,020
 

307
00:05:55,020 --> 00:05:58,130
sequel they will throw an error my

308
00:05:58,130 --> 00:05:58,140

309
00:05:58,140 --> 00:05:59,450
sequel actor will throw a silent error

310
00:05:59,450 --> 00:05:59,460
 

311
00:05:59,460 --> 00:06:00,410
for this one

312
00:06:00,410 --> 00:06:00,420

313
00:06:00,420 --> 00:06:02,210
Postgres will do it correctly at least

314
00:06:02,210 --> 00:06:02,220

315
00:06:02,220 --> 00:06:04,790
my sequel five point seven and say you

316
00:06:04,790 --> 00:06:04,800
 

317
00:06:04,800 --> 00:06:06,170
can't create this foreign key reference

318
00:06:06,170 --> 00:06:06,180
 

319
00:06:06,180 --> 00:06:09,020
because you need to have a unique index

320
00:06:09,020 --> 00:06:09,030
 

321
00:06:09,030 --> 00:06:10,640
on on the food table for the thing

322
00:06:10,640 --> 00:06:10,650
 

323
00:06:10,650 --> 00:06:12,530
you're pointing to but there's nothing

324
00:06:12,530 --> 00:06:12,540
 

325
00:06:12,540 --> 00:06:14,090
about the relational model that says

326
00:06:14,090 --> 00:06:14,100
 

327
00:06:14,100 --> 00:06:15,470
that this is the case I think this is

328
00:06:15,470 --> 00:06:15,480
 

329
00:06:15,480 --> 00:06:18,320
strictly an implementation issue maybe

330
00:06:18,320 --> 00:06:18,330
 

331
00:06:18,330 --> 00:06:19,460
has to do something and the sequel

332
00:06:19,460 --> 00:06:19,470
 

333
00:06:19,470 --> 00:06:21,290
standard says something about this but I

334
00:06:21,290 --> 00:06:21,300
 

335
00:06:21,300 --> 00:06:22,880
think at a high level there's no no

336
00:06:22,880 --> 00:06:22,890
 

337
00:06:22,890 --> 00:06:24,350
reason this is they have to require this

338
00:06:24,350 --> 00:06:24,360
 

339
00:06:24,360 --> 00:06:26,120
this is why I thought they were gonna

340
00:06:26,120 --> 00:06:26,130

341
00:06:26,130 --> 00:06:28,730
automatically create one so the only way

342
00:06:28,730 --> 00:06:28,740
 

343
00:06:28,740 --> 00:06:30,320
to really make this work is actually if

344
00:06:30,320 --> 00:06:30,330
 

345
00:06:30,330 --> 00:06:32,900
you change the the food table to make

346
00:06:32,900 --> 00:06:32,910
 

347
00:06:32,910 --> 00:06:35,660
the the value the first value attribute

348
00:06:35,660 --> 00:06:35,670
 

349
00:06:35,670 --> 00:06:37,550
be unique and again that automatically

350
00:06:37,550 --> 00:06:37,560
 

351
00:06:37,560 --> 00:06:39,200
doesn't index and then this thing can

352
00:06:39,200 --> 00:06:39,210
 

353
00:06:39,210 --> 00:06:41,720
now point to it right so this is sort of

354
00:06:41,720 --> 00:06:41,730
 

355
00:06:41,730 --> 00:06:42,260
clear right

356
00:06:42,260 --> 00:06:42,270
 

357
00:06:42,270 --> 00:06:44,240
anytime you define a constraint when you

358
00:06:44,240 --> 00:06:44,250
 

359
00:06:44,250 --> 00:06:45,500
create the table at automatic

360
00:06:45,500 --> 00:06:45,510
 

361
00:06:45,510 --> 00:06:47,720
create the index for you now I can also

362
00:06:47,720 --> 00:06:47,730
 

363
00:06:47,730 --> 00:06:50,380
go back and create the indexes manually

364
00:06:50,380 --> 00:06:50,390
 

365
00:06:50,390 --> 00:06:53,690
but you can do it directly when you call

366
00:06:53,690 --> 00:06:53,700
 

367
00:06:53,700 --> 00:06:57,470
create table alright so another

368
00:06:57,470 --> 00:06:57,480
 

369
00:06:57,480 --> 00:06:59,630
interesting way to expand what we have

370
00:06:59,630 --> 00:06:59,640
 

371
00:06:59,640 --> 00:07:00,890
we can use indexes are called partial

372
00:07:00,890 --> 00:07:00,900

373
00:07:00,900 --> 00:07:05,240
indexes and the idea here is that so far

374
00:07:05,240 --> 00:07:05,250
 

375
00:07:05,250 --> 00:07:06,890
we've assumed that anytime I call create

376
00:07:06,890 --> 00:07:06,900
 

377
00:07:06,900 --> 00:07:08,930
index it's going to scan through every

378
00:07:08,930 --> 00:07:08,940
 

379
00:07:08,940 --> 00:07:10,790
single tuple in that table and build an

380
00:07:10,790 --> 00:07:10,800
 

381
00:07:10,800 --> 00:07:12,980
index for the entire table but there may

382
00:07:12,980 --> 00:07:12,990
 

383
00:07:12,990 --> 00:07:14,390
be some cases where you don't actually

384
00:07:14,390 --> 00:07:14,400
 

385
00:07:14,400 --> 00:07:15,950
want an index on the entire table you

386
00:07:15,950 --> 00:07:15,960
 

387
00:07:15,960 --> 00:07:18,410
want a subset at the table so this is

388
00:07:18,410 --> 00:07:18,420
 

389
00:07:18,420 --> 00:07:21,020
what it's called partial indexes so the

390
00:07:21,020 --> 00:07:21,030
 

391
00:07:21,030 --> 00:07:23,390
way you make this work is that in the

392
00:07:23,390 --> 00:07:23,400
 

393
00:07:23,400 --> 00:07:25,340
where you add a where clause to the

394
00:07:25,340 --> 00:07:25,350
 

395
00:07:25,350 --> 00:07:27,440
Krait index statement and you add some

396
00:07:27,440 --> 00:07:27,450
 

397
00:07:27,450 --> 00:07:29,960
additional predicates to say only index

398
00:07:29,960 --> 00:07:29,970
 

399
00:07:29,970 --> 00:07:31,670
the tuples on the base table in this

400
00:07:31,670 --> 00:07:31,680
 

401
00:07:31,680 --> 00:07:35,030
case foo where C equals mooting or some

402
00:07:35,030 --> 00:07:35,040
 

403
00:07:35,040 --> 00:07:37,640
expression has to evaluate to true so

404
00:07:37,640 --> 00:07:37,650
 

405
00:07:37,650 --> 00:07:39,380
inside of this index we're only going to

406
00:07:39,380 --> 00:07:39,390
 

407
00:07:39,390 --> 00:07:42,170
index a and B but implicitly there's

408
00:07:42,170 --> 00:07:42,180
 

409
00:07:42,180 --> 00:07:43,760
some metadata we're maintaining to know

410
00:07:43,760 --> 00:07:43,770
 

411
00:07:43,770 --> 00:07:47,240
that for this particular index there are

412
00:07:47,240 --> 00:07:47,250
 

413
00:07:47,250 --> 00:07:49,340
only B entries where C equals wu-tang

414
00:07:49,340 --> 00:07:49,350
 

415
00:07:49,350 --> 00:07:52,220
from the food table and so the advantage

416
00:07:52,220 --> 00:07:52,230
 

417
00:07:52,230 --> 00:07:53,600
of this is now if you come along with a

418
00:07:53,600 --> 00:07:53,610
 

419
00:07:53,610 --> 00:07:56,210
query like this let me say we're a

420
00:07:56,210 --> 00:07:56,220
 

421
00:07:56,220 --> 00:07:59,600
equals 1 2 3 and C equals whoo tang so

422
00:07:59,600 --> 00:07:59,610
 

423
00:07:59,610 --> 00:08:02,390
now we for for a the a attribute we can

424
00:08:02,390 --> 00:08:02,400
 

425
00:08:02,400 --> 00:08:04,700
get that from the index but we would

426
00:08:04,700 --> 00:08:04,710
 

427
00:08:04,710 --> 00:08:06,770
even afford them we would check to see

428
00:08:06,770 --> 00:08:06,780
 

429
00:08:06,780 --> 00:08:09,080
whether this the C predicate matches

430
00:08:09,080 --> 00:08:09,090
 

431
00:08:09,090 --> 00:08:10,760
what we've declared as the the partial

432
00:08:10,760 --> 00:08:10,770

433
00:08:10,770 --> 00:08:13,250
index where clause for this index if it

434
00:08:13,250 --> 00:08:13,260
 

435
00:08:13,260 --> 00:08:14,510
doesn't match that we can't use the

436
00:08:14,510 --> 00:08:14,520
 

437
00:08:14,520 --> 00:08:16,370
index if it does match then we know that

438
00:08:16,370 --> 00:08:16,380
 

439
00:08:16,380 --> 00:08:18,050
it's safe for us to go inside of it and

440
00:08:18,050 --> 00:08:18,060
 

441
00:08:18,060 --> 00:08:20,630
then extract out the new apply to a

442
00:08:20,630 --> 00:08:20,640
 

443
00:08:20,640 --> 00:08:22,750
predicate to get the keys that we want

444
00:08:22,750 --> 00:08:22,760
 

445
00:08:22,760 --> 00:08:26,090
so this is actually a very common setup

446
00:08:26,090 --> 00:08:26,100
 

447
00:08:26,100 --> 00:08:28,820
in a lot of applications when you maybe

448
00:08:28,820 --> 00:08:28,830
 

449
00:08:28,830 --> 00:08:30,740
want to partition the index based on

450
00:08:30,740 --> 00:08:30,750

451
00:08:30,750 --> 00:08:33,680
things like date so you have like say

452
00:08:33,680 --> 00:08:33,690
 

453
00:08:33,690 --> 00:08:35,839
you split up your you know the list of

454
00:08:35,839 --> 00:08:35,849
 

455
00:08:35,849 --> 00:08:38,360
orders for your business you can have

456
00:08:38,360 --> 00:08:38,370
 

457
00:08:38,370 --> 00:08:40,150
one index for each individual month

458
00:08:40,150 --> 00:08:40,160

459
00:08:40,160 --> 00:08:43,430
right and then this reduces the size of

460
00:08:43,430 --> 00:08:43,440
 

461
00:08:43,440 --> 00:08:45,230
the index and it makes maintaining them

462
00:08:45,230 --> 00:08:45,240
 

463
00:08:45,240 --> 00:08:47,740
much easier because they're more compact

464
00:08:47,740 --> 00:08:47,750
 

465
00:08:47,750 --> 00:08:50,390
if you have a lot of queries that only

466
00:08:50,390 --> 00:08:50,400
 

467
00:08:50,400 --> 00:08:52,520
focus on a single month then you don't

468
00:08:52,520 --> 00:08:52,530
 

469
00:08:52,530 --> 00:08:54,230
have to maybe swap in you know a you

470
00:08:54,230 --> 00:08:54,240
 

471
00:08:54,240 --> 00:08:55,970
know giant index into your buffer pool

472
00:08:55,970 --> 00:08:55,980
 

473
00:08:55,980 --> 00:08:57,590
that has a bunch of keys that don't

474
00:08:57,590 --> 00:08:57,600
 

475
00:08:57,600 --> 00:08:59,510
actually matter for you

476
00:08:59,510 --> 00:08:59,520

477
00:08:59,520 --> 00:09:01,850
so this this is this is very common

478
00:09:01,850 --> 00:09:01,860
 

479
00:09:01,860 --> 00:09:04,010
approach that people use to sort of sort

480
00:09:04,010 --> 00:09:04,020
 

481
00:09:04,020 --> 00:09:05,900
of manually partition the database or

482
00:09:05,900 --> 00:09:05,910
 

483
00:09:05,910 --> 00:09:07,640
partition the data in such a way to

484
00:09:07,640 --> 00:09:07,650
 

485
00:09:07,650 --> 00:09:13,070
reduce the overhead of large scans so

486
00:09:13,070 --> 00:09:13,080
 

487
00:09:13,080 --> 00:09:15,980
one additional thing about this query if

488
00:09:15,980 --> 00:09:15,990
 

489
00:09:15,990 --> 00:09:18,070
you want to notice also too is that

490
00:09:18,070 --> 00:09:18,080
 

491
00:09:18,080 --> 00:09:21,170
everything I need to answer this query

492
00:09:21,170 --> 00:09:21,180
 

493
00:09:21,180 --> 00:09:23,270
is actually contained in the index

494
00:09:23,270 --> 00:09:23,280
 

495
00:09:23,280 --> 00:09:27,350
itself right so I'm doing a look-up on a

496
00:09:27,350 --> 00:09:27,360
 

497
00:09:27,360 --> 00:09:29,870
I did my where calls on see you there

498
00:09:29,870 --> 00:09:29,880
 

499
00:09:29,880 --> 00:09:31,880
and then the only thing I want to

500
00:09:31,880 --> 00:09:31,890
 

501
00:09:31,890 --> 00:09:35,810
produce is my output was B so do I

502
00:09:35,810 --> 00:09:35,820
 

503
00:09:35,820 --> 00:09:37,040
actually need to look at the tuple for

504
00:09:37,040 --> 00:09:37,050
 

505
00:09:37,050 --> 00:09:40,670
this rank is how would we normally

506
00:09:40,670 --> 00:09:40,680
 

507
00:09:40,680 --> 00:09:42,260
execute this we'd follow the index the

508
00:09:42,260 --> 00:09:42,270
 

509
00:09:42,270 --> 00:09:44,000
index at the value at the leaf node

510
00:09:44,000 --> 00:09:44,010

511
00:09:44,010 --> 00:09:46,220
assuming we have a B+ tree would have a

512
00:09:46,220 --> 00:09:46,230
 

513
00:09:46,230 --> 00:09:48,080
record pointer and then we would go

514
00:09:48,080 --> 00:09:48,090
 

515
00:09:48,090 --> 00:09:49,940
follow that record to go get the tuple

516
00:09:49,940 --> 00:09:49,950
 

517
00:09:49,950 --> 00:09:51,970
and then evaluate the rest of the query

518
00:09:51,970 --> 00:09:51,980
 

519
00:09:51,980 --> 00:09:54,440
but this particular query there's

520
00:09:54,440 --> 00:09:54,450
 

521
00:09:54,450 --> 00:09:57,890
nothing from the tuple itself that we

522
00:09:57,890 --> 00:09:57,900
 

523
00:09:57,900 --> 00:10:01,550
don't already get from the index so

524
00:10:01,550 --> 00:10:01,560
 

525
00:10:01,560 --> 00:10:04,490
these are called covering indexes so the

526
00:10:04,490 --> 00:10:04,500
 

527
00:10:04,500 --> 00:10:06,710
idea is that a covering index covers all

528
00:10:06,710 --> 00:10:06,720
 

529
00:10:06,720 --> 00:10:08,870
the data you need to exude a particular

530
00:10:08,870 --> 00:10:08,880
 

531
00:10:08,880 --> 00:10:11,330
query so this is not something you would

532
00:10:11,330 --> 00:10:11,340
 

533
00:10:11,340 --> 00:10:13,100
declare you don't say make this index B

534
00:10:13,100 --> 00:10:13,110
 

535
00:10:13,110 --> 00:10:15,530
recovering index it has to do on a query

536
00:10:15,530 --> 00:10:15,540
 

537
00:10:15,540 --> 00:10:17,810
by query basis write the data to system

538
00:10:17,810 --> 00:10:17,820
 

539
00:10:17,820 --> 00:10:19,100
can recognize that for this particular

540
00:10:19,100 --> 00:10:19,110
 

541
00:10:19,110 --> 00:10:21,110
query everything I need to answer the

542
00:10:21,110 --> 00:10:21,120
 

543
00:10:21,120 --> 00:10:22,700
question that you're asking me can be

544
00:10:22,700 --> 00:10:22,710
 

545
00:10:22,710 --> 00:10:24,890
found in a particular index and if so

546
00:10:24,890 --> 00:10:24,900
 

547
00:10:24,900 --> 00:10:26,960
it's considered a covering index all

548
00:10:26,960 --> 00:10:26,970

549
00:10:26,970 --> 00:10:29,810
right so to simplify our theme for for

550
00:10:29,810 --> 00:10:29,820
 

551
00:10:29,820 --> 00:10:31,520
the our simple query select B from food

552
00:10:31,520 --> 00:10:31,530

553
00:10:31,530 --> 00:10:34,430
where a equals 1 2 3 we can get the B

554
00:10:34,430 --> 00:10:34,440
 

555
00:10:34,440 --> 00:10:37,100
that we have needed from the output from

556
00:10:37,100 --> 00:10:37,110

557
00:10:37,110 --> 00:10:39,260
from the index after the arrows are

558
00:10:39,260 --> 00:10:39,270
 

559
00:10:39,270 --> 00:10:40,490
wrong right that should be there that's

560
00:10:40,490 --> 00:10:40,500
 

561
00:10:40,500 --> 00:10:42,020
read there all right so a would be for

562
00:10:42,020 --> 00:10:42,030
 

563
00:10:42,030 --> 00:10:44,680
this a D for that that that'd be there

564
00:10:44,680 --> 00:10:44,690
 

565
00:10:44,690 --> 00:10:46,300
right

566
00:10:46,300 --> 00:10:46,310

567
00:10:46,310 --> 00:10:48,680
so I've already sort of slowed and

568
00:10:48,680 --> 00:10:48,690
 

569
00:10:48,690 --> 00:10:52,160
what's the advantage of this I don't

570
00:10:52,160 --> 00:10:52,170
 

571
00:10:52,170 --> 00:10:53,660
have to go look at the tuple because

572
00:10:53,660 --> 00:10:53,670
 

573
00:10:53,670 --> 00:10:56,150
everything I need is is directly in the

574
00:10:56,150 --> 00:10:56,160
 

575
00:10:56,160 --> 00:10:59,840
index but we know this from our from you

576
00:10:59,840 --> 00:10:59,850

577
00:10:59,850 --> 00:11:00,800
guys are implementing your profitable

578
00:11:00,800 --> 00:11:00,810
 

579
00:11:00,810 --> 00:11:04,160
manager memory is limited so I already

580
00:11:04,160 --> 00:11:04,170
 

581
00:11:04,170 --> 00:11:05,930
have to bring in the index pages in

582
00:11:05,930 --> 00:11:05,940
 

583
00:11:05,940 --> 00:11:07,250
order to traverse the tree to get to the

584
00:11:07,250 --> 00:11:07,260
 

585
00:11:07,260 --> 00:11:09,410
leaf node that I wanted but now if I

586
00:11:09,410 --> 00:11:09,420
 

587
00:11:09,420 --> 00:11:10,790
have a covering index I don't have to go

588
00:11:10,790 --> 00:11:10,800
 

589
00:11:10,800 --> 00:11:12,200
look at the tuple there's one less page

590
00:11:12,200 --> 00:11:12,210
 

591
00:11:12,210 --> 00:11:12,820
read

592
00:11:12,820 --> 00:11:12,830

593
00:11:12,830 --> 00:11:14,530
one less entry into the buffer pool I

594
00:11:14,530 --> 00:11:14,540

595
00:11:14,540 --> 00:11:16,630
have two good make to get the data I

596
00:11:16,630 --> 00:11:16,640
 

597
00:11:16,640 --> 00:11:19,060
need for this query so this can

598
00:11:19,060 --> 00:11:19,070
 

599
00:11:19,070 --> 00:11:20,800
significantly speed things up in a lot

600
00:11:20,800 --> 00:11:20,810
 

601
00:11:20,810 --> 00:11:22,870
of cases especially for doing a lot you

602
00:11:22,870 --> 00:11:22,880
 

603
00:11:22,880 --> 00:11:24,430
know large range scan where you only

604
00:11:24,430 --> 00:11:24,440
 

605
00:11:24,440 --> 00:11:26,380
want to get things you know you were

606
00:11:26,380 --> 00:11:26,390
 

607
00:11:26,390 --> 00:11:27,550
doing a large reading scan and your

608
00:11:27,550 --> 00:11:27,560
 

609
00:11:27,560 --> 00:11:29,199
tuples are really big so I mean to go

610
00:11:29,199 --> 00:11:29,209

611
00:11:29,209 --> 00:11:30,460
fetch the data for the tuple would be

612
00:11:30,460 --> 00:11:30,470
 

613
00:11:30,470 --> 00:11:33,000
you know you have to read a lot of pages

614
00:11:33,000 --> 00:11:33,010
 

615
00:11:33,010 --> 00:11:36,040
so this is something that is widely used

616
00:11:36,040 --> 00:11:36,050
 

617
00:11:36,050 --> 00:11:40,410
in the the major commercial systems

618
00:11:40,410 --> 00:11:40,420
 

619
00:11:40,420 --> 00:11:43,930
MongoDB supports this uh I think

620
00:11:43,930 --> 00:11:43,940
 

621
00:11:43,940 --> 00:11:45,880
Postgres supports it now they're getting

622
00:11:45,880 --> 00:11:45,890
 

623
00:11:45,890 --> 00:11:47,380
better and post eleven which comes out

624
00:11:47,380 --> 00:11:47,390
 

625
00:11:47,390 --> 00:11:49,300
later I don't think my sequel at least

626
00:11:49,300 --> 00:11:49,310
 

627
00:11:49,310 --> 00:11:50,980
my sequel five point seven doesn't does

628
00:11:50,980 --> 00:11:50,990
 

629
00:11:50,990 --> 00:11:53,319
not support this I don't know what

630
00:11:53,319 --> 00:11:53,329
 

631
00:11:53,329 --> 00:11:55,750
sequel light does right again the idea

632
00:11:55,750 --> 00:11:55,760
 

633
00:11:55,760 --> 00:11:57,250
here is we can reduce contention in a

634
00:11:57,250 --> 00:11:57,260
 

635
00:11:57,260 --> 00:11:58,990
buffalo and not only for the amount of

636
00:11:58,990 --> 00:11:59,000
 

637
00:11:59,000 --> 00:12:01,780
memory we have to fetch from disk to go

638
00:12:01,780 --> 00:12:01,790
 

639
00:12:01,790 --> 00:12:03,639
into the query but also just the we have

640
00:12:03,639 --> 00:12:03,649
 

641
00:12:03,649 --> 00:12:04,960
to go into the buffalo manager fewer

642
00:12:04,960 --> 00:12:04,970

643
00:12:04,970 --> 00:12:07,690
times we take fewer latches so this this

644
00:12:07,690 --> 00:12:07,700
 

645
00:12:07,700 --> 00:12:09,569
is a big win in a lot of situations

646
00:12:09,569 --> 00:12:09,579
 

647
00:12:09,579 --> 00:12:12,190
now that may be some cases also to where

648
00:12:12,190 --> 00:12:12,200
 

649
00:12:12,200 --> 00:12:15,880
the data I need though for to make it a

650
00:12:15,880 --> 00:12:15,890
 

651
00:12:15,890 --> 00:12:17,740
covering index is not not actually being

652
00:12:17,740 --> 00:12:17,750
 

653
00:12:17,750 --> 00:12:20,230
indexed right in theory I could if I

654
00:12:20,230 --> 00:12:20,240
 

655
00:12:20,240 --> 00:12:23,110
have say actuaries ABC on foo I could

656
00:12:23,110 --> 00:12:23,120
 

657
00:12:23,120 --> 00:12:27,190
index make an index on a and B and C and

658
00:12:27,190 --> 00:12:27,200
 

659
00:12:27,200 --> 00:12:29,110
just never you know never do the lookup

660
00:12:29,110 --> 00:12:29,120
 

661
00:12:29,120 --> 00:12:35,350
on C so in this case here it would make

662
00:12:35,350 --> 00:12:35,360
 

663
00:12:35,360 --> 00:12:38,199
a covering index more often than not but

664
00:12:38,199 --> 00:12:38,209
 

665
00:12:38,209 --> 00:12:40,180
you're sort of wasting space now because

666
00:12:40,180 --> 00:12:40,190
 

667
00:12:40,190 --> 00:12:42,579
in your upper levels of the tree the

668
00:12:42,579 --> 00:12:42,589
 

669
00:12:42,589 --> 00:12:43,440
Internode's

670
00:12:43,440 --> 00:12:43,450
 

671
00:12:43,450 --> 00:12:45,760
your index and see when maybe you don't

672
00:12:45,760 --> 00:12:45,770
 

673
00:12:45,770 --> 00:12:48,579
actually need to so way to get around

674
00:12:48,579 --> 00:12:48,589
 

675
00:12:48,589 --> 00:12:51,639
this is called index include columns and

676
00:12:51,639 --> 00:12:51,649
 

677
00:12:51,649 --> 00:12:53,199
the idea here is that in our create

678
00:12:53,199 --> 00:12:53,209
 

679
00:12:53,209 --> 00:12:55,090
index statement we add a little include

680
00:12:55,090 --> 00:12:55,100
 

681
00:12:55,100 --> 00:12:56,920
clause and then we list a bunch of atras

682
00:12:56,920 --> 00:12:56,930
 

683
00:12:56,930 --> 00:13:00,160
that we want to get packed into the leaf

684
00:13:00,160 --> 00:13:00,170
 

685
00:13:00,170 --> 00:13:02,310
nodes for any key that were indexing

686
00:13:02,310 --> 00:13:02,320
 

687
00:13:02,320 --> 00:13:05,110
right so this again this case here I

688
00:13:05,110 --> 00:13:05,120
 

689
00:13:05,120 --> 00:13:07,870
build my index on a and B but now in the

690
00:13:07,870 --> 00:13:07,880
 

691
00:13:07,880 --> 00:13:09,850
leaf nodes for every entry of unique

692
00:13:09,850 --> 00:13:09,860
 

693
00:13:09,860 --> 00:13:11,769
pair of a and B I'm also going to

694
00:13:11,769 --> 00:13:11,779

695
00:13:11,779 --> 00:13:15,340
include the values of C so now if I have

696
00:13:15,340 --> 00:13:15,350
 

697
00:13:15,350 --> 00:13:17,050
my query that from before where I say

698
00:13:17,050 --> 00:13:17,060
 

699
00:13:17,060 --> 00:13:18,730
you know select B for food what a equals

700
00:13:18,730 --> 00:13:18,740
 

701
00:13:18,740 --> 00:13:21,069
1 through 3 and C equals whoo tang I can

702
00:13:21,069 --> 00:13:21,079
 

703
00:13:21,079 --> 00:13:23,439
get a and B from the index and then get

704
00:13:23,439 --> 00:13:23,449
 

705
00:13:23,449 --> 00:13:26,910
C from the where clause

706
00:13:26,910 --> 00:13:26,920
 

707
00:13:26,920 --> 00:13:29,769
so I as far as I know I know sequel

708
00:13:29,769 --> 00:13:29,779
 

709
00:13:29,779 --> 00:13:31,299
servers from Microsoft supports this

710
00:13:31,299 --> 00:13:31,309
 

711
00:13:31,309 --> 00:13:33,249
again Postgres 11 will support this

712
00:13:33,249 --> 00:13:33,259
 

713
00:13:33,259 --> 00:13:35,259
later this year my sequel doesn't do

714
00:13:35,259 --> 00:13:35,269
 

715
00:13:35,269 --> 00:13:38,169
this at least not in version 5,7 sequel

716
00:13:38,169 --> 00:13:38,179
 

717
00:13:38,179 --> 00:13:40,629
light doesn't do this and actually I

718
00:13:40,629 --> 00:13:40,639
 

719
00:13:40,639 --> 00:13:42,340
don't think Oracle and db2 does this but

720
00:13:42,340 --> 00:13:42,350
 

721
00:13:42,350 --> 00:13:46,329
I might be wrong so in theory again you

722
00:13:46,329 --> 00:13:46,339
 

723
00:13:46,339 --> 00:13:47,499
could just pack everything in the

724
00:13:47,499 --> 00:13:47,509
 

725
00:13:47,509 --> 00:13:49,179
include clause but then you essentially

726
00:13:49,179 --> 00:13:49,189
 

727
00:13:49,189 --> 00:13:52,059
end up with an index organized table and

728
00:13:52,059 --> 00:13:52,069
 

729
00:13:52,069 --> 00:13:54,160
you're just really sort of duplicating

730
00:13:54,160 --> 00:13:54,170
 

731
00:13:54,170 --> 00:13:56,590
things unnecessarily so sort of this

732
00:13:56,590 --> 00:13:56,600
 

733
00:13:56,600 --> 00:13:58,210
trade-off between how much I want to

734
00:13:58,210 --> 00:13:58,220
 

735
00:13:58,220 --> 00:14:01,389
include my index versus you know how

736
00:14:01,389 --> 00:14:01,399
 

737
00:14:01,399 --> 00:14:02,679
much extra space I'm willing to pay it

738
00:14:02,679 --> 00:14:02,689
 

739
00:14:02,689 --> 00:14:06,970
is try to speed up queries right so the

740
00:14:06,970 --> 00:14:06,980
 

741
00:14:06,980 --> 00:14:09,249
last thing I will talk about are what

742
00:14:09,249 --> 00:14:09,259
 

743
00:14:09,259 --> 00:14:10,540
are called functional and expression

744
00:14:10,540 --> 00:14:10,550

745
00:14:10,550 --> 00:14:13,030
indexes Postgres originally used to call

746
00:14:13,030 --> 00:14:13,040
 

747
00:14:13,040 --> 00:14:15,040
these functional indexes sometimes in

748
00:14:15,040 --> 00:14:15,050
 

749
00:14:15,050 --> 00:14:16,030
the literature it'll call expression

750
00:14:16,030 --> 00:14:16,040

751
00:14:16,040 --> 00:14:18,040
indexes but the way I think about this

752
00:14:18,040 --> 00:14:18,050
 

753
00:14:18,050 --> 00:14:20,889
is everything I've shown so far anytime

754
00:14:20,889 --> 00:14:20,899
 

755
00:14:20,899 --> 00:14:22,090
you created an index we would just

756
00:14:22,090 --> 00:14:22,100
 

757
00:14:22,100 --> 00:14:25,150
always say oh and attribute a 1 actually

758
00:14:25,150 --> 00:14:25,160
 

759
00:14:25,160 --> 00:14:27,280
be and would copy the exact values of

760
00:14:27,280 --> 00:14:27,290
 

761
00:14:27,290 --> 00:14:29,980
those attributes from the table and and

762
00:14:29,980 --> 00:14:29,990
 

763
00:14:29,990 --> 00:14:32,379
build your keys on those but there may

764
00:14:32,379 --> 00:14:32,389

765
00:14:32,389 --> 00:14:33,939
be some cases where I don't want to

766
00:14:33,939 --> 00:14:33,949
 

767
00:14:33,949 --> 00:14:36,340
store the keys exactly as they appear in

768
00:14:36,340 --> 00:14:36,350
 

769
00:14:36,350 --> 00:14:39,579
the underlying table let's say I have a

770
00:14:39,579 --> 00:14:39,589
 

771
00:14:39,589 --> 00:14:41,410
query like this I have a new table

772
00:14:41,410 --> 00:14:41,420
 

773
00:14:41,420 --> 00:14:42,879
called users and just think of like

774
00:14:42,879 --> 00:14:42,889
 

775
00:14:42,889 --> 00:14:44,919
people it's a user account and you keep

776
00:14:44,919 --> 00:14:44,929
 

777
00:14:44,929 --> 00:14:46,480
track of the timestamp of when someone

778
00:14:46,480 --> 00:14:46,490
 

779
00:14:46,490 --> 00:14:48,699
logged in and I have some query that

780
00:14:48,699 --> 00:14:48,709

781
00:14:48,709 --> 00:14:52,059
says I want to give me all the users

782
00:14:52,059 --> 00:14:52,069
 

783
00:14:52,069 --> 00:14:55,269
that logged in on a Tuesday so the

784
00:14:55,269 --> 00:14:55,279
 

785
00:14:55,279 --> 00:14:57,429
extract function says for given

786
00:14:57,429 --> 00:14:57,439

787
00:14:57,439 --> 00:14:59,650
timestamp login extract the day a week

788
00:14:59,650 --> 00:14:59,660
 

789
00:14:59,660 --> 00:15:00,970
from it and I'm checking here to see

790
00:15:00,970 --> 00:15:00,980
 

791
00:15:00,980 --> 00:15:02,679
equals to which is which is Tuesday

792
00:15:02,679 --> 00:15:02,689
 

793
00:15:02,689 --> 00:15:06,699
right sunday 0 Monday 1 Tuesday 2 so

794
00:15:06,699 --> 00:15:06,709
 

795
00:15:06,709 --> 00:15:08,910
let's say I build the index on login

796
00:15:08,910 --> 00:15:08,920
 

797
00:15:08,920 --> 00:15:11,889
like this would this help me for this

798
00:15:11,889 --> 00:15:11,899
 

799
00:15:11,899 --> 00:15:23,710
query shaking head no why correct he

800
00:15:23,710 --> 00:15:23,720
 

801
00:15:23,720 --> 00:15:25,210
says the data that we want in order to

802
00:15:25,210 --> 00:15:25,220
 

803
00:15:25,220 --> 00:15:27,340
that we need for to satisfy our where

804
00:15:27,340 --> 00:15:27,350
 

805
00:15:27,350 --> 00:15:29,710
Clause is not in the data itself it's

806
00:15:29,710 --> 00:15:29,720
 

807
00:15:29,720 --> 00:15:31,269
derived from the function we invoke

808
00:15:31,269 --> 00:15:31,279
 

809
00:15:31,279 --> 00:15:33,759
right so think about what this index is

810
00:15:33,759 --> 00:15:33,769
 

811
00:15:33,769 --> 00:15:35,739
actually doing it's going to create you

812
00:15:35,739 --> 00:15:35,749
 

813
00:15:35,749 --> 00:15:37,900
a sorted list of all the users based on

814
00:15:37,900 --> 00:15:37,910
 

815
00:15:37,910 --> 00:15:40,210
their login but I want

816
00:15:40,210 --> 00:15:40,220

817
00:15:40,220 --> 00:15:42,250
people that are logged in on Tuesday so

818
00:15:42,250 --> 00:15:42,260
 

819
00:15:42,260 --> 00:15:43,900
there's not gonna be a single range

820
00:15:43,900 --> 00:15:43,910
 

821
00:15:43,910 --> 00:15:46,330
where I can get these values that give

822
00:15:46,330 --> 00:15:46,340
 

823
00:15:46,340 --> 00:15:48,460
me all the people that are that logged

824
00:15:48,460 --> 00:15:48,470
 

825
00:15:48,470 --> 00:15:50,500
in on Tuesday I can may be a little bit

826
00:15:50,500 --> 00:15:50,510
 

827
00:15:50,510 --> 00:15:52,870
tricky and recognize my lower bound and

828
00:15:52,870 --> 00:15:52,880
 

829
00:15:52,880 --> 00:15:54,490
upper bound and try to calculate you

830
00:15:54,490 --> 00:15:54,500
 

831
00:15:54,500 --> 00:15:56,680
know what ranges would be people logging

832
00:15:56,680 --> 00:15:56,690
 

833
00:15:56,690 --> 00:15:58,720
in on Tuesday but as far as they don't

834
00:15:58,720 --> 00:15:58,730
 

835
00:15:58,730 --> 00:15:59,830
know data some what actually would

836
00:15:59,830 --> 00:15:59,840
 

837
00:15:59,840 --> 00:16:02,290
actually do that so this index doesn't

838
00:16:02,290 --> 00:16:02,300
 

839
00:16:02,300 --> 00:16:04,180
help us so instead what we can do is

840
00:16:04,180 --> 00:16:04,190
 

841
00:16:04,190 --> 00:16:06,070
that we can just take the expression

842
00:16:06,070 --> 00:16:06,080
 

843
00:16:06,080 --> 00:16:08,860
that we want to compute and embed that

844
00:16:08,860 --> 00:16:08,870
 

845
00:16:08,870 --> 00:16:12,550
in the index itself so now when I define

846
00:16:12,550 --> 00:16:12,560
 

847
00:16:12,560 --> 00:16:14,140
my import Keys I want to put my index

848
00:16:14,140 --> 00:16:14,150
 

849
00:16:14,150 --> 00:16:17,080
instead of having you know a single

850
00:16:17,080 --> 00:16:17,090
 

851
00:16:17,090 --> 00:16:18,850
attribute I can then put the same

852
00:16:18,850 --> 00:16:18,860
 

853
00:16:18,860 --> 00:16:20,170
function I would have normally in my

854
00:16:20,170 --> 00:16:20,180
 

855
00:16:20,180 --> 00:16:22,300
where clause in this case here we're

856
00:16:22,300 --> 00:16:22,310

857
00:16:22,310 --> 00:16:23,770
gonna we're gonna index everyone based

858
00:16:23,770 --> 00:16:23,780
 

859
00:16:23,780 --> 00:16:25,390
on the day of the week right we're still

860
00:16:25,390 --> 00:16:25,400
 

861
00:16:25,400 --> 00:16:26,680
getting everybody on Monday Tuesday

862
00:16:26,680 --> 00:16:26,690
 

863
00:16:26,690 --> 00:16:29,020
Wednesday and so forth and then now when

864
00:16:29,020 --> 00:16:29,030
 

865
00:16:29,030 --> 00:16:32,410
I execute this query it can it can you

866
00:16:32,410 --> 00:16:32,420
 

867
00:16:32,420 --> 00:16:34,240
know it you can know that I have the

868
00:16:34,240 --> 00:16:34,250
 

869
00:16:34,250 --> 00:16:36,100
function my where clause exactly matches

870
00:16:36,100 --> 00:16:36,110
 

871
00:16:36,110 --> 00:16:38,530
what I need in my in my index and

872
00:16:38,530 --> 00:16:38,540
 

873
00:16:38,540 --> 00:16:41,920
therefore I can use that so is there

874
00:16:41,920 --> 00:16:41,930
 

875
00:16:41,930 --> 00:16:43,000
another way to sort of do the same thing

876
00:16:43,000 --> 00:16:43,010
 

877
00:16:43,010 --> 00:16:44,940
and that we talked about before so far

878
00:16:44,940 --> 00:16:44,950
 

879
00:16:44,950 --> 00:16:47,080
another type of index we can use it to

880
00:16:47,080 --> 00:16:47,090
 

881
00:16:47,090 --> 00:16:49,090
essentially do the same thing for us say

882
00:16:49,090 --> 00:16:49,100
 

883
00:16:49,100 --> 00:16:50,590
we want to get exactly everybody that's

884
00:16:50,590 --> 00:16:50,600
 

885
00:16:50,600 --> 00:16:52,690
on a Tuesday with an index how would I

886
00:16:52,690 --> 00:16:52,700
 

887
00:16:52,700 --> 00:16:59,650
do that partial index right the where

888
00:16:59,650 --> 00:16:59,660
 

889
00:16:59,660 --> 00:17:01,000
clause means again to be anything you

890
00:17:01,000 --> 00:17:01,010
 

891
00:17:01,010 --> 00:17:02,200
have in a select statement and a where

892
00:17:02,200 --> 00:17:02,210
 

893
00:17:02,210 --> 00:17:03,490
clause you can put in your create index

894
00:17:03,490 --> 00:17:03,500
 

895
00:17:03,500 --> 00:17:08,410
in a where Clause right so let's do a

896
00:17:08,410 --> 00:17:08,420
 

897
00:17:08,420 --> 00:17:11,740
demo and we can see a little bit now

898
00:17:11,740 --> 00:17:11,750
 

899
00:17:11,750 --> 00:17:15,450
also how Postgres is gonna pick plans so

900
00:17:15,450 --> 00:17:15,460
 

901
00:17:15,460 --> 00:17:19,720
excuse me somebody asked why am I always

902
00:17:19,720 --> 00:17:19,730
 

903
00:17:19,730 --> 00:17:22,720
using Postgres and my demos is it

904
00:17:22,720 --> 00:17:22,730
 

905
00:17:22,730 --> 00:17:25,180
because I'm like you know a fanboy or

906
00:17:25,180 --> 00:17:25,190
 

907
00:17:25,190 --> 00:17:26,710
just you know obsessed with Postgres

908
00:17:26,710 --> 00:17:26,720
 

909
00:17:26,720 --> 00:17:29,380
postgis is really good post-crisis has

910
00:17:29,380 --> 00:17:29,390
 

911
00:17:29,390 --> 00:17:30,550
all the things that we're talking about

912
00:17:30,550 --> 00:17:30,560
 

913
00:17:30,560 --> 00:17:31,240
in this class

914
00:17:31,240 --> 00:17:31,250
 

915
00:17:31,250 --> 00:17:35,430
Postgres has available to us and we can

916
00:17:35,430 --> 00:17:35,440
 

917
00:17:35,440 --> 00:17:37,780
it's almost like almost a textbook

918
00:17:37,780 --> 00:17:37,790
 

919
00:17:37,790 --> 00:17:39,760
definition or implementation of a

920
00:17:39,760 --> 00:17:39,770
 

921
00:17:39,770 --> 00:17:41,950
database system and another thing I like

922
00:17:41,950 --> 00:17:41,960
 

923
00:17:41,960 --> 00:17:43,840
about Postgres too also is that it has

924
00:17:43,840 --> 00:17:43,850
 

925
00:17:43,850 --> 00:17:46,360
many of those things that the commercial

926
00:17:46,360 --> 00:17:46,370
 

927
00:17:46,370 --> 00:17:48,340
guys have Postgres eventually gets as

928
00:17:48,340 --> 00:17:48,350
 

929
00:17:48,350 --> 00:17:51,130
well right I said that the index include

930
00:17:51,130 --> 00:17:51,140
 

931
00:17:51,140 --> 00:17:52,420
columns was in sequel server that's

932
00:17:52,420 --> 00:17:52,430
 

933
00:17:52,430 --> 00:17:53,860
where its first implemented post

934
00:17:53,860 --> 00:17:53,870
 

935
00:17:53,870 --> 00:17:55,960
adding that now in 11 and it's open

936
00:17:55,960 --> 00:17:55,970
 

937
00:17:55,970 --> 00:17:59,049
source and free it's amazing alright so

938
00:17:59,049 --> 00:17:59,059
 

939
00:17:59,059 --> 00:18:01,030
let me do this let me drop the table of

940
00:18:01,030 --> 00:18:01,040
 

941
00:18:01,040 --> 00:18:05,049
users I'll create a new one right it

942
00:18:05,049 --> 00:18:05,059
 

943
00:18:05,059 --> 00:18:07,510
only has two fields has the ID field for

944
00:18:07,510 --> 00:18:07,520
 

945
00:18:07,520 --> 00:18:09,100
the primary key and just a wandering

946
00:18:09,100 --> 00:18:09,110
 

947
00:18:09,110 --> 00:18:10,780
current key always increasing and then

948
00:18:10,780 --> 00:18:10,790
 

949
00:18:10,790 --> 00:18:11,890
it's going to have this timestamp field

950
00:18:11,890 --> 00:18:11,900
 

951
00:18:11,900 --> 00:18:15,490
and then let's generate some synthetic

952
00:18:15,490 --> 00:18:15,500
 

953
00:18:15,500 --> 00:18:19,590
data so for this what I'll do is I will

954
00:18:19,590 --> 00:18:19,600

955
00:18:19,600 --> 00:18:27,400
do now I will do an insert query that

956
00:18:27,400 --> 00:18:27,410
 

957
00:18:27,410 --> 00:18:29,350
it's going to insert into the login

958
00:18:29,350 --> 00:18:29,360
 

959
00:18:29,360 --> 00:18:31,930
table and then it's gonna there's this

960
00:18:31,930 --> 00:18:31,940
 

961
00:18:31,940 --> 00:18:33,130
function in Postgres called generate

962
00:18:33,130 --> 00:18:33,140
 

963
00:18:33,140 --> 00:18:36,549
series that's just going to generate a

964
00:18:36,549 --> 00:18:36,559
 

965
00:18:36,559 --> 00:18:38,200
monotonically increasing a list of

966
00:18:38,200 --> 00:18:38,210

967
00:18:38,210 --> 00:18:40,030
values so it's going to generate me a

968
00:18:40,030 --> 00:18:40,040
 

969
00:18:40,040 --> 00:18:42,820
bunch of time stamps from 2017 generate

970
00:18:42,820 --> 00:18:42,830
 

971
00:18:42,830 --> 00:18:45,010
first until today at one month of

972
00:18:45,010 --> 00:18:45,020
 

973
00:18:45,020 --> 00:18:46,390
one-minute intervals and it's going to

974
00:18:46,390 --> 00:18:46,400
 

975
00:18:46,400 --> 00:18:50,740
created 900 thousand records so let's

976
00:18:50,740 --> 00:18:50,750
 

977
00:18:50,750 --> 00:18:53,110
say I take the query that I wanted right

978
00:18:53,110 --> 00:18:53,120
 

979
00:18:53,120 --> 00:18:55,390
like this if I run it it comes back

980
00:18:55,390 --> 00:18:55,400
 

981
00:18:55,400 --> 00:18:57,940
pretty fast but if we go check the query

982
00:18:57,940 --> 00:18:57,950
 

983
00:18:57,950 --> 00:19:00,790
plan you see that it's doing a

984
00:19:00,790 --> 00:19:00,800
 

985
00:19:00,800 --> 00:19:02,980
sequential scan on the user's table in

986
00:19:02,980 --> 00:19:02,990
 

987
00:19:02,990 --> 00:19:07,150
order to apply the predicate right so if

988
00:19:07,150 --> 00:19:07,160
 

989
00:19:07,160 --> 00:19:11,590
I now go create my index on just a login

990
00:19:11,590 --> 00:19:11,600
 

991
00:19:11,600 --> 00:19:18,130
field when everyone explain again it

992
00:19:18,130 --> 00:19:18,140
 

993
00:19:18,140 --> 00:19:19,450
doesn't pick the index because it

994
00:19:19,450 --> 00:19:19,460
 

995
00:19:19,460 --> 00:19:21,460
doesn't help us it only does this

996
00:19:21,460 --> 00:19:21,470
 

997
00:19:21,470 --> 00:19:24,400
winchell scan so let's drop that index

998
00:19:24,400 --> 00:19:24,410
 

999
00:19:24,410 --> 00:19:34,540
and make one with the partial index the

1000
00:19:34,540 --> 00:19:34,550
 

1001
00:19:34,550 --> 00:19:39,100
expression index and now when I run my

1002
00:19:39,100 --> 00:19:39,110
 

1003
00:19:39,110 --> 00:19:41,799
plug query plan it recognizes that it

1004
00:19:41,799 --> 00:19:41,809
 

1005
00:19:41,809 --> 00:19:44,970
can use the index that is created for a

1006
00:19:44,970 --> 00:19:44,980
 

1007
00:19:44,980 --> 00:19:48,400
for the for to do next and I'll explain

1008
00:19:48,400 --> 00:19:48,410
 

1009
00:19:48,410 --> 00:19:50,590
what a bitmap scan is later on but

1010
00:19:50,590 --> 00:19:50,600
 

1011
00:19:50,600 --> 00:19:52,000
basically just think about it

1012
00:19:52,000 --> 00:19:52,010
 

1013
00:19:52,010 --> 00:19:54,070
it's how post is keeping track of what

1014
00:19:54,070 --> 00:19:54,080
 

1015
00:19:54,080 --> 00:19:57,190
to post match so now let's create though

1016
00:19:57,190 --> 00:19:57,200
 

1017
00:19:57,200 --> 00:20:02,500
the partial index that I had before so

1018
00:20:02,500 --> 00:20:02,510
 

1019
00:20:02,510 --> 00:20:17,570
to Postgres login where

1020
00:20:17,570 --> 00:20:17,580


1021
00:20:17,580 --> 00:20:20,730
right so this is creating the partial

1022
00:20:20,730 --> 00:20:20,740
 

1023
00:20:20,740 --> 00:20:23,400
index where I'm still going to long get

1024
00:20:23,400 --> 00:20:23,410
 

1025
00:20:23,410 --> 00:20:25,080
all of the login information that the

1026
00:20:25,080 --> 00:20:25,090
 

1027
00:20:25,090 --> 00:20:27,090
login timestamp but my where clause says

1028
00:20:27,090 --> 00:20:27,100
 

1029
00:20:27,100 --> 00:20:28,770
only get people where they logged in on

1030
00:20:28,770 --> 00:20:28,780
 

1031
00:20:28,780 --> 00:20:31,830
on Tuesday so now if we go back to our

1032
00:20:31,830 --> 00:20:31,840
 

1033
00:20:31,840 --> 00:20:35,070
query plan let's take a take a bet who

1034
00:20:35,070 --> 00:20:35,080

1035
00:20:35,080 --> 00:20:36,450
says post dress is gonna pick the

1036
00:20:36,450 --> 00:20:36,460
 

1037
00:20:36,460 --> 00:20:38,430
partial index who says it's going to

1038
00:20:38,430 --> 00:20:38,440
 

1039
00:20:38,440 --> 00:20:41,670
pick the expression index raise your

1040
00:20:41,670 --> 00:20:41,680
 

1041
00:20:41,680 --> 00:20:46,020
hand for partial and if you say raise

1042
00:20:46,020 --> 00:20:46,030
 

1043
00:20:46,030 --> 00:20:48,450
hand for the expression index so why do

1044
00:20:48,450 --> 00:20:48,460
 

1045
00:20:48,460 --> 00:20:49,380
you think it would pick the expression

1046
00:20:49,380 --> 00:20:49,390
 

1047
00:20:49,390 --> 00:20:53,130
index horse isn't it

1048
00:20:53,130 --> 00:20:53,140
 

1049
00:20:53,140 --> 00:20:54,840
although the partial index is pretty

1050
00:20:54,840 --> 00:20:54,850

1051
00:20:54,850 --> 00:20:56,430
specific right

1052
00:20:56,430 --> 00:20:56,440
 

1053
00:20:56,440 --> 00:20:59,460
the partial index was which one was it

1054
00:20:59,460 --> 00:20:59,470

1055
00:20:59,470 --> 00:21:05,370
this one this one right where extract

1056
00:21:05,370 --> 00:21:05,380
 

1057
00:21:05,380 --> 00:21:08,280
we're day a week with a lot from login

1058
00:21:08,280 --> 00:21:08,290
 

1059
00:21:08,290 --> 00:21:10,680
equals two that's exactly what I want to

1060
00:21:10,680 --> 00:21:10,690
 

1061
00:21:10,690 --> 00:21:16,470
execute in my query right from one my

1062
00:21:16,470 --> 00:21:16,480
 

1063
00:21:16,480 --> 00:21:18,210
index is where day a week from login

1064
00:21:18,210 --> 00:21:18,220
 

1065
00:21:18,220 --> 00:21:22,560
Eagles - so take the partial index again

1066
00:21:22,560 --> 00:21:22,570
 

1067
00:21:22,570 --> 00:21:24,480
it knows how to match the where clause

1068
00:21:24,480 --> 00:21:24,490
 

1069
00:21:24,490 --> 00:21:26,430
with what's in with that's defined for

1070
00:21:26,430 --> 00:21:26,440
 

1071
00:21:26,440 --> 00:21:28,230
the index with the where clause that's

1072
00:21:28,230 --> 00:21:28,240
 

1073
00:21:28,240 --> 00:21:31,140
defining your query and pick that if I

1074
00:21:31,140 --> 00:21:31,150
 

1075
00:21:31,150 --> 00:21:33,080
change this to b3

1076
00:21:33,080 --> 00:21:33,090
 

1077
00:21:33,090 --> 00:21:36,630
right it picks the expression index

1078
00:21:36,630 --> 00:21:36,640
 

1079
00:21:36,640 --> 00:21:38,430
because the partial index doesn't have

1080
00:21:38,430 --> 00:21:38,440
 

1081
00:21:38,440 --> 00:21:42,090
any of that information all right this

1082
00:21:42,090 --> 00:21:42,100
 

1083
00:21:42,100 --> 00:21:43,380
is sort of clear what's going on to meet

1084
00:21:43,380 --> 00:21:43,390
 

1085
00:21:43,390 --> 00:21:46,050
the covers and it uses the same all the

1086
00:21:46,050 --> 00:21:46,060
 

1087
00:21:46,060 --> 00:21:47,490
same storage information that we talked

1088
00:21:47,490 --> 00:21:47,500
 

1089
00:21:47,500 --> 00:21:49,650
about last class right it's doing the

1090
00:21:49,650 --> 00:21:49,660
 

1091
00:21:49,660 --> 00:21:51,600
same thing all right there's nothing

1092
00:21:51,600 --> 00:21:51,610
 

1093
00:21:51,610 --> 00:21:52,830
special because it's an expression it

1094
00:21:52,830 --> 00:21:52,840
 

1095
00:21:52,840 --> 00:21:56,550
just knows that when I insert a record I

1096
00:21:56,550 --> 00:21:56,560
 

1097
00:21:56,560 --> 00:21:59,060
run that expression and insert that into

1098
00:21:59,060 --> 00:21:59,070
 

1099
00:21:59,070 --> 00:22:02,070
as the key rather than the original

1100
00:22:02,070 --> 00:22:02,080
 

1101
00:22:02,080 --> 00:22:03,660
attribute the original value of the

1102
00:22:03,660 --> 00:22:03,670
 

1103
00:22:03,670 --> 00:22:08,740
thing I am indexing yes

1104
00:22:08,740 --> 00:22:08,750


1105
00:22:08,750 --> 00:22:10,090
his question is when should you create

1106
00:22:10,090 --> 00:22:10,100
 

1107
00:22:10,100 --> 00:22:14,530
or drop an index I is that just an

1108
00:22:14,530 --> 00:22:14,540
 

1109
00:22:14,540 --> 00:22:18,550
open-ended broad question do you mean

1110
00:22:18,550 --> 00:22:18,560
 

1111
00:22:18,560 --> 00:22:19,630
and mean something specifically in

1112
00:22:19,630 --> 00:22:19,640
 

1113
00:22:19,640 --> 00:22:21,310
people notation or is it like like if

1114
00:22:21,310 --> 00:22:21,320
 

1115
00:22:21,320 --> 00:22:22,600
I'm administrating a database when

1116
00:22:22,600 --> 00:22:22,610

1117
00:22:22,610 --> 00:22:26,590
should I do this this question is from

1118
00:22:26,590 --> 00:22:26,600
 

1119
00:22:26,600 --> 00:22:28,060
the application level when it when is

1120
00:22:28,060 --> 00:22:28,070
 

1121
00:22:28,070 --> 00:22:29,590
the right time to drop a created index

1122
00:22:29,590 --> 00:22:29,600
 

1123
00:22:29,600 --> 00:22:33,040
so this is essentially what DBAs do for

1124
00:22:33,040 --> 00:22:33,050
 

1125
00:22:33,050 --> 00:22:36,070
you right you you basically look for

1126
00:22:36,070 --> 00:22:36,080
 

1127
00:22:36,080 --> 00:22:38,020
your application and say what queries

1128
00:22:38,020 --> 00:22:38,030
 

1129
00:22:38,030 --> 00:22:41,230
are running slow and which ones are you

1130
00:22:41,230 --> 00:22:41,240
 

1131
00:22:41,240 --> 00:22:42,610
know what queries running flow and are

1132
00:22:42,610 --> 00:22:42,620

1133
00:22:42,620 --> 00:22:43,930
the indexes that could help me improve

1134
00:22:43,930 --> 00:22:43,940
 

1135
00:22:43,940 --> 00:22:46,480
the performance right so there's tools

1136
00:22:46,480 --> 00:22:46,490

1137
00:22:46,490 --> 00:22:48,340
to sort of do this for you and a lot of

1138
00:22:48,340 --> 00:22:48,350
 

1139
00:22:48,350 --> 00:22:51,040
cases for like OTP applications like if

1140
00:22:51,040 --> 00:22:51,050
 

1141
00:22:51,050 --> 00:22:53,020
you use like an ORM like you know Django

1142
00:22:53,020 --> 00:22:53,030
 

1143
00:22:53,030 --> 00:22:53,980
or Ruby on Rails

1144
00:22:53,980 --> 00:22:53,990
 

1145
00:22:53,990 --> 00:22:57,250
you know you define you get implicit

1146
00:22:57,250 --> 00:22:57,260

1147
00:22:57,260 --> 00:22:58,750
index for free right because you say I

1148
00:22:58,750 --> 00:22:58,760
 

1149
00:22:58,760 --> 00:23:01,060
want this activity unique because most

1150
00:23:01,060 --> 00:23:01,070
 

1151
00:23:01,070 --> 00:23:02,050
of the time I'm doing the lookups on

1152
00:23:02,050 --> 00:23:02,060
 

1153
00:23:02,060 --> 00:23:04,060
that so then it'll create the index for

1154
00:23:04,060 --> 00:23:04,070
 

1155
00:23:04,070 --> 00:23:05,920
you so you gets you things speed up the

1156
00:23:05,920 --> 00:23:05,930
 

1157
00:23:05,930 --> 00:23:07,960
more complicated things are when you

1158
00:23:07,960 --> 00:23:07,970
 

1159
00:23:07,970 --> 00:23:09,340
have to let the local it queries are

1160
00:23:09,340 --> 00:23:09,350
 

1161
00:23:09,350 --> 00:23:10,750
running slow and there's ways to turn on

1162
00:23:10,750 --> 00:23:10,760
 

1163
00:23:10,760 --> 00:23:12,760
this it's called the slow query log and

1164
00:23:12,760 --> 00:23:12,770
 

1165
00:23:12,770 --> 00:23:14,230
my sequin Postgres in those systems to

1166
00:23:14,230 --> 00:23:14,240
 

1167
00:23:14,240 --> 00:23:15,820
say show me all the queries that run

1168
00:23:15,820 --> 00:23:15,830
 

1169
00:23:15,830 --> 00:23:18,040
longer than 20 milliseconds you look at

1170
00:23:18,040 --> 00:23:18,050
 

1171
00:23:18,050 --> 00:23:19,090
a bunch of those and say well what's

1172
00:23:19,090 --> 00:23:19,100
 

1173
00:23:19,100 --> 00:23:20,530
what's that what indexes could I use to

1174
00:23:20,530 --> 00:23:20,540
 

1175
00:23:20,540 --> 00:23:22,990
speed things up all right so it's sort

1176
00:23:22,990 --> 00:23:23,000
 

1177
00:23:23,000 --> 00:23:24,310
of like you just let the look and see

1178
00:23:24,310 --> 00:23:24,320
 

1179
00:23:24,320 --> 00:23:26,710
what's slowing you down there's no like

1180
00:23:26,710 --> 00:23:26,720
 

1181
00:23:26,720 --> 00:23:27,940
there's no the conventional wisdom a

1182
00:23:27,940 --> 00:23:27,950
 

1183
00:23:27,950 --> 00:23:29,680
hard fast rule to say if your query

1184
00:23:29,680 --> 00:23:29,690
 

1185
00:23:29,690 --> 00:23:31,030
looks like this then add it index if

1186
00:23:31,030 --> 00:23:31,040
 

1187
00:23:31,040 --> 00:23:31,750
your quarry looks like that and then

1188
00:23:31,750 --> 00:23:31,760
 

1189
00:23:31,760 --> 00:23:33,970
drop an index it depends on the

1190
00:23:33,970 --> 00:23:33,980
 

1191
00:23:33,980 --> 00:23:35,110
application what you care about

1192
00:23:35,110 --> 00:23:35,120
 

1193
00:23:35,120 --> 00:23:38,980
right it's maybe the case that I have a

1194
00:23:38,980 --> 00:23:38,990
 

1195
00:23:38,990 --> 00:23:41,230
query that's just like it takes you know

1196
00:23:41,230 --> 00:23:41,240
 

1197
00:23:41,240 --> 00:23:43,750
100 milliseconds but it runs once a day

1198
00:23:43,750 --> 00:23:43,760
 

1199
00:23:43,760 --> 00:23:44,580
so who cares

1200
00:23:44,580 --> 00:23:44,590

1201
00:23:44,590 --> 00:23:47,080
all right it depends what you want your

1202
00:23:47,080 --> 00:23:47,090
 

1203
00:23:47,090 --> 00:23:52,270
application ok all right so any

1204
00:23:52,270 --> 00:23:52,280
 

1205
00:23:52,280 --> 00:23:53,530
questions about like these other ways to

1206
00:23:53,530 --> 00:23:53,540
 

1207
00:23:53,540 --> 00:23:56,200
use indexes all right pretty

1208
00:23:56,200 --> 00:23:56,210
 

1209
00:23:56,210 --> 00:23:57,700
straightforward again it just builds on

1210
00:23:57,700 --> 00:23:57,710
 

1211
00:23:57,710 --> 00:23:58,810
top of the things we've already talked

1212
00:23:58,810 --> 00:23:58,820

1213
00:23:58,820 --> 00:24:00,220
about like what you have a you know

1214
00:24:00,220 --> 00:24:00,230
 

1215
00:24:00,230 --> 00:24:02,560
awesome underlying data structure that

1216
00:24:02,560 --> 00:24:02,570
 

1217
00:24:02,570 --> 00:24:04,630
you know is its thread safe and reliable

1218
00:24:04,630 --> 00:24:04,640
 

1219
00:24:04,640 --> 00:24:06,430
you can stand start implementing all

1220
00:24:06,430 --> 00:24:06,440
 

1221
00:24:06,440 --> 00:24:07,660
these other cool things on top of this

1222
00:24:07,660 --> 00:24:07,670
 

1223
00:24:07,670 --> 00:24:08,740
and it's essentially what you know that

1224
00:24:08,740 --> 00:24:08,750
 

1225
00:24:08,750 --> 00:24:12,550
do it why more older database systems

1226
00:24:12,550 --> 00:24:12,560
 

1227
00:24:12,560 --> 00:24:14,070
have more way more features than the

1228
00:24:14,070 --> 00:24:14,080
 

1229
00:24:14,080 --> 00:24:16,540
then let the newer guys like Postgres

1230
00:24:16,540 --> 00:24:16,550
 

1231
00:24:16,550 --> 00:24:17,470
has been around for a while and there's

1232
00:24:17,470 --> 00:24:17,480
 

1233
00:24:17,480 --> 00:24:18,700
adding all this we'll call some stuff

1234
00:24:18,700 --> 00:24:18,710
 

1235
00:24:18,710 --> 00:24:20,320
you know on top of their existing

1236
00:24:20,320 --> 00:24:20,330
 

1237
00:24:20,330 --> 00:24:22,360
infrastructure

1238
00:24:22,360 --> 00:24:22,370

1239
00:24:22,370 --> 00:24:24,070
all right so I want to step back now and

1240
00:24:24,070 --> 00:24:24,080
 

1241
00:24:24,080 --> 00:24:25,240
start talking out different data

1242
00:24:25,240 --> 00:24:25,250
 

1243
00:24:25,250 --> 00:24:29,380
structures so the way to think about

1244
00:24:29,380 --> 00:24:29,390
 

1245
00:24:29,390 --> 00:24:31,269
what we talked about last class with the

1246
00:24:31,269 --> 00:24:31,279
 

1247
00:24:31,279 --> 00:24:34,600
B plus stream is that we were

1248
00:24:34,600 --> 00:24:34,610
 

1249
00:24:34,610 --> 00:24:37,180
essentially building a sorted list of

1250
00:24:37,180 --> 00:24:37,190
 

1251
00:24:37,190 --> 00:24:39,880
keys right if you think of like the leaf

1252
00:24:39,880 --> 00:24:39,890
 

1253
00:24:39,890 --> 00:24:41,529
nodes the leaf nodes were just just

1254
00:24:41,529 --> 00:24:41,539

1255
00:24:41,539 --> 00:24:44,289
essentially just a linked list of keys

1256
00:24:44,289 --> 00:24:44,299
 

1257
00:24:44,299 --> 00:24:46,510
in sorted order and then there was some

1258
00:24:46,510 --> 00:24:46,520
 

1259
00:24:46,520 --> 00:24:48,340
infrastructure on top of them to keep

1260
00:24:48,340 --> 00:24:48,350
 

1261
00:24:48,350 --> 00:24:50,380
the the the tree portion of the data

1262
00:24:50,380 --> 00:24:50,390

1263
00:24:50,390 --> 00:24:52,330
structure that we would use to route

1264
00:24:52,330 --> 00:24:52,340
 

1265
00:24:52,340 --> 00:24:53,950
ourselves to find the data that we're

1266
00:24:53,950 --> 00:24:53,960
 

1267
00:24:53,960 --> 00:24:56,500
looking for but the most simplest way to

1268
00:24:56,500 --> 00:24:56,510
 

1269
00:24:56,510 --> 00:24:58,029
actually implement an index would be

1270
00:24:58,029 --> 00:24:58,039
 

1271
00:24:58,039 --> 00:25:04,060
just just a single linked list right the

1272
00:25:04,060 --> 00:25:04,070
 

1273
00:25:04,070 --> 00:25:05,769
problem though is that all the

1274
00:25:05,769 --> 00:25:05,779
 

1275
00:25:05,779 --> 00:25:08,080
operations on that linked list would be

1276
00:25:08,080 --> 00:25:08,090
 

1277
00:25:08,090 --> 00:25:11,889
always in oh end time because you have

1278
00:25:11,889 --> 00:25:11,899
 

1279
00:25:11,899 --> 00:25:14,200
to do a linear search alright so again

1280
00:25:14,200 --> 00:25:14,210
 

1281
00:25:14,210 --> 00:25:16,000
think of this is just the leaf nodes of

1282
00:25:16,000 --> 00:25:16,010
 

1283
00:25:16,010 --> 00:25:18,700
our of our B plus tree we have keys and

1284
00:25:18,700 --> 00:25:18,710
 

1285
00:25:18,710 --> 00:25:21,370
then we have values the value portion is

1286
00:25:21,370 --> 00:25:21,380
 

1287
00:25:21,380 --> 00:25:23,769
just a pointer to the next key so

1288
00:25:23,769 --> 00:25:23,779
 

1289
00:25:23,779 --> 00:25:25,560
anytime I want to find Pickler key I

1290
00:25:25,560 --> 00:25:25,570
 

1291
00:25:25,570 --> 00:25:28,330
don't I can't jump to the middle I have

1292
00:25:28,330 --> 00:25:28,340
 

1293
00:25:28,340 --> 00:25:29,889
to scan across from the beginning and

1294
00:25:29,889 --> 00:25:29,899
 

1295
00:25:29,899 --> 00:25:32,740
check as I go along worst worst case

1296
00:25:32,740 --> 00:25:32,750
 

1297
00:25:32,750 --> 00:25:34,090
scenario I'm at the end best case

1298
00:25:34,090 --> 00:25:34,100

1299
00:25:34,100 --> 00:25:35,320
scenario I'm the first one I'm looking

1300
00:25:35,320 --> 00:25:35,330
 

1301
00:25:35,330 --> 00:25:38,740
for right again it's just just a simple

1302
00:25:38,740 --> 00:25:38,750
 

1303
00:25:38,750 --> 00:25:42,460
linked list so one way to sort of speed

1304
00:25:42,460 --> 00:25:42,470
 

1305
00:25:42,470 --> 00:25:45,220
things up is that rather than doing our

1306
00:25:45,220 --> 00:25:45,230
 

1307
00:25:45,230 --> 00:25:47,110
searches in literally by just looking at

1308
00:25:47,110 --> 00:25:47,120
 

1309
00:25:47,120 --> 00:25:49,120
one key after another we could actually

1310
00:25:49,120 --> 00:25:49,130
 

1311
00:25:49,130 --> 00:25:51,880
maybe build sort of a way to jump ahead

1312
00:25:51,880 --> 00:25:51,890
 

1313
00:25:51,890 --> 00:25:56,139
in our linked list to find keys the key

1314
00:25:56,139 --> 00:25:56,149
 

1315
00:25:56,149 --> 00:25:57,120
that we're looking for more quickly

1316
00:25:57,120 --> 00:25:57,130
 

1317
00:25:57,130 --> 00:25:59,320
right so it's a really simple way to do

1318
00:25:59,320 --> 00:25:59,330
 

1319
00:25:59,330 --> 00:26:01,870
this would just be add another pointer

1320
00:26:01,870 --> 00:26:01,880
 

1321
00:26:01,880 --> 00:26:04,120
for every other element that points to

1322
00:26:04,120 --> 00:26:04,130
 

1323
00:26:04,130 --> 00:26:06,340
that jumps over that element that key

1324
00:26:06,340 --> 00:26:06,350
 

1325
00:26:06,350 --> 00:26:08,500
right so from key 1 I can either go from

1326
00:26:08,500 --> 00:26:08,510
 

1327
00:26:08,510 --> 00:26:11,710
key to or jump ahead and go to key 3 so

1328
00:26:11,710 --> 00:26:11,720
 

1329
00:26:11,720 --> 00:26:13,299
now if I'm looking for a particular key

1330
00:26:13,299 --> 00:26:13,309
 

1331
00:26:13,309 --> 00:26:16,389
say key key 5 I can look at key 1 so

1332
00:26:16,389 --> 00:26:16,399
 

1333
00:26:16,399 --> 00:26:18,220
that's not the one I want jump ahead to

1334
00:26:18,220 --> 00:26:18,230
 

1335
00:26:18,230 --> 00:26:20,799
key 3 that's not the one I want either

1336
00:26:20,799 --> 00:26:20,809
 

1337
00:26:20,809 --> 00:26:22,690
jump ahead using the top level over key

1338
00:26:22,690 --> 00:26:22,700
 

1339
00:26:22,700 --> 00:26:24,639
for - key 5 and then I found what I

1340
00:26:24,639 --> 00:26:24,649
 

1341
00:26:24,649 --> 00:26:29,280
wanted yes

1342
00:26:29,280 --> 00:26:29,290


1343
00:26:29,290 --> 00:26:31,720
so this question is our belief notes and

1344
00:26:31,720 --> 00:26:31,730
 

1345
00:26:31,730 --> 00:26:33,760
gatito's regions of memory for this

1346
00:26:33,760 --> 00:26:33,770
 

1347
00:26:33,770 --> 00:26:42,940
assume no statement is if we if we

1348
00:26:42,940 --> 00:26:42,950
 

1349
00:26:42,950 --> 00:26:44,950
assume yes can we just do a binary

1350
00:26:44,950 --> 00:26:44,960
 

1351
00:26:44,960 --> 00:26:48,700
search that will make searching go

1352
00:26:48,700 --> 00:26:48,710
 

1353
00:26:48,710 --> 00:26:50,710
faster that makes insertion slower

1354
00:26:50,710 --> 00:26:50,720
 

1355
00:26:50,720 --> 00:26:52,330
because now you got to slide everything

1356
00:26:52,330 --> 00:26:52,340
 

1357
00:26:52,340 --> 00:26:55,930
over right just keep it really steep

1358
00:26:55,930 --> 00:26:55,940
 

1359
00:26:55,940 --> 00:26:57,130
ascent with a linked list writes the

1360
00:26:57,130 --> 00:26:57,140
 

1361
00:26:57,140 --> 00:27:00,010
easiest data structure to implement ok

1362
00:27:00,010 --> 00:27:00,020
 

1363
00:27:00,020 --> 00:27:01,750
so we knew this and skip ahead and that

1364
00:27:01,750 --> 00:27:01,760
 

1365
00:27:01,760 --> 00:27:03,220
helps us that cuts things down further

1366
00:27:03,220 --> 00:27:03,230
 

1367
00:27:03,230 --> 00:27:05,409
we can just go add another level of

1368
00:27:05,409 --> 00:27:05,419
 

1369
00:27:05,419 --> 00:27:07,930
pointers and skip every 4th one right

1370
00:27:07,930 --> 00:27:07,940
 

1371
00:27:07,940 --> 00:27:10,750
and so forth right so now to find the

1372
00:27:10,750 --> 00:27:10,760
 

1373
00:27:10,760 --> 00:27:13,180
key that we'll be looking for is is we

1374
00:27:13,180 --> 00:27:13,190
 

1375
00:27:13,190 --> 00:27:14,740
can follow along the top point and we

1376
00:27:14,740 --> 00:27:14,750
 

1377
00:27:14,750 --> 00:27:16,990
realized we go too far can we go down

1378
00:27:16,990 --> 00:27:17,000
 

1379
00:27:17,000 --> 00:27:18,400
the next level may follow those pointers

1380
00:27:18,400 --> 00:27:18,410
 

1381
00:27:18,410 --> 00:27:19,690
until we reach the very bottom and find

1382
00:27:19,690 --> 00:27:19,700
 

1383
00:27:19,700 --> 00:27:21,400
the thing we want or find that we've

1384
00:27:21,400 --> 00:27:21,410
 

1385
00:27:21,410 --> 00:27:24,370
gone past the key where we we've gone

1386
00:27:24,370 --> 00:27:24,380
 

1387
00:27:24,380 --> 00:27:25,840
past the key where our key should be so

1388
00:27:25,840 --> 00:27:25,850
 

1389
00:27:25,850 --> 00:27:28,720
we know it's not there so this is a high

1390
00:27:28,720 --> 00:27:28,730
 

1391
00:27:28,730 --> 00:27:31,750
level is what a skip list is so skip

1392
00:27:31,750 --> 00:27:31,760
 

1393
00:27:31,760 --> 00:27:33,310
list is essentially a multiple level two

1394
00:27:33,310 --> 00:27:33,320
 

1395
00:27:33,320 --> 00:27:36,190
linked lists and you could have extra

1396
00:27:36,190 --> 00:27:36,200
 

1397
00:27:36,200 --> 00:27:38,799
pointers there skip over intermediate

1398
00:27:38,799 --> 00:27:38,809
 

1399
00:27:38,809 --> 00:27:40,810
nodes in your linked list there's a

1400
00:27:40,810 --> 00:27:40,820
 

1401
00:27:40,820 --> 00:27:42,730
quick show hands who here is heard of a

1402
00:27:42,730 --> 00:27:42,740

1403
00:27:42,740 --> 00:27:46,450
skip list before ok but about a third

1404
00:27:46,450 --> 00:27:46,460
 

1405
00:27:46,460 --> 00:27:51,340
maybe lesson happen so again the way to

1406
00:27:51,340 --> 00:27:51,350
 

1407
00:27:51,350 --> 00:27:52,480
think about is it gonna have multiple

1408
00:27:52,480 --> 00:27:52,490
 

1409
00:27:52,490 --> 00:27:53,799
levels of these linked lists and what

1410
00:27:53,799 --> 00:27:53,809
 

1411
00:27:53,809 --> 00:27:55,030
have these extra pointers allow us to

1412
00:27:55,030 --> 00:27:55,040
 

1413
00:27:55,040 --> 00:27:56,830
jump ahead things now if you sort of

1414
00:27:56,830 --> 00:27:56,840
 

1415
00:27:56,840 --> 00:27:58,539
think at a high level when I show the

1416
00:27:58,539 --> 00:27:58,549
 

1417
00:27:58,549 --> 00:28:00,340
diagram it's gonna look a lot like a P

1418
00:28:00,340 --> 00:28:00,350
 

1419
00:28:00,350 --> 00:28:03,130
plus tree right but we'll see some

1420
00:28:03,130 --> 00:28:03,140
 

1421
00:28:03,140 --> 00:28:04,510
differences later on because we don't

1422
00:28:04,510 --> 00:28:04,520

1423
00:28:04,520 --> 00:28:07,180
have to end up doing any rebalancing

1424
00:28:07,180 --> 00:28:07,190
 

1425
00:28:07,190 --> 00:28:09,460
anytime we do it insert and delete with

1426
00:28:09,460 --> 00:28:09,470
 

1427
00:28:09,470 --> 00:28:11,200
a linked list we don't have to ever do

1428
00:28:11,200 --> 00:28:11,210
 

1429
00:28:11,210 --> 00:28:13,539
splits and merges because all we know

1430
00:28:13,539 --> 00:28:13,549

1431
00:28:13,549 --> 00:28:15,730
that we we want to add our entry we just

1432
00:28:15,730 --> 00:28:15,740
 

1433
00:28:15,740 --> 00:28:17,650
update the guy that came before it to

1434
00:28:17,650 --> 00:28:17,660
 

1435
00:28:17,660 --> 00:28:19,090
now point to us instead of pointing to

1436
00:28:19,090 --> 00:28:19,100
 

1437
00:28:19,100 --> 00:28:22,630
the one that we now point to so this is

1438
00:28:22,630 --> 00:28:22,640
 

1439
00:28:22,640 --> 00:28:23,740
sort of one of the advantages you're

1440
00:28:23,740 --> 00:28:23,750
 

1441
00:28:23,750 --> 00:28:25,960
gonna get within a skip list so it's not

1442
00:28:25,960 --> 00:28:25,970
 

1443
00:28:25,970 --> 00:28:28,480
a new data structure it dates back to I

1444
00:28:28,480 --> 00:28:28,490
 

1445
00:28:28,490 --> 00:28:30,250
think 1990 it was invented by a

1446
00:28:30,250 --> 00:28:30,260
 

1447
00:28:30,260 --> 00:28:33,220
professor at University of Maryland but

1448
00:28:33,220 --> 00:28:33,230
 

1449
00:28:33,230 --> 00:28:35,110
in the last 10 years

1450
00:28:35,110 --> 00:28:35,120
 

1451
00:28:35,120 --> 00:28:36,610
skip lows have become sort of

1452
00:28:36,610 --> 00:28:36,620
 

1453
00:28:36,620 --> 00:28:39,580
fashionable because you can actually

1454
00:28:39,580 --> 00:28:39,590
 

1455
00:28:39,590 --> 00:28:41,500
implement one as a lock free data

1456
00:28:41,500 --> 00:28:41,510
 

1457
00:28:41,510 --> 00:28:43,460
structure

1458
00:28:43,460 --> 00:28:43,470

1459
00:28:43,470 --> 00:28:44,930
we can argue whether that's a good idea

1460
00:28:44,930 --> 00:28:44,940
 

1461
00:28:44,940 --> 00:28:46,250
or not and actually show numbers I

1462
00:28:46,250 --> 00:28:46,260
 

1463
00:28:46,260 --> 00:28:48,410
showed it is not a good idea but there

1464
00:28:48,410 --> 00:28:48,420
 

1465
00:28:48,420 --> 00:28:50,420
has been a couple systems in recent

1466
00:28:50,420 --> 00:28:50,430
 

1467
00:28:50,430 --> 00:28:53,510
years that that you skip list so rock DB

1468
00:28:53,510 --> 00:28:53,520
 

1469
00:28:53,520 --> 00:28:55,280
is a log structured system that we

1470
00:28:55,280 --> 00:28:55,290
 

1471
00:28:55,290 --> 00:28:57,050
talked about earlier right instead of

1472
00:28:57,050 --> 00:28:57,060
 

1473
00:28:57,060 --> 00:28:58,700
sorting the tuples they store logs in

1474
00:28:58,700 --> 00:28:58,710
 

1475
00:28:58,710 --> 00:29:00,980
the heap files and then they build it in

1476
00:29:00,980 --> 00:29:00,990
 

1477
00:29:00,990 --> 00:29:02,630
memory skip lists to keep map u from

1478
00:29:02,630 --> 00:29:02,640
 

1479
00:29:02,640 --> 00:29:06,230
keys to offsets in the log Y our Tiger

1480
00:29:06,230 --> 00:29:06,240
 

1481
00:29:06,240 --> 00:29:07,850
builds builds an in memory skip lists as

1482
00:29:07,850 --> 00:29:07,860
 

1483
00:29:07,860 --> 00:29:09,320
an ephemeral data structure when they

1484
00:29:09,320 --> 00:29:09,330

1485
00:29:09,330 --> 00:29:10,940
fetch in a page getting sort of the same

1486
00:29:10,940 --> 00:29:10,950
 

1487
00:29:10,950 --> 00:29:12,590
thing you build some way to jump to

1488
00:29:12,590 --> 00:29:12,600
 

1489
00:29:12,600 --> 00:29:14,720
different offsets very quickly in an ER

1490
00:29:14,720 --> 00:29:14,730
 

1491
00:29:14,730 --> 00:29:17,150
page the most famous Skip list database

1492
00:29:17,150 --> 00:29:17,160
 

1493
00:29:17,160 --> 00:29:19,220
system is mem sequel we can talk offline

1494
00:29:19,220 --> 00:29:19,230
 

1495
00:29:19,230 --> 00:29:21,080
about how they came around to deciding

1496
00:29:21,080 --> 00:29:21,090
 

1497
00:29:21,090 --> 00:29:22,940
to use a skip list but there are all the

1498
00:29:22,940 --> 00:29:22,950
 

1499
00:29:22,950 --> 00:29:24,320
non skip lists they do not have a B+

1500
00:29:24,320 --> 00:29:24,330
 

1501
00:29:24,330 --> 00:29:26,240
tree they do not have any other index

1502
00:29:26,240 --> 00:29:26,250
 

1503
00:29:26,250 --> 00:29:27,740
that they're all they use nothing but

1504
00:29:27,740 --> 00:29:27,750
 

1505
00:29:27,750 --> 00:29:38,960
skippers yes why does what sorry well

1506
00:29:38,960 --> 00:29:38,970
 

1507
00:29:38,970 --> 00:29:40,760
what will make more complicated so it's

1508
00:29:40,760 --> 00:29:40,770
 

1509
00:29:40,770 --> 00:29:41,840
quite this question is does this make

1510
00:29:41,840 --> 00:29:41,850
 

1511
00:29:41,850 --> 00:29:43,640
insertion more complicated let's go

1512
00:29:43,640 --> 00:29:43,650
 

1513
00:29:43,650 --> 00:29:44,870
through an example of insertions and

1514
00:29:44,870 --> 00:29:44,880
 

1515
00:29:44,880 --> 00:29:47,120
you'll see why not again comparing this

1516
00:29:47,120 --> 00:29:47,130
 

1517
00:29:47,130 --> 00:29:48,680
with the B+ tree the B+ tree I do an

1518
00:29:48,680 --> 00:29:48,690
 

1519
00:29:48,690 --> 00:29:51,320
insertion and I may have to split my

1520
00:29:51,320 --> 00:29:51,330
 

1521
00:29:51,330 --> 00:29:53,540
node but then that that recursively goes

1522
00:29:53,540 --> 00:29:53,550
 

1523
00:29:53,550 --> 00:29:54,590
up the tree and I have this put my

1524
00:29:54,590 --> 00:29:54,600
 

1525
00:29:54,600 --> 00:29:55,820
parent would may split the root maybe

1526
00:29:55,820 --> 00:29:55,830
 

1527
00:29:55,830 --> 00:29:57,530
split everyone else so with a single

1528
00:29:57,530 --> 00:29:57,540
 

1529
00:29:57,540 --> 00:29:59,030
insertion a worst case scenario I have

1530
00:29:59,030 --> 00:29:59,040
 

1531
00:29:59,040 --> 00:30:01,310
to rebuild the entire tree in a skip

1532
00:30:01,310 --> 00:30:01,320
 

1533
00:30:01,320 --> 00:30:02,570
list you never have to do that every

1534
00:30:02,570 --> 00:30:02,580
 

1535
00:30:02,580 --> 00:30:04,670
modification is always localized to the

1536
00:30:04,670 --> 00:30:04,680
 

1537
00:30:04,680 --> 00:30:08,380
portion of the list you're modifying

1538
00:30:08,380 --> 00:30:08,390
 

1539
00:30:08,390 --> 00:30:12,650
okay so the way you think about skip

1540
00:30:12,650 --> 00:30:12,660
 

1541
00:30:12,660 --> 00:30:14,300
list as I said is just a collection of

1542
00:30:14,300 --> 00:30:14,310
 

1543
00:30:14,310 --> 00:30:16,610
linked lists and so at the very bottom

1544
00:30:16,610 --> 00:30:16,620
 

1545
00:30:16,620 --> 00:30:18,980
is like the leaf nodes and B plus tree

1546
00:30:18,980 --> 00:30:18,990
 

1547
00:30:18,990 --> 00:30:21,140
you have to have every single key that

1548
00:30:21,140 --> 00:30:21,150
 

1549
00:30:21,150 --> 00:30:23,050
exists right because otherwise you know

1550
00:30:23,050 --> 00:30:23,060
 

1551
00:30:23,060 --> 00:30:24,980
you'd have false negatives because the

1552
00:30:24,980 --> 00:30:24,990
 

1553
00:30:24,990 --> 00:30:25,760
key wasn't be there

1554
00:30:25,760 --> 00:30:25,770
 

1555
00:30:25,770 --> 00:30:27,260
all right so every kid exists is always

1556
00:30:27,260 --> 00:30:27,270
 

1557
00:30:27,270 --> 00:30:29,720
at the bottom and he had pointers from

1558
00:30:29,720 --> 00:30:29,730
 

1559
00:30:29,730 --> 00:30:32,300
one key to the next but then the next

1560
00:30:32,300 --> 00:30:32,310
 

1561
00:30:32,310 --> 00:30:34,490
level above bag is gonna have links or

1562
00:30:34,490 --> 00:30:34,500
 

1563
00:30:34,500 --> 00:30:37,310
pointers to every other key going above

1564
00:30:37,310 --> 00:30:37,320
 

1565
00:30:37,320 --> 00:30:38,840
that you can have every fourth key and

1566
00:30:38,840 --> 00:30:38,850
 

1567
00:30:38,850 --> 00:30:40,790
so forth so in general what's gonna

1568
00:30:40,790 --> 00:30:40,800
 

1569
00:30:40,800 --> 00:30:43,160
happen is at every level you'll have

1570
00:30:43,160 --> 00:30:43,170
 

1571
00:30:43,170 --> 00:30:45,860
half as number of pointers as the little

1572
00:30:45,860 --> 00:30:45,870
 

1573
00:30:45,870 --> 00:30:49,370
below you and so the way you figure out

1574
00:30:49,370 --> 00:30:49,380
 

1575
00:30:49,380 --> 00:30:51,170
whether you want to add a pointer at a

1576
00:30:51,170 --> 00:30:51,180
 

1577
00:30:51,180 --> 00:30:54,470
level when you do an insertion is you

1578
00:30:54,470 --> 00:30:54,480

1579
00:30:54,480 --> 00:30:55,910
actually flip a coin

1580
00:30:55,910 --> 00:30:55,920
 

1581
00:30:55,920 --> 00:30:58,100
you use a random number generator decide

1582
00:30:58,100 --> 00:30:58,110
 

1583
00:30:58,110 --> 00:30:59,980
whether you're going to actually add a

1584
00:30:59,980 --> 00:30:59,990
 

1585
00:30:59,990 --> 00:31:03,320
pointer at a level so this mends up

1586
00:31:03,320 --> 00:31:03,330
 

1587
00:31:03,330 --> 00:31:04,550
making this a probabilistic data

1588
00:31:04,550 --> 00:31:04,560
 

1589
00:31:04,560 --> 00:31:05,990
structure which is different than the B

1590
00:31:05,990 --> 00:31:06,000
 

1591
00:31:06,000 --> 00:31:07,550
plus tree or the radix tree you want to

1592
00:31:07,550 --> 00:31:07,560
 

1593
00:31:07,560 --> 00:31:08,810
see a second which are deterministic

1594
00:31:08,810 --> 00:31:08,820
 

1595
00:31:08,820 --> 00:31:11,030
data structures so that means that if I

1596
00:31:11,030 --> 00:31:11,040
 

1597
00:31:11,040 --> 00:31:13,970
had take the same set of keys and I

1598
00:31:13,970 --> 00:31:13,980
 

1599
00:31:13,980 --> 00:31:15,770
insert it to my Skip list and you know

1600
00:31:15,770 --> 00:31:15,780
 

1601
00:31:15,780 --> 00:31:17,660
use a different random number generator

1602
00:31:17,660 --> 00:31:17,670
 

1603
00:31:17,670 --> 00:31:19,640
seed I may end up with a different

1604
00:31:19,640 --> 00:31:19,650
 

1605
00:31:19,650 --> 00:31:21,920
physical structure of the data of the

1606
00:31:21,920 --> 00:31:21,930
 

1607
00:31:21,930 --> 00:31:25,010
index every single time I rebuild it and

1608
00:31:25,010 --> 00:31:25,020
 

1609
00:31:25,020 --> 00:31:27,080
it B plus tree you wouldn't have that

1610
00:31:27,080 --> 00:31:27,090

1611
00:31:27,090 --> 00:31:29,360
because its terminus t'k meaning when I

1612
00:31:29,360 --> 00:31:29,370
 

1613
00:31:29,370 --> 00:31:31,400
do an insert I know where it's gonna go

1614
00:31:31,400 --> 00:31:31,410
 

1615
00:31:31,410 --> 00:31:33,950
and then if I do a split merge long as

1616
00:31:33,950 --> 00:31:33,960
 

1617
00:31:33,960 --> 00:31:35,180
you don't you know flip a coin when you

1618
00:31:35,180 --> 00:31:35,190
 

1619
00:31:35,190 --> 00:31:36,110
decide whether you want to steal from

1620
00:31:36,110 --> 00:31:36,120
 

1621
00:31:36,120 --> 00:31:38,050
the light sibling of the left sibling

1622
00:31:38,050 --> 00:31:38,060
 

1623
00:31:38,060 --> 00:31:40,280
you're gonna always end up the exact

1624
00:31:40,280 --> 00:31:40,290
 

1625
00:31:40,290 --> 00:31:43,160
same physical layout of the data no

1626
00:31:43,160 --> 00:31:43,170
 

1627
00:31:43,170 --> 00:31:44,450
matter how many times you rebuild the

1628
00:31:44,450 --> 00:31:44,460
 

1629
00:31:44,460 --> 00:31:46,610
index in the case of the Skip list it

1630
00:31:46,610 --> 00:31:46,620

1631
00:31:46,620 --> 00:31:48,110
can change every single time because you

1632
00:31:48,110 --> 00:31:48,120
 

1633
00:31:48,120 --> 00:31:51,440
have this randomness to it so because

1634
00:31:51,440 --> 00:31:51,450
 

1635
00:31:51,450 --> 00:31:55,820
though even though it's it's it's gonna

1636
00:31:55,820 --> 00:31:55,830
 

1637
00:31:55,830 --> 00:31:58,430
be random the math works out that will

1638
00:31:58,430 --> 00:31:58,440
 

1639
00:31:58,440 --> 00:32:00,620
get approximately log n

1640
00:32:00,620 --> 00:32:00,630
 

1641
00:32:00,630 --> 00:32:03,830
search and insertion operations which is

1642
00:32:03,830 --> 00:32:03,840
 

1643
00:32:03,840 --> 00:32:06,800
the same thing we saw in the in the B+

1644
00:32:06,800 --> 00:32:06,810
 

1645
00:32:06,810 --> 00:32:08,930
tree so worst case scenario we get

1646
00:32:08,930 --> 00:32:08,940
 

1647
00:32:08,940 --> 00:32:11,060
completely unluckily and know that we

1648
00:32:11,060 --> 00:32:11,070

1649
00:32:11,070 --> 00:32:13,940
always have no no pointers that upper

1650
00:32:13,940 --> 00:32:13,950
 

1651
00:32:13,950 --> 00:32:15,710
levels but you know with a billion keys

1652
00:32:15,710 --> 00:32:15,720
 

1653
00:32:15,720 --> 00:32:17,800
that's almost impossible to ever happen

1654
00:32:17,800 --> 00:32:17,810
 

1655
00:32:17,810 --> 00:32:20,150
so in the end we work out almost the

1656
00:32:20,150 --> 00:32:20,160
 

1657
00:32:20,160 --> 00:32:23,210
same asymptotic properties as as a B+

1658
00:32:23,210 --> 00:32:23,220
 

1659
00:32:23,220 --> 00:32:28,460
tree so let's look at example so as I

1660
00:32:28,460 --> 00:32:28,470
 

1661
00:32:28,470 --> 00:32:29,990
said the way they're going to skip lists

1662
00:32:29,990 --> 00:32:30,000
 

1663
00:32:30,000 --> 00:32:31,940
in some ways it's just a it's just

1664
00:32:31,940 --> 00:32:31,950
 

1665
00:32:31,950 --> 00:32:34,820
another B+ tree the way everyone

1666
00:32:34,820 --> 00:32:34,830
 

1667
00:32:34,830 --> 00:32:36,890
represents it in these diagrams is

1668
00:32:36,890 --> 00:32:36,900
 

1669
00:32:36,900 --> 00:32:39,050
always a flat list like this but if you

1670
00:32:39,050 --> 00:32:39,060
 

1671
00:32:39,060 --> 00:32:40,340
certain things you should have rotated

1672
00:32:40,340 --> 00:32:40,350
 

1673
00:32:40,350 --> 00:32:41,530
it in some ways it looks a lot like a

1674
00:32:41,530 --> 00:32:41,540
 

1675
00:32:41,540 --> 00:32:44,660
binary tree so the first thing to point

1676
00:32:44,660 --> 00:32:44,670
 

1677
00:32:44,670 --> 00:32:46,760
out is that we have at the beginning and

1678
00:32:46,760 --> 00:32:46,770
 

1679
00:32:46,770 --> 00:32:49,130
the end we have the starting entering

1680
00:32:49,130 --> 00:32:49,140
 

1681
00:32:49,140 --> 00:32:51,860
point for our our index with these

1682
00:32:51,860 --> 00:32:51,870

1683
00:32:51,870 --> 00:32:53,570
different levels and at the end we have

1684
00:32:53,570 --> 00:32:53,580
 

1685
00:32:53,580 --> 00:32:55,790
just these these markers to say we reach

1686
00:32:55,790 --> 00:32:55,800
 

1687
00:32:55,800 --> 00:32:57,020
the end of the linked list at a given

1688
00:32:57,020 --> 00:32:57,030
 

1689
00:32:57,030 --> 00:32:59,870
level right and then we just love what

1690
00:32:59,870 --> 00:32:59,880
 

1691
00:32:59,880 --> 00:33:01,490
we have the probability that we're going

1692
00:33:01,490 --> 00:33:01,500
 

1693
00:33:01,500 --> 00:33:05,060
to have a pointer for a given key you

1694
00:33:05,060 --> 00:33:05,070
 

1695
00:33:05,070 --> 00:33:06,980
know based on how high we are so at the

1696
00:33:06,980 --> 00:33:06,990
 

1697
00:33:06,990 --> 00:33:08,870
very bottom the first level the

1698
00:33:08,870 --> 00:33:08,880
 

1699
00:33:08,880 --> 00:33:09,600
probability of

1700
00:33:09,600 --> 00:33:09,610

1701
00:33:09,610 --> 00:33:12,419
a pointer for particular key is one and

1702
00:33:12,419 --> 00:33:12,429
 

1703
00:33:12,429 --> 00:33:14,070
above that it's half that and above that

1704
00:33:14,070 --> 00:33:14,080
 

1705
00:33:14,080 --> 00:33:17,970
it's half of that and so forth the very

1706
00:33:17,970 --> 00:33:17,980
 

1707
00:33:17,980 --> 00:33:20,600
bottom is is again is the linked list

1708
00:33:20,600 --> 00:33:20,610
 

1709
00:33:20,610 --> 00:33:22,590
this is where you have to have every pot

1710
00:33:22,590 --> 00:33:22,600
 

1711
00:33:22,600 --> 00:33:24,570
every ski every key we could represent

1712
00:33:24,570 --> 00:33:24,580
 

1713
00:33:24,580 --> 00:33:26,760
as a triplet so you have the key that

1714
00:33:26,760 --> 00:33:26,770
 

1715
00:33:26,770 --> 00:33:29,460
that you inserted the value would be the

1716
00:33:29,460 --> 00:33:29,470
 

1717
00:33:29,470 --> 00:33:31,500
P the record pointer to to the actual

1718
00:33:31,500 --> 00:33:31,510
 

1719
00:33:31,510 --> 00:33:33,000
tuple and then you have a pointer to

1720
00:33:33,000 --> 00:33:33,010
 

1721
00:33:33,010 --> 00:33:36,690
your neighbor in the linked list in the

1722
00:33:36,690 --> 00:33:36,700
 

1723
00:33:36,700 --> 00:33:38,490
levels above that you replace the record

1724
00:33:38,490 --> 00:33:38,500
 

1725
00:33:38,500 --> 00:33:40,620
pointer with actually a pointer to pick

1726
00:33:40,620 --> 00:33:40,630
 

1727
00:33:40,630 --> 00:33:43,560
the same key below you so in order to

1728
00:33:43,560 --> 00:33:43,570
 

1729
00:33:43,570 --> 00:33:46,080
have a key above in an upper level you

1730
00:33:46,080 --> 00:33:46,090

1731
00:33:46,090 --> 00:33:47,669
have to have obviously the key below you

1732
00:33:47,669 --> 00:33:47,679
 

1733
00:33:47,679 --> 00:33:50,789
so this vertical sort of strip of having

1734
00:33:50,789 --> 00:33:50,799

1735
00:33:50,799 --> 00:33:53,159
the same key across different levels

1736
00:33:53,159 --> 00:33:53,169
 

1737
00:33:53,169 --> 00:33:56,250
it's called a tower in skip list right

1738
00:33:56,250 --> 00:33:56,260
 

1739
00:33:56,260 --> 00:33:59,070
so what that means that I can't have a

1740
00:33:59,070 --> 00:33:59,080
 

1741
00:33:59,080 --> 00:34:01,950
key to be up in here in level three

1742
00:34:01,950 --> 00:34:01,960
 

1743
00:34:01,960 --> 00:34:06,750
without having a key in level two all

1744
00:34:06,750 --> 00:34:06,760
 

1745
00:34:06,760 --> 00:34:08,550
right and then at the top one we haven't

1746
00:34:08,550 --> 00:34:08,560
 

1747
00:34:08,560 --> 00:34:10,889
we haven't had any keys end up in the

1748
00:34:10,889 --> 00:34:10,899
 

1749
00:34:10,899 --> 00:34:14,190
first level so it just points to the the

1750
00:34:14,190 --> 00:34:14,200
 

1751
00:34:14,200 --> 00:34:16,950
end marker in reality what way this

1752
00:34:16,950 --> 00:34:16,960
 

1753
00:34:16,960 --> 00:34:18,419
would work is you just keep a counter it

1754
00:34:18,419 --> 00:34:18,429
 

1755
00:34:18,429 --> 00:34:19,740
says how many what's the highest level I

1756
00:34:19,740 --> 00:34:19,750
 

1757
00:34:19,750 --> 00:34:21,690
have so that when you do an insertion or

1758
00:34:21,690 --> 00:34:21,700
 

1759
00:34:21,700 --> 00:34:23,399
do a lookup you know where to always

1760
00:34:23,399 --> 00:34:23,409
 

1761
00:34:23,409 --> 00:34:24,840
start off with so in this case here we'd

1762
00:34:24,840 --> 00:34:24,850
 

1763
00:34:24,850 --> 00:34:27,060
say all right the highest link I have is

1764
00:34:27,060 --> 00:34:27,070
 

1765
00:34:27,070 --> 00:34:28,980
in the second level so I always stop

1766
00:34:28,980 --> 00:34:28,990
 

1767
00:34:28,990 --> 00:34:30,869
start at level two I never started level

1768
00:34:30,869 --> 00:34:30,879
 

1769
00:34:30,879 --> 00:34:33,659
three all right let's see an example of

1770
00:34:33,659 --> 00:34:33,669
 

1771
00:34:33,669 --> 00:34:36,090
how to do an insertion so let's say I

1772
00:34:36,090 --> 00:34:36,100
 

1773
00:34:36,100 --> 00:34:37,800
want to start key five and I've

1774
00:34:37,800 --> 00:34:37,810
 

1775
00:34:37,810 --> 00:34:39,359
conveniently left off space here to

1776
00:34:39,359 --> 00:34:39,369
 

1777
00:34:39,369 --> 00:34:42,780
start a key five in my diagram so to do

1778
00:34:42,780 --> 00:34:42,790
 

1779
00:34:42,790 --> 00:34:43,859
the insertion what we're gonna do is

1780
00:34:43,859 --> 00:34:43,869

1781
00:34:43,869 --> 00:34:46,290
we're gonna flip a coin decide how many

1782
00:34:46,290 --> 00:34:46,300
 

1783
00:34:46,300 --> 00:34:48,659
levels we want to go we want to add a

1784
00:34:48,659 --> 00:34:48,669
 

1785
00:34:48,669 --> 00:34:51,960
tower our new key into so you always

1786
00:34:51,960 --> 00:34:51,970
 

1787
00:34:51,970 --> 00:34:54,060
have to have key at the first level we

1788
00:34:54,060 --> 00:34:54,070
 

1789
00:34:54,070 --> 00:34:55,649
flip a coin to the second level

1790
00:34:55,649 --> 00:34:55,659
 

1791
00:34:55,659 --> 00:34:57,810
it comes up heads so we say yes we want

1792
00:34:57,810 --> 00:34:57,820
 

1793
00:34:57,820 --> 00:34:59,970
to insert it we flip a coin again for

1794
00:34:59,970 --> 00:34:59,980
 

1795
00:34:59,980 --> 00:35:01,290
the third level it comes up ahead so we

1796
00:35:01,290 --> 00:35:01,300
 

1797
00:35:01,300 --> 00:35:02,910
wanna start it again we flip it the

1798
00:35:02,910 --> 00:35:02,920
 

1799
00:35:02,920 --> 00:35:05,310
third time and it comes up tails so we

1800
00:35:05,310 --> 00:35:05,320
 

1801
00:35:05,320 --> 00:35:07,470
know we don't want to add a new level

1802
00:35:07,470 --> 00:35:07,480
 

1803
00:35:07,480 --> 00:35:09,000
all right we keep going until we hit

1804
00:35:09,000 --> 00:35:09,010
 

1805
00:35:09,010 --> 00:35:11,609
tails all right so that means that we

1806
00:35:11,609 --> 00:35:11,619
 

1807
00:35:11,619 --> 00:35:14,160
want to add key five to these these to

1808
00:35:14,160 --> 00:35:14,170
 

1809
00:35:14,170 --> 00:35:16,230
be levels like this so at this point

1810
00:35:16,230 --> 00:35:16,240
 

1811
00:35:16,240 --> 00:35:17,609
here I've allocated a memory I've

1812
00:35:17,609 --> 00:35:17,619
 

1813
00:35:17,619 --> 00:35:20,400
created my triplets to store the key but

1814
00:35:20,400 --> 00:35:20,410

1815
00:35:20,410 --> 00:35:22,230
it's not fully integrated into the index

1816
00:35:22,230 --> 00:35:22,240
 

1817
00:35:22,240 --> 00:35:23,340
because the

1818
00:35:23,340 --> 00:35:23,350
 

1819
00:35:23,350 --> 00:35:24,660
keys that come before it in the list

1820
00:35:24,660 --> 00:35:24,670
 

1821
00:35:24,670 --> 00:35:28,080
still are pointing to key six okey four

1822
00:35:28,080 --> 00:35:28,090
 

1823
00:35:28,090 --> 00:35:29,610
is pointing to key six on the first

1824
00:35:29,610 --> 00:35:29,620

1825
00:35:29,620 --> 00:35:31,290
level and key for is pointing to the

1826
00:35:31,290 --> 00:35:31,300
 

1827
00:35:31,300 --> 00:35:35,730
endpoint in this in the second level so

1828
00:35:35,730 --> 00:35:35,740
 

1829
00:35:35,740 --> 00:35:37,230
the first thing I need to do in my tower

1830
00:35:37,230 --> 00:35:37,240
 

1831
00:35:37,240 --> 00:35:40,710
is add the pointers now going down right

1832
00:35:40,710 --> 00:35:40,720
 

1833
00:35:40,720 --> 00:35:42,450
so then that way if anybody lands at the

1834
00:35:42,450 --> 00:35:42,460
 

1835
00:35:42,460 --> 00:35:43,530
higher point they can always reach it

1836
00:35:43,530 --> 00:35:43,540
 

1837
00:35:43,540 --> 00:35:46,620
reach reach to the bottom and then going

1838
00:35:46,620 --> 00:35:46,630
 

1839
00:35:46,630 --> 00:35:49,290
from the bottom to the top I'm now gonna

1840
00:35:49,290 --> 00:35:49,300
 

1841
00:35:49,300 --> 00:35:51,060
all right same thing I have that pointer

1842
00:35:51,060 --> 00:35:51,070
 

1843
00:35:51,070 --> 00:35:52,680
to the end but going from the bottom to

1844
00:35:52,680 --> 00:35:52,690
 

1845
00:35:52,690 --> 00:35:55,260
the top I'm gonna add I'm gonna modify

1846
00:35:55,260 --> 00:35:55,270
 

1847
00:35:55,270 --> 00:35:59,070
the key to come before me to now point

1848
00:35:59,070 --> 00:35:59,080
 

1849
00:35:59,080 --> 00:36:03,330
to me right and at this point the key is

1850
00:36:03,330 --> 00:36:03,340
 

1851
00:36:03,340 --> 00:36:06,240
integrated into the index mean the

1852
00:36:06,240 --> 00:36:06,250
 

1853
00:36:06,250 --> 00:36:08,190
anybody that scans along the bottom will

1854
00:36:08,190 --> 00:36:08,200
 

1855
00:36:08,200 --> 00:36:11,520
find us but what what happened two

1856
00:36:11,520 --> 00:36:11,530
 

1857
00:36:11,530 --> 00:36:12,900
priests came across the top when we find

1858
00:36:12,900 --> 00:36:12,910
 

1859
00:36:12,910 --> 00:36:19,910
it no right is that cuz is that so okay

1860
00:36:19,910 --> 00:36:19,920
 

1861
00:36:19,920 --> 00:36:22,170
she's taking her yes and he seemed real

1862
00:36:22,170 --> 00:36:22,180
 

1863
00:36:22,180 --> 00:36:29,640
emphatic about it why that says that

1864
00:36:29,640 --> 00:36:29,650
 

1865
00:36:29,650 --> 00:36:32,700
we're gonna eventually add it but think

1866
00:36:32,700 --> 00:36:32,710
 

1867
00:36:32,710 --> 00:36:34,740
of this scenario alright at this point

1868
00:36:34,740 --> 00:36:34,750
 

1869
00:36:34,750 --> 00:36:37,620
here the index looks like this key five

1870
00:36:37,620 --> 00:36:37,630
 

1871
00:36:37,630 --> 00:36:39,630
is there anybody that just comes along

1872
00:36:39,630 --> 00:36:39,640
 

1873
00:36:39,640 --> 00:36:41,490
the bottom and scans along here would

1874
00:36:41,490 --> 00:36:41,500
 

1875
00:36:41,500 --> 00:36:44,160
find it but anybody that maybe starts at

1876
00:36:44,160 --> 00:36:44,170
 

1877
00:36:44,170 --> 00:36:45,990
the second level scans along here and

1878
00:36:45,990 --> 00:36:46,000
 

1879
00:36:46,000 --> 00:36:47,880
they're looking for key five this thing

1880
00:36:47,880 --> 00:36:47,890
 

1881
00:36:47,890 --> 00:36:49,530
still points to the end so it's a oh

1882
00:36:49,530 --> 00:36:49,540
 

1883
00:36:49,540 --> 00:36:51,150
well key font

1884
00:36:51,150 --> 00:36:51,160
 

1885
00:36:51,160 --> 00:36:52,860
there's nothing beyond key for at this

1886
00:36:52,860 --> 00:36:52,870

1887
00:36:52,870 --> 00:36:54,960
point that I'm looking for so I've just

1888
00:36:54,960 --> 00:36:54,970
 

1889
00:36:54,970 --> 00:36:59,520
skipped past it right it would miss it

1890
00:36:59,520 --> 00:36:59,530
 

1891
00:36:59,530 --> 00:37:03,870
it'd be a false negative so I'm not

1892
00:37:03,870 --> 00:37:03,880
 

1893
00:37:03,880 --> 00:37:05,730
gonna explain it all in detail now but I

1894
00:37:05,730 --> 00:37:05,740
 

1895
00:37:05,740 --> 00:37:07,620
sort of set us up a little bit for next

1896
00:37:07,620 --> 00:37:07,630
 

1897
00:37:07,630 --> 00:37:08,670
class and later when we talk about

1898
00:37:08,670 --> 00:37:08,680
 

1899
00:37:08,680 --> 00:37:12,240
transactions this is okay to have this

1900
00:37:12,240 --> 00:37:12,250
 

1901
00:37:12,250 --> 00:37:14,940
right this is this is this is a higher

1902
00:37:14,940 --> 00:37:14,950
 

1903
00:37:14,950 --> 00:37:17,130
level logical thing that where

1904
00:37:17,130 --> 00:37:17,140

1905
00:37:17,140 --> 00:37:20,040
transactions may not see all the changes

1906
00:37:20,040 --> 00:37:20,050
 

1907
00:37:20,050 --> 00:37:23,220
immediately and that's okay what's not

1908
00:37:23,220 --> 00:37:23,230
 

1909
00:37:23,230 --> 00:37:25,560
okay if we have corrupted data structure

1910
00:37:25,560 --> 00:37:25,570
 

1911
00:37:25,570 --> 00:37:27,600
so this thing said uh pointing to key

1912
00:37:27,600 --> 00:37:27,610
 

1913
00:37:27,610 --> 00:37:29,520
five or key six appointed a garbage and

1914
00:37:29,520 --> 00:37:29,530
 

1915
00:37:29,530 --> 00:37:30,900
some other thread came along and

1916
00:37:30,900 --> 00:37:30,910
 

1917
00:37:30,910 --> 00:37:32,190
followed that pointer and started

1918
00:37:32,190 --> 00:37:32,200

1919
00:37:32,200 --> 00:37:34,190
reading garbage that would be bad right

1920
00:37:34,190 --> 00:37:34,200
 

1921
00:37:34,200 --> 00:37:36,330
cuz he would crash we'd read something

1922
00:37:36,330 --> 00:37:36,340
 

1923
00:37:36,340 --> 00:37:37,319
we shouldn't we shouldn't

1924
00:37:37,319 --> 00:37:37,329
 

1925
00:37:37,329 --> 00:37:39,719
reading but in this case here the data

1926
00:37:39,719 --> 00:37:39,729

1927
00:37:39,729 --> 00:37:41,759
structures sound all the pointers are

1928
00:37:41,759 --> 00:37:41,769
 

1929
00:37:41,769 --> 00:37:43,469
going to the correct things just whether

1930
00:37:43,469 --> 00:37:43,479

1931
00:37:43,479 --> 00:37:46,410
a thread comes along that you know maybe

1932
00:37:46,410 --> 00:37:46,420
 

1933
00:37:46,420 --> 00:37:48,150
was here at the moment this thing got

1934
00:37:48,150 --> 00:37:48,160
 

1935
00:37:48,160 --> 00:37:50,190
got flipped in and it would miss it and

1936
00:37:50,190 --> 00:37:50,200

1937
00:37:50,200 --> 00:37:53,099
keep going logically that's okay we can

1938
00:37:53,099 --> 00:37:53,109
 

1939
00:37:53,109 --> 00:37:55,199
we can rectify that later on but

1940
00:37:55,199 --> 00:37:55,209
 

1941
00:37:55,209 --> 00:37:58,019
physically it's you know physically we

1942
00:37:58,019 --> 00:37:58,029
 

1943
00:37:58,029 --> 00:37:59,309
don't want to have it point to nothing

1944
00:37:59,309 --> 00:37:59,319
 

1945
00:37:59,319 --> 00:38:01,589
so this is a good good distinction

1946
00:38:01,589 --> 00:38:01,599
 

1947
00:38:01,599 --> 00:38:03,359
between having a consistent data

1948
00:38:03,359 --> 00:38:03,369
 

1949
00:38:03,369 --> 00:38:04,410
structure versus a corrupted data

1950
00:38:04,410 --> 00:38:04,420

1951
00:38:04,420 --> 00:38:06,779
structure the higher-level semantics of

1952
00:38:06,779 --> 00:38:06,789
 

1953
00:38:06,789 --> 00:38:08,699
what our queries are doing are allowed

1954
00:38:08,699 --> 00:38:08,709
 

1955
00:38:08,709 --> 00:38:12,630
to miss this change but we obviously

1956
00:38:12,630 --> 00:38:12,640
 

1957
00:38:12,640 --> 00:38:14,759
don't want to crash so we'll cover more

1958
00:38:14,759 --> 00:38:14,769
 

1959
00:38:14,769 --> 00:38:17,370
about this on on on Wednesday we're

1960
00:38:17,370 --> 00:38:17,380
 

1961
00:38:17,380 --> 00:38:18,509
mostly going to focus on how do we make

1962
00:38:18,509 --> 00:38:18,519
 

1963
00:38:18,519 --> 00:38:21,390
sure our data structure thread safe when

1964
00:38:21,390 --> 00:38:21,400
 

1965
00:38:21,400 --> 00:38:22,799
we talk about transactions we then we

1966
00:38:22,799 --> 00:38:22,809

1967
00:38:22,809 --> 00:38:24,479
talk about the problem of one

1968
00:38:24,479 --> 00:38:24,489
 

1969
00:38:24,489 --> 00:38:25,949
transaction not seeing the changes from

1970
00:38:25,949 --> 00:38:25,959
 

1971
00:38:25,959 --> 00:38:27,180
another transaction that they probably

1972
00:38:27,180 --> 00:38:27,190
 

1973
00:38:27,190 --> 00:38:29,880
should all right so the main thing I'm

1974
00:38:29,880 --> 00:38:29,890
 

1975
00:38:29,890 --> 00:38:30,719
trying to point out here is like

1976
00:38:30,719 --> 00:38:30,729
 

1977
00:38:30,729 --> 00:38:33,420
swapping the pointers like this may not

1978
00:38:33,420 --> 00:38:33,430
 

1979
00:38:33,430 --> 00:38:35,459
make it so that any threat can see the

1980
00:38:35,459 --> 00:38:35,469
 

1981
00:38:35,469 --> 00:38:38,039
data that we need at this moment but

1982
00:38:38,039 --> 00:38:38,049
 

1983
00:38:38,049 --> 00:38:40,319
that's okay I could do to avoid all this

1984
00:38:40,319 --> 00:38:40,329
 

1985
00:38:40,329 --> 00:38:41,699
by having a single latch on the entire

1986
00:38:41,699 --> 00:38:41,709
 

1987
00:38:41,709 --> 00:38:43,410
data structure so that no thread could

1988
00:38:43,410 --> 00:38:43,420
 

1989
00:38:43,420 --> 00:38:45,599
could ever read it anytime I modify it

1990
00:38:45,599 --> 00:38:45,609
 

1991
00:38:45,609 --> 00:38:47,189
but that would be slow cuz now

1992
00:38:47,189 --> 00:38:47,199
 

1993
00:38:47,199 --> 00:38:49,109
everyone's gonna bottleneck on that so

1994
00:38:49,109 --> 00:38:49,119

1995
00:38:49,119 --> 00:38:51,359
instead we're gonna have we just do the

1996
00:38:51,359 --> 00:38:51,369
 

1997
00:38:51,369 --> 00:38:54,059
single compare and swap here allow other

1998
00:38:54,059 --> 00:38:54,069
 

1999
00:38:54,069 --> 00:38:55,680
threads to read inconsistent data and

2000
00:38:55,680 --> 00:38:55,690
 

2001
00:38:55,690 --> 00:38:58,670
that's okay okay

2002
00:38:58,670 --> 00:38:58,680
 

2003
00:38:58,680 --> 00:39:01,380
all right so again now I'm going from

2004
00:39:01,380 --> 00:39:01,390
 

2005
00:39:01,390 --> 00:39:03,359
from the bottom to the top I go to the

2006
00:39:03,359 --> 00:39:03,369
 

2007
00:39:03,369 --> 00:39:05,009
next level say anything I felt my

2008
00:39:05,009 --> 00:39:05,019
 

2009
00:39:05,019 --> 00:39:06,209
pointer now anybody comes along that

2010
00:39:06,209 --> 00:39:06,219
 

2011
00:39:06,219 --> 00:39:08,699
sees us and then the level here gets

2012
00:39:08,699 --> 00:39:08,709
 

2013
00:39:08,709 --> 00:39:10,109
swapped in and then out anybody can find

2014
00:39:10,109 --> 00:39:10,119
 

2015
00:39:10,119 --> 00:39:12,319
us and now our key is fully integrate

2016
00:39:12,319 --> 00:39:12,329
 

2017
00:39:12,329 --> 00:39:14,069
all right so that's that answer a

2018
00:39:14,069 --> 00:39:14,079
 

2019
00:39:14,079 --> 00:39:21,029
question of inserts okay yes this

2020
00:39:21,029 --> 00:39:21,039
 

2021
00:39:21,039 --> 00:39:22,469
question is how do you know which node

2022
00:39:22,469 --> 00:39:22,479
 

2023
00:39:22,479 --> 00:39:24,569
is before you so to do an insert you

2024
00:39:24,569 --> 00:39:24,579
 

2025
00:39:24,579 --> 00:39:26,430
have to basically figure out where I do

2026
00:39:26,430 --> 00:39:26,440
 

2027
00:39:26,440 --> 00:39:27,449
a search and forgot where I should be

2028
00:39:27,449 --> 00:39:27,459
 

2029
00:39:27,459 --> 00:39:29,130
and you keep track of the steps along

2030
00:39:29,130 --> 00:39:29,140
 

2031
00:39:29,140 --> 00:39:33,420
the way

2032
00:39:33,420 --> 00:39:33,430


2033
00:39:33,430 --> 00:39:41,220
okay yes this question is does this mean

2034
00:39:41,220 --> 00:39:41,230
 

2035
00:39:41,230 --> 00:39:44,280
you do a search on every level

2036
00:39:44,280 --> 00:39:44,290
 

2037
00:39:44,290 --> 00:39:46,380
yes actually let's go through that demo

2038
00:39:46,380 --> 00:39:46,390
 

2039
00:39:46,390 --> 00:39:49,110
now okay all right so they say yeah

2040
00:39:49,110 --> 00:39:49,120
 

2041
00:39:49,120 --> 00:40:01,470
sorry so your statement your question is

2042
00:40:01,470 --> 00:40:01,480
 

2043
00:40:01,480 --> 00:40:04,380
the gap between two nodes at a different

2044
00:40:04,380 --> 00:40:04,390
 

2045
00:40:04,390 --> 00:40:06,090
level are not the same ones the second

2046
00:40:06,090 --> 00:40:06,100
 

2047
00:40:06,100 --> 00:40:17,970
part you said same what yes alright so

2048
00:40:17,970 --> 00:40:17,980
 

2049
00:40:17,980 --> 00:40:19,590
his question is in this case here at the

2050
00:40:19,590 --> 00:40:19,600

2051
00:40:19,600 --> 00:40:21,420
second level key to jumped over one

2052
00:40:21,420 --> 00:40:21,430
 

2053
00:40:21,430 --> 00:40:23,610
tuple one key here and what a key for

2054
00:40:23,610 --> 00:40:23,620
 

2055
00:40:23,620 --> 00:40:26,970
but now this at this point here the the

2056
00:40:26,970 --> 00:40:26,980
 

2057
00:40:26,980 --> 00:40:28,260
number of tuples that this thing's gonna

2058
00:40:28,260 --> 00:40:28,270
 

2059
00:40:28,270 --> 00:40:30,120
jump over is is actually zero because

2060
00:40:30,120 --> 00:40:30,130
 

2061
00:40:30,130 --> 00:40:31,620
you go to there so again it's a

2062
00:40:31,620 --> 00:40:31,630
 

2063
00:40:31,630 --> 00:40:33,090
probabilistic data structure I flipped

2064
00:40:33,090 --> 00:40:33,100
 

2065
00:40:33,100 --> 00:40:36,240
the coin to decide where I want how I

2066
00:40:36,240 --> 00:40:36,250
 

2067
00:40:36,250 --> 00:40:38,060
want my Tower to be when I insert it so

2068
00:40:38,060 --> 00:40:38,070
 

2069
00:40:38,070 --> 00:40:42,150
this by chance by random it said all

2070
00:40:42,150 --> 00:40:42,160
 

2071
00:40:42,160 --> 00:40:43,620
right I want something key to and I want

2072
00:40:43,620 --> 00:40:43,630
 

2073
00:40:43,630 --> 00:40:45,240
I'm sorry level two and level three so

2074
00:40:45,240 --> 00:40:45,250
 

2075
00:40:45,250 --> 00:40:49,340
this made the gap be zero right in

2076
00:40:49,340 --> 00:40:49,350
 

2077
00:40:49,350 --> 00:40:51,600
practice with a really large data set

2078
00:40:51,600 --> 00:40:51,610
 

2079
00:40:51,610 --> 00:40:53,370
this randomness works out that on

2080
00:40:53,370 --> 00:40:53,380
 

2081
00:40:53,380 --> 00:40:55,650
average you're you're skipping at least

2082
00:40:55,650 --> 00:40:55,660
 

2083
00:40:55,660 --> 00:40:58,520
one this particular exam why doesn't

2084
00:40:58,520 --> 00:40:58,530
 

2085
00:40:58,530 --> 00:41:02,160
right because the alternative could be

2086
00:41:02,160 --> 00:41:02,170
 

2087
00:41:02,170 --> 00:41:04,260
if you think about it if you if you

2088
00:41:04,260 --> 00:41:04,270
 

2089
00:41:04,270 --> 00:41:05,730
hadn't forced it so that every single

2090
00:41:05,730 --> 00:41:05,740
 

2091
00:41:05,740 --> 00:41:08,460
time you add a new key and you don't

2092
00:41:08,460 --> 00:41:08,470
 

2093
00:41:08,470 --> 00:41:09,840
want to add it to a level that you

2094
00:41:09,840 --> 00:41:09,850
 

2095
00:41:09,850 --> 00:41:11,910
always make sure that it jumps at least

2096
00:41:11,910 --> 00:41:11,920
 

2097
00:41:11,920 --> 00:41:18,750
one if now I insert say if I insert and

2098
00:41:18,750 --> 00:41:18,760
 

2099
00:41:18,760 --> 00:41:20,400
say something four point five in here I

2100
00:41:20,400 --> 00:41:20,410
 

2101
00:41:20,410 --> 00:41:24,750
would have to then maybe modify other

2102
00:41:24,750 --> 00:41:24,760
 

2103
00:41:24,760 --> 00:41:26,310
things in the tree to make sure that

2104
00:41:26,310 --> 00:41:26,320
 

2105
00:41:26,320 --> 00:41:28,860
it's only jumping one but it's random I

2106
00:41:28,860 --> 00:41:28,870
 

2107
00:41:28,870 --> 00:41:30,720
don't care I don't care whether it's

2108
00:41:30,720 --> 00:41:30,730
 

2109
00:41:30,730 --> 00:41:33,570
exactly one or or some some you know

2110
00:41:33,570 --> 00:41:33,580
 

2111
00:41:33,580 --> 00:41:35,790
exactly one or zero or something large

2112
00:41:35,790 --> 00:41:35,800
 

2113
00:41:35,800 --> 00:41:37,830
in that I don't care

2114
00:41:37,830 --> 00:41:37,840
 

2115
00:41:37,840 --> 00:41:39,540
hey because I it makes the change be

2116
00:41:39,540 --> 00:41:39,550
 

2117
00:41:39,550 --> 00:41:41,430
localized and in practice with a large

2118
00:41:41,430 --> 00:41:41,440
 

2119
00:41:41,440 --> 00:41:42,900
enough you know the billion keys it

2120
00:41:42,900 --> 00:41:42,910
 

2121
00:41:42,910 --> 00:41:46,150
works out just fine

2122
00:41:46,150 --> 00:41:46,160


2123
00:41:46,160 --> 00:42:09,770
yes yeah so his question good basic

2124
00:42:09,770 --> 00:42:09,780
 

2125
00:42:09,780 --> 00:42:10,280
start here

2126
00:42:10,280 --> 00:42:10,290

2127
00:42:10,290 --> 00:42:14,420
I had a key five right initially nobody

2128
00:42:14,420 --> 00:42:14,430
 

2129
00:42:14,430 --> 00:42:17,630
points to me now I go through and I at

2130
00:42:17,630 --> 00:42:17,640
 

2131
00:42:17,640 --> 00:42:19,250
every level going from the bottom to the

2132
00:42:19,250 --> 00:42:19,260
 

2133
00:42:19,260 --> 00:42:21,560
top I have to then swap this point or

2134
00:42:21,560 --> 00:42:21,570
 

2135
00:42:21,570 --> 00:42:24,010
now point to me yes you have to do

2136
00:42:24,010 --> 00:42:24,020
 

2137
00:42:24,020 --> 00:42:30,620
what's that this question is the cost of

2138
00:42:30,620 --> 00:42:30,630
 

2139
00:42:30,630 --> 00:42:34,070
doing the swap small absolutely yeah so

2140
00:42:34,070 --> 00:42:34,080
 

2141
00:42:34,080 --> 00:42:37,130
in if it's an emery index its compare

2142
00:42:37,130 --> 00:42:37,140
 

2143
00:42:37,140 --> 00:42:39,590
and swap in modern CPUs that's a single

2144
00:42:39,590 --> 00:42:39,600
 

2145
00:42:39,600 --> 00:42:41,930
instruction that's super cheap okay

2146
00:42:41,930 --> 00:42:41,940
 

2147
00:42:41,940 --> 00:42:44,710
again it be done atomically

2148
00:42:44,710 --> 00:42:44,720
 

2149
00:42:44,720 --> 00:42:47,030
this is sir he made a comment before to

2150
00:42:47,030 --> 00:42:47,040
 

2151
00:42:47,040 --> 00:42:48,710
is like if i assumed everything is in

2152
00:42:48,710 --> 00:42:48,720
 

2153
00:42:48,720 --> 00:42:53,650
pages together opportunity memory then

2154
00:42:53,650 --> 00:42:53,660

2155
00:42:53,660 --> 00:42:55,910
you know maybe don't the swap pointer as

2156
00:42:55,910 --> 00:42:55,920
 

2157
00:42:55,920 --> 00:42:58,370
much cuz you just move things around the

2158
00:42:58,370 --> 00:42:58,380
 

2159
00:42:58,380 --> 00:43:00,980
way people try to mm up these sort of as

2160
00:43:00,980 --> 00:43:00,990
 

2161
00:43:00,990 --> 00:43:03,200
a first pass is just you just have every

2162
00:43:03,200 --> 00:43:03,210
 

2163
00:43:03,210 --> 00:43:04,670
node sort of be its own sort of chunk of

2164
00:43:04,670 --> 00:43:04,680
 

2165
00:43:04,680 --> 00:43:07,220
memory and then you do have the swap

2166
00:43:07,220 --> 00:43:07,230
 

2167
00:43:07,230 --> 00:43:08,720
this point if you cluster them together

2168
00:43:08,720 --> 00:43:08,730
 

2169
00:43:08,730 --> 00:43:11,270
group them together you can you may not

2170
00:43:11,270 --> 00:43:11,280
 

2171
00:43:11,280 --> 00:43:13,190
have to actually swap a pointer but in

2172
00:43:13,190 --> 00:43:13,200
 

2173
00:43:13,200 --> 00:43:14,360
the in addict able here at you do and

2174
00:43:14,360 --> 00:43:14,370
 

2175
00:43:14,370 --> 00:43:17,360
it's cheap to do and again if I do it

2176
00:43:17,360 --> 00:43:17,370
 

2177
00:43:17,370 --> 00:43:19,430
here like he's in there it's not that's

2178
00:43:19,430 --> 00:43:19,440
 

2179
00:43:19,440 --> 00:43:20,960
another thread may come along and miss

2180
00:43:20,960 --> 00:43:20,970
 

2181
00:43:20,970 --> 00:43:23,600
me that's okay and then I end up and

2182
00:43:23,600 --> 00:43:23,610
 

2183
00:43:23,610 --> 00:43:25,130
then I've mentioned I'll swap the rest

2184
00:43:25,130 --> 00:43:25,140
 

2185
00:43:25,140 --> 00:43:27,650
and then now I'm fully integrated right

2186
00:43:27,650 --> 00:43:27,660
 

2187
00:43:27,660 --> 00:43:29,060
the reason why we go from the bottom to

2188
00:43:29,060 --> 00:43:29,070
 

2189
00:43:29,070 --> 00:43:30,860
the top that way if someone someone is

2190
00:43:30,860 --> 00:43:30,870
 

2191
00:43:30,870 --> 00:43:36,320
here if I'm here and someone's trying to

2192
00:43:36,320 --> 00:43:36,330
 

2193
00:43:36,330 --> 00:43:38,000
start key four point five same time I'm

2194
00:43:38,000 --> 00:43:38,010
 

2195
00:43:38,010 --> 00:43:40,160
trying to start key five we do the

2196
00:43:40,160 --> 00:43:40,170
 

2197
00:43:40,170 --> 00:43:40,790
compare-and-swap

2198
00:43:40,790 --> 00:43:40,800
 

2199
00:43:40,800 --> 00:43:42,590
only one of us is gonna win because

2200
00:43:42,590 --> 00:43:42,600
 

2201
00:43:42,600 --> 00:43:45,050
compare-and-swap says check to see

2202
00:43:45,050 --> 00:43:45,060
 

2203
00:43:45,060 --> 00:43:46,880
whether the value I want to replace in

2204
00:43:46,880 --> 00:43:46,890
 

2205
00:43:46,890 --> 00:43:48,410
memory equals what I think it should

2206
00:43:48,410 --> 00:43:48,420
 

2207
00:43:48,420 --> 00:43:51,110
equal if yes replace it with my new

2208
00:43:51,110 --> 00:43:51,120
 

2209
00:43:51,120 --> 00:43:54,380
value if no then you fail so if both

2210
00:43:54,380 --> 00:43:54,390
 

2211
00:43:54,390 --> 00:43:55,580
these guys try to do the compare and

2212
00:43:55,580 --> 00:43:55,590
 

2213
00:43:55,590 --> 00:43:58,220
swap thinking that key four points to

2214
00:43:58,220 --> 00:43:58,230
 

2215
00:43:58,230 --> 00:43:58,970
key six

2216
00:43:58,970 --> 00:43:58,980
 

2217
00:43:58,980 --> 00:44:01,309
only one of them will succeed they don't

2218
00:44:01,309 --> 00:44:01,319
 

2219
00:44:01,319 --> 00:44:03,440
have to back off and retry so doing this

2220
00:44:03,440 --> 00:44:03,450
 

2221
00:44:03,450 --> 00:44:08,750
is really cheap adieu okay let's just

2222
00:44:08,750 --> 00:44:08,760
 

2223
00:44:08,760 --> 00:44:10,789
see how we do a search now all right so

2224
00:44:10,789 --> 00:44:10,799
 

2225
00:44:10,799 --> 00:44:14,030
I want to find key three so I at this

2226
00:44:14,030 --> 00:44:14,040
 

2227
00:44:14,040 --> 00:44:15,589
point here I know from my data structure

2228
00:44:15,589 --> 00:44:15,599
 

2229
00:44:15,599 --> 00:44:17,690
I have three levels so I also have to

2230
00:44:17,690 --> 00:44:17,700
 

2231
00:44:17,700 --> 00:44:19,549
start at the first level so I'm gonna

2232
00:44:19,549 --> 00:44:19,559
 

2233
00:44:19,559 --> 00:44:21,109
look ahead and the pull in the pointer

2234
00:44:21,109 --> 00:44:21,119
 

2235
00:44:21,119 --> 00:44:24,079
and it says oh it points to key five I

2236
00:44:24,079 --> 00:44:24,089
 

2237
00:44:24,089 --> 00:44:26,150
know that key five is greater than key

2238
00:44:26,150 --> 00:44:26,160
 

2239
00:44:26,160 --> 00:44:27,980
three so I can't continue along this

2240
00:44:27,980 --> 00:44:27,990

2241
00:44:27,990 --> 00:44:30,799
path in the Skip list at this level I

2242
00:44:30,799 --> 00:44:30,809
 

2243
00:44:30,809 --> 00:44:33,349
have to go down to the next level and I

2244
00:44:33,349 --> 00:44:33,359
 

2245
00:44:33,359 --> 00:44:34,819
do the same thing I fall along the path

2246
00:44:34,819 --> 00:44:34,829
 

2247
00:44:34,829 --> 00:44:37,549
now I see key 3 is greater than key 2

2248
00:44:37,549 --> 00:44:37,559
 

2249
00:44:37,559 --> 00:44:40,069
so I do want to skip ahead jump along

2250
00:44:40,069 --> 00:44:40,079

2251
00:44:40,079 --> 00:44:43,220
and now look ahead to the next the next

2252
00:44:43,220 --> 00:44:43,230
 

2253
00:44:43,230 --> 00:44:46,039
node the next key which is key for but

2254
00:44:46,039 --> 00:44:46,049

2255
00:44:46,049 --> 00:44:48,380
key 3 is less than key 4 so now I go

2256
00:44:48,380 --> 00:44:48,390
 

2257
00:44:48,390 --> 00:44:51,440
down and then now I just scan across the

2258
00:44:51,440 --> 00:44:51,450
 

2259
00:44:51,450 --> 00:44:52,849
leaf nodes until I find the one thing

2260
00:44:52,849 --> 00:44:52,859
 

2261
00:44:52,859 --> 00:44:54,230
I'm looking for so sort of like you're

2262
00:44:54,230 --> 00:44:54,240
 

2263
00:44:54,240 --> 00:44:56,359
stepping down different levels trying to

2264
00:44:56,359 --> 00:44:56,369

2265
00:44:56,369 --> 00:44:58,520
go as far as you can across horizontally

2266
00:44:58,520 --> 00:44:58,530

2267
00:44:58,530 --> 00:45:00,260
because that means you're skipping it

2268
00:45:00,260 --> 00:45:00,270
 

2269
00:45:00,270 --> 00:45:02,390
way more keys at the bottom but at some

2270
00:45:02,390 --> 00:45:02,400
 

2271
00:45:02,400 --> 00:45:03,530
point you'll hit a boundary you say I

2272
00:45:03,530 --> 00:45:03,540
 

2273
00:45:03,540 --> 00:45:05,150
can't go past this because the Kia that

2274
00:45:05,150 --> 00:45:05,160
 

2275
00:45:05,160 --> 00:45:07,400
I'm looking for is less than what your

2276
00:45:07,400 --> 00:45:07,410
 

2277
00:45:07,410 --> 00:45:09,289
key is so I go down a level and

2278
00:45:09,289 --> 00:45:09,299

2279
00:45:09,299 --> 00:45:10,520
eventually reach the very bottom and

2280
00:45:10,520 --> 00:45:10,530
 

2281
00:45:10,530 --> 00:45:12,799
then now it's just a linear scan to find

2282
00:45:12,799 --> 00:45:12,809
 

2283
00:45:12,809 --> 00:45:17,930
what I want it so this clip nice pretty

2284
00:45:17,930 --> 00:45:17,940
 

2285
00:45:17,940 --> 00:45:20,690
straightforward alright so let's do

2286
00:45:20,690 --> 00:45:20,700
 

2287
00:45:20,700 --> 00:45:24,470
deletion so the thing I want to focus on

2288
00:45:24,470 --> 00:45:24,480
 

2289
00:45:24,480 --> 00:45:28,160
here is that we have this distinction

2290
00:45:28,160 --> 00:45:28,170
 

2291
00:45:28,170 --> 00:45:31,099
logical deletes and physical deletes so

2292
00:45:31,099 --> 00:45:31,109
 

2293
00:45:31,109 --> 00:45:34,039
a logical leap is late means that any

2294
00:45:34,039 --> 00:45:34,049
 

2295
00:45:34,049 --> 00:45:36,260
thread that comes along should will not

2296
00:45:36,260 --> 00:45:36,270
 

2297
00:45:36,270 --> 00:45:38,059
see the key I just deleted but

2298
00:45:38,059 --> 00:45:38,069
 

2299
00:45:38,069 --> 00:45:40,250
physically it's still there and memory

2300
00:45:40,250 --> 00:45:40,260

2301
00:45:40,260 --> 00:45:43,910
is still inside of my pages right that's

2302
00:45:43,910 --> 00:45:43,920
 

2303
00:45:43,920 --> 00:45:45,289
different than what we saw in the B plus

2304
00:45:45,289 --> 00:45:45,299
 

2305
00:45:45,299 --> 00:45:46,760
tree because when we did a delete we

2306
00:45:46,760 --> 00:45:46,770

2307
00:45:46,770 --> 00:45:49,400
went and took the key actually out we

2308
00:45:49,400 --> 00:45:49,410
 

2309
00:45:49,410 --> 00:45:52,099
may have to do a merge to reshuffle

2310
00:45:52,099 --> 00:45:52,109

2311
00:45:52,109 --> 00:45:55,640
things around accordingly so what I'm

2312
00:45:55,640 --> 00:45:55,650
 

2313
00:45:55,650 --> 00:45:57,319
going to do now is along the leaf nodes

2314
00:45:57,319 --> 00:45:57,329
 

2315
00:45:57,329 --> 00:46:00,109
or sorry the bottom level for my my keys

2316
00:46:00,109 --> 00:46:00,119
 

2317
00:46:00,119 --> 00:46:02,450
I'm gonna add a simple boolean flag that

2318
00:46:02,450 --> 00:46:02,460
 

2319
00:46:02,460 --> 00:46:03,859
says whether it's been deleted true or

2320
00:46:03,859 --> 00:46:03,869
 

2321
00:46:03,869 --> 00:46:06,349
false so now let's say I want to delete

2322
00:46:06,349 --> 00:46:06,359
 

2323
00:46:06,359 --> 00:46:09,500
key 5 I do my search just like I did

2324
00:46:09,500 --> 00:46:09,510
 

2325
00:46:09,510 --> 00:46:11,510
before and I walk down until I find the

2326
00:46:11,510 --> 00:46:11,520
 

2327
00:46:11,520 --> 00:46:12,770
the leaf node that I want

2328
00:46:12,770 --> 00:46:12,780
 

2329
00:46:12,780 --> 00:46:15,020
for the key that one delete and then I

2330
00:46:15,020 --> 00:46:15,030
 

2331
00:46:15,030 --> 00:46:17,570
just flip its flag to be true it's now

2332
00:46:17,570 --> 00:46:17,580
 

2333
00:46:17,580 --> 00:46:18,980
at this point any thread that comes

2334
00:46:18,980 --> 00:46:18,990
 

2335
00:46:18,990 --> 00:46:21,290
along and they see and looking for key

2336
00:46:21,290 --> 00:46:21,300
 

2337
00:46:21,300 --> 00:46:23,870
five would say oh the belief flag is

2338
00:46:23,870 --> 00:46:23,880
 

2339
00:46:23,880 --> 00:46:26,020
true therefore I should just ignore it

2340
00:46:26,020 --> 00:46:26,030
 

2341
00:46:26,030 --> 00:46:28,300
right but physically it's still there

2342
00:46:28,300 --> 00:46:28,310
 

2343
00:46:28,310 --> 00:46:31,640
and then now what I do is I start

2344
00:46:31,640 --> 00:46:31,650
 

2345
00:46:31,650 --> 00:46:33,230
removing the pointers going in reverse

2346
00:46:33,230 --> 00:46:33,240
 

2347
00:46:33,240 --> 00:46:36,200
direction from the top to the bottom so

2348
00:46:36,200 --> 00:46:36,210
 

2349
00:46:36,210 --> 00:46:38,450
I'll unlink it from from the top level

2350
00:46:38,450 --> 00:46:38,460
 

2351
00:46:38,460 --> 00:46:41,450
and the second level and so forth and

2352
00:46:41,450 --> 00:46:41,460
 

2353
00:46:41,460 --> 00:46:43,340
the very bottom I get here and then now

2354
00:46:43,340 --> 00:46:43,350
 

2355
00:46:43,350 --> 00:46:45,380
anybody that's getting along would be

2356
00:46:45,380 --> 00:46:45,390
 

2357
00:46:45,390 --> 00:46:50,780
rerouted around me so the reason why

2358
00:46:50,780 --> 00:46:50,790
 

2359
00:46:50,790 --> 00:46:53,450
we're doing this is because it's sort of

2360
00:46:53,450 --> 00:46:53,460
 

2361
00:46:53,460 --> 00:46:56,510
work where we want to let everyone know

2362
00:46:56,510 --> 00:46:56,520
 

2363
00:46:56,520 --> 00:46:58,520
that things have been deleted as soon as

2364
00:46:58,520 --> 00:46:58,530
 

2365
00:46:58,530 --> 00:47:00,410
possible so to minimize that we know

2366
00:47:00,410 --> 00:47:00,420
 

2367
00:47:00,420 --> 00:47:01,730
where someone might get a false positive

2368
00:47:01,730 --> 00:47:01,740
 

2369
00:47:01,740 --> 00:47:03,950
and so because we have to go to the top

2370
00:47:03,950 --> 00:47:03,960
 

2371
00:47:03,960 --> 00:47:07,220
to the bottom right we would just go we

2372
00:47:07,220 --> 00:47:07,230
 

2373
00:47:07,230 --> 00:47:08,900
want to flip this thing to be true so

2374
00:47:08,900 --> 00:47:08,910
 

2375
00:47:08,910 --> 00:47:10,640
that way as we're going down our towers

2376
00:47:10,640 --> 00:47:10,650
 

2377
00:47:10,650 --> 00:47:12,620
and linking things anybody that comes

2378
00:47:12,620 --> 00:47:12,630

2379
00:47:12,630 --> 00:47:14,330
along can just ignore the key that it

2380
00:47:14,330 --> 00:47:14,340
 

2381
00:47:14,340 --> 00:47:18,380
sees right because otherwise we only

2382
00:47:18,380 --> 00:47:18,390
 

2383
00:47:18,390 --> 00:47:19,910
delete it till we reach the very very

2384
00:47:19,910 --> 00:47:19,920
 

2385
00:47:19,920 --> 00:47:25,130
bottom right and then once we and then

2386
00:47:25,130 --> 00:47:25,140
 

2387
00:47:25,140 --> 00:47:26,920
you know we're not gonna talk about

2388
00:47:26,920 --> 00:47:26,930
 

2389
00:47:26,930 --> 00:47:30,230
garbage collection or thread safe Tina's

2390
00:47:30,230 --> 00:47:30,240
 

2391
00:47:30,240 --> 00:47:31,910
here but once you know that no other

2392
00:47:31,910 --> 00:47:31,920
 

2393
00:47:31,920 --> 00:47:33,530
thread could ever possibly looking at

2394
00:47:33,530 --> 00:47:33,540
 

2395
00:47:33,540 --> 00:47:35,620
your node it's okay hey free the memory

2396
00:47:35,620 --> 00:47:35,630
 

2397
00:47:35,630 --> 00:47:37,910
again this avoids having people read

2398
00:47:37,910 --> 00:47:37,920
 

2399
00:47:37,920 --> 00:47:41,720
corrupted data all right so to finish up

2400
00:47:41,720 --> 00:47:41,730
 

2401
00:47:41,730 --> 00:47:46,160
skip list the advantages are the main

2402
00:47:46,160 --> 00:47:46,170
 

2403
00:47:46,170 --> 00:47:47,030
thing is that the insertions deletions

2404
00:47:47,030 --> 00:47:47,040
 

2405
00:47:47,040 --> 00:47:48,980
do not require any major rebalancing

2406
00:47:48,980 --> 00:47:48,990
 

2407
00:47:48,990 --> 00:47:51,800
because all the changes are localized to

2408
00:47:51,800 --> 00:47:51,810
 

2409
00:47:51,810 --> 00:47:53,750
just that point of the of the Skip list

2410
00:47:53,750 --> 00:47:53,760
 

2411
00:47:53,760 --> 00:47:55,760
right it's not like a B+ tree where you

2412
00:47:55,760 --> 00:47:55,770
 

2413
00:47:55,770 --> 00:47:56,840
have to recursively grow up and do

2414
00:47:56,840 --> 00:47:56,850
 

2415
00:47:56,850 --> 00:47:58,430
splits emerges that calls you to

2416
00:47:58,430 --> 00:47:58,440
 

2417
00:47:58,440 --> 00:48:01,910
reshuffle everything in practice the

2418
00:48:01,910 --> 00:48:01,920
 

2419
00:48:01,920 --> 00:48:04,040
Skip list could potentially use less

2420
00:48:04,040 --> 00:48:04,050
 

2421
00:48:04,050 --> 00:48:05,890
memory than a typical be blushed reading

2422
00:48:05,890 --> 00:48:05,900
 

2423
00:48:05,900 --> 00:48:08,540
if you don't use the optimizations that

2424
00:48:08,540 --> 00:48:08,550
 

2425
00:48:08,550 --> 00:48:09,860
the compression stuff we talked about

2426
00:48:09,860 --> 00:48:09,870
 

2427
00:48:09,870 --> 00:48:13,910
last class and only you only get that

2428
00:48:13,910 --> 00:48:13,920
 

2429
00:48:13,920 --> 00:48:15,320
benefit though if you don't include

2430
00:48:15,320 --> 00:48:15,330

2431
00:48:15,330 --> 00:48:18,680
reverse pointers so I showed in the loop

2432
00:48:18,680 --> 00:48:18,690
 

2433
00:48:18,690 --> 00:48:20,210
at the lowest level the linked list

2434
00:48:20,210 --> 00:48:20,220
 

2435
00:48:20,220 --> 00:48:22,040
always went one direction if I wanted to

2436
00:48:22,040 --> 00:48:22,050
 

2437
00:48:22,050 --> 00:48:25,580
reverse scan I can't do that as is being

2438
00:48:25,580 --> 00:48:25,590

2439
00:48:25,590 --> 00:48:26,360
shown because I don't

2440
00:48:26,360 --> 00:48:26,370
 

2441
00:48:26,370 --> 00:48:28,190
pointers in the other direction if I had

2442
00:48:28,190 --> 00:48:28,200
 

2443
00:48:28,200 --> 00:48:29,780
other points in the other direction then

2444
00:48:29,780 --> 00:48:29,790
 

2445
00:48:29,790 --> 00:48:31,190
then I can't do that compare-and-swap

2446
00:48:31,190 --> 00:48:31,200

2447
00:48:31,200 --> 00:48:33,560
atomically that I talked about and happy

2448
00:48:33,560 --> 00:48:33,570
 

2449
00:48:33,570 --> 00:48:35,120
you know store extra space for those

2450
00:48:35,120 --> 00:48:35,130
 

2451
00:48:35,130 --> 00:48:38,690
pointers so case MMC Co if you find the

2452
00:48:38,690 --> 00:48:38,700
 

2453
00:48:38,700 --> 00:48:40,130
early blog post when they announced hey

2454
00:48:40,130 --> 00:48:40,140

2455
00:48:40,140 --> 00:48:42,020
we're a new in a memory database system

2456
00:48:42,020 --> 00:48:42,030
 

2457
00:48:42,030 --> 00:48:43,220
and me you skip less because they lock

2458
00:48:43,220 --> 00:48:43,230
 

2459
00:48:43,230 --> 00:48:45,440
free the first thing people point out in

2460
00:48:45,440 --> 00:48:45,450
 

2461
00:48:45,450 --> 00:48:47,180
there so let's get less we can't go in

2462
00:48:47,180 --> 00:48:47,190
 

2463
00:48:47,190 --> 00:48:49,580
reverse direction so then people guys

2464
00:48:49,580 --> 00:48:49,590
 

2465
00:48:49,590 --> 00:48:50,870
came back and said well the way you

2466
00:48:50,870 --> 00:48:50,880
 

2467
00:48:50,880 --> 00:48:52,490
you saw that just usually make a second

2468
00:48:52,490 --> 00:48:52,500
 

2469
00:48:52,500 --> 00:48:54,860
set a separate second skip list that has

2470
00:48:54,860 --> 00:48:54,870
 

2471
00:48:54,870 --> 00:48:57,350
things sorted in reverse order and that

2472
00:48:57,350 --> 00:48:57,360
 

2473
00:48:57,360 --> 00:48:58,610
defeats the purpose the memory savings

2474
00:48:58,610 --> 00:48:58,620
 

2475
00:48:58,620 --> 00:49:00,890
you get from the Skip list so the

2476
00:49:00,890 --> 00:49:00,900
 

2477
00:49:00,900 --> 00:49:02,750
downside and the skip lists are that

2478
00:49:02,750 --> 00:49:02,760
 

2479
00:49:02,760 --> 00:49:04,730
they are not dissing cash friendly as he

2480
00:49:04,730 --> 00:49:04,740
 

2481
00:49:04,740 --> 00:49:07,340
was asking about before because we're

2482
00:49:07,340 --> 00:49:07,350
 

2483
00:49:07,350 --> 00:49:08,630
following all these pointers and jumping

2484
00:49:08,630 --> 00:49:08,640
 

2485
00:49:08,640 --> 00:49:10,790
along to the different locations every

2486
00:49:10,790 --> 00:49:10,800
 

2487
00:49:10,800 --> 00:49:13,880
single time we traverse things and then

2488
00:49:13,880 --> 00:49:13,890
 

2489
00:49:13,890 --> 00:49:15,560
as I said reverse search is non true to

2490
00:49:15,560 --> 00:49:15,570
 

2491
00:49:15,570 --> 00:49:17,090
implement you have to do something extra

2492
00:49:17,090 --> 00:49:17,100
 

2493
00:49:17,100 --> 00:49:18,910
which we'll cover in the advanced class

2494
00:49:18,910 --> 00:49:18,920

2495
00:49:18,920 --> 00:49:21,560
of how to do searches when you don't

2496
00:49:21,560 --> 00:49:21,570
 

2497
00:49:21,570 --> 00:49:23,330
have pointers in the other direction so

2498
00:49:23,330 --> 00:49:23,340
 

2499
00:49:23,340 --> 00:49:26,390
in the advanced class 15:21 for the last

2500
00:49:26,390 --> 00:49:26,400
 

2501
00:49:26,400 --> 00:49:28,160
two years in the spring ii programming

2502
00:49:28,160 --> 00:49:28,170
 

2503
00:49:28,170 --> 00:49:29,930
project was you have to implement your

2504
00:49:29,930 --> 00:49:29,940
 

2505
00:49:29,940 --> 00:49:33,610
own thread safe walk free skip lists

2506
00:49:33,610 --> 00:49:33,620
 

2507
00:49:33,620 --> 00:49:37,780
debating whether do that again this year

2508
00:49:37,780 --> 00:49:37,790


2509
00:49:37,790 --> 00:49:40,220
no and just I don't know interesting it

2510
00:49:40,220 --> 00:49:40,230
 

2511
00:49:40,230 --> 00:49:41,600
is and skip lists are not that common

2512
00:49:41,600 --> 00:49:41,610
 

2513
00:49:41,610 --> 00:49:42,740
but all right

2514
00:49:42,740 --> 00:49:42,750
 

2515
00:49:42,750 --> 00:49:44,120
all right any question that's goodness

2516
00:49:44,120 --> 00:49:44,130
 

2517
00:49:44,130 --> 00:49:48,440
yes his question is are they store the

2518
00:49:48,440 --> 00:49:48,450
 

2519
00:49:48,450 --> 00:49:50,120
buff ball yes if if you want to be

2520
00:49:50,120 --> 00:49:50,130
 

2521
00:49:50,130 --> 00:49:51,800
backed by disk yes means you have to

2522
00:49:51,800 --> 00:49:51,810
 

2523
00:49:51,810 --> 00:49:54,140
organize it in pages anything you wanna

2524
00:49:54,140 --> 00:49:54,150
 

2525
00:49:54,150 --> 00:49:55,220
be able to spill to disk has to be

2526
00:49:55,220 --> 00:49:55,230
 

2527
00:49:55,230 --> 00:49:56,660
stored in the buffer pool organizing

2528
00:49:56,660 --> 00:49:56,670
 

2529
00:49:56,670 --> 00:50:01,760
pages so you'd have to you can pack

2530
00:50:01,760 --> 00:50:01,770
 

2531
00:50:01,770 --> 00:50:04,460
multiple keys in a single page right but

2532
00:50:04,460 --> 00:50:04,470

2533
00:50:04,470 --> 00:50:08,450
then it that does require rebalancing if

2534
00:50:08,450 --> 00:50:08,460

2535
00:50:08,460 --> 00:50:10,310
you now insert things that expand the

2536
00:50:10,310 --> 00:50:10,320
 

2537
00:50:10,320 --> 00:50:11,900
key and you mean move it left and right

2538
00:50:11,900 --> 00:50:11,910
 

2539
00:50:11,910 --> 00:50:19,220
yeah this question is what the level

2540
00:50:19,220 --> 00:50:19,230
 

2541
00:50:19,230 --> 00:50:20,630
does get let's increase as we insert new

2542
00:50:20,630 --> 00:50:20,640
 

2543
00:50:20,640 --> 00:50:22,760
things yes because the probability that

2544
00:50:22,760 --> 00:50:22,770
 

2545
00:50:22,770 --> 00:50:25,250
you're gonna have a tower go up to a

2546
00:50:25,250 --> 00:50:25,260
 

2547
00:50:25,260 --> 00:50:27,230
really high level increases if the more

2548
00:50:27,230 --> 00:50:27,240
 

2549
00:50:27,240 --> 00:50:33,730
Keys you have

2550
00:50:33,730 --> 00:50:33,740


2551
00:50:33,740 --> 00:50:36,790
it's random every time I insert I flip

2552
00:50:36,790 --> 00:50:36,800
 

2553
00:50:36,800 --> 00:50:39,130
that coin and I keep I keep going until

2554
00:50:39,130 --> 00:50:39,140
 

2555
00:50:39,140 --> 00:50:40,480
it comes back with a head with tails

2556
00:50:40,480 --> 00:50:40,490
 

2557
00:50:40,490 --> 00:50:43,300
meaning like false right it's a random

2558
00:50:43,300 --> 00:50:43,310
 

2559
00:50:43,310 --> 00:50:46,270
data structure probablistic data

2560
00:50:46,270 --> 00:50:46,280

2561
00:50:46,280 --> 00:50:54,280
structure yes his question is why would

2562
00:50:54,280 --> 00:50:54,290

2563
00:50:54,290 --> 00:50:56,440
you want to even use a probability to

2564
00:50:56,440 --> 00:50:56,450
 

2565
00:50:56,450 --> 00:51:04,630
build this data structure over a B+ tree

2566
00:51:04,630 --> 00:51:04,640
 

2567
00:51:04,640 --> 00:51:06,190
or just for this particular data

2568
00:51:06,190 --> 00:51:06,200
 

2569
00:51:06,200 --> 00:51:10,270
structure Thanks I mean what's the

2570
00:51:10,270 --> 00:51:10,280
 

2571
00:51:10,280 --> 00:51:11,680
alternative the alternative would be you

2572
00:51:11,680 --> 00:51:11,690
 

2573
00:51:11,690 --> 00:51:13,750
have a heuristic and say all right for a

2574
00:51:13,750 --> 00:51:13,760
 

2575
00:51:13,760 --> 00:51:15,310
key that looks like this I add so many

2576
00:51:15,310 --> 00:51:15,320
 

2577
00:51:15,320 --> 00:51:17,470
levels and member I said before the

2578
00:51:17,470 --> 00:51:17,480
 

2579
00:51:17,480 --> 00:51:19,780
issue of that one now is like I don't

2580
00:51:19,780 --> 00:51:19,790
 

2581
00:51:19,790 --> 00:51:20,620
know what all the keys are gonna be

2582
00:51:20,620 --> 00:51:20,630
 

2583
00:51:20,630 --> 00:51:23,890
ahead of time so I may pick a bad

2584
00:51:23,890 --> 00:51:23,900
 

2585
00:51:23,900 --> 00:51:27,310
heuristic that would say you know four

2586
00:51:27,310 --> 00:51:27,320
 

2587
00:51:27,320 --> 00:51:29,050
keys that mod two equals zero

2588
00:51:29,050 --> 00:51:29,060
 

2589
00:51:29,060 --> 00:51:31,630
you know add it to level two key mod to

2590
00:51:31,630 --> 00:51:31,640
 

2591
00:51:31,640 --> 00:51:34,000
equal three add it to level three that

2592
00:51:34,000 --> 00:51:34,010
 

2593
00:51:34,010 --> 00:51:35,770
maybe bags I may never see keys that

2594
00:51:35,770 --> 00:51:35,780
 

2595
00:51:35,780 --> 00:51:38,290
have the had the particular batteries in

2596
00:51:38,290 --> 00:51:38,300
 

2597
00:51:38,300 --> 00:51:39,609
it I have just I just have a stupid

2598
00:51:39,609 --> 00:51:39,619
 

2599
00:51:39,619 --> 00:51:41,740
linked list at the bottom by making it

2600
00:51:41,740 --> 00:51:41,750
 

2601
00:51:41,750 --> 00:51:44,290
random you sort of make a good best

2602
00:51:44,290 --> 00:51:44,300

2603
00:51:44,300 --> 00:51:46,540
effort for all possible domains of

2604
00:51:46,540 --> 00:51:46,550
 

2605
00:51:46,550 --> 00:51:49,750
values and again really large key spaces

2606
00:51:49,750 --> 00:51:49,760
 

2607
00:51:49,760 --> 00:51:51,220
it works out fine for a billion keys

2608
00:51:51,220 --> 00:51:51,230
 

2609
00:51:51,230 --> 00:51:53,140
it'll look it almost looks exactly like

2610
00:51:53,140 --> 00:51:53,150
 

2611
00:51:53,150 --> 00:51:56,040
a P plus tree

2612
00:51:56,040 --> 00:51:56,050


2613
00:51:56,050 --> 00:52:02,589
all right red X trees so red X trees are

2614
00:52:02,589 --> 00:52:02,599
 

2615
00:52:02,599 --> 00:52:06,490
less common but what's interesting about

2616
00:52:06,490 --> 00:52:06,500
 

2617
00:52:06,500 --> 00:52:09,550
them is that they they have different

2618
00:52:09,550 --> 00:52:09,560
 

2619
00:52:09,560 --> 00:52:11,020
properties than a B plus tree in a skip

2620
00:52:11,020 --> 00:52:11,030
 

2621
00:52:11,030 --> 00:52:12,730
list so I think that worth worth

2622
00:52:12,730 --> 00:52:12,740
 

2623
00:52:12,740 --> 00:52:16,390
discussing and I think that the current

2624
00:52:16,390 --> 00:52:16,400
 

2625
00:52:16,400 --> 00:52:17,890
research trend is that these things are

2626
00:52:17,890 --> 00:52:17,900
 

2627
00:52:17,900 --> 00:52:19,839
very interesting and a lot of the newer

2628
00:52:19,839 --> 00:52:19,849
 

2629
00:52:19,849 --> 00:52:21,310
systems are thinking about people think

2630
00:52:21,310 --> 00:52:21,320
 

2631
00:52:21,320 --> 00:52:25,960
about exploring them now so also say

2632
00:52:25,960 --> 00:52:25,970
 

2633
00:52:25,970 --> 00:52:27,579
ahead of time so there's a Ameri

2634
00:52:27,579 --> 00:52:27,589
 

2635
00:52:27,589 --> 00:52:28,930
database system out of Germany called

2636
00:52:28,930 --> 00:52:28,940
 

2637
00:52:28,940 --> 00:52:30,880
hyper that is very influential in state

2638
00:52:30,880 --> 00:52:30,890
 

2639
00:52:30,890 --> 00:52:33,010
of the art got bought by tableau last

2640
00:52:33,010 --> 00:52:33,020
 

2641
00:52:33,020 --> 00:52:35,290
year they use a radix tree as their main

2642
00:52:35,290 --> 00:52:35,300
 

2643
00:52:35,300 --> 00:52:36,310
data structure they don't have B plus

2644
00:52:36,310 --> 00:52:36,320

2645
00:52:36,320 --> 00:52:38,740
trees I know the data stacks guys that

2646
00:52:38,740 --> 00:52:38,750
 

2647
00:52:38,750 --> 00:52:39,910
are working on Cassandra

2648
00:52:39,910 --> 00:52:39,920
 

2649
00:52:39,920 --> 00:52:43,630
they are super keen on the radix trees

2650
00:52:43,630 --> 00:52:43,640
 

2651
00:52:43,640 --> 00:52:45,070
and tries less than I talk to them and

2652
00:52:45,070 --> 00:52:45,080
 

2653
00:52:45,080 --> 00:52:47,200
they look about integrating tries all

2654
00:52:47,200 --> 00:52:47,210
 

2655
00:52:47,210 --> 00:52:47,650
throughout

2656
00:52:47,650 --> 00:52:47,660

2657
00:52:47,660 --> 00:52:48,640
Cassandra which i think is really

2658
00:52:48,640 --> 00:52:48,650
 

2659
00:52:48,650 --> 00:52:52,210
interesting so a ray dextry

2660
00:52:52,210 --> 00:52:52,220
 

2661
00:52:52,220 --> 00:52:53,380
the way to think about this is that

2662
00:52:53,380 --> 00:52:53,390
 

2663
00:52:53,390 --> 00:52:55,660
we're gonna represent keys we want to

2664
00:52:55,660 --> 00:52:55,670
 

2665
00:52:55,670 --> 00:52:58,750
store in our inner index by their

2666
00:52:58,750 --> 00:52:58,760
 

2667
00:52:58,760 --> 00:53:01,510
individual digits rather than the entire

2668
00:53:01,510 --> 00:53:01,520
 

2669
00:53:01,520 --> 00:53:03,520
key and so by digit I don't necessarily

2670
00:53:03,520 --> 00:53:03,530
 

2671
00:53:03,530 --> 00:53:05,680
mean like you know a number like one two

2672
00:53:05,680 --> 00:53:05,690
 

2673
00:53:05,690 --> 00:53:07,890
or three like if I have a string of

2674
00:53:07,890 --> 00:53:07,900
 

2675
00:53:07,900 --> 00:53:11,500
characters each character is a digit or

2676
00:53:11,500 --> 00:53:11,510
 

2677
00:53:11,510 --> 00:53:13,089
if I have a number that each each number

2678
00:53:13,089 --> 00:53:13,099
 

2679
00:53:13,099 --> 00:53:18,760
is a digit so the the reason why we're

2680
00:53:18,760 --> 00:53:18,770

2681
00:53:18,770 --> 00:53:20,170
going to do this is now we're gonna be

2682
00:53:20,170 --> 00:53:20,180
 

2683
00:53:20,180 --> 00:53:23,440
able to do comparisons on the digits of

2684
00:53:23,440 --> 00:53:23,450
 

2685
00:53:23,450 --> 00:53:26,170
the keys in sort of prefix order one by

2686
00:53:26,170 --> 00:53:26,180
 

2687
00:53:26,180 --> 00:53:28,299
one rather than having to examine the

2688
00:53:28,299 --> 00:53:28,309
 

2689
00:53:28,309 --> 00:53:31,569
entire key so you sort of already do

2690
00:53:31,569 --> 00:53:31,579
 

2691
00:53:31,579 --> 00:53:33,039
this in some ways with with certain

2692
00:53:33,039 --> 00:53:33,049
 

2693
00:53:33,049 --> 00:53:34,750
functions like doing sring comparison

2694
00:53:34,750 --> 00:53:34,760
 

2695
00:53:34,760 --> 00:53:36,460
like you know it's this a four that

2696
00:53:36,460 --> 00:53:36,470
 

2697
00:53:36,470 --> 00:53:38,109
walks through the characters the

2698
00:53:38,109 --> 00:53:38,119
 

2699
00:53:38,119 --> 00:53:38,980
beginning of a string and actually

2700
00:53:38,980 --> 00:53:38,990
 

2701
00:53:38,990 --> 00:53:41,200
compare them and if it stops which means

2702
00:53:41,200 --> 00:53:41,210
 

2703
00:53:41,210 --> 00:53:43,359
you don't have a match but now the data

2704
00:53:43,359 --> 00:53:43,369
 

2705
00:53:43,369 --> 00:53:44,890
structure itself is gonna be designed to

2706
00:53:44,890 --> 00:53:44,900
 

2707
00:53:44,900 --> 00:53:49,930
do this very efficiently so the the

2708
00:53:49,930 --> 00:53:49,940
 

2709
00:53:49,940 --> 00:53:51,309
reason why what's what interesting about

2710
00:53:51,309 --> 00:53:51,319
 

2711
00:53:51,319 --> 00:53:54,039
is that now the height of the tree is no

2712
00:53:54,039 --> 00:53:54,049
 

2713
00:53:54,049 --> 00:53:56,980
longer dependent on the number of keys

2714
00:53:56,980 --> 00:53:56,990
 

2715
00:53:56,990 --> 00:53:59,650
that you have ranked in the B+ tree if

2716
00:53:59,650 --> 00:53:59,660
 

2717
00:53:59,660 --> 00:54:01,870
I'm sort of billion keys right depending

2718
00:54:01,870 --> 00:54:01,880
 

2719
00:54:01,880 --> 00:54:03,309
what my fan-out level is about how many

2720
00:54:03,309 --> 00:54:03,319
 

2721
00:54:03,319 --> 00:54:05,260
entries on I want to pack on my node

2722
00:54:05,260 --> 00:54:05,270
 

2723
00:54:05,270 --> 00:54:07,000
that's going to determine the number of

2724
00:54:07,000 --> 00:54:07,010
 

2725
00:54:07,010 --> 00:54:09,730
levels that I have in a radix tree

2726
00:54:09,730 --> 00:54:09,740
 

2727
00:54:09,740 --> 00:54:11,680
because the height of the tree actually

2728
00:54:11,680 --> 00:54:11,690
 

2729
00:54:11,690 --> 00:54:14,769
depends on the length of the key right

2730
00:54:14,769 --> 00:54:14,779
 

2731
00:54:14,779 --> 00:54:16,809
so I could have a billion tuples or

2732
00:54:16,809 --> 00:54:16,819
 

2733
00:54:16,819 --> 00:54:19,690
billion keys and have a really you know

2734
00:54:19,690 --> 00:54:19,700
 

2735
00:54:19,700 --> 00:54:22,000
a small key because they're not really

2736
00:54:22,000 --> 00:54:22,010

2737
00:54:22,010 --> 00:54:23,109
long strings but I can have another

2738
00:54:23,109 --> 00:54:23,119
 

2739
00:54:23,119 --> 00:54:24,460
billion key to the really long strings

2740
00:54:24,460 --> 00:54:24,470
 

2741
00:54:24,470 --> 00:54:26,099
and now my index will be really long

2742
00:54:26,099 --> 00:54:26,109
 

2743
00:54:26,109 --> 00:54:30,370
right so in a radix tree we're not going

2744
00:54:30,370 --> 00:54:30,380
 

2745
00:54:30,380 --> 00:54:32,170
to not require any rebalancing the major

2746
00:54:32,170 --> 00:54:32,180
 

2747
00:54:32,180 --> 00:54:34,329
level or reshuffling the same way we do

2748
00:54:34,329 --> 00:54:34,339
 

2749
00:54:34,339 --> 00:54:37,359
splits emerges in nmp plus tree and

2750
00:54:37,359 --> 00:54:37,369
 

2751
00:54:37,369 --> 00:54:38,920
instead of actually storing the entire

2752
00:54:38,920 --> 00:54:38,930
 

2753
00:54:38,930 --> 00:54:41,230
key at every single level and then we

2754
00:54:41,230 --> 00:54:41,240
 

2755
00:54:41,240 --> 00:54:42,549
destroy these digits and then we can

2756
00:54:42,549 --> 00:54:42,559
 

2757
00:54:42,559 --> 00:54:44,710
reconstruct the key based on what path

2758
00:54:44,710 --> 00:54:44,720
 

2759
00:54:44,720 --> 00:54:47,769
we take down into the tree so quick show

2760
00:54:47,769 --> 00:54:47,779
 

2761
00:54:47,779 --> 00:54:49,180
of hands who here has heard of a radix

2762
00:54:49,180 --> 00:54:49,190
 

2763
00:54:49,190 --> 00:54:53,200
tree before even fewer patrícia tree

2764
00:54:53,200 --> 00:54:53,210
 

2765
00:54:53,210 --> 00:54:57,789
anybody who here is heard of a try all

2766
00:54:57,789 --> 00:54:57,799
 

2767
00:54:57,799 --> 00:54:59,470
right there we go good excellent so a

2768
00:54:59,470 --> 00:54:59,480
 

2769
00:54:59,480 --> 00:55:01,539
radix tree is just a variant of a try

2770
00:55:01,539 --> 00:55:01,549
 

2771
00:55:01,549 --> 00:55:04,659
okay so here's a tribe so I have three

2772
00:55:04,659 --> 00:55:04,669
 

2773
00:55:04,669 --> 00:55:07,899
keys hello have an hello hat to have so

2774
00:55:07,899 --> 00:55:07,909
 

2775
00:55:07,909 --> 00:55:10,059
in this sort of visual representation in

2776
00:55:10,059 --> 00:55:10,069
 

2777
00:55:10,069 --> 00:55:12,909
the Tri I'm storing at every edge

2778
00:55:12,909 --> 00:55:12,919
 

2779
00:55:12,919 --> 00:55:15,429
represents a single character of a key

2780
00:55:15,429 --> 00:55:15,439
 

2781
00:55:15,439 --> 00:55:18,039
so at the root I have H because all

2782
00:55:18,039 --> 00:55:18,049
 

2783
00:55:18,049 --> 00:55:20,799
three keys start with H in the case of

2784
00:55:20,799 --> 00:55:20,809

2785
00:55:20,809 --> 00:55:22,839
hello I'm gonna have now path down

2786
00:55:22,839 --> 00:55:22,849
 

2787
00:55:22,849 --> 00:55:26,319
h-e-l-l-o right I can reconstruct that

2788
00:55:26,319 --> 00:55:26,329
 

2789
00:55:26,329 --> 00:55:28,209
key by following that path so if I want

2790
00:55:28,209 --> 00:55:28,219
 

2791
00:55:28,219 --> 00:55:31,059
to check is the key hello in my index I

2792
00:55:31,059 --> 00:55:31,069
 

2793
00:55:31,069 --> 00:55:33,489
can start at the root I CH IC e you see

2794
00:55:33,489 --> 00:55:33,499
 

2795
00:55:33,499 --> 00:55:35,439
llo so forth and I reach my record

2796
00:55:35,439 --> 00:55:35,449
 

2797
00:55:35,449 --> 00:55:38,559
pointer at the bottom in the case of hat

2798
00:55:38,559 --> 00:55:38,569

2799
00:55:38,569 --> 00:55:41,679
and have they both start the second

2800
00:55:41,679 --> 00:55:41,689

2801
00:55:41,689 --> 00:55:44,439
character is a so I only need one entry

2802
00:55:44,439 --> 00:55:44,449
 

2803
00:55:44,449 --> 00:55:46,839
for a and then I have my split point for

2804
00:55:46,839 --> 00:55:46,849
 

2805
00:55:46,849 --> 00:55:52,259
the e for have and T for hat so the

2806
00:55:52,259 --> 00:55:52,269
 

2807
00:55:52,269 --> 00:55:54,429
tribes were first discovered back in

2808
00:55:54,429 --> 00:55:54,439
 

2809
00:55:54,439 --> 00:55:57,909
1959 by some French dude and then two

2810
00:55:57,909 --> 00:55:57,919
 

2811
00:55:57,919 --> 00:55:59,289
years later after that there was a

2812
00:55:59,289 --> 00:55:59,299
 

2813
00:55:59,299 --> 00:56:00,909
professor

2814
00:56:00,909 --> 00:56:00,919
 

2815
00:56:00,919 --> 00:56:04,019
edward edward fredkin coined the term

2816
00:56:04,019 --> 00:56:04,029
 

2817
00:56:04,029 --> 00:56:08,579
try as a concatenation of retrieval tree

2818
00:56:08,579 --> 00:56:08,589
 

2819
00:56:08,589 --> 00:56:11,589
he apparently his faculty at CMU I think

2820
00:56:11,589 --> 00:56:11,599
 

2821
00:56:11,599 --> 00:56:13,870
he's retired he's like a famous dude he

2822
00:56:13,870 --> 00:56:13,880
 

2823
00:56:13,880 --> 00:56:15,399
doesn't show up any faculty meetings but

2824
00:56:15,399 --> 00:56:15,409
 

2825
00:56:15,409 --> 00:56:17,199
apparently he's here I don't think that

2826
00:56:17,199 --> 00:56:17,209
 

2827
00:56:17,209 --> 00:56:21,099
he's in the directory so a radix tree is

2828
00:56:21,099 --> 00:56:21,109

2829
00:56:21,109 --> 00:56:23,649
sort of like a compressed version of the

2830
00:56:23,649 --> 00:56:23,659
 

2831
00:56:23,659 --> 00:56:28,089
Tri so in the try for h-e-l-l-o no other

2832
00:56:28,089 --> 00:56:28,099
 

2833
00:56:28,099 --> 00:56:30,189
key shared those those characters after

2834
00:56:30,189 --> 00:56:30,199

2835
00:56:30,199 --> 00:56:32,709
the after the h-e-l-l-o was specific to

2836
00:56:32,709 --> 00:56:32,719
 

2837
00:56:32,719 --> 00:56:34,959
hello but it still had that entire path

2838
00:56:34,959 --> 00:56:34,969
 

2839
00:56:34,969 --> 00:56:38,259
in a radix tree you recognize that

2840
00:56:38,259 --> 00:56:38,269
 

2841
00:56:38,269 --> 00:56:42,479
nobody else stores is storing PLO

2842
00:56:42,479 --> 00:56:42,489
 

2843
00:56:42,489 --> 00:56:45,639
so I just have a single edge with that

2844
00:56:45,639 --> 00:56:45,649
 

2845
00:56:45,649 --> 00:56:48,309
information there right sort of it's

2846
00:56:48,309 --> 00:56:48,319
 

2847
00:56:48,319 --> 00:56:52,109
packed together and the same thing for I

2848
00:56:52,109 --> 00:56:52,119
 

2849
00:56:52,119 --> 00:56:54,549
hat and have we're both sharing a so I

2850
00:56:54,549 --> 00:56:54,559
 

2851
00:56:54,559 --> 00:56:56,289
have my entry for a and then for have

2852
00:56:56,289 --> 00:56:56,299
 

2853
00:56:56,299 --> 00:56:58,089
nobody else shares ve so it's there by

2854
00:56:58,089 --> 00:56:58,099
 

2855
00:56:58,099 --> 00:57:01,719
itself right so that so a ray dextry is

2856
00:57:01,719 --> 00:57:01,729
 

2857
00:57:01,729 --> 00:57:04,359
a compressed version of a try if you

2858
00:57:04,359 --> 00:57:04,369

2859
00:57:04,369 --> 00:57:05,589
look in the literature or Wikipedia

2860
00:57:05,589 --> 00:57:05,599
 

2861
00:57:05,599 --> 00:57:07,120
sometimes they'll call Patricia Patricia

2862
00:57:07,120 --> 00:57:07,130
 

2863
00:57:07,130 --> 00:57:09,849
trees it's not named after a person it

2864
00:57:09,849 --> 00:57:09,859

2865
00:57:09,859 --> 00:57:11,620
has some other meaning from the 50s or

2866
00:57:11,620 --> 00:57:11,630
 

2867
00:57:11,630 --> 00:57:14,259
60s n I'll remember sometimes in

2868
00:57:14,259 --> 00:57:14,269
 

2869
00:57:14,269 --> 00:57:15,520
literature these are called

2870
00:57:15,520 --> 00:57:15,530

2871
00:57:15,530 --> 00:57:19,120
Suffolk's arrays or suffix trees the the

2872
00:57:19,120 --> 00:57:19,130
 

2873
00:57:19,130 --> 00:57:21,070
basic idea is the same databases we call

2874
00:57:21,070 --> 00:57:21,080
 

2875
00:57:21,080 --> 00:57:23,950
them radix trees so let's see actually

2876
00:57:23,950 --> 00:57:23,960
 

2877
00:57:23,960 --> 00:57:26,200
how you actually really store this so

2878
00:57:26,200 --> 00:57:26,210
 

2879
00:57:26,210 --> 00:57:27,820
nobody actually really stores the in

2880
00:57:27,820 --> 00:57:27,830
 

2881
00:57:27,830 --> 00:57:30,160
that sort of edge oriented diagram that

2882
00:57:30,160 --> 00:57:30,170
 

2883
00:57:30,170 --> 00:57:31,120
show before where you have the

2884
00:57:31,120 --> 00:57:31,130
 

2885
00:57:31,130 --> 00:57:32,980
characters the digit stored in the edges

2886
00:57:32,980 --> 00:57:32,990
 

2887
00:57:32,990 --> 00:57:35,500
you storm the nodes right and your nodes

2888
00:57:35,500 --> 00:57:35,510
 

2889
00:57:35,510 --> 00:57:38,890
have to fit in pages so the way you

2890
00:57:38,890 --> 00:57:38,900

2891
00:57:38,900 --> 00:57:40,330
would actually mmm this is maybe try to

2892
00:57:40,330 --> 00:57:40,340
 

2893
00:57:40,340 --> 00:57:42,940
pack in as much data you can within a

2894
00:57:42,940 --> 00:57:42,950
 

2895
00:57:42,950 --> 00:57:45,580
single page at a different level in the

2896
00:57:45,580 --> 00:57:45,590
 

2897
00:57:45,590 --> 00:57:49,180
tree so in this case here for the second

2898
00:57:49,180 --> 00:57:49,190
 

2899
00:57:49,190 --> 00:57:51,610
level I have elo for hello and then a

2900
00:57:51,610 --> 00:57:51,620
 

2901
00:57:51,620 --> 00:57:54,880
shared by I hadn't have I would pack

2902
00:57:54,880 --> 00:57:54,890

2903
00:57:54,890 --> 00:57:58,180
them into a single page now let's see if

2904
00:57:58,180 --> 00:57:58,190
 

2905
00:57:58,190 --> 00:57:59,530
I wouldn't start a new key on the sort

2906
00:57:59,530 --> 00:57:59,540
 

2907
00:57:59,540 --> 00:58:02,890
hair in this case here I would recognize

2908
00:58:02,890 --> 00:58:02,900
 

2909
00:58:02,900 --> 00:58:05,470
that the H and a or row share so that I

2910
00:58:05,470 --> 00:58:05,480
 

2911
00:58:05,480 --> 00:58:07,450
just follow along term up to my third

2912
00:58:07,450 --> 00:58:07,460
 

2913
00:58:07,460 --> 00:58:09,190
level here and then I see that I already

2914
00:58:09,190 --> 00:58:09,200
 

2915
00:58:09,200 --> 00:58:12,580
have space to store I R and so I can

2916
00:58:12,580 --> 00:58:12,590
 

2917
00:58:12,590 --> 00:58:17,860
pack it in there so it's not we are

2918
00:58:17,860 --> 00:58:17,870
 

2919
00:58:17,870 --> 00:58:21,850
gonna do potentially do merges but we

2920
00:58:21,850 --> 00:58:21,860
 

2921
00:58:21,860 --> 00:58:24,250
never have to do we may have to do

2922
00:58:24,250 --> 00:58:24,260
 

2923
00:58:24,260 --> 00:58:25,780
splits as well but it's always sort of

2924
00:58:25,780 --> 00:58:25,790
 

2925
00:58:25,790 --> 00:58:29,560
in and we never have to do it be

2926
00:58:29,560 --> 00:58:29,570
 

2927
00:58:29,570 --> 00:58:30,910
balancing the same way that you have to

2928
00:58:30,910 --> 00:58:30,920
 

2929
00:58:30,920 --> 00:58:33,640
do it in a B+ tree so let's say I went

2930
00:58:33,640 --> 00:58:33,650
 

2931
00:58:33,650 --> 00:58:35,740
delete hat in half so I go ahead and

2932
00:58:35,740 --> 00:58:35,750
 

2933
00:58:35,750 --> 00:58:37,360
find my two injuries here and I delete

2934
00:58:37,360 --> 00:58:37,370
 

2935
00:58:37,370 --> 00:58:39,580
them and then I recognize that I have R

2936
00:58:39,580 --> 00:58:39,590
 

2937
00:58:39,590 --> 00:58:41,470
by I R by itself and I can decide to

2938
00:58:41,470 --> 00:58:41,480
 

2939
00:58:41,480 --> 00:58:43,300
leave it here if I wanted to and

2940
00:58:43,300 --> 00:58:43,310
 

2941
00:58:43,310 --> 00:58:45,760
everything's still correct or if I'm if

2942
00:58:45,760 --> 00:58:45,770
 

2943
00:58:45,770 --> 00:58:47,920
I'm gonna be aggressive about using Rena

2944
00:58:47,920 --> 00:58:47,930
 

2945
00:58:47,930 --> 00:58:49,930
reusing memory or saving space I can

2946
00:58:49,930 --> 00:58:49,940
 

2947
00:58:49,940 --> 00:58:52,290
just can compress it and move it back up

2948
00:58:52,290 --> 00:58:52,300
 

2949
00:58:52,300 --> 00:58:58,240
alright so this sounds awesome right

2950
00:58:58,240 --> 00:58:58,250
 

2951
00:58:58,250 --> 00:59:00,520
because now we're storing using way less

2952
00:59:00,520 --> 00:59:00,530
 

2953
00:59:00,530 --> 00:59:03,100
data to store are like he's like if this

2954
00:59:03,100 --> 00:59:03,110
 

2955
00:59:03,110 --> 00:59:04,720
was a B+ tree but I want to store these

2956
00:59:04,720 --> 00:59:04,730
 

2957
00:59:04,730 --> 00:59:08,050
these these two keys hello and and hair

2958
00:59:08,050 --> 00:59:08,060
 

2959
00:59:08,060 --> 00:59:11,200
I'm going back here maybe the better

2960
00:59:11,200 --> 00:59:11,210
 

2961
00:59:11,210 --> 00:59:14,040
examine when I had all my keys in there

2962
00:59:14,040 --> 00:59:14,050
 

2963
00:59:14,050 --> 00:59:16,930
back here I would have maybe the root

2964
00:59:16,930 --> 00:59:16,940
 

2965
00:59:16,940 --> 00:59:19,330
would have hello or hat I have you know

2966
00:59:19,330 --> 00:59:19,340
 

2967
00:59:19,340 --> 00:59:21,670
in this entire form and then down below

2968
00:59:21,670 --> 00:59:21,680
 

2969
00:59:21,680 --> 00:59:22,930
in the leaf knows that I have the keys

2970
00:59:22,930 --> 00:59:22,940
 

2971
00:59:22,940 --> 00:59:25,450
in there time form again as well in this

2972
00:59:25,450 --> 00:59:25,460
 

2973
00:59:25,460 --> 00:59:27,070
case here I don't have to do that and

2974
00:59:27,070 --> 00:59:27,080
 

2975
00:59:27,080 --> 00:59:29,140
only store the key essentially once

2976
00:59:29,140 --> 00:59:29,150
 

2977
00:59:29,150 --> 00:59:32,890
a path into a record pointer can only

2978
00:59:32,890 --> 00:59:32,900
 

2979
00:59:32,900 --> 00:59:34,059
point out with the obvious downside of

2980
00:59:34,059 --> 00:59:34,069
 

2981
00:59:34,069 --> 00:59:37,390
this that is though what's the one

2982
00:59:37,390 --> 00:59:37,400
 

2983
00:59:37,400 --> 00:59:38,769
operation I said was really efficient in

2984
00:59:38,769 --> 00:59:38,779
 

2985
00:59:38,779 --> 00:59:43,930
a B+ tree you made the hand gesture

2986
00:59:43,930 --> 00:59:43,940
 

2987
00:59:43,940 --> 00:59:47,109
sorry yes scratch your scans along the

2988
00:59:47,109 --> 00:59:47,119
 

2989
00:59:47,119 --> 00:59:49,059
leaf nodes how do i how would I do that

2990
00:59:49,059 --> 00:59:49,069
 

2991
00:59:49,069 --> 00:59:52,390
here right I can't write I essentially

2992
00:59:52,390 --> 00:59:52,400
 

2993
00:59:52,400 --> 00:59:54,069
have because I because if I scan along

2994
00:59:54,069 --> 00:59:54,079
 

2995
00:59:54,079 --> 00:59:56,769
these guys I don't know what the key is

2996
00:59:56,769 --> 00:59:56,779
 

2997
00:59:56,779 --> 00:59:58,569
because the keys not being stored down

2998
00:59:58,569 --> 00:59:58,579
 

2999
00:59:58,579 --> 01:00:01,120
with me so I essentially have to keep a

3000
01:00:01,120 --> 01:00:01,130
 

3001
01:00:01,130 --> 01:00:03,250
stack of how I traversing the tree and

3002
01:00:03,250 --> 01:00:03,260
 

3003
01:00:03,260 --> 01:00:05,829
go back up and go back down and one of

3004
01:00:05,829 --> 01:00:05,839
 

3005
01:00:05,839 --> 01:00:07,150
the scan alone leave notes until I find

3006
01:00:07,150 --> 01:00:07,160
 

3007
01:00:07,160 --> 01:00:10,180
my end point so this is me way more

3008
01:00:10,180 --> 01:00:10,190
 

3009
01:00:10,190 --> 01:00:13,000
efficient for for storing storing keys

3010
01:00:13,000 --> 01:00:13,010
 

3011
01:00:13,010 --> 01:00:14,980
it'll make in the second we'll see well

3012
01:00:14,980 --> 01:00:14,990
 

3013
01:00:14,990 --> 01:00:16,900
Hawaii point queries are much more much

3014
01:00:16,900 --> 01:00:16,910
 

3015
01:00:16,910 --> 01:00:18,819
more efficient insertions are much more

3016
01:00:18,819 --> 01:00:18,829
 

3017
01:00:18,829 --> 01:00:20,950
inefficient as well but the scans are

3018
01:00:20,950 --> 01:00:20,960
 

3019
01:00:20,960 --> 01:00:22,539
gonna be much slower because again we

3020
01:00:22,539 --> 01:00:22,549
 

3021
01:00:22,549 --> 01:00:27,519
have to backtracking all right so the

3022
01:00:27,519 --> 01:00:27,529
 

3023
01:00:27,529 --> 01:00:29,589
the major thing to talk about though is

3024
01:00:29,589 --> 01:00:29,599
 

3025
01:00:29,599 --> 01:00:31,870
how we're actually to store keys in our

3026
01:00:31,870 --> 01:00:31,880
 

3027
01:00:31,880 --> 01:00:36,609
in our raid extreme so not all the ash

3028
01:00:36,609 --> 01:00:36,619
 

3029
01:00:36,619 --> 01:00:39,099
trees we want to store can we just split

3030
01:00:39,099 --> 01:00:39,109
 

3031
01:00:39,109 --> 01:00:40,930
them up by their digits or characters

3032
01:00:40,930 --> 01:00:40,940
 

3033
01:00:40,940 --> 01:00:42,970
and store them directly in the index you

3034
01:00:42,970 --> 01:00:42,980
 

3035
01:00:42,980 --> 01:00:44,349
actually do some transformations in

3036
01:00:44,349 --> 01:00:44,359
 

3037
01:00:44,359 --> 01:00:45,190
order to put it through a form that

3038
01:00:45,190 --> 01:00:45,200

3039
01:00:45,200 --> 01:00:48,880
makes it amenable to doing the comic you

3040
01:00:48,880 --> 01:00:48,890
 

3041
01:00:48,890 --> 01:00:51,160
know digit by digit comparison we want

3042
01:00:51,160 --> 01:00:51,170
 

3043
01:00:51,170 --> 01:00:53,559
to do and this has to has to do a lot

3044
01:00:53,559 --> 01:00:53,569
 

3045
01:00:53,569 --> 01:00:56,650
with how the the underlying CPU is going

3046
01:00:56,650 --> 01:00:56,660
 

3047
01:00:56,660 --> 01:00:59,319
to represent data let's say you have an

3048
01:00:59,319 --> 01:00:59,329
 

3049
01:00:59,329 --> 01:01:01,660
unsigned integer so we want to maybe

3050
01:01:01,660 --> 01:01:01,670
 

3051
01:01:01,670 --> 01:01:03,819
split it up by by bytes and struggles

3052
01:01:03,819 --> 01:01:03,829
 

3053
01:01:03,829 --> 01:01:07,210
bytes as our digits in the in our in our

3054
01:01:07,210 --> 01:01:07,220
 

3055
01:01:07,220 --> 01:01:08,529
tree because we can do really efficient

3056
01:01:08,529 --> 01:01:08,539
 

3057
01:01:08,539 --> 01:01:09,880
single instructions and do comparisons

3058
01:01:09,880 --> 01:01:09,890

3059
01:01:09,890 --> 01:01:13,450
of bytes the problem is though if we're

3060
01:01:13,450 --> 01:01:13,460
 

3061
01:01:13,460 --> 01:01:15,579
on Intel CPUs which are little endian if

3062
01:01:15,579 --> 01:01:15,589
 

3063
01:01:15,589 --> 01:01:18,190
we go from you know from left to right

3064
01:01:18,190 --> 01:01:18,200
 

3065
01:01:18,200 --> 01:01:19,870
and look at that then we're actually

3066
01:01:19,870 --> 01:01:19,880
 

3067
01:01:19,880 --> 01:01:21,670
looking at the most literally the least

3068
01:01:21,670 --> 01:01:21,680
 

3069
01:01:21,680 --> 01:01:23,829
significant bit first and that's how can

3070
01:01:23,829 --> 01:01:23,839
 

3071
01:01:23,839 --> 01:01:25,870
you do incorrect comparisons so we're

3072
01:01:25,870 --> 01:01:25,880

3073
01:01:25,880 --> 01:01:27,370
need to flip it and start it as big

3074
01:01:27,370 --> 01:01:27,380
 

3075
01:01:27,380 --> 01:01:29,500
endian form and then store the prefixes

3076
01:01:29,500 --> 01:01:29,510
 

3077
01:01:29,510 --> 01:01:30,940
that way and I'll show an example what

3078
01:01:30,940 --> 01:01:30,950
 

3079
01:01:30,950 --> 01:01:33,130
that looks like in a second same problem

3080
01:01:33,130 --> 01:01:33,140
 

3081
01:01:33,140 --> 01:01:34,539
for sign integers right we have the two

3082
01:01:34,539 --> 01:01:34,549
 

3083
01:01:34,549 --> 01:01:37,120
complements bit in the front so we had

3084
01:01:37,120 --> 01:01:37,130
 

3085
01:01:37,130 --> 01:01:38,319
them flip back to make sure that

3086
01:01:38,319 --> 01:01:38,329
 

3087
01:01:38,329 --> 01:01:39,880
negative numbers are less than positive

3088
01:01:39,880 --> 01:01:39,890
 

3089
01:01:39,890 --> 01:01:41,650
numbers and then we can store everything

3090
01:01:41,650 --> 01:01:41,660
 

3091
01:01:41,660 --> 01:01:42,640
else in

3092
01:01:42,640 --> 01:01:42,650

3093
01:01:42,650 --> 01:01:44,049
inform that we talked about before for

3094
01:01:44,049 --> 01:01:44,059
 

3095
01:01:44,059 --> 01:01:46,720
floats be more complicated you have to

3096
01:01:46,720 --> 01:01:46,730
 

3097
01:01:46,730 --> 01:01:47,920
classify them whether deposit or

3098
01:01:47,920 --> 01:01:47,930
 

3099
01:01:47,930 --> 01:01:49,480
negative whether there's normalized

3100
01:01:49,480 --> 01:01:49,490
 

3101
01:01:49,490 --> 01:01:50,829
denormalize and then just try to store

3102
01:01:50,829 --> 01:01:50,839
 

3103
01:01:50,839 --> 01:01:52,749
them as unsigned integers right cuz I

3104
01:01:52,749 --> 01:01:52,759
 

3105
01:01:52,759 --> 01:01:54,489
think about this way the the harbor's

3106
01:01:54,489 --> 01:01:54,499
 

3107
01:01:54,499 --> 01:01:56,470
can represent the floating point so it

3108
01:01:56,470 --> 01:01:56,480
 

3109
01:01:56,480 --> 01:01:57,609
keeps track of where that floating point

3110
01:01:57,609 --> 01:01:57,619
 

3111
01:01:57,619 --> 01:02:00,099
number is so that means you know thirty

3112
01:02:00,099 --> 01:02:00,109
 

3113
01:02:00,109 --> 01:02:02,529
three point zero is is greater than

3114
01:02:02,529 --> 01:02:02,539
 

3115
01:02:02,539 --> 01:02:05,019
three point three zero so we need to

3116
01:02:05,019 --> 01:02:05,029
 

3117
01:02:05,029 --> 01:02:06,400
keep track of you know where that

3118
01:02:06,400 --> 01:02:06,410
 

3119
01:02:06,410 --> 01:02:08,109
floating point is so that we can do our

3120
01:02:08,109 --> 01:02:08,119
 

3121
01:02:08,119 --> 01:02:09,339
correct comparison so we can normalize

3122
01:02:09,339 --> 01:02:09,349
 

3123
01:02:09,349 --> 01:02:12,430
everything for compound in keys like if

3124
01:02:12,430 --> 01:02:12,440
 

3125
01:02:12,440 --> 01:02:13,599
I have two integers I'm going to build

3126
01:02:13,599 --> 01:02:13,609
 

3127
01:02:13,609 --> 01:02:15,940
an index on that I do my transformation

3128
01:02:15,940 --> 01:02:15,950
 

3129
01:02:15,950 --> 01:02:17,049
then concatenate them together and

3130
01:02:17,049 --> 01:02:17,059

3131
01:02:17,059 --> 01:02:19,180
everything worked up just fine well

3132
01:02:19,180 --> 01:02:19,190
 

3133
01:02:19,190 --> 01:02:20,380
let's look at the unsigned integer

3134
01:02:20,380 --> 01:02:20,390
 

3135
01:02:20,390 --> 01:02:22,539
problem let's say that I want to store

3136
01:02:22,539 --> 01:02:22,549
 

3137
01:02:22,549 --> 01:02:25,359
this key here 168 million I don't to

3138
01:02:25,359 --> 01:02:25,369
 

3139
01:02:25,369 --> 01:02:26,859
sort of store this as an unsigned 32-bit

3140
01:02:26,859 --> 01:02:26,869
 

3141
01:02:26,869 --> 01:02:29,620
integer so we're about two compliments

3142
01:02:29,620 --> 01:02:29,630
 

3143
01:02:29,630 --> 01:02:32,440
here all right so I can represent this

3144
01:02:32,440 --> 01:02:32,450
 

3145
01:02:32,450 --> 01:02:39,279
as 4 1 byte hex codes alright and would

3146
01:02:39,279 --> 01:02:39,289
 

3147
01:02:39,289 --> 01:02:41,349
look like this so now if I store it

3148
01:02:41,349 --> 01:02:41,359
 

3149
01:02:41,359 --> 01:02:44,109
though in order and big-endian versus

3150
01:02:44,109 --> 01:02:44,119
 

3151
01:02:44,119 --> 01:02:46,120
little-endian form we see that we get to

3152
01:02:46,120 --> 01:02:46,130
 

3153
01:02:46,130 --> 01:02:47,739
lead to totally different sort orders of

3154
01:02:47,739 --> 01:02:47,749
 

3155
01:02:47,749 --> 01:02:52,269
these right so for big endian the most

3156
01:02:52,269 --> 01:02:52,279
 

3157
01:02:52,279 --> 01:02:53,799
difficult it will be represented first

3158
01:02:53,799 --> 01:02:53,809
 

3159
01:02:53,809 --> 01:02:55,559
but a little endian it's at the bottom

3160
01:02:55,559 --> 01:02:55,569
 

3161
01:02:55,569 --> 01:02:58,509
so say now I want to compare whether 3

3162
01:02:58,509 --> 01:02:58,519
 

3163
01:02:58,519 --> 01:03:03,430
is less than 116 million in the case if

3164
01:03:03,430 --> 01:03:03,440
 

3165
01:03:03,440 --> 01:03:04,930
I was stored in little-endian then I

3166
01:03:04,930 --> 01:03:04,940
 

3167
01:03:04,940 --> 01:03:06,279
would happen I wouldn't know until I get

3168
01:03:06,279 --> 01:03:06,289
 

3169
01:03:06,289 --> 01:03:09,489
to the very bottom right but if I'm big

3170
01:03:09,489 --> 01:03:09,499
 

3171
01:03:09,499 --> 01:03:10,749
endian but I would know at the very top

3172
01:03:10,749 --> 01:03:10,759
 

3173
01:03:10,759 --> 01:03:12,640
that yes 3 is less than a hundred

3174
01:03:12,640 --> 01:03:12,650
 

3175
01:03:12,650 --> 01:03:15,579
sixty-eight million so I can terminate

3176
01:03:15,579 --> 01:03:15,589
 

3177
01:03:15,589 --> 01:03:17,890
the search immediately right so it

3178
01:03:17,890 --> 01:03:17,900
 

3179
01:03:17,900 --> 01:03:20,920
looked like this in our tree right and

3180
01:03:20,920 --> 01:03:20,930
 

3181
01:03:20,930 --> 01:03:23,620
so this would be a path down into store

3182
01:03:23,620 --> 01:03:23,630
 

3183
01:03:23,630 --> 01:03:25,690
hundred million I mean compare whether

3184
01:03:25,690 --> 01:03:25,700
 

3185
01:03:25,700 --> 01:03:27,279
the value 1 is there right because I

3186
01:03:27,279 --> 01:03:27,289
 

3187
01:03:27,289 --> 01:03:29,259
want to compare if I'm stored in

3188
01:03:29,259 --> 01:03:29,269
 

3189
01:03:29,269 --> 01:03:31,390
little-endian form the value 3 the

3190
01:03:31,390 --> 01:03:31,400
 

3191
01:03:31,400 --> 01:03:35,289
integer 3 at the the most difficult is 0

3192
01:03:35,289 --> 01:03:35,299
 

3193
01:03:35,299 --> 01:03:40,960
0 right but the bottom would be mean you

3194
01:03:40,960 --> 01:03:40,970
 

3195
01:03:40,970 --> 01:03:44,289
know 1 0 out right yes 1 1 and 1 1 would

3196
01:03:44,289 --> 01:03:44,299
 

3197
01:03:44,299 --> 01:03:45,609
be great in them rather than this and

3198
01:03:45,609 --> 01:03:45,619
 

3199
01:03:45,619 --> 01:03:48,729
therefore I it would be incorrect so we

3200
01:03:48,729 --> 01:03:48,739
 

3201
01:03:48,739 --> 01:03:49,989
flip it around when we want to store

3202
01:03:49,989 --> 01:03:49,999
 

3203
01:03:49,999 --> 01:03:52,089
this on on little-endian cpus to make

3204
01:03:52,089 --> 01:03:52,099
 

3205
01:03:52,099 --> 01:03:53,890
sure we can do faster comparisons so if

3206
01:03:53,890 --> 01:03:53,900

3207
01:03:53,900 --> 01:03:55,690
they do this for all the possible basic

3208
01:03:55,690 --> 01:03:55,700
 

3209
01:03:55,700 --> 01:03:56,920
data types we want to

3210
01:03:56,920 --> 01:03:56,930
 

3211
01:03:56,930 --> 01:03:59,560
I is this sort of clear this is

3212
01:03:59,560 --> 01:03:59,570
 

3213
01:03:59,570 --> 01:04:00,670
something but the architecture with the

3214
01:04:00,670 --> 01:04:00,680
 

3215
01:04:00,680 --> 01:04:03,130
ticket be mindful of and and transform

3216
01:04:03,130 --> 01:04:03,140
 

3217
01:04:03,140 --> 01:04:04,930
our data to make it amenable restoring

3218
01:04:04,930 --> 01:04:04,940
 

3219
01:04:04,940 --> 01:04:08,680
in a rate extreme so now for this entire

3220
01:04:08,680 --> 01:04:08,690
 

3221
01:04:08,690 --> 01:04:11,740
class I've not shown you any benchmark

3222
01:04:11,740 --> 01:04:11,750
 

3223
01:04:11,750 --> 01:04:13,990
numbers because I want to sort of focus

3224
01:04:13,990 --> 01:04:14,000
 

3225
01:04:14,000 --> 01:04:16,390
on the fundamentals of the databases

3226
01:04:16,390 --> 01:04:16,400
 

3227
01:04:16,400 --> 01:04:17,530
that we're talking about in this this

3228
01:04:17,530 --> 01:04:17,540
 

3229
01:04:17,540 --> 01:04:20,109
course but I want to show you in case

3230
01:04:20,109 --> 01:04:20,119
 

3231
01:04:20,119 --> 01:04:21,370
you get the wrong idea of how amazing

3232
01:04:21,370 --> 01:04:21,380
 

3233
01:04:21,380 --> 01:04:24,550
skip lists are some benchmark results

3234
01:04:24,550 --> 01:04:24,560
 

3235
01:04:24,560 --> 01:04:25,960
we've done in our own research to show

3236
01:04:25,960 --> 01:04:25,970
 

3237
01:04:25,970 --> 01:04:28,270
that it's not actually the case so this

3238
01:04:28,270 --> 01:04:28,280
 

3239
01:04:28,280 --> 01:04:29,770
is a comparison we published in sigmod

3240
01:04:29,770 --> 01:04:29,780
 

3241
01:04:29,780 --> 01:04:32,290
this year written by was done by a PG

3242
01:04:32,290 --> 01:04:32,300
 

3243
01:04:32,300 --> 01:04:35,680
student here at CMU and we compared a

3244
01:04:35,680 --> 01:04:35,690
 

3245
01:04:35,690 --> 01:04:37,359
data structure that we implemented

3246
01:04:37,359 --> 01:04:37,369
 

3247
01:04:37,369 --> 01:04:39,849
called the called the BW tree so this is

3248
01:04:39,849 --> 01:04:39,859
 

3249
01:04:39,859 --> 01:04:40,690
something originally invented by

3250
01:04:40,690 --> 01:04:40,700

3251
01:04:40,700 --> 01:04:43,150
Microsoft for the hackaton system for

3252
01:04:43,150 --> 01:04:43,160
 

3253
01:04:43,160 --> 01:04:45,069
sequel server from five or six years ago

3254
01:04:45,069 --> 01:04:45,079

3255
01:04:45,079 --> 01:04:47,200
we when I showed up a CMU I thought was

3256
01:04:47,200 --> 01:04:47,210
 

3257
01:04:47,210 --> 01:04:48,880
amazing thing and we went we set out to

3258
01:04:48,880 --> 01:04:48,890
 

3259
01:04:48,890 --> 01:04:50,020
build our own because it was an open

3260
01:04:50,020 --> 01:04:50,030
 

3261
01:04:50,030 --> 01:04:51,849
source one so we built our own open

3262
01:04:51,849 --> 01:04:51,859
 

3263
01:04:51,859 --> 01:04:53,380
source BW tree was a lock free data

3264
01:04:53,380 --> 01:04:53,390
 

3265
01:04:53,390 --> 01:04:55,180
structure and we want to see how well it

3266
01:04:55,180 --> 01:04:55,190
 

3267
01:04:55,190 --> 01:04:56,950
would compare against other existing

3268
01:04:56,950 --> 01:04:56,960
 

3269
01:04:56,960 --> 01:05:00,849
data structures let's the spoiler is

3270
01:05:00,849 --> 01:05:00,859
 

3271
01:05:00,859 --> 01:05:03,970
that it sucks and gets crushed but we

3272
01:05:03,970 --> 01:05:03,980

3273
01:05:03,980 --> 01:05:05,620
also compared the BtoB tree against the

3274
01:05:05,620 --> 01:05:05,630
 

3275
01:05:05,630 --> 01:05:07,809
B+ tree a skip list and a raid extreme

3276
01:05:07,809 --> 01:05:07,819
 

3277
01:05:07,819 --> 01:05:10,569
and so for this this is on a single

3278
01:05:10,569 --> 01:05:10,579
 

3279
01:05:10,579 --> 01:05:12,700
socket CPU and we're running with ten

3280
01:05:12,700 --> 01:05:12,710
 

3281
01:05:12,710 --> 01:05:15,160
cores or twenty twenty threads we're

3282
01:05:15,160 --> 01:05:15,170
 

3283
01:05:15,170 --> 01:05:17,260
doing insert only read only and then

3284
01:05:17,260 --> 01:05:17,270
 

3285
01:05:17,270 --> 01:05:19,630
read an update and what you see is that

3286
01:05:19,630 --> 01:05:19,640
 

3287
01:05:19,640 --> 01:05:21,900
for the radix tree crushes every one

3288
01:05:21,900 --> 01:05:21,910
 

3289
01:05:21,910 --> 01:05:24,579
right it's just so fast to do these

3290
01:05:24,579 --> 01:05:24,589
 

3291
01:05:24,589 --> 01:05:26,950
quick you know breaking up these values

3292
01:05:26,950 --> 01:05:26,960
 

3293
01:05:26,960 --> 01:05:28,510
into digits and doing insertions and

3294
01:05:28,510 --> 01:05:28,520
 

3295
01:05:28,520 --> 01:05:30,940
lookups and updates very quickly the

3296
01:05:30,940 --> 01:05:30,950

3297
01:05:30,950 --> 01:05:36,190
Skip list always loses right the BW tree

3298
01:05:36,190 --> 01:05:36,200
 

3299
01:05:36,200 --> 01:05:37,990
turns out actually almost always loses

3300
01:05:37,990 --> 01:05:38,000
 

3301
01:05:38,000 --> 01:05:42,579
to a regular actually skip list is doing

3302
01:05:42,579 --> 01:05:42,589
 

3303
01:05:42,589 --> 01:05:49,010
okay here yeah that might be wrong

3304
01:05:49,010 --> 01:05:49,020


3305
01:05:49,020 --> 01:05:50,720
yeah these might be flood baby might be

3306
01:05:50,720 --> 01:05:50,730
 

3307
01:05:50,730 --> 01:05:53,930
swept swatch there's no way yeah there's

3308
01:05:53,930 --> 01:05:53,940
 

3309
01:05:53,940 --> 01:05:56,450
no way sorry my fault okay I shoulda put

3310
01:05:56,450 --> 01:05:56,460
 

3311
01:05:56,460 --> 01:05:59,720
bread maybe for my C to go check the

3312
01:05:59,720 --> 01:05:59,730
 

3313
01:05:59,730 --> 01:06:02,600
paper now make some papers right so the

3314
01:06:02,600 --> 01:06:02,610

3315
01:06:02,610 --> 01:06:04,760
raid x-tree blows everyone away right

3316
01:06:04,760 --> 01:06:04,770
 

3317
01:06:04,770 --> 01:06:06,770
it's just because the the amount of work

3318
01:06:06,770 --> 01:06:06,780
 

3319
01:06:06,780 --> 01:06:10,160
you have to do to do comparisons is so

3320
01:06:10,160 --> 01:06:10,170
 

3321
01:06:10,170 --> 01:06:12,770
much less than a B+ tree for doing

3322
01:06:12,770 --> 01:06:12,780
 

3323
01:06:12,780 --> 01:06:14,030
insertions you don't think these splits

3324
01:06:14,030 --> 01:06:14,040
 

3325
01:06:14,040 --> 01:06:16,609
emerges right in the Skip list this is

3326
01:06:16,609 --> 01:06:16,619
 

3327
01:06:16,619 --> 01:06:17,750
an in-memory database we're not worried

3328
01:06:17,750 --> 01:06:17,760
 

3329
01:06:17,760 --> 01:06:19,310
about reading from from the buffer pool

3330
01:06:19,310 --> 01:06:19,320

3331
01:06:19,320 --> 01:06:22,400
the the you always lose out because the

3332
01:06:22,400 --> 01:06:22,410
 

3333
01:06:22,410 --> 01:06:25,670
cache misses in an indirection from from

3334
01:06:25,670 --> 01:06:25,680
 

3335
01:06:25,680 --> 01:06:28,580
chasing pointers and the BtoB tree just

3336
01:06:28,580 --> 01:06:28,590
 

3337
01:06:28,590 --> 01:06:29,900
has so much overhead to make it lock

3338
01:06:29,900 --> 01:06:29,910
 

3339
01:06:29,910 --> 01:06:32,390
free this is again we'll just if you

3340
01:06:32,390 --> 01:06:32,400
 

3341
01:06:32,400 --> 01:06:33,500
take the advanced class we'll discuss

3342
01:06:33,500 --> 01:06:33,510

3343
01:06:33,510 --> 01:06:35,240
this lock free sounds like an amazing

3344
01:06:35,240 --> 01:06:35,250

3345
01:06:35,250 --> 01:06:36,650
thing we want to use this for all our

3346
01:06:36,650 --> 01:06:36,660
 

3347
01:06:36,660 --> 01:06:39,920
data structures but in the day and B

3348
01:06:39,920 --> 01:06:39,930
 

3349
01:06:39,930 --> 01:06:41,540
plus tree which is you know latching

3350
01:06:41,540 --> 01:06:41,550
 

3351
01:06:41,550 --> 01:06:42,609
that we'll talk about on Wednesday

3352
01:06:42,609 --> 01:06:42,619
 

3353
01:06:42,619 --> 01:06:46,190
outperforms it and the radix tree is

3354
01:06:46,190 --> 01:06:46,200
 

3355
01:06:46,200 --> 01:06:47,510
using latching well it's not it's not

3356
01:06:47,510 --> 01:06:47,520

3357
01:06:47,520 --> 01:07:02,420
walk free okay any questions yes so his

3358
01:07:02,420 --> 01:07:02,430
 

3359
01:07:02,430 --> 01:07:04,760
question is for the rate extreme when I

3360
01:07:04,760 --> 01:07:04,770
 

3361
01:07:04,770 --> 01:07:06,349
showed the compression or the compare

3362
01:07:06,349 --> 01:07:06,359
 

3363
01:07:06,359 --> 01:07:10,010
the collapsing collapsing of one node

3364
01:07:10,010 --> 01:07:10,020

3365
01:07:10,020 --> 01:07:11,990
into another node his question is is

3366
01:07:11,990 --> 01:07:12,000
 

3367
01:07:12,000 --> 01:07:14,450
that only don' at the leaf nodes or is

3368
01:07:14,450 --> 01:07:14,460
 

3369
01:07:14,460 --> 01:07:16,609
it done anywhere in the tree so the

3370
01:07:16,609 --> 01:07:16,619
 

3371
01:07:16,619 --> 01:07:18,590
textbook definition of a radix tree does

3372
01:07:18,590 --> 01:07:18,600
 

3373
01:07:18,600 --> 01:07:20,180
not actually do any of this collapsing

3374
01:07:20,180 --> 01:07:20,190
 

3375
01:07:20,190 --> 01:07:22,520
in a practical implementation you won't

3376
01:07:22,520 --> 01:07:22,530
 

3377
01:07:22,530 --> 01:07:24,349
you'd want to do this so in the hyper

3378
01:07:24,349 --> 01:07:24,359
 

3379
01:07:24,359 --> 01:07:25,940
system but the German system I mentioned

3380
01:07:25,940 --> 01:07:25,950
 

3381
01:07:25,950 --> 01:07:28,550
was bought by tableau they have a paper

3382
01:07:28,550 --> 01:07:28,560
 

3383
01:07:28,560 --> 01:07:30,620
where they show how to adaptively do

3384
01:07:30,620 --> 01:07:30,630
 

3385
01:07:30,630 --> 01:07:32,900
this there's collapsing or splitting at

3386
01:07:32,900 --> 01:07:32,910
 

3387
01:07:32,910 --> 01:07:37,700
all different levels yeah there's one of

3388
01:07:37,700 --> 01:07:37,710
 

3389
01:07:37,710 --> 01:07:38,840
those things were like a radix tree was

3390
01:07:38,840 --> 01:07:38,850
 

3391
01:07:38,850 --> 01:07:39,950
an old idea it's been around for a while

3392
01:07:39,950 --> 01:07:39,960
 

3393
01:07:39,960 --> 01:07:41,180
and it wasn't till like people actually

3394
01:07:41,180 --> 01:07:41,190
 

3395
01:07:41,190 --> 01:07:42,770
oh this seems like a good idea let's

3396
01:07:42,770 --> 01:07:42,780
 

3397
01:07:42,780 --> 01:07:44,060
actually try to make one work in

3398
01:07:44,060 --> 01:07:44,070
 

3399
01:07:44,070 --> 01:07:45,830
practice that people recognize oh this

3400
01:07:45,830 --> 01:07:45,840
 

3401
01:07:45,840 --> 01:07:54,410
is something we should revisit yes this

3402
01:07:54,410 --> 01:07:54,420
 

3403
01:07:54,420 --> 01:07:55,760
question is the rate of trees so fast

3404
01:07:55,760 --> 01:07:55,770
 

3405
01:07:55,770 --> 01:07:57,530
for special stands I don't have the

3406
01:07:57,530 --> 01:07:57,540
 

3407
01:07:57,540 --> 01:07:59,780
graph here and answers now B plus tree

3408
01:07:59,780 --> 01:07:59,790
 

3409
01:07:59,790 --> 01:08:01,840
is always gonna win

3410
01:08:01,840 --> 01:08:01,850
 

3411
01:08:01,850 --> 01:08:04,330
the Skip list does okay too because he's

3412
01:08:04,330 --> 01:08:04,340
 

3413
01:08:04,340 --> 01:08:06,450
just following leaf nodes but the

3414
01:08:06,450 --> 01:08:06,460
 

3415
01:08:06,460 --> 01:08:15,610
pointer chasing always loses out okay so

3416
01:08:15,610 --> 01:08:15,620
 

3417
01:08:15,620 --> 01:08:17,170
we have five minutes left so we'll do a

3418
01:08:17,170 --> 01:08:17,180
 

3419
01:08:17,180 --> 01:08:20,500
crash course on on on inverted indexes

3420
01:08:20,500 --> 01:08:20,510

3421
01:08:20,510 --> 01:08:23,200
so all the tree Anika's we talked about

3422
01:08:23,200 --> 01:08:23,210
 

3423
01:08:23,210 --> 01:08:24,880
so far are really good for what are

3424
01:08:24,880 --> 01:08:24,890
 

3425
01:08:24,890 --> 01:08:26,230
called point queries and range queries

3426
01:08:26,230 --> 01:08:26,240

3427
01:08:26,240 --> 01:08:28,630
pointed queries are fine you know Andy's

3428
01:08:28,630 --> 01:08:28,640
 

3429
01:08:28,640 --> 01:08:30,130
find a customer record where they had

3430
01:08:30,130 --> 01:08:30,140
 

3431
01:08:30,140 --> 01:08:32,170
the zip code one five two one seven or

3432
01:08:32,170 --> 01:08:32,180
 

3433
01:08:32,180 --> 01:08:33,940
range query be fine all the orders

3434
01:08:33,940 --> 01:08:33,950
 

3435
01:08:33,950 --> 01:08:36,280
within a particular time range right

3436
01:08:36,280 --> 01:08:36,290
 

3437
01:08:36,290 --> 01:08:38,590
from June 27th June 2018 is September

3438
01:08:38,590 --> 01:08:38,600
 

3439
01:08:38,600 --> 01:08:41,320
2018 but these data structures are not

3440
01:08:41,320 --> 01:08:41,330
 

3441
01:08:41,330 --> 01:08:43,930
good for keyword searches so I'm going

3442
01:08:43,930 --> 01:08:43,940
 

3443
01:08:43,940 --> 01:08:45,700
to find all the Wikipedia articles that

3444
01:08:45,700 --> 01:08:45,710
 

3445
01:08:45,710 --> 01:08:50,260
contain the word Pablo right I can't use

3446
01:08:50,260 --> 01:08:50,270
 

3447
01:08:50,270 --> 01:08:52,210
my index for that right because think

3448
01:08:52,210 --> 01:08:52,220

3449
01:08:52,220 --> 01:08:53,440
about how you actually would store the

3450
01:08:53,440 --> 01:08:53,450
 

3451
01:08:53,450 --> 01:08:55,870
Wikipedia article I we saw this we saw

3452
01:08:55,870 --> 01:08:55,880
 

3453
01:08:55,880 --> 01:08:58,690
this before right this is the the sample

3454
01:08:58,690 --> 01:08:58,700
 

3455
01:08:58,700 --> 01:09:01,329
schema from the real actual Wikipedia

3456
01:09:01,329 --> 01:09:01,339
 

3457
01:09:01,339 --> 01:09:04,180
software okay we have user accounts and

3458
01:09:04,180 --> 01:09:04,190
 

3459
01:09:04,190 --> 01:09:06,250
your pages and there's revisions for

3460
01:09:06,250 --> 01:09:06,260
 

3461
01:09:06,260 --> 01:09:09,130
pages right and then the so the actual

3462
01:09:09,130 --> 01:09:09,140
 

3463
01:09:09,140 --> 01:09:12,579
content of the article is stored here in

3464
01:09:12,579 --> 01:09:12,589
 

3465
01:09:12,589 --> 01:09:15,340
this content field as a text field so I

3466
01:09:15,340 --> 01:09:15,350
 

3467
01:09:15,350 --> 01:09:17,980
could build an index on text field but

3468
01:09:17,980 --> 01:09:17,990
 

3469
01:09:17,990 --> 01:09:21,010
that is actually not what we want right

3470
01:09:21,010 --> 01:09:21,020
 

3471
01:09:21,020 --> 01:09:22,360
because that's going to be an exact

3472
01:09:22,360 --> 01:09:22,370
 

3473
01:09:22,370 --> 01:09:24,789
match of all everything that's in my

3474
01:09:24,789 --> 01:09:24,799
 

3475
01:09:24,799 --> 01:09:27,210
text field and actually I think

3476
01:09:27,210 --> 01:09:27,220
 

3477
01:09:27,220 --> 01:09:29,230
databases will let you do this but it's

3478
01:09:29,230 --> 01:09:29,240
 

3479
01:09:29,240 --> 01:09:30,340
actually a terrible idea because these

3480
01:09:30,340 --> 01:09:30,350
 

3481
01:09:30,350 --> 01:09:31,599
text fields are gonna be you know

3482
01:09:31,599 --> 01:09:31,609
 

3483
01:09:31,609 --> 01:09:34,390
kilobytes I think how long is the it's

3484
01:09:34,390 --> 01:09:34,400
 

3485
01:09:34,400 --> 01:09:35,680
always like some Star Wars article it's

3486
01:09:35,680 --> 01:09:35,690
 

3487
01:09:35,690 --> 01:09:36,640
always the longest we compete the

3488
01:09:36,640 --> 01:09:36,650
 

3489
01:09:36,650 --> 01:09:38,380
article what might be Pokemon now right

3490
01:09:38,380 --> 01:09:38,390
 

3491
01:09:38,390 --> 01:09:41,020
if I build an index on that I'm storing

3492
01:09:41,020 --> 01:09:41,030
 

3493
01:09:41,030 --> 01:09:43,360
that entire Pokemon article as a key and

3494
01:09:43,360 --> 01:09:43,370
 

3495
01:09:43,370 --> 01:09:46,090
then I can only men use it for exact

3496
01:09:46,090 --> 01:09:46,100
 

3497
01:09:46,100 --> 01:09:49,660
matches this is - so this is not what we

3498
01:09:49,660 --> 01:09:49,670
 

3499
01:09:49,670 --> 01:09:52,000
want so even if I go again if I try to

3500
01:09:52,000 --> 01:09:52,010
 

3501
01:09:52,010 --> 01:09:54,130
build my index on content it won't help

3502
01:09:54,130 --> 01:09:54,140
 

3503
01:09:54,140 --> 01:09:57,010
for this particular query because it's

3504
01:09:57,010 --> 01:09:57,020
 

3505
01:09:57,020 --> 01:09:58,930
just me it's I want to find a partial

3506
01:09:58,930 --> 01:09:58,940
 

3507
01:09:58,940 --> 01:10:00,820
match with this in actuality this is

3508
01:10:00,820 --> 01:10:00,830
 

3509
01:10:00,830 --> 01:10:03,040
actually not the right sequel itself

3510
01:10:03,040 --> 01:10:03,050
 

3511
01:10:03,050 --> 01:10:04,330
higher because I'm gonna find maybe the

3512
01:10:04,330 --> 01:10:04,340
 

3513
01:10:04,340 --> 01:10:07,000
word Pablo but this is gonna find any

3514
01:10:07,000 --> 01:10:07,010
 

3515
01:10:07,010 --> 01:10:09,700
substring that matches with pop whoa all

3516
01:10:09,700 --> 01:10:09,710
 

3517
01:10:09,710 --> 01:10:10,990
right a lot of times people want to use

3518
01:10:10,990 --> 01:10:11,000
 

3519
01:10:11,000 --> 01:10:12,910
these these these these data systems you

3520
01:10:12,910 --> 01:10:12,920
 

3521
01:10:12,920 --> 01:10:14,290
want to find you know show me the word

3522
01:10:14,290 --> 01:10:14,300
 

3523
01:10:14,300 --> 01:10:15,550
that says Obama

3524
01:10:15,550 --> 01:10:15,560
 

3525
01:10:15,560 --> 01:10:16,990
not in a mobile or something like that

3526
01:10:16,990 --> 01:10:17,000
 

3527
01:10:17,000 --> 01:10:20,260
right so this is what an inverted index

3528
01:10:20,260 --> 01:10:20,270
 

3529
01:10:20,270 --> 01:10:23,530
does so an emergent index is going to

3530
01:10:23,530 --> 01:10:23,540
 

3531
01:10:23,540 --> 01:10:26,770
map words within a record or the

3532
01:10:26,770 --> 01:10:26,780
 

3533
01:10:26,780 --> 01:10:28,630
hatchery that were indexing to the

3534
01:10:28,630 --> 01:10:28,640
 

3535
01:10:28,640 --> 01:10:31,090
actual record itself right and the

3536
01:10:31,090 --> 01:10:31,100
 

3537
01:10:31,100 --> 01:10:32,440
reason why it's called inverted because

3538
01:10:32,440 --> 01:10:32,450
 

3539
01:10:32,450 --> 01:10:34,510
think about like your strong documents

3540
01:10:34,510 --> 01:10:34,520
 

3541
01:10:34,520 --> 01:10:37,720
like in these Wikipedia articles instead

3542
01:10:37,720 --> 01:10:37,730

3543
01:10:37,730 --> 01:10:39,550
of storing this the whole document you

3544
01:10:39,550 --> 01:10:39,560
 

3545
01:10:39,560 --> 01:10:41,830
have you you invert it so you store

3546
01:10:41,830 --> 01:10:41,840
 

3547
01:10:41,840 --> 01:10:44,020
pointers to this documents based on what

3548
01:10:44,020 --> 01:10:44,030
 

3549
01:10:44,030 --> 01:10:46,600
words they use alright so in the

3550
01:10:46,600 --> 01:10:46,610
 

3551
01:10:46,610 --> 01:10:48,700
literature these are sometimes called at

3552
01:10:48,700 --> 01:10:48,710
 

3553
01:10:48,710 --> 01:10:49,720
least databases called

3554
01:10:49,720 --> 01:10:49,730

3555
01:10:49,730 --> 01:10:53,350
full text search indexes to go back to

3556
01:10:53,350 --> 01:10:53,360
 

3557
01:10:53,360 --> 01:10:54,520
like the 1800s

3558
01:10:54,520 --> 01:10:54,530
 

3559
01:10:54,530 --> 01:10:56,820
they were neighbors called concordances

3560
01:10:56,820 --> 01:10:56,830

3561
01:10:56,830 --> 01:10:59,800
right so the concordance would be like

3562
01:10:59,800 --> 01:10:59,810
 

3563
01:10:59,810 --> 01:11:02,860
somebody in 1800s some woman spent 16

3564
01:11:02,860 --> 01:11:02,870
 

3565
01:11:02,870 --> 01:11:05,560
years making essentially an inverted

3566
01:11:05,560 --> 01:11:05,570
 

3567
01:11:05,570 --> 01:11:08,650
index to track every single word in that

3568
01:11:08,650 --> 01:11:08,660
 

3569
01:11:08,660 --> 01:11:10,510
Shakespeare used in this entire like

3570
01:11:10,510 --> 01:11:10,520
 

3571
01:11:10,520 --> 01:11:14,050
bibliography alright so but nobody

3572
01:11:14,050 --> 01:11:14,060
 

3573
01:11:14,060 --> 01:11:15,970
already calls that now an invert usually

3574
01:11:15,970 --> 01:11:15,980
 

3575
01:11:15,980 --> 01:11:18,730
called an inverted indexes so we're not

3576
01:11:18,730 --> 01:11:18,740
 

3577
01:11:18,740 --> 01:11:19,930
gonna have time to go into the actual

3578
01:11:19,930 --> 01:11:19,940
 

3579
01:11:19,940 --> 01:11:21,970
implementation of this but essentially

3580
01:11:21,970 --> 01:11:21,980
 

3581
01:11:21,980 --> 01:11:24,700
you can think about it as we can use

3582
01:11:24,700 --> 01:11:24,710
 

3583
01:11:24,710 --> 01:11:27,220
some tree indexes to find the words that

3584
01:11:27,220 --> 01:11:27,230
 

3585
01:11:27,230 --> 01:11:28,030
we want and then some additional

3586
01:11:28,030 --> 01:11:28,040
 

3587
01:11:28,040 --> 01:11:30,640
metadata and say here's here's where the

3588
01:11:30,640 --> 01:11:30,650
 

3589
01:11:30,650 --> 01:11:32,200
work can be found or here's what words

3590
01:11:32,200 --> 01:11:32,210
 

3591
01:11:32,210 --> 01:11:34,420
are close to it so all the major

3592
01:11:34,420 --> 01:11:34,430
 

3593
01:11:34,430 --> 01:11:36,840
databases would support full-text

3594
01:11:36,840 --> 01:11:36,850
 

3595
01:11:36,850 --> 01:11:39,520
full-text search indexes in some form

3596
01:11:39,520 --> 01:11:39,530
 

3597
01:11:39,530 --> 01:11:41,740
the other the commercial guys actually

3598
01:11:41,740 --> 01:11:41,750
 

3599
01:11:41,750 --> 01:11:43,480
have obviously have much better packages

3600
01:11:43,480 --> 01:11:43,490

3601
01:11:43,490 --> 01:11:45,460
Postgres of course has this thing called

3602
01:11:45,460 --> 01:11:45,470
 

3603
01:11:45,470 --> 01:11:48,060
gin the generalized inverted index I

3604
01:11:48,060 --> 01:11:48,070
 

3605
01:11:48,070 --> 01:11:50,560
think it was called and it has a bunch

3606
01:11:50,560 --> 01:11:50,570
 

3607
01:11:50,570 --> 01:11:51,940
different ways you can use B plus trees

3608
01:11:51,940 --> 01:11:51,950
 

3609
01:11:51,950 --> 01:11:53,410
or hash indexes to represent the data

3610
01:11:53,410 --> 01:11:53,420
 

3611
01:11:53,420 --> 01:11:56,440
structure itself and then they have

3612
01:11:56,440 --> 01:11:56,450
 

3613
01:11:56,450 --> 01:11:58,300
extensions to sequel to allow you do

3614
01:11:58,300 --> 01:11:58,310

3615
01:11:58,310 --> 01:11:59,800
more complicated things than than the

3616
01:11:59,800 --> 01:11:59,810
 

3617
01:11:59,810 --> 01:12:03,010
like that I shared before so again all

3618
01:12:03,010 --> 01:12:03,020

3619
01:12:03,020 --> 01:12:04,150
of the major systems have that have

3620
01:12:04,150 --> 01:12:04,160
 

3621
01:12:04,160 --> 01:12:06,580
these but there are all sorts these

3622
01:12:06,580 --> 01:12:06,590
 

3623
01:12:06,590 --> 01:12:09,040
specialized database systems that are

3624
01:12:09,040 --> 01:12:09,050

3625
01:12:09,050 --> 01:12:11,500
designed explicitly for these full-text

3626
01:12:11,500 --> 01:12:11,510
 

3627
01:12:11,510 --> 01:12:13,570
searches so elastic search is probably

3628
01:12:13,570 --> 01:12:13,580
 

3629
01:12:13,580 --> 01:12:15,160
the most famous one that's built on top

3630
01:12:15,160 --> 01:12:15,170
 

3631
01:12:15,170 --> 01:12:18,490
of leucine there's another project

3632
01:12:18,490 --> 01:12:18,500
 

3633
01:12:18,500 --> 01:12:21,070
called Sphinx and then Apache Solr I

3634
01:12:21,070 --> 01:12:21,080
 

3635
01:12:21,080 --> 01:12:23,230
think is I think also maybe built on top

3636
01:12:23,230 --> 01:12:23,240
 

3637
01:12:23,240 --> 01:12:25,690
of leucine as well but again think of it

3638
01:12:25,690 --> 01:12:25,700
 

3639
01:12:25,700 --> 01:12:27,490
again like they build inverted they're

3640
01:12:27,490 --> 01:12:27,500
 

3641
01:12:27,500 --> 01:12:29,250
designed to doing searches on

3642
01:12:29,250 --> 01:12:29,260
 

3643
01:12:29,260 --> 01:12:31,080
two indexes right instead of doing

3644
01:12:31,080 --> 01:12:31,090
 

3645
01:12:31,090 --> 01:12:34,319
searches on B plus trees so the separate

3646
01:12:34,319 --> 01:12:34,329
 

3647
01:12:34,329 --> 01:12:35,459
type of queries we want to execute our

3648
01:12:35,459 --> 01:12:35,469
 

3649
01:12:35,469 --> 01:12:37,470
go beyond what we saw before

3650
01:12:37,470 --> 01:12:37,480

3651
01:12:37,480 --> 01:12:38,879
I'm gonna do phrase searchers I want to

3652
01:12:38,879 --> 01:12:38,889

3653
01:12:38,889 --> 01:12:42,870
find exact phrases in my text I wanna do

3654
01:12:42,870 --> 01:12:42,880
 

3655
01:12:42,880 --> 01:12:44,819
proximity searches so I wanted to say

3656
01:12:44,819 --> 01:12:44,829
 

3657
01:12:44,829 --> 01:12:48,060
find me find me all documents or all

3658
01:12:48,060 --> 01:12:48,070

3659
01:12:48,070 --> 01:12:50,279
records where one word is if within

3660
01:12:50,279 --> 01:12:50,289
 

3661
01:12:50,289 --> 01:12:53,040
three words of another word right and I

3662
01:12:53,040 --> 01:12:53,050
 

3663
01:12:53,050 --> 01:12:54,120
don't care what words come in in between

3664
01:12:54,120 --> 01:12:54,130
 

3665
01:12:54,130 --> 01:12:55,589
it but I know I have to be exactly three

3666
01:12:55,589 --> 01:12:55,599

3667
01:12:55,599 --> 01:12:57,899
words you do wildcard searches or

3668
01:12:57,899 --> 01:12:57,909
 

3669
01:12:57,909 --> 01:12:59,009
regular expressions to find more

3670
01:12:59,009 --> 01:12:59,019
 

3671
01:12:59,019 --> 01:13:00,270
complicated patterns you want to match

3672
01:13:00,270 --> 01:13:00,280
 

3673
01:13:00,280 --> 01:13:02,520
them in your in your text and the

3674
01:13:02,520 --> 01:13:02,530
 

3675
01:13:02,530 --> 01:13:04,140
various systems all sort of have their

3676
01:13:04,140 --> 01:13:04,150
 

3677
01:13:04,150 --> 01:13:06,450
own proprietary extensions to expose

3678
01:13:06,450 --> 01:13:06,460
 

3679
01:13:06,460 --> 01:13:07,500
this information I think there's a

3680
01:13:07,500 --> 01:13:07,510
 

3681
01:13:07,510 --> 01:13:09,089
sequel standard that says how you can

3682
01:13:09,089 --> 01:13:09,099
 

3683
01:13:09,099 --> 01:13:10,950
write these kind of queries but no one

3684
01:13:10,950 --> 01:13:10,960
 

3685
01:13:10,960 --> 01:13:14,790
actually follows it very well when you

3686
01:13:14,790 --> 01:13:14,800
 

3687
01:13:14,800 --> 01:13:16,680
actually implement this again what what

3688
01:13:16,680 --> 01:13:16,690
 

3689
01:13:16,690 --> 01:13:18,359
distinguishes one implementation from

3690
01:13:18,359 --> 01:13:18,369
 

3691
01:13:18,369 --> 01:13:19,470
the next is what information they're

3692
01:13:19,470 --> 01:13:19,480
 

3693
01:13:19,480 --> 01:13:21,930
storing so the very least the most

3694
01:13:21,930 --> 01:13:21,940
 

3695
01:13:21,940 --> 01:13:23,310
minimal thing you need to store is just

3696
01:13:23,310 --> 01:13:23,320
 

3697
01:13:23,320 --> 01:13:25,470
an inverted index that map's the words

3698
01:13:25,470 --> 01:13:25,480
 

3699
01:13:25,480 --> 01:13:29,520
to the records right and then how do you

3700
01:13:29,520 --> 01:13:29,530
 

3701
01:13:29,530 --> 01:13:31,410
define a word depend on you know how you

3702
01:13:31,410 --> 01:13:31,420
 

3703
01:13:31,420 --> 01:13:33,689
actually split the text up you and

3704
01:13:33,689 --> 01:13:33,699
 

3705
01:13:33,699 --> 01:13:35,250
punctuation the spaces sometimes there's

3706
01:13:35,250 --> 01:13:35,260

3707
01:13:35,260 --> 01:13:37,169
stop words like the word though would

3708
01:13:37,169 --> 01:13:37,179
 

3709
01:13:37,179 --> 01:13:39,060
always split you know things together

3710
01:13:39,060 --> 01:13:39,070
 

3711
01:13:39,070 --> 01:13:41,250
things like that but you know also store

3712
01:13:41,250 --> 01:13:41,260
 

3713
01:13:41,260 --> 01:13:42,720
things like how often the word appears

3714
01:13:42,720 --> 01:13:42,730
 

3715
01:13:42,730 --> 01:13:44,490
where it actually appears and other

3716
01:13:44,490 --> 01:13:44,500
 

3717
01:13:44,500 --> 01:13:47,220
metadata about the data you're indexing

3718
01:13:47,220 --> 01:13:47,230
 

3719
01:13:47,230 --> 01:13:49,979
and then the big thing we care about in

3720
01:13:49,979 --> 01:13:49,989
 

3721
01:13:49,989 --> 01:13:51,240
a database system is when we actually

3722
01:13:51,240 --> 01:13:51,250
 

3723
01:13:51,250 --> 01:13:53,970
update it so you could just only do this

3724
01:13:53,970 --> 01:13:53,980
 

3725
01:13:53,980 --> 01:13:55,589
in a batch mode where you say take all

3726
01:13:55,589 --> 01:13:55,599
 

3727
01:13:55,599 --> 01:13:57,419
my documents or my records and build my

3728
01:13:57,419 --> 01:13:57,429
 

3729
01:13:57,429 --> 01:14:00,299
index you know once every day ideally we

3730
01:14:00,299 --> 01:14:00,309
 

3731
01:14:00,309 --> 01:14:01,740
want to keep it up to date so we could

3732
01:14:01,740 --> 01:14:01,750
 

3733
01:14:01,750 --> 01:14:05,129
maintain a sort of Ziller data structure

3734
01:14:05,129 --> 01:14:05,139
 

3735
01:14:05,139 --> 01:14:06,209
to keep track of all the changes and

3736
01:14:06,209 --> 01:14:06,219
 

3737
01:14:06,219 --> 01:14:08,459
eventually merge them into a batch again

3738
01:14:08,459 --> 01:14:08,469
 

3739
01:14:08,469 --> 01:14:09,660
the different systems do different

3740
01:14:09,660 --> 01:14:09,670
 

3741
01:14:09,670 --> 01:14:12,450
things so the main takeaway from this is

3742
01:14:12,450 --> 01:14:12,460
 

3743
01:14:12,460 --> 01:14:14,790
that there are additional data

3744
01:14:14,790 --> 01:14:14,800

3745
01:14:14,800 --> 01:14:17,100
structures we could build in for our

3746
01:14:17,100 --> 01:14:17,110
 

3747
01:14:17,110 --> 01:14:18,330
table indexes that allows to do more

3748
01:14:18,330 --> 01:14:18,340
 

3749
01:14:18,340 --> 01:14:20,520
complicated things than the B plus tree

3750
01:14:20,520 --> 01:14:20,530

3751
01:14:20,530 --> 01:14:22,290
or the hash indexes or the Skip list and

3752
01:14:22,290 --> 01:14:22,300
 

3753
01:14:22,300 --> 01:14:23,129
the radix trees that we seen before

3754
01:14:23,129 --> 01:14:23,139
 

3755
01:14:23,139 --> 01:14:25,109
because all of those guys are doing key

3756
01:14:25,109 --> 01:14:25,119
 

3757
01:14:25,119 --> 01:14:27,629
matches this allows us to do way more

3758
01:14:27,629 --> 01:14:27,639
 

3759
01:14:27,639 --> 01:14:30,299
complicated things again I realize I'm

3760
01:14:30,299 --> 01:14:30,309
 

3761
01:14:30,309 --> 01:14:34,049
going fast on this but if you if you're

3762
01:14:34,049 --> 01:14:34,059
 

3763
01:14:34,059 --> 01:14:35,459
really interested in inverted indexes

3764
01:14:35,459 --> 01:14:35,469
 

3765
01:14:35,469 --> 01:14:38,970
then we have a whole course at CMU 11 4

3766
01:14:38,970 --> 01:14:38,980
 

3767
01:14:38,980 --> 01:14:41,609
42 or 642 I think it just called search

3768
01:14:41,609 --> 01:14:41,619
 

3769
01:14:41,619 --> 01:14:42,630
engines

3770
01:14:42,630 --> 01:14:42,640

3771
01:14:42,640 --> 01:14:44,730
so the inverted index is essentially the

3772
01:14:44,730 --> 01:14:44,740
 

3773
01:14:44,740 --> 01:14:46,680
underlying data structure implementation

3774
01:14:46,680 --> 01:14:46,690

3775
01:14:46,690 --> 01:14:48,510
that the data store of how search

3776
01:14:48,510 --> 01:14:48,520

3777
01:14:48,520 --> 01:14:50,880
engines are implemented and as I said

3778
01:14:50,880 --> 01:14:50,890
 

3779
01:14:50,890 --> 01:14:52,800
they store way more complicated things

3780
01:14:52,800 --> 01:14:52,810
 

3781
01:14:52,810 --> 01:14:55,380
than just the actual key in order to you

3782
01:14:55,380 --> 01:14:55,390
 

3783
01:14:55,390 --> 01:14:57,210
know do do ranked matching and other

3784
01:14:57,210 --> 01:14:57,220
 

3785
01:14:57,220 --> 01:14:58,410
things that you may want to do in your

3786
01:14:58,410 --> 01:14:58,420
 

3787
01:14:58,420 --> 01:15:02,730
system okay so it's my opinion that B

3788
01:15:02,730 --> 01:15:02,740
 

3789
01:15:02,740 --> 01:15:04,710
plus trees are still the best way to go

3790
01:15:04,710 --> 01:15:04,720
 

3791
01:15:04,720 --> 01:15:06,750
for doing indexes radix trees are

3792
01:15:06,750 --> 01:15:06,760
 

3793
01:15:06,760 --> 01:15:08,580
promising and I think the start seeing

3794
01:15:08,580 --> 01:15:08,590
 

3795
01:15:08,590 --> 01:15:11,100
more in them in the future but the B

3796
01:15:11,100 --> 01:15:11,110
 

3797
01:15:11,110 --> 01:15:12,780
plus tree there's a reason why you know

3798
01:15:12,780 --> 01:15:12,790
 

3799
01:15:12,790 --> 01:15:14,940
it was called a 1979 u ubiquitous beat

3800
01:15:14,940 --> 01:15:14,950
 

3801
01:15:14,950 --> 01:15:17,520
up B plus tree it's so good so even now

3802
01:15:17,520 --> 01:15:17,530
 

3803
01:15:17,530 --> 01:15:21,150
even with loffley data structures it's

3804
01:15:21,150 --> 01:15:21,160
 

3805
01:15:21,160 --> 01:15:23,370
always the way to go so we didn't have

3806
01:15:23,370 --> 01:15:23,380
 

3807
01:15:23,380 --> 01:15:25,640
time to also discuss geospatial indexes

3808
01:15:25,640 --> 01:15:25,650
 

3809
01:15:25,650 --> 01:15:28,080
so think of indexes do you want to do

3810
01:15:28,080 --> 01:15:28,090

3811
01:15:28,090 --> 01:15:30,330
matching on like geospatial data like I

3812
01:15:30,330 --> 01:15:30,340
 

3813
01:15:30,340 --> 01:15:32,880
have a I have a map of the United States

3814
01:15:32,880 --> 01:15:32,890
 

3815
01:15:32,890 --> 01:15:35,280
and it's broken up by state I want to

3816
01:15:35,280 --> 01:15:35,290
 

3817
01:15:35,290 --> 01:15:36,780
know whether a given point is in a state

3818
01:15:36,780 --> 01:15:36,790
 

3819
01:15:36,790 --> 01:15:38,940
or not so you can't use two B plus tree

3820
01:15:38,940 --> 01:15:38,950
 

3821
01:15:38,950 --> 01:15:40,500
for that because again it's not doing

3822
01:15:40,500 --> 01:15:40,510
 

3823
01:15:40,510 --> 01:15:41,880
key matching the way we talked about so

3824
01:15:41,880 --> 01:15:41,890
 

3825
01:15:41,890 --> 01:15:43,980
far so the specialized data structure

3826
01:15:43,980 --> 01:15:43,990
 

3827
01:15:43,990 --> 01:15:45,300
it's called geospatial data structures

3828
01:15:45,300 --> 01:15:45,310

3829
01:15:45,310 --> 01:15:47,010
or multimedia data structures or

3830
01:15:47,010 --> 01:15:47,020
 

3831
01:15:47,020 --> 01:15:48,690
multi-dimensional data structures that

3832
01:15:48,690 --> 01:15:48,700
 

3833
01:15:48,700 --> 01:15:50,820
can handle these kind of things so I

3834
01:15:50,820 --> 01:15:50,830
 

3835
01:15:50,830 --> 01:15:52,230
just want you to be aware that they

3836
01:15:52,230 --> 01:15:52,240
 

3837
01:15:52,240 --> 01:15:55,380
exist are trees quadtrees KD trees if

3838
01:15:55,380 --> 01:15:55,390
 

3839
01:15:55,390 --> 01:15:56,220
you want to learn more about that

3840
01:15:56,220 --> 01:15:56,230
 

3841
01:15:56,230 --> 01:15:58,470
there's a class 15 826 taught by

3842
01:15:58,470 --> 01:15:58,480
 

3843
01:15:58,480 --> 01:16:00,060
christos flutist the guy go and tour

3844
01:16:00,060 --> 01:16:00,070
 

3845
01:16:00,070 --> 01:16:03,570
with his pop cover man I don't think

3846
01:16:03,570 --> 01:16:03,580
 

3847
01:16:03,580 --> 01:16:05,100
he's back in the spring so may not be

3848
01:16:05,100 --> 01:16:05,110
 

3849
01:16:05,110 --> 01:16:06,480
offered in the spring but it might be

3850
01:16:06,480 --> 01:16:06,490
 

3851
01:16:06,490 --> 01:16:12,360
offered the fall 2019 okay okay any

3852
01:16:12,360 --> 01:16:12,370
 

3853
01:16:12,370 --> 01:16:15,480
questions we're done all right next

3854
01:16:15,480 --> 01:16:15,490
 

3855
01:16:15,490 --> 01:16:16,530
class we'll talk about how to make all

3856
01:16:16,530 --> 01:16:16,540
 

3857
01:16:16,540 --> 01:16:18,180
these indexes thread-safe be focus on

3858
01:16:18,180 --> 01:16:18,190
 

3859
01:16:18,190 --> 01:16:19,740
crabbing because you need to know this

3860
01:16:19,740 --> 01:16:19,750
 

3861
01:16:19,750 --> 01:16:20,850
for a project to which I'll be

3862
01:16:20,850 --> 01:16:20,860
 

3863
01:16:20,860 --> 01:16:25,820
presenting as well on on Wednesday okay

3864
01:16:25,820 --> 01:16:25,830
 

3865
01:16:25,830 --> 01:16:34,720
all right guys have a good week

3866
01:16:34,720 --> 01:16:34,730


3867
01:16:34,730 --> 01:16:42,620
[Music]

3868
01:16:42,620 --> 01:16:42,630


3869
01:16:42,630 --> 01:17:05,610
to the party by the 12-pack case of a

3870
01:17:05,610 --> 01:17:05,620
 

3871
01:17:05,620 --> 01:17:08,210
boy six-pack for the egg gets the Real

3872
01:17:08,210 --> 01:17:08,220

3873
01:17:08,220 --> 01:17:11,370
ID replete with your drinking proper 12

3874
01:17:11,370 --> 01:17:11,380
 

3875
01:17:11,380 --> 01:17:11,970
ow

3876
01:17:11,970 --> 01:17:11,980

3877
01:17:11,980 --> 01:17:14,100
they say bill makes your breath but

3878
01:17:14,100 --> 01:17:14,110
 

3879
01:17:14,110 --> 01:17:16,080
saying eyes are straight so it really

3880
01:17:16,080 --> 01:17:16,090
 

3881
01:17:16,090 --> 01:17:18,450
don't matter

