1
00:00:00,730 --> 00:00:10,720
[Music]

2
00:00:10,720 --> 00:00:10,730


3
00:00:10,730 --> 00:00:17,890
maybe on the Jill's neck parallel so

4
00:00:17,890 --> 00:00:17,900
 

5
00:00:17,900 --> 00:00:21,410
missing here on the slides is that I'll

6
00:00:21,410 --> 00:00:21,420
 

7
00:00:21,420 --> 00:00:23,240
send an announcement on Piazza I've

8
00:00:23,240 --> 00:00:23,250
 

9
00:00:23,250 --> 00:00:25,610
given that we've sort of people are

10
00:00:25,610 --> 00:00:25,620
 

11
00:00:25,620 --> 00:00:27,440
struggling with this the second project

12
00:00:27,440 --> 00:00:27,450
 

13
00:00:27,450 --> 00:00:29,660
finishing that up I've bumped a bunch of

14
00:00:29,660 --> 00:00:29,670
 

15
00:00:29,670 --> 00:00:30,890
other deadlines to give you more time

16
00:00:30,890 --> 00:00:30,900
 

17
00:00:30,900 --> 00:00:34,550
for the later stuff so homework for we

18
00:00:34,550 --> 00:00:34,560
 

19
00:00:34,560 --> 00:00:37,370
do like a week or so after it's normally

20
00:00:37,370 --> 00:00:37,380
 

21
00:00:37,380 --> 00:00:38,960
do now and then same thing for project

22
00:00:38,960 --> 00:00:38,970
 

23
00:00:38,970 --> 00:00:40,880
three and four okay I'll post a some

24
00:00:40,880 --> 00:00:40,890
 

25
00:00:40,890 --> 00:00:47,090
Piazza for the for the the the the the

26
00:00:47,090 --> 00:00:47,100
 

27
00:00:47,100 --> 00:00:49,430
database updates or the Davis talks in

28
00:00:49,430 --> 00:00:49,440
 

29
00:00:49,440 --> 00:00:51,830
the next two weeks so next week or this

30
00:00:51,830 --> 00:00:51,840
 

31
00:00:51,840 --> 00:00:53,690
week we have on Thursday the guys from

32
00:00:53,690 --> 00:00:53,700

33
00:00:53,700 --> 00:00:55,490
blazing be be down texts are coming up

34
00:00:55,490 --> 00:00:55,500
 

35
00:00:55,500 --> 00:00:58,069
to give a Tech Talk and then bright

36
00:00:58,069 --> 00:00:58,079
 

37
00:00:58,079 --> 00:01:00,049
light is out of London or Norway I think

38
00:01:00,049 --> 00:01:00,059

39
00:01:00,059 --> 00:01:01,790
and they're coming on November first to

40
00:01:01,790 --> 00:01:01,800
 

41
00:01:01,800 --> 00:01:03,619
give a talk so again I'll I'll send an

42
00:01:03,619 --> 00:01:03,629

43
00:01:03,629 --> 00:01:07,520
announcement about that on on Piazza all

44
00:01:07,520 --> 00:01:07,530
 

45
00:01:07,530 --> 00:01:10,429
right so today we're talking securing so

46
00:01:10,429 --> 00:01:10,439
 

47
00:01:10,439 --> 00:01:11,929
everything we've talked about so far and

48
00:01:11,929 --> 00:01:11,939
 

49
00:01:11,939 --> 00:01:15,679
in the semester has has mostly focused

50
00:01:15,679 --> 00:01:15,689
 

51
00:01:15,689 --> 00:01:18,620
on single threaded operations right we

52
00:01:18,620 --> 00:01:18,630
 

53
00:01:18,630 --> 00:01:19,789
did talk about doing concurrent updates

54
00:01:19,789 --> 00:01:19,799
 

55
00:01:19,799 --> 00:01:22,449
or chrome core operations on the B+ tree

56
00:01:22,449 --> 00:01:22,459
 

57
00:01:22,459 --> 00:01:24,379
but now we want to talk about how we're

58
00:01:24,379 --> 00:01:24,389
 

59
00:01:24,389 --> 00:01:27,440
gonna actually queries in parallel what

60
00:01:27,440 --> 00:01:27,450
 

61
00:01:27,450 --> 00:01:28,999
the kind of optimizations we can give

62
00:01:28,999 --> 00:01:29,009
 

63
00:01:29,009 --> 00:01:31,609
with this so it sort of goes obvious and

64
00:01:31,609 --> 00:01:31,619
 

65
00:01:31,619 --> 00:01:32,899
goes without saying but why would you

66
00:01:32,899 --> 00:01:32,909
 

67
00:01:32,909 --> 00:01:34,239
want to actually run things in parallel

68
00:01:34,239 --> 00:01:34,249
 

69
00:01:34,249 --> 00:01:38,629
right sorry right because because we get

70
00:01:38,629 --> 00:01:38,639
 

71
00:01:38,639 --> 00:01:40,279
we get performance benefits there's the

72
00:01:40,279 --> 00:01:40,289
 

73
00:01:40,289 --> 00:01:43,999
key thing right well be able to run

74
00:01:43,999 --> 00:01:44,009
 

75
00:01:44,009 --> 00:01:45,649
queries more efficiently because we now

76
00:01:45,649 --> 00:01:45,659
 

77
00:01:45,659 --> 00:01:46,969
we can break it up across multiple cores

78
00:01:46,969 --> 00:01:46,979
 

79
00:01:46,979 --> 00:01:50,330
and multiple storage devices and what

80
00:01:50,330 --> 00:01:50,340
 

81
00:01:50,340 --> 00:01:52,219
you know get faster latency and better

82
00:01:52,219 --> 00:01:52,229

83
00:01:52,229 --> 00:01:53,749
response times the system would end up

84
00:01:53,749 --> 00:01:53,759
 

85
00:01:53,759 --> 00:01:55,639
being looking more responsive and we'll

86
00:01:55,639 --> 00:01:55,649
 

87
00:01:55,649 --> 00:01:57,109
see this when we talk about transactions

88
00:01:57,109 --> 00:01:57,119
 

89
00:01:57,119 --> 00:01:59,629
we have multiple threads updating the

90
00:01:59,629 --> 00:01:59,639
 

91
00:01:59,639 --> 00:02:01,550
database if you have to go get a page

92
00:02:01,550 --> 00:02:01,560
 

93
00:02:01,560 --> 00:02:02,839
from the buffer pool and the buffer pool

94
00:02:02,839 --> 00:02:02,849
 

95
00:02:02,849 --> 00:02:04,550
doesn't have it you have to stall and go

96
00:02:04,550 --> 00:02:04,560
 

97
00:02:04,560 --> 00:02:06,409
out the disk you want to let other

98
00:02:06,409 --> 00:02:06,419
 

99
00:02:06,419 --> 00:02:08,059
things keep running and and still make

100
00:02:08,059 --> 00:02:08,069
 

101
00:02:08,069 --> 00:02:10,910
forward progress all right so this is

102
00:02:10,910 --> 00:02:10,920
 

103
00:02:10,920 --> 00:02:12,320
sort of the state of the world that we

104
00:02:12,320 --> 00:02:12,330
 

105
00:02:12,330 --> 00:02:15,320
live in now Moore's Law is over our CPUs

106
00:02:15,320 --> 00:02:15,330
 

107
00:02:15,330 --> 00:02:16,160
getting more core

108
00:02:16,160 --> 00:02:16,170
 

109
00:02:16,170 --> 00:02:17,630
we're getting more storage devices like

110
00:02:17,630 --> 00:02:17,640
 

111
00:02:17,640 --> 00:02:19,850
cloud storage is cheap so think we want

112
00:02:19,850 --> 00:02:19,860
 

113
00:02:19,860 --> 00:02:21,350
to take all take advantage of all these

114
00:02:21,350 --> 00:02:21,360
 

115
00:02:21,360 --> 00:02:25,040
things inside of our database system so

116
00:02:25,040 --> 00:02:25,050
 

117
00:02:25,050 --> 00:02:28,370
the for this lecture we're going to

118
00:02:28,370 --> 00:02:28,380
 

119
00:02:28,380 --> 00:02:31,670
focus on parallel databases we'll have

120
00:02:31,670 --> 00:02:31,680
 

121
00:02:31,680 --> 00:02:33,020
two lectures at the end of semester talk

122
00:02:33,020 --> 00:02:33,030
 

123
00:02:33,030 --> 00:02:34,550
about distributed databases and I'll

124
00:02:34,550 --> 00:02:34,560
 

125
00:02:34,560 --> 00:02:35,540
cover what the difference is between

126
00:02:35,540 --> 00:02:35,550
 

127
00:02:35,550 --> 00:02:38,330
these two of them but the high level way

128
00:02:38,330 --> 00:02:38,340
 

129
00:02:38,340 --> 00:02:39,770
to think about parallel in tribute of

130
00:02:39,770 --> 00:02:39,780
 

131
00:02:39,780 --> 00:02:43,340
databases are that to the application

132
00:02:43,340 --> 00:02:43,350
 

133
00:02:43,350 --> 00:02:44,990
programmer the person writing sequel and

134
00:02:44,990 --> 00:02:45,000

135
00:02:45,000 --> 00:02:47,839
submitting them to the system a parallel

136
00:02:47,839 --> 00:02:47,849
 

137
00:02:47,849 --> 00:02:49,160
database or tribute database it's gonna

138
00:02:49,160 --> 00:02:49,170

139
00:02:49,170 --> 00:02:51,470
look like a single database instance

140
00:02:51,470 --> 00:02:51,480
 

141
00:02:51,480 --> 00:02:54,050
right like you open up the terminal and

142
00:02:54,050 --> 00:02:54,060
 

143
00:02:54,060 --> 00:02:55,039
you start writing queries to it you

144
00:02:55,039 --> 00:02:55,049
 

145
00:02:55,049 --> 00:02:57,620
don't know that the database is split up

146
00:02:57,620 --> 00:02:57,630
 

147
00:02:57,630 --> 00:03:00,020
across you know multiple cores or

148
00:03:00,020 --> 00:03:00,030
 

149
00:03:00,030 --> 00:03:03,380
multiple multiple machines right it all

150
00:03:03,380 --> 00:03:03,390
 

151
00:03:03,390 --> 00:03:04,850
looks the same to you and this is the

152
00:03:04,850 --> 00:03:04,860
 

153
00:03:04,860 --> 00:03:06,140
beauty of sequel and a declarative

154
00:03:06,140 --> 00:03:06,150
 

155
00:03:06,150 --> 00:03:08,300
language but you just say hey run this

156
00:03:08,300 --> 00:03:08,310
 

157
00:03:08,310 --> 00:03:11,449
query and it doesn't matter whether it's

158
00:03:11,449 --> 00:03:11,459
 

159
00:03:11,459 --> 00:03:13,940
on a single node or a thousand nodes the

160
00:03:13,940 --> 00:03:13,950
 

161
00:03:13,950 --> 00:03:15,259
database system could take that single

162
00:03:15,259 --> 00:03:15,269
 

163
00:03:15,269 --> 00:03:16,190
query and figure out what the best way

164
00:03:16,190 --> 00:03:16,200
 

165
00:03:16,200 --> 00:03:19,309
to execute it is for you so that's the

166
00:03:19,309 --> 00:03:19,319
 

167
00:03:19,319 --> 00:03:22,430
beauty of what we're gonna take on we

168
00:03:22,430 --> 00:03:22,440
 

169
00:03:22,440 --> 00:03:23,990
need to take advantage this now inside

170
00:03:23,990 --> 00:03:24,000
 

171
00:03:24,000 --> 00:03:27,740
of our system so the the distinction or

172
00:03:27,740 --> 00:03:27,750
 

173
00:03:27,750 --> 00:03:29,000
the difference between parallel

174
00:03:29,000 --> 00:03:29,010

175
00:03:29,010 --> 00:03:30,470
databases and tributed races that I like

176
00:03:30,470 --> 00:03:30,480

177
00:03:30,480 --> 00:03:32,210
to make is the way to think about this

178
00:03:32,210 --> 00:03:32,220
 

179
00:03:32,220 --> 00:03:35,900
is a parallel database is one where the

180
00:03:35,900 --> 00:03:35,910
 

181
00:03:35,910 --> 00:03:38,720
the nodes and I'll use the term note

182
00:03:38,720 --> 00:03:38,730
 

183
00:03:38,730 --> 00:03:40,910
loosely the nodes are physically close

184
00:03:40,910 --> 00:03:40,920
 

185
00:03:40,920 --> 00:03:41,630
to each other

186
00:03:41,630 --> 00:03:41,640
 

187
00:03:41,640 --> 00:03:44,960
write a note could be a CPU socket a

188
00:03:44,960 --> 00:03:44,970
 

189
00:03:44,970 --> 00:03:46,280
node could be a whole another machine

190
00:03:46,280 --> 00:03:46,290
 

191
00:03:46,290 --> 00:03:48,830
but the idea is that these machines are

192
00:03:48,830 --> 00:03:48,840
 

193
00:03:48,840 --> 00:03:50,960
close to each other and communicate very

194
00:03:50,960 --> 00:03:50,970
 

195
00:03:50,970 --> 00:03:53,150
efficiently and so because we're

196
00:03:53,150 --> 00:03:53,160
 

197
00:03:53,160 --> 00:03:54,380
assuming that they're close to each

198
00:03:54,380 --> 00:03:54,390
 

199
00:03:54,390 --> 00:03:56,390
other then we don't have to worry about

200
00:03:56,390 --> 00:03:56,400
 

201
00:03:56,400 --> 00:03:59,840
unreliable communication I said think of

202
00:03:59,840 --> 00:03:59,850
 

203
00:03:59,850 --> 00:04:01,580
like the most simplest parallel machine

204
00:04:01,580 --> 00:04:01,590
 

205
00:04:01,590 --> 00:04:03,860
could be a single socket CPU that has

206
00:04:03,860 --> 00:04:03,870
 

207
00:04:03,870 --> 00:04:06,590
four cores or two cores right that's a

208
00:04:06,590 --> 00:04:06,600
 

209
00:04:06,600 --> 00:04:09,680
parallel database system distributed

210
00:04:09,680 --> 00:04:09,690

211
00:04:09,690 --> 00:04:11,509
database typically are ones where the

212
00:04:11,509 --> 00:04:11,519
 

213
00:04:11,519 --> 00:04:13,370
nodes can be are far away from each

214
00:04:13,370 --> 00:04:13,380
 

215
00:04:13,380 --> 00:04:15,770
other so far away could be you know in

216
00:04:15,770 --> 00:04:15,780
 

217
00:04:15,780 --> 00:04:17,529
the same you know the same data center

218
00:04:17,529 --> 00:04:17,539
 

219
00:04:17,539 --> 00:04:19,879
across town or different geographical

220
00:04:19,879 --> 00:04:19,889
 

221
00:04:19,889 --> 00:04:22,550
region right and in these environments

222
00:04:22,550 --> 00:04:22,560
 

223
00:04:22,560 --> 00:04:25,279
the typically you're gonna be connecting

224
00:04:25,279 --> 00:04:25,289
 

225
00:04:25,289 --> 00:04:27,710
to them over a public network if you're

226
00:04:27,710 --> 00:04:27,720
 

227
00:04:27,720 --> 00:04:29,870
inside of Amazon's data center then it's

228
00:04:29,870 --> 00:04:29,880
 

229
00:04:29,880 --> 00:04:32,330
but but it's still not the same as like

230
00:04:32,330 --> 00:04:32,340
 

231
00:04:32,340 --> 00:04:35,360
two sockets in the same box together so

232
00:04:35,360 --> 00:04:35,370
 

233
00:04:35,370 --> 00:04:38,180
in a distributed database we're not

234
00:04:38,180 --> 00:04:38,190
 

235
00:04:38,190 --> 00:04:39,470
going to be able to ignore the

236
00:04:39,470 --> 00:04:39,480
 

237
00:04:39,480 --> 00:04:42,050
communication costs right of you know

238
00:04:42,050 --> 00:04:42,060
 

239
00:04:42,060 --> 00:04:43,580
sending data from one node to the next

240
00:04:43,580 --> 00:04:43,590
 

241
00:04:43,590 --> 00:04:46,160
and it also means that we can't assume

242
00:04:46,160 --> 00:04:46,170
 

243
00:04:46,170 --> 00:04:48,950
that the communication is reliable we'll

244
00:04:48,950 --> 00:04:48,960
 

245
00:04:48,960 --> 00:04:50,540
see this later on in the semester when

246
00:04:50,540 --> 00:04:50,550
 

247
00:04:50,550 --> 00:04:52,040
we talk about doing transactions over

248
00:04:52,040 --> 00:04:52,050
 

249
00:04:52,050 --> 00:04:53,900
over a distributed database

250
00:04:53,900 --> 00:04:53,910
 

251
00:04:53,910 --> 00:04:56,060
you know this changes how you actually

252
00:04:56,060 --> 00:04:56,070
 

253
00:04:56,070 --> 00:04:57,320
set up some of your algorithms because

254
00:04:57,320 --> 00:04:57,330
 

255
00:04:57,330 --> 00:04:58,670
you can't assume that I send a message

256
00:04:58,670 --> 00:04:58,680
 

257
00:04:58,680 --> 00:05:00,260
to somebody they're gonna get it in the

258
00:05:00,260 --> 00:05:00,270
 

259
00:05:00,270 --> 00:05:01,910
right order that I expect them to get it

260
00:05:01,910 --> 00:05:01,920
 

261
00:05:01,920 --> 00:05:04,730
and so in for today's class we're

262
00:05:04,730 --> 00:05:04,740
 

263
00:05:04,740 --> 00:05:06,050
focused on payload data is we're not

264
00:05:06,050 --> 00:05:06,060
 

265
00:05:06,060 --> 00:05:06,800
gonna we don't the word with that

266
00:05:06,800 --> 00:05:06,810
 

267
00:05:06,810 --> 00:05:08,480
problem at all the question is really

268
00:05:08,480 --> 00:05:08,490
 

269
00:05:08,490 --> 00:05:11,300
how can we take advantage of additional

270
00:05:11,300 --> 00:05:11,310
 

271
00:05:11,310 --> 00:05:13,070
resources to actuate our queries more

272
00:05:13,070 --> 00:05:13,080
 

273
00:05:13,080 --> 00:05:17,390
efficiently so the two per type of two

274
00:05:17,390 --> 00:05:17,400
 

275
00:05:17,400 --> 00:05:18,620
types of parallelism we're gonna talk

276
00:05:18,620 --> 00:05:18,630
 

277
00:05:18,630 --> 00:05:20,750
about our inner query parallelism and

278
00:05:20,750 --> 00:05:20,760
 

279
00:05:20,760 --> 00:05:23,900
intra query parallelism so inner query

280
00:05:23,900 --> 00:05:23,910
 

281
00:05:23,910 --> 00:05:26,030
inter query parallelism is essential

282
00:05:26,030 --> 00:05:26,040
 

283
00:05:26,040 --> 00:05:28,610
what most people think about in it

284
00:05:28,610 --> 00:05:28,620
 

285
00:05:28,620 --> 00:05:31,370
payload database is I can run multiple

286
00:05:31,370 --> 00:05:31,380
 

287
00:05:31,380 --> 00:05:33,290
queries at the same time and they're

288
00:05:33,290 --> 00:05:33,300

289
00:05:33,300 --> 00:05:35,690
gonna run on different threads or

290
00:05:35,690 --> 00:05:35,700
 

291
00:05:35,700 --> 00:05:39,170
different cords right and we do this

292
00:05:39,170 --> 00:05:39,180
 

293
00:05:39,180 --> 00:05:41,480
because we want to improve our

294
00:05:41,480 --> 00:05:41,490
 

295
00:05:41,490 --> 00:05:42,800
throughput latency we don't want to have

296
00:05:42,800 --> 00:05:42,810
 

297
00:05:42,810 --> 00:05:45,230
everyone stymied or blocked on this one

298
00:05:45,230 --> 00:05:45,240
 

299
00:05:45,240 --> 00:05:46,520
thread that's executing queries one

300
00:05:46,520 --> 00:05:46,530

301
00:05:46,530 --> 00:05:50,150
after another and Joker intro query

302
00:05:50,150 --> 00:05:50,160
 

303
00:05:50,160 --> 00:05:51,830
parallelism is where we're gonna take

304
00:05:51,830 --> 00:05:51,840
 

305
00:05:51,840 --> 00:05:53,960
the operations of a single query I think

306
00:05:53,960 --> 00:05:53,970
 

307
00:05:53,970 --> 00:05:56,000
of a single query plan and we're gonna

308
00:05:56,000 --> 00:05:56,010
 

309
00:05:56,010 --> 00:05:58,790
execute those operations in in parallel

310
00:05:58,790 --> 00:05:58,800
 

311
00:05:58,800 --> 00:06:01,220
this either could be and we'll see this

312
00:06:01,220 --> 00:06:01,230

313
00:06:01,230 --> 00:06:02,900
in a second we go closer to horizontal

314
00:06:02,900 --> 00:06:02,910
 

315
00:06:02,910 --> 00:06:04,580
parallelism where we're taking the same

316
00:06:04,580 --> 00:06:04,590
 

317
00:06:04,590 --> 00:06:06,440
operator for executing in parallel

318
00:06:06,440 --> 00:06:06,450
 

319
00:06:06,450 --> 00:06:08,360
multiple threads or vertical parallelism

320
00:06:08,360 --> 00:06:08,370
 

321
00:06:08,370 --> 00:06:10,070
where we can actually to different

322
00:06:10,070 --> 00:06:10,080
 

323
00:06:10,080 --> 00:06:11,600
operators onto different threads at the

324
00:06:11,600 --> 00:06:11,610
 

325
00:06:11,610 --> 00:06:14,210
same time and so this is be more useful

326
00:06:14,210 --> 00:06:14,220
 

327
00:06:14,220 --> 00:06:17,180
in analytical queries or long-running

328
00:06:17,180 --> 00:06:17,190

329
00:06:17,190 --> 00:06:18,770
queries we have to scan a lot of data

330
00:06:18,770 --> 00:06:18,780
 

331
00:06:18,780 --> 00:06:20,540
and crunch it over a lot a lot of tuples

332
00:06:20,540 --> 00:06:20,550
 

333
00:06:20,550 --> 00:06:22,520
right because because you're usually

334
00:06:22,520 --> 00:06:22,530
 

335
00:06:22,530 --> 00:06:24,530
gonna be i/o bound or CPU bound in these

336
00:06:24,530 --> 00:06:24,540
 

337
00:06:24,540 --> 00:06:27,260
in these environments so by having

338
00:06:27,260 --> 00:06:27,270
 

339
00:06:27,270 --> 00:06:29,060
additional parallelism you you get

340
00:06:29,060 --> 00:06:29,070
 

341
00:06:29,070 --> 00:06:32,600
better performance all right so to begin

342
00:06:32,600 --> 00:06:32,610
 

343
00:06:32,610 --> 00:06:33,650
we're talk about different process

344
00:06:33,650 --> 00:06:33,660

345
00:06:33,660 --> 00:06:36,110
models a way to design a parallel

346
00:06:36,110 --> 00:06:36,120
 

347
00:06:36,120 --> 00:06:38,690
database system then we'll actually talk

348
00:06:38,690 --> 00:06:38,700
 

349
00:06:38,700 --> 00:06:40,190
about how you execute operators in

350
00:06:40,190 --> 00:06:40,200
 

351
00:06:40,200 --> 00:06:41,960
parallel and then we'll finish off

352
00:06:41,960 --> 00:06:41,970
 

353
00:06:41,970 --> 00:06:43,580
talking about how we can

354
00:06:43,580 --> 00:06:43,590
 

355
00:06:43,590 --> 00:06:44,900
build our system ala to get Iowa

356
00:06:44,900 --> 00:06:44,910
 

357
00:06:44,910 --> 00:06:49,790
parallelism okay alright so the data

358
00:06:49,790 --> 00:06:49,800
 

359
00:06:49,800 --> 00:06:52,700
assistance process model defines how the

360
00:06:52,700 --> 00:06:52,710
 

361
00:06:52,710 --> 00:06:55,460
system is going to be designed to take

362
00:06:55,460 --> 00:06:55,470
 

363
00:06:55,470 --> 00:06:57,680
advantage of additional resources and

364
00:06:57,680 --> 00:06:57,690
 

365
00:06:57,690 --> 00:06:59,270
execute multiple requests from the

366
00:06:59,270 --> 00:06:59,280
 

367
00:06:59,280 --> 00:07:02,360
applications in parallel right and so

368
00:07:02,360 --> 00:07:02,370
 

369
00:07:02,370 --> 00:07:03,860
instead of using the term thread or

370
00:07:03,860 --> 00:07:03,870

371
00:07:03,870 --> 00:07:06,920
process or you know core I'm gonna try

372
00:07:06,920 --> 00:07:06,930
 

373
00:07:06,930 --> 00:07:09,650
to use the word worker right because

374
00:07:09,650 --> 00:07:09,660
 

375
00:07:09,660 --> 00:07:11,360
that can really mean either you know a

376
00:07:11,360 --> 00:07:11,370
 

377
00:07:11,370 --> 00:07:13,790
bunch of different entities executing

378
00:07:13,790 --> 00:07:13,800
 

379
00:07:13,800 --> 00:07:16,430
something in our system so the idea is

380
00:07:16,430 --> 00:07:16,440
 

381
00:07:16,440 --> 00:07:18,530
that we're gonna have some worker in our

382
00:07:18,530 --> 00:07:18,540
 

383
00:07:18,540 --> 00:07:20,270
database system that's gonna be

384
00:07:20,270 --> 00:07:20,280
 

385
00:07:20,280 --> 00:07:22,400
responsible for executing tasks and I'll

386
00:07:22,400 --> 00:07:22,410
 

387
00:07:22,410 --> 00:07:24,830
define what tasks are in a second for

388
00:07:24,830 --> 00:07:24,840

389
00:07:24,840 --> 00:07:27,110
our queries and we want our workers be

390
00:07:27,110 --> 00:07:27,120
 

391
00:07:27,120 --> 00:07:30,770
able to run in parallel all right so the

392
00:07:30,770 --> 00:07:30,780
 

393
00:07:30,780 --> 00:07:31,850
three ways you can architect a data

394
00:07:31,850 --> 00:07:31,860

395
00:07:31,860 --> 00:07:33,890
system is that you can have a single

396
00:07:33,890 --> 00:07:33,900
 

397
00:07:33,900 --> 00:07:36,260
process like an OS process per database

398
00:07:36,260 --> 00:07:36,270

399
00:07:36,270 --> 00:07:39,050
worker you can have a process pool where

400
00:07:39,050 --> 00:07:39,060
 

401
00:07:39,060 --> 00:07:41,240
you can dispatch work to those there's

402
00:07:41,240 --> 00:07:41,250
 

403
00:07:41,250 --> 00:07:44,450
workers and then you can have a single

404
00:07:44,450 --> 00:07:44,460

405
00:07:44,460 --> 00:07:47,690
thread per core database worker and

406
00:07:47,690 --> 00:07:47,700

407
00:07:47,700 --> 00:07:49,550
there's trade-offs for all of these so

408
00:07:49,550 --> 00:07:49,560
 

409
00:07:49,560 --> 00:07:51,590
the first one is process per worker and

410
00:07:51,590 --> 00:07:51,600

411
00:07:51,600 --> 00:07:53,750
again the idea is that a single OS

412
00:07:53,750 --> 00:07:53,760
 

413
00:07:53,760 --> 00:07:56,710
process corresponds to one worker

414
00:07:56,710 --> 00:07:56,720
 

415
00:07:56,720 --> 00:07:59,120
typically and it can can be a single

416
00:07:59,120 --> 00:07:59,130
 

417
00:07:59,130 --> 00:08:02,810
thread for that process and we rely on

418
00:08:02,810 --> 00:08:02,820
 

419
00:08:02,820 --> 00:08:04,970
the operating system scheduler to decide

420
00:08:04,970 --> 00:08:04,980
 

421
00:08:04,980 --> 00:08:07,190
what you know what process runs next

422
00:08:07,190 --> 00:08:07,200

423
00:08:07,200 --> 00:08:08,840
which one has higher priority over

424
00:08:08,840 --> 00:08:08,850
 

425
00:08:08,850 --> 00:08:11,540
another so the idea is that say this

426
00:08:11,540 --> 00:08:11,550
 

427
00:08:11,550 --> 00:08:13,610
your application you had something in

428
00:08:13,610 --> 00:08:13,620
 

429
00:08:13,620 --> 00:08:16,070
the front caught it like a dispatcher or

430
00:08:16,070 --> 00:08:16,080
 

431
00:08:16,080 --> 00:08:18,050
a coordinator or Postgres calls this the

432
00:08:18,050 --> 00:08:18,060
 

433
00:08:18,060 --> 00:08:21,380
postmaster and the application sends a

434
00:08:21,380 --> 00:08:21,390
 

435
00:08:21,390 --> 00:08:23,480
request to the dispatcher says hey I

436
00:08:23,480 --> 00:08:23,490
 

437
00:08:23,490 --> 00:08:26,480
want to execute this query tell me who's

438
00:08:26,480 --> 00:08:26,490
 

439
00:08:26,490 --> 00:08:28,520
gonna do it for me and the dispatcher

440
00:08:28,520 --> 00:08:28,530
 

441
00:08:28,530 --> 00:08:30,380
will will hand this request off to a

442
00:08:30,380 --> 00:08:30,390
 

443
00:08:30,390 --> 00:08:32,630
free worker and then the worker comes

444
00:08:32,630 --> 00:08:32,640

445
00:08:32,640 --> 00:08:34,910
back and tells the application hey I got

446
00:08:34,910 --> 00:08:34,920
 

447
00:08:34,920 --> 00:08:37,130
your request here's my socket if you

448
00:08:37,130 --> 00:08:37,140
 

449
00:08:37,140 --> 00:08:38,870
want to talk to me here's where you can

450
00:08:38,870 --> 00:08:38,880

451
00:08:38,880 --> 00:08:40,760
send me all all the requests that you

452
00:08:40,760 --> 00:08:40,770
 

453
00:08:40,770 --> 00:08:42,290
know that you want me to execute and

454
00:08:42,290 --> 00:08:42,300
 

455
00:08:42,300 --> 00:08:44,090
then now it's responsible for the worker

456
00:08:44,090 --> 00:08:44,100
 

457
00:08:44,100 --> 00:08:46,640
to interact with the database to exit

458
00:08:46,640 --> 00:08:46,650
 

459
00:08:46,650 --> 00:08:47,750
your query and then send you back

460
00:08:47,750 --> 00:08:47,760
 

461
00:08:47,760 --> 00:08:51,170
results so this was the approach that

462
00:08:51,170 --> 00:08:51,180
 

463
00:08:51,180 --> 00:08:54,590
most systems were using back in the old

464
00:08:54,590 --> 00:08:54,600
 

465
00:08:54,600 --> 00:08:57,530
days the 70s and 80s this

466
00:08:57,530 --> 00:08:57,540
 

467
00:08:57,540 --> 00:08:59,840
what IVM db2 does this Oracle does is

468
00:08:59,840 --> 00:08:59,850
 

469
00:08:59,850 --> 00:09:01,699
what ingress does this is what Postgres

470
00:09:01,699 --> 00:09:01,709
 

471
00:09:01,709 --> 00:09:04,759
does right everything I guess why this

472
00:09:04,759 --> 00:09:04,769

473
00:09:04,769 --> 00:09:06,740
is the most common approach in the old

474
00:09:06,740 --> 00:09:06,750
 

475
00:09:06,750 --> 00:09:12,370
days yes

476
00:09:12,370 --> 00:09:12,380

477
00:09:12,380 --> 00:09:19,519
he says the CPU is only one core I think

478
00:09:19,519 --> 00:09:19,529
 

479
00:09:19,529 --> 00:09:20,660
of what why would you want to do this

480
00:09:20,660 --> 00:09:20,670
 

481
00:09:20,670 --> 00:09:22,129
instead of threads let me put it that

482
00:09:22,129 --> 00:09:22,139
 

483
00:09:22,139 --> 00:09:26,829
way

484
00:09:26,829 --> 00:09:26,839


485
00:09:26,839 --> 00:09:29,389
think of the 1980s right was Linux

486
00:09:29,389 --> 00:09:29,399
 

487
00:09:29,399 --> 00:09:31,309
around No

488
00:09:31,309 --> 00:09:31,319
 

489
00:09:31,319 --> 00:09:34,490
did was POSIX and as prevalent as it is

490
00:09:34,490 --> 00:09:34,500
 

491
00:09:34,500 --> 00:09:37,129
now no all right so there's no you know

492
00:09:37,129 --> 00:09:37,139
 

493
00:09:37,139 --> 00:09:39,379
P threads right there wasn't a standard

494
00:09:39,379 --> 00:09:39,389
 

495
00:09:39,389 --> 00:09:40,790
threading library all these different

496
00:09:40,790 --> 00:09:40,800

497
00:09:40,800 --> 00:09:41,749
versions of Unix

498
00:09:41,749 --> 00:09:41,759
 

499
00:09:41,759 --> 00:09:44,180
had their own threading packages so if

500
00:09:44,180 --> 00:09:44,190
 

501
00:09:44,190 --> 00:09:46,579
you wrote a multi-threaded application

502
00:09:46,579 --> 00:09:46,589

503
00:09:46,589 --> 00:09:49,910
for one operating system like BSD and

504
00:09:49,910 --> 00:09:49,920
 

505
00:09:49,920 --> 00:09:51,970
then you want to run on VAX

506
00:09:51,970 --> 00:09:51,980
 

507
00:09:51,980 --> 00:09:54,110
you probably can't use the same

508
00:09:54,110 --> 00:09:54,120
 

509
00:09:54,120 --> 00:09:56,780
threading package right but the basic

510
00:09:56,780 --> 00:09:56,790
 

511
00:09:56,790 --> 00:09:58,430
concept of our process it would exist in

512
00:09:58,430 --> 00:09:58,440
 

513
00:09:58,440 --> 00:10:00,110
all these different operating systems so

514
00:10:00,110 --> 00:10:00,120
 

515
00:10:00,120 --> 00:10:02,300
this is why most of these systems in the

516
00:10:02,300 --> 00:10:02,310
 

517
00:10:02,310 --> 00:10:03,920
old the old days we're implementing this

518
00:10:03,920 --> 00:10:03,930
 

519
00:10:03,930 --> 00:10:07,519
way so an extension of this is use a

520
00:10:07,519 --> 00:10:07,529
 

521
00:10:07,529 --> 00:10:10,460
process pool and the idea is that you

522
00:10:10,460 --> 00:10:10,470
 

523
00:10:10,470 --> 00:10:11,660
still have the dispatcher you still have

524
00:10:11,660 --> 00:10:11,670
 

525
00:10:11,670 --> 00:10:14,629
something in the front but it's

526
00:10:14,629 --> 00:10:14,639
 

527
00:10:14,639 --> 00:10:16,490
responsible just handing things off to

528
00:10:16,490 --> 00:10:16,500
 

529
00:10:16,500 --> 00:10:19,309
whatever worker is free and then you can

530
00:10:19,309 --> 00:10:19,319
 

531
00:10:19,319 --> 00:10:21,889
go ahead and execute it right there's

532
00:10:21,889 --> 00:10:21,899
 

533
00:10:21,899 --> 00:10:24,319
sort of a better implementation of the

534
00:10:24,319 --> 00:10:24,329
 

535
00:10:24,329 --> 00:10:26,600
the single process a single worker per

536
00:10:26,600 --> 00:10:26,610
 

537
00:10:26,610 --> 00:10:30,439
process and this is used by IBM db2 and

538
00:10:30,439 --> 00:10:30,449
 

539
00:10:30,449 --> 00:10:33,650
it's also used as of 2015 the latest

540
00:10:33,650 --> 00:10:33,660
 

541
00:10:33,660 --> 00:10:35,870
versions of Postgres now you sort of use

542
00:10:35,870 --> 00:10:35,880
 

543
00:10:35,880 --> 00:10:37,340
this sort of model if they could have

544
00:10:37,340 --> 00:10:37,350
 

545
00:10:37,350 --> 00:10:38,509
one worker communicate with another

546
00:10:38,509 --> 00:10:38,519

547
00:10:38,519 --> 00:10:40,900
worker to handle handed off work

548
00:10:40,900 --> 00:10:40,910

549
00:10:40,910 --> 00:10:45,290
the most common approach that that is

550
00:10:45,290 --> 00:10:45,300
 

551
00:10:45,300 --> 00:10:47,240
used today and you know if you're

552
00:10:47,240 --> 00:10:47,250
 

553
00:10:47,250 --> 00:10:48,410
building a new device is from scratch

554
00:10:48,410 --> 00:10:48,420
 

555
00:10:48,420 --> 00:10:50,030
this is probably what you would use is

556
00:10:50,030 --> 00:10:50,040
 

557
00:10:50,040 --> 00:10:52,699
you just have a single process for your

558
00:10:52,699 --> 00:10:52,709
 

559
00:10:52,709 --> 00:10:54,439
database system and you'd have multiple

560
00:10:54,439 --> 00:10:54,449
 

561
00:10:54,449 --> 00:10:56,990
threads and internally you're you know

562
00:10:56,990 --> 00:10:57,000
 

563
00:10:57,000 --> 00:10:58,429
how to dispatch work to those threads

564
00:10:58,429 --> 00:10:58,439

565
00:10:58,439 --> 00:10:59,809
and you're scheduling and other things

566
00:10:59,809 --> 00:10:59,819
 

567
00:10:59,819 --> 00:11:02,300
that the other approaches with processes

568
00:11:02,300 --> 00:11:02,310
 

569
00:11:02,310 --> 00:11:03,590
would have to rely on the operating

570
00:11:03,590 --> 00:11:03,600
 

571
00:11:03,600 --> 00:11:05,480
system to use and everything's in the

572
00:11:05,480 --> 00:11:05,490
 

573
00:11:05,490 --> 00:11:07,040
same address space so you don't have to

574
00:11:07,040 --> 00:11:07,050
 

575
00:11:07,050 --> 00:11:08,269
worry about using shared memory to

576
00:11:08,269 --> 00:11:08,279
 

577
00:11:08,279 --> 00:11:09,600
communicate or

578
00:11:09,600 --> 00:11:09,610

579
00:11:09,610 --> 00:11:10,740
inter-process communication

580
00:11:10,740 --> 00:11:10,750
 

581
00:11:10,750 --> 00:11:13,440
communicating for processes you can just

582
00:11:13,440 --> 00:11:13,450
 

583
00:11:13,450 --> 00:11:14,970
write in a memory and any other thread

584
00:11:14,970 --> 00:11:14,980
 

585
00:11:14,980 --> 00:11:18,660
can can read it so as I said this is the

586
00:11:18,660 --> 00:11:18,670
 

587
00:11:18,670 --> 00:11:20,250
most common approach every single new

588
00:11:20,250 --> 00:11:20,260
 

589
00:11:20,260 --> 00:11:21,509
data system written in the last ten

590
00:11:21,509 --> 00:11:21,519
 

591
00:11:21,519 --> 00:11:24,660
years is gonna using this with the

592
00:11:24,660 --> 00:11:24,670
 

593
00:11:24,670 --> 00:11:26,280
exception of any system that's based on

594
00:11:26,280 --> 00:11:26,290
 

595
00:11:26,290 --> 00:11:28,019
Postgres because Postgres is based on

596
00:11:28,019 --> 00:11:28,029
 

597
00:11:28,029 --> 00:11:30,449
the process model so there's a lot of

598
00:11:30,449 --> 00:11:30,459
 

599
00:11:30,459 --> 00:11:31,920
systems that took Postgres hacked it up

600
00:11:31,920 --> 00:11:31,930
 

601
00:11:31,930 --> 00:11:34,139
and and put out you know you know

602
00:11:34,139 --> 00:11:34,149
 

603
00:11:34,149 --> 00:11:36,750
optimized version of it and they're

604
00:11:36,750 --> 00:11:36,760
 

605
00:11:36,760 --> 00:11:39,000
gonna inherit the the process model

606
00:11:39,000 --> 00:11:39,010

607
00:11:39,010 --> 00:11:41,610
from-from Postgres so we actually still

608
00:11:41,610 --> 00:11:41,620
 

609
00:11:41,620 --> 00:11:42,780
first started building our own system

610
00:11:42,780 --> 00:11:42,790
 

611
00:11:42,790 --> 00:11:45,509
here at CMU we did what everyone else

612
00:11:45,509 --> 00:11:45,519
 

613
00:11:45,519 --> 00:11:47,370
does we start with Postgres rip up the

614
00:11:47,370 --> 00:11:47,380
 

615
00:11:47,380 --> 00:11:49,410
bottom half and use the top half but we

616
00:11:49,410 --> 00:11:49,420
 

617
00:11:49,420 --> 00:11:51,960
decided that to get away from all the

618
00:11:51,960 --> 00:11:51,970
 

619
00:11:51,970 --> 00:11:53,280
the process model we actually end up

620
00:11:53,280 --> 00:11:53,290
 

621
00:11:53,290 --> 00:11:58,560
rewriting Postgres to use multi you use

622
00:11:58,560 --> 00:11:58,570
 

623
00:11:58,570 --> 00:12:01,019
multiple threads use threading model and

624
00:12:01,019 --> 00:12:01,029
 

625
00:12:01,029 --> 00:12:03,500
I have seen some posts on the Postgres

626
00:12:03,500 --> 00:12:03,510
 

627
00:12:03,510 --> 00:12:05,639
like message board people talking about

628
00:12:05,639 --> 00:12:05,649
 

629
00:12:05,649 --> 00:12:08,040
a what you know is it worth time for us

630
00:12:08,040 --> 00:12:08,050
 

631
00:12:08,050 --> 00:12:09,240
looking at switch to a multi-threaded

632
00:12:09,240 --> 00:12:09,250
 

633
00:12:09,250 --> 00:12:11,970
model because he manages the context

634
00:12:11,970 --> 00:12:11,980
 

635
00:12:11,980 --> 00:12:13,440
switch inside of our multi-threaded

636
00:12:13,440 --> 00:12:13,450
 

637
00:12:13,450 --> 00:12:15,210
application is much cheaper than going

638
00:12:15,210 --> 00:12:15,220
 

639
00:12:15,220 --> 00:12:19,560
across different processes so again the

640
00:12:19,560 --> 00:12:19,570

641
00:12:19,570 --> 00:12:21,240
in my opinion the multi thread approach

642
00:12:21,240 --> 00:12:21,250
 

643
00:12:21,250 --> 00:12:23,610
is the better way to do this again you

644
00:12:23,610 --> 00:12:23,620
 

645
00:12:23,620 --> 00:12:26,130
have less let's ever head from a context

646
00:12:26,130 --> 00:12:26,140
 

647
00:12:26,140 --> 00:12:27,509
which you don't have to worry about

648
00:12:27,509 --> 00:12:27,519
 

649
00:12:27,519 --> 00:12:29,850
using shared memory the obviously

650
00:12:29,850 --> 00:12:29,860
 

651
00:12:29,860 --> 00:12:31,319
downside is if you have a rogue thread

652
00:12:31,319 --> 00:12:31,329

653
00:12:31,329 --> 00:12:33,870
that things up and you crash that

654
00:12:33,870 --> 00:12:33,880
 

655
00:12:33,880 --> 00:12:35,160
thread crashes you take down the whole

656
00:12:35,160 --> 00:12:35,170

657
00:12:35,170 --> 00:12:37,829
thing whereas in a process model

658
00:12:37,829 --> 00:12:37,839
 

659
00:12:37,839 --> 00:12:40,380
approach the process per worker approach

660
00:12:40,380 --> 00:12:40,390
 

661
00:12:40,390 --> 00:12:42,389
if one worker crashes then only that

662
00:12:42,389 --> 00:12:42,399
 

663
00:12:42,399 --> 00:12:43,860
process is killed the whole thing can

664
00:12:43,860 --> 00:12:43,870
 

665
00:12:43,870 --> 00:12:48,120
still stay up so the other thing I'll

666
00:12:48,120 --> 00:12:48,130

667
00:12:48,130 --> 00:12:51,110
point out too is just because you have a

668
00:12:51,110 --> 00:12:51,120
 

669
00:12:51,120 --> 00:12:53,910
you know a single you use the thread

670
00:12:53,910 --> 00:12:53,920
 

671
00:12:53,920 --> 00:12:57,000
pool worker model doesn't mean that you

672
00:12:57,000 --> 00:12:57,010
 

673
00:12:57,010 --> 00:12:59,069
automatically get in truck where

674
00:12:59,069 --> 00:12:59,079
 

675
00:12:59,079 --> 00:13:01,800
parallelism all right so my sequel uses

676
00:13:01,800 --> 00:13:01,810
 

677
00:13:01,810 --> 00:13:04,259
multiple threads but they can still only

678
00:13:04,259 --> 00:13:04,269
 

679
00:13:04,269 --> 00:13:07,350
execute at least as of 5,7 still can

680
00:13:07,350 --> 00:13:07,360
 

681
00:13:07,360 --> 00:13:10,740
only execute a one query with one thread

682
00:13:10,740 --> 00:13:10,750
 

683
00:13:10,750 --> 00:13:11,880
they can't take a query and break it up

684
00:13:11,880 --> 00:13:11,890
 

685
00:13:11,890 --> 00:13:14,340
across multiple threads right and

686
00:13:14,340 --> 00:13:14,350
 

687
00:13:14,350 --> 00:13:15,870
Postgres actually uses the process model

688
00:13:15,870 --> 00:13:15,880
 

689
00:13:15,880 --> 00:13:17,730
and they actually now support intro

690
00:13:17,730 --> 00:13:17,740
 

691
00:13:17,740 --> 00:13:19,460
query parallels

692
00:13:19,460 --> 00:13:19,470

693
00:13:19,470 --> 00:13:21,330
so the bunch of other stuff you have to

694
00:13:21,330 --> 00:13:21,340
 

695
00:13:21,340 --> 00:13:23,790
deal with as you can imagine in when we

696
00:13:23,790 --> 00:13:23,800
 

697
00:13:23,800 --> 00:13:25,290
have a multi-threaded environment a

698
00:13:25,290 --> 00:13:25,300
 

699
00:13:25,300 --> 00:13:26,940
multi-process environment in terms of

700
00:13:26,940 --> 00:13:26,950

701
00:13:26,950 --> 00:13:29,010
scheduling right so there's a bunch of

702
00:13:29,010 --> 00:13:29,020
 

703
00:13:29,020 --> 00:13:30,240
other stuff we have to decide our

704
00:13:30,240 --> 00:13:30,250
 

705
00:13:30,250 --> 00:13:32,760
database system like who's you know who

706
00:13:32,760 --> 00:13:32,770
 

707
00:13:32,770 --> 00:13:34,590
to hand off tasks to how much resources

708
00:13:34,590 --> 00:13:34,600

709
00:13:34,600 --> 00:13:37,230
those tasks should get what cores or CPU

710
00:13:37,230 --> 00:13:37,240
 

711
00:13:37,240 --> 00:13:39,300
course we just sign workers to write all

712
00:13:39,300 --> 00:13:39,310
 

713
00:13:39,310 --> 00:13:40,680
these things are not gonna cover in this

714
00:13:40,680 --> 00:13:40,690
 

715
00:13:40,690 --> 00:13:41,790
class we'll cover in the advanced class

716
00:13:41,790 --> 00:13:41,800
 

717
00:13:41,800 --> 00:13:43,980
but the way to think about it is the

718
00:13:43,980 --> 00:13:43,990
 

719
00:13:43,990 --> 00:13:45,420
same kind of scheduling that an

720
00:13:45,420 --> 00:13:45,430
 

721
00:13:45,430 --> 00:13:48,810
operating system has to do about its

722
00:13:48,810 --> 00:13:48,820
 

723
00:13:48,820 --> 00:13:50,790
processes and it threads running in the

724
00:13:50,790 --> 00:13:50,800
 

725
00:13:50,800 --> 00:13:52,710
system we want to do the same kind of

726
00:13:52,710 --> 00:13:52,720
 

727
00:13:52,720 --> 00:13:54,510
thing of our database system because we

728
00:13:54,510 --> 00:13:54,520
 

729
00:13:54,520 --> 00:13:55,770
know what the threads were actually

730
00:13:55,770 --> 00:13:55,780

731
00:13:55,780 --> 00:13:57,420
doing we do we know what data they're

732
00:13:57,420 --> 00:13:57,430

733
00:13:57,430 --> 00:13:59,550
touching and we can be smarter about how

734
00:13:59,550 --> 00:13:59,560
 

735
00:13:59,560 --> 00:14:02,040
we organize things against the the

736
00:14:02,040 --> 00:14:02,050
 

737
00:14:02,050 --> 00:14:10,140
decent always knows more yes so this

738
00:14:10,140 --> 00:14:10,150
 

739
00:14:10,150 --> 00:14:13,110
question is for the process model what

740
00:14:13,110 --> 00:14:13,120
 

741
00:14:13,120 --> 00:14:15,930
is the advantage of the worker pool

742
00:14:15,930 --> 00:14:15,940

743
00:14:15,940 --> 00:14:21,120
versus the process per worker the idea

744
00:14:21,120 --> 00:14:21,130
 

745
00:14:21,130 --> 00:14:24,510
so the advantages for this one here from

746
00:14:24,510 --> 00:14:24,520
 

747
00:14:24,520 --> 00:14:27,030
one query shows up in this worker that

748
00:14:27,030 --> 00:14:27,040
 

749
00:14:27,040 --> 00:14:28,590
worker is the only thing person that can

750
00:14:28,590 --> 00:14:28,600
 

751
00:14:28,600 --> 00:14:32,460
execute it right in this one here you

752
00:14:32,460 --> 00:14:32,470
 

753
00:14:32,470 --> 00:14:34,890
could have free workers that the query

754
00:14:34,890 --> 00:14:34,900
 

755
00:14:34,900 --> 00:14:37,410
shows up to this guy here but he could

756
00:14:37,410 --> 00:14:37,420

757
00:14:37,420 --> 00:14:38,880
say alright well I know these other guys

758
00:14:38,880 --> 00:14:38,890
 

759
00:14:38,890 --> 00:14:41,280
are free here so let me hand off one one

760
00:14:41,280 --> 00:14:41,290
 

761
00:14:41,290 --> 00:14:42,690
piece of my work to them and they'll

762
00:14:42,690 --> 00:14:42,700
 

763
00:14:42,700 --> 00:14:43,860
execute it and then send the result back

764
00:14:43,860 --> 00:14:43,870
 

765
00:14:43,870 --> 00:14:47,670
to me all right again so that this won't

766
00:14:47,670 --> 00:14:47,680
 

767
00:14:47,680 --> 00:14:50,520
be one worker equals one query this one

768
00:14:50,520 --> 00:14:50,530
 

769
00:14:50,530 --> 00:14:52,080
could be one query it could be used

770
00:14:52,080 --> 00:14:52,090
 

771
00:14:52,090 --> 00:14:55,260
cross suit across multiple workers and

772
00:14:55,260 --> 00:14:55,270
 

773
00:14:55,270 --> 00:14:56,850
the obviously you can do the same thing

774
00:14:56,850 --> 00:14:56,860
 

775
00:14:56,860 --> 00:14:59,550
and in the thread pool the threading

776
00:14:59,550 --> 00:14:59,560

777
00:14:59,560 --> 00:15:07,230
model approach okay so the as I said the

778
00:15:07,230 --> 00:15:07,240
 

779
00:15:07,240 --> 00:15:08,700
two type of parallelism we can have our

780
00:15:08,700 --> 00:15:08,710
 

781
00:15:08,710 --> 00:15:10,290
inner query pills and intra query

782
00:15:10,290 --> 00:15:10,300
 

783
00:15:10,300 --> 00:15:12,480
parallelism so inner query pail ISM just

784
00:15:12,480 --> 00:15:12,490
 

785
00:15:12,490 --> 00:15:14,760
means that we're gonna have multiple

786
00:15:14,760 --> 00:15:14,770
 

787
00:15:14,770 --> 00:15:16,290
threads multiple queries better run at

788
00:15:16,290 --> 00:15:16,300
 

789
00:15:16,300 --> 00:15:19,260
the same times in our system if

790
00:15:19,260 --> 00:15:19,270
 

791
00:15:19,270 --> 00:15:20,610
everything's read only in this

792
00:15:20,610 --> 00:15:20,620
 

793
00:15:20,620 --> 00:15:23,250
environment then this is this is super

794
00:15:23,250 --> 00:15:23,260
 

795
00:15:23,260 --> 00:15:25,380
easy to do because we don't have to

796
00:15:25,380 --> 00:15:25,390
 

797
00:15:25,390 --> 00:15:26,280
worry about any of the threads

798
00:15:26,280 --> 00:15:26,290
 

799
00:15:26,290 --> 00:15:28,170
coordinating or the workers coordinated

800
00:15:28,170 --> 00:15:28,180
 

801
00:15:28,180 --> 00:15:29,790
with each other yeah this guy can run

802
00:15:29,790 --> 00:15:29,800
 

803
00:15:29,800 --> 00:15:32,580
this query I can run my query and we

804
00:15:32,580 --> 00:15:32,590
 

805
00:15:32,590 --> 00:15:34,410
have to worry about you know and then

806
00:15:34,410 --> 00:15:34,420
 

807
00:15:34,420 --> 00:15:35,610
modifying anything

808
00:15:35,610 --> 00:15:35,620

809
00:15:35,620 --> 00:15:39,030
it's when you have queries updating the

810
00:15:39,030 --> 00:15:39,040

811
00:15:39,040 --> 00:15:40,770
database at the same time that's when

812
00:15:40,770 --> 00:15:40,780
 

813
00:15:40,780 --> 00:15:42,930
trouble starts and that's where you need

814
00:15:42,930 --> 00:15:42,940
 

815
00:15:42,940 --> 00:15:44,490
something a country to a protocol which

816
00:15:44,490 --> 00:15:44,500
 

817
00:15:44,500 --> 00:15:46,320
we'll discuss next week to make sure

818
00:15:46,320 --> 00:15:46,330
 

819
00:15:46,330 --> 00:15:49,050
that each worker only reads the data

820
00:15:49,050 --> 00:15:49,060
 

821
00:15:49,060 --> 00:15:49,980
that they're supposed to be reading

822
00:15:49,980 --> 00:15:49,990
 

823
00:15:49,990 --> 00:15:52,080
right we don't wanna test you don't want

824
00:15:52,080 --> 00:15:52,090
 

825
00:15:52,090 --> 00:15:54,480
to read data from one worker before this

826
00:15:54,480 --> 00:15:54,490
 

827
00:15:54,490 --> 00:15:56,190
actually saved anything in you know in

828
00:15:56,190 --> 00:15:56,200
 

829
00:15:56,200 --> 00:15:59,940
another worker so the idea is that a

830
00:15:59,940 --> 00:15:59,950
 

831
00:15:59,950 --> 00:16:02,070
commercial protocol is gonna have allow

832
00:16:02,070 --> 00:16:02,080
 

833
00:16:02,080 --> 00:16:03,450
us to give the illusion that each worker

834
00:16:03,450 --> 00:16:03,460
 

835
00:16:03,460 --> 00:16:05,010
is running in the data is by itself even

836
00:16:05,010 --> 00:16:05,020
 

837
00:16:05,020 --> 00:16:06,720
though they're not really again this is

838
00:16:06,720 --> 00:16:06,730
 

839
00:16:06,730 --> 00:16:08,130
really hard this is the thing that

840
00:16:08,130 --> 00:16:08,140
 

841
00:16:08,140 --> 00:16:09,660
excites me the most in databases and

842
00:16:09,660 --> 00:16:09,670
 

843
00:16:09,670 --> 00:16:13,650
we'll discuss more of this next week for

844
00:16:13,650 --> 00:16:13,660
 

845
00:16:13,660 --> 00:16:15,900
Android query parallelism right the idea

846
00:16:15,900 --> 00:16:15,910
 

847
00:16:15,910 --> 00:16:17,790
is again for a single query can we break

848
00:16:17,790 --> 00:16:17,800
 

849
00:16:17,800 --> 00:16:21,360
up it's it's it's it's tasks into sort

850
00:16:21,360 --> 00:16:21,370
 

851
00:16:21,370 --> 00:16:22,980
of sub tasks and run those in parallel

852
00:16:22,980 --> 00:16:22,990
 

853
00:16:22,990 --> 00:16:25,760
the two approaches that you are

854
00:16:25,760 --> 00:16:25,770
 

855
00:16:25,770 --> 00:16:27,620
interoperate or parallelism in

856
00:16:27,620 --> 00:16:27,630
 

857
00:16:27,630 --> 00:16:30,240
interoperate apparel ISM and we'll say

858
00:16:30,240 --> 00:16:30,250
 

859
00:16:30,250 --> 00:16:31,770
is that these techniques are not not

860
00:16:31,770 --> 00:16:31,780
 

861
00:16:31,780 --> 00:16:33,360
mutually exclusive just because you're

862
00:16:33,360 --> 00:16:33,370
 

863
00:16:33,370 --> 00:16:34,410
using the first approach doesn't mean

864
00:16:34,410 --> 00:16:34,420
 

865
00:16:34,420 --> 00:16:35,790
you can't also use the second approach

866
00:16:35,790 --> 00:16:35,800
 

867
00:16:35,800 --> 00:16:37,890
well but most people actually only use

868
00:16:37,890 --> 00:16:37,900
 

869
00:16:37,900 --> 00:16:40,590
the first approach and for all the

870
00:16:40,590 --> 00:16:40,600
 

871
00:16:40,600 --> 00:16:42,060
algorithms that we talked about so far

872
00:16:42,060 --> 00:16:42,070
 

873
00:16:42,070 --> 00:16:44,550
did you join to do sorting to do scans

874
00:16:44,550 --> 00:16:44,560
 

875
00:16:44,560 --> 00:16:47,010
there are parallel versions of all of

876
00:16:47,010 --> 00:16:47,020
 

877
00:16:47,020 --> 00:16:49,890
these right basically just think about

878
00:16:49,890 --> 00:16:49,900
 

879
00:16:49,900 --> 00:16:52,260
you hash join instead of having one

880
00:16:52,260 --> 00:16:52,270
 

881
00:16:52,270 --> 00:16:53,940
thread scan the table and build the hash

882
00:16:53,940 --> 00:16:53,950
 

883
00:16:53,950 --> 00:16:55,920
table you could have different threads

884
00:16:55,920 --> 00:16:55,930
 

885
00:16:55,930 --> 00:16:58,380
scan at the same time and build the same

886
00:16:58,380 --> 00:16:58,390
 

887
00:16:58,390 --> 00:17:00,240
hash table together of course now you

888
00:17:00,240 --> 00:17:00,250
 

889
00:17:00,250 --> 00:17:01,980
need latches to protect protect them

890
00:17:01,980 --> 00:17:01,990
 

891
00:17:01,990 --> 00:17:05,250
from each other so again we'll go

892
00:17:05,250 --> 00:17:05,260

893
00:17:05,260 --> 00:17:07,130
through these two approaches one by one

894
00:17:07,130 --> 00:17:07,140
 

895
00:17:07,140 --> 00:17:10,199
so intraoperative parallelism is also

896
00:17:10,199 --> 00:17:10,209
 

897
00:17:10,209 --> 00:17:11,430
sometimes called horizontal parallelism

898
00:17:11,430 --> 00:17:11,440
 

899
00:17:11,440 --> 00:17:15,120
and the idea is that for a single sort

900
00:17:15,120 --> 00:17:15,130
 

901
00:17:15,130 --> 00:17:17,310
of high-level logical operator in our

902
00:17:17,310 --> 00:17:17,320
 

903
00:17:17,320 --> 00:17:20,340
query plan like scan table egg we're

904
00:17:20,340 --> 00:17:20,350
 

905
00:17:20,350 --> 00:17:23,090
gonna instantiate multiple instances of

906
00:17:23,090 --> 00:17:23,100

907
00:17:23,100 --> 00:17:27,630
that operator and then execute them in

908
00:17:27,630 --> 00:17:27,640

909
00:17:27,640 --> 00:17:29,730
parallel and then we're gonna introduced

910
00:17:29,730 --> 00:17:29,740
 

911
00:17:29,740 --> 00:17:31,140
a new type of operator called the

912
00:17:31,140 --> 00:17:31,150

913
00:17:31,150 --> 00:17:35,010
exchange operator that's gonna be a sort

914
00:17:35,010 --> 00:17:35,020
 

915
00:17:35,020 --> 00:17:38,820
of a barrier that checks to see whether

916
00:17:38,820 --> 00:17:38,830
 

917
00:17:38,830 --> 00:17:42,180
all the subtasks for our single operator

918
00:17:42,180 --> 00:17:42,190
 

919
00:17:42,190 --> 00:17:45,660
are completed and if so then we can then

920
00:17:45,660 --> 00:17:45,670
 

921
00:17:45,670 --> 00:17:48,000
along the the results to the next

922
00:17:48,000 --> 00:17:48,010
 

923
00:17:48,010 --> 00:17:50,430
operator in our query plan so the

924
00:17:50,430 --> 00:17:50,440
 

925
00:17:50,440 --> 00:17:51,960
exchange operator was introduced in the

926
00:17:51,960 --> 00:17:51,970

927
00:17:51,970 --> 00:17:55,350
late 1980s early 1990s from the same

928
00:17:55,350 --> 00:17:55,360
 

929
00:17:55,360 --> 00:17:58,140
author that did the volcano stuff we

930
00:17:58,140 --> 00:17:58,150
 

931
00:17:58,150 --> 00:17:59,850
talked about before the iterator model

932
00:17:59,850 --> 00:17:59,860
 

933
00:17:59,860 --> 00:18:01,590
said it also could be called the volcano

934
00:18:01,590 --> 00:18:01,600
 

935
00:18:01,600 --> 00:18:03,840
right this all comes in the same paper

936
00:18:03,840 --> 00:18:03,850
 

937
00:18:03,850 --> 00:18:05,310
and that's the same paper also

938
00:18:05,310 --> 00:18:05,320
 

939
00:18:05,320 --> 00:18:07,770
introduces this exchange operator and in

940
00:18:07,770 --> 00:18:07,780
 

941
00:18:07,780 --> 00:18:10,320
most parallel databases they have

942
00:18:10,320 --> 00:18:10,330
 

943
00:18:10,330 --> 00:18:12,540
something like this that that you would

944
00:18:12,540 --> 00:18:12,550
 

945
00:18:12,550 --> 00:18:14,970
use to combine things together and this

946
00:18:14,970 --> 00:18:14,980
 

947
00:18:14,980 --> 00:18:16,170
is also approach is also used in

948
00:18:16,170 --> 00:18:16,180
 

949
00:18:16,180 --> 00:18:19,260
distributed databases as well let's say

950
00:18:19,260 --> 00:18:19,270

951
00:18:19,270 --> 00:18:21,030
we have our query here we want to do a

952
00:18:21,030 --> 00:18:21,040
 

953
00:18:21,040 --> 00:18:23,640
joint on a and B and we have a filter or

954
00:18:23,640 --> 00:18:23,650
 

955
00:18:23,650 --> 00:18:26,430
an A and a filter on B all right so this

956
00:18:26,430 --> 00:18:26,440
 

957
00:18:26,440 --> 00:18:27,870
query plan I'm showing here this looked

958
00:18:27,870 --> 00:18:27,880
 

959
00:18:27,880 --> 00:18:29,670
the logical view of the query plan we're

960
00:18:29,670 --> 00:18:29,680

961
00:18:29,680 --> 00:18:30,720
not saying anything but what algorithms

962
00:18:30,720 --> 00:18:30,730
 

963
00:18:30,730 --> 00:18:32,130
are using we're not saying anything

964
00:18:32,130 --> 00:18:32,140
 

965
00:18:32,140 --> 00:18:34,560
about you know where the data is

966
00:18:34,560 --> 00:18:34,570
 

967
00:18:34,570 --> 00:18:36,630
actually stored but now we can just

968
00:18:36,630 --> 00:18:36,640
 

969
00:18:36,640 --> 00:18:38,730
answer eight multiple we just go to

970
00:18:38,730 --> 00:18:38,740
 

971
00:18:38,740 --> 00:18:40,290
execute it we can stand she ate these

972
00:18:40,290 --> 00:18:40,300
 

973
00:18:40,300 --> 00:18:41,700
different operators and parallel with

974
00:18:41,700 --> 00:18:41,710
 

975
00:18:41,710 --> 00:18:44,310
each other so take the first thing of

976
00:18:44,310 --> 00:18:44,320
 

977
00:18:44,320 --> 00:18:47,130
this scan on AIM so we can say that

978
00:18:47,130 --> 00:18:47,140
 

979
00:18:47,140 --> 00:18:48,060
we're gonna break it up to three

980
00:18:48,060 --> 00:18:48,070
 

981
00:18:48,070 --> 00:18:52,230
subtasks a 1 to 8 a 1 a 2 a 3 that are

982
00:18:52,230 --> 00:18:52,240
 

983
00:18:52,240 --> 00:18:54,750
each going to be assigned to a single

984
00:18:54,750 --> 00:18:54,760
 

985
00:18:54,760 --> 00:18:57,270
worker like a single thing of single

986
00:18:57,270 --> 00:18:57,280
 

987
00:18:57,280 --> 00:19:00,870
thread and I'm going to scan disjoint

988
00:19:00,870 --> 00:19:00,880
 

989
00:19:00,880 --> 00:19:03,960
subsets of the table and then pass them

990
00:19:03,960 --> 00:19:03,970

991
00:19:03,970 --> 00:19:05,940
up to the next operator in the query

992
00:19:05,940 --> 00:19:05,950
 

993
00:19:05,950 --> 00:19:08,490
plan all right but actually we can do

994
00:19:08,490 --> 00:19:08,500
 

995
00:19:08,500 --> 00:19:10,170
some pipelining here because we see that

996
00:19:10,170 --> 00:19:10,180

997
00:19:10,180 --> 00:19:12,270
immediately after the scan we're gonna

998
00:19:12,270 --> 00:19:12,280
 

999
00:19:12,280 --> 00:19:14,160
do our filter right we're a value is

1000
00:19:14,160 --> 00:19:14,170
 

1001
00:19:14,170 --> 00:19:17,820
less than 999 a value is less than 99 so

1002
00:19:17,820 --> 00:19:17,830
 

1003
00:19:17,830 --> 00:19:20,640
in addition to doing the scan will also

1004
00:19:20,640 --> 00:19:20,650
 

1005
00:19:20,650 --> 00:19:23,160
feed the output into a parallel version

1006
00:19:23,160 --> 00:19:23,170
 

1007
00:19:23,170 --> 00:19:25,800
of the filter who then feeds the data up

1008
00:19:25,800 --> 00:19:25,810
 

1009
00:19:25,810 --> 00:19:29,310
even further so now again because we

1010
00:19:29,310 --> 00:19:29,320
 

1011
00:19:29,320 --> 00:19:30,750
know if to join up for that each of

1012
00:19:30,750 --> 00:19:30,760
 

1013
00:19:30,760 --> 00:19:32,820
these guys can then build the hash table

1014
00:19:32,820 --> 00:19:32,830
 

1015
00:19:32,830 --> 00:19:34,500
we'll build a single global hash table

1016
00:19:34,500 --> 00:19:34,510
 

1017
00:19:34,510 --> 00:19:36,450
for all these threads what do you just

1018
00:19:36,450 --> 00:19:36,460
 

1019
00:19:36,460 --> 00:19:38,820
use latches to protect them and then now

1020
00:19:38,820 --> 00:19:38,830
 

1021
00:19:38,830 --> 00:19:41,250
this then gets fed up into an exchange

1022
00:19:41,250 --> 00:19:41,260
 

1023
00:19:41,260 --> 00:19:43,500
operator again think of this just as a

1024
00:19:43,500 --> 00:19:43,510
 

1025
00:19:43,510 --> 00:19:46,350
barrier there's it's just a sort of

1026
00:19:46,350 --> 00:19:46,360

1027
00:19:46,360 --> 00:19:47,880
physical construct and said write query

1028
00:19:47,880 --> 00:19:47,890
 

1029
00:19:47,890 --> 00:19:50,780
plan execution that has no corresponding

1030
00:19:50,780 --> 00:19:50,790
 

1031
00:19:50,790 --> 00:19:53,100
logical operator in relational algebra

1032
00:19:53,100 --> 00:19:53,110
 

1033
00:19:53,110 --> 00:19:54,510
it's just something internally we're

1034
00:19:54,510 --> 00:19:54,520
 

1035
00:19:54,520 --> 00:19:55,650
using to synchronize the different

1036
00:19:55,650 --> 00:19:55,660

1037
00:19:55,660 --> 00:19:58,050
threads and say we can't go pass in a

1038
00:19:58,050 --> 00:19:58,060
 

1039
00:19:58,060 --> 00:19:59,520
query plan until we get the result

1040
00:19:59,520 --> 00:19:59,530
 

1041
00:19:59,530 --> 00:20:03,120
all our subtasks I just think there's a

1042
00:20:03,120 --> 00:20:03,130
 

1043
00:20:03,130 --> 00:20:04,500
counter inside this thing that says I

1044
00:20:04,500 --> 00:20:04,510
 

1045
00:20:04,510 --> 00:20:06,330
know I have three subtasks and every

1046
00:20:06,330 --> 00:20:06,340
 

1047
00:20:06,340 --> 00:20:08,220
single time this guy is one of these

1048
00:20:08,220 --> 00:20:08,230
 

1049
00:20:08,230 --> 00:20:09,690
task complete since tells an exchange

1050
00:20:09,690 --> 00:20:09,700
 

1051
00:20:09,700 --> 00:20:11,340
operator hey I'm done I don't have any

1052
00:20:11,340 --> 00:20:11,350
 

1053
00:20:11,350 --> 00:20:13,320
more data to give you then you decrement

1054
00:20:13,320 --> 00:20:13,330
 

1055
00:20:13,330 --> 00:20:15,690
that counter by one then when the

1056
00:20:15,690 --> 00:20:15,700
 

1057
00:20:15,700 --> 00:20:16,980
counter is zero then you can take

1058
00:20:16,980 --> 00:20:16,990
 

1059
00:20:16,990 --> 00:20:18,420
whatever this thing is cold less

1060
00:20:18,420 --> 00:20:18,430
 

1061
00:20:18,430 --> 00:20:20,580
together and feed it up to the next

1062
00:20:20,580 --> 00:20:20,590
 

1063
00:20:20,590 --> 00:20:24,630
operator all right so we can do the same

1064
00:20:24,630 --> 00:20:24,640
 

1065
00:20:24,640 --> 00:20:27,120
thing for B say B is the smaller table

1066
00:20:27,120 --> 00:20:27,130
 

1067
00:20:27,130 --> 00:20:29,460
and so maybe we only want to give it two

1068
00:20:29,460 --> 00:20:29,470
 

1069
00:20:29,470 --> 00:20:31,610
cores or two workers to execute this and

1070
00:20:31,610 --> 00:20:31,620
 

1071
00:20:31,620 --> 00:20:33,720
they'll just can do the same thing

1072
00:20:33,720 --> 00:20:33,730
 

1073
00:20:33,730 --> 00:20:36,120
they'll scan and parallel do the filter

1074
00:20:36,120 --> 00:20:36,130

1075
00:20:36,130 --> 00:20:37,800
and say we're doing the grace hash join

1076
00:20:37,800 --> 00:20:37,810
 

1077
00:20:37,810 --> 00:20:40,110
where we want to partition this and so

1078
00:20:40,110 --> 00:20:40,120
 

1079
00:20:40,120 --> 00:20:41,640
we'll partition these guys into two

1080
00:20:41,640 --> 00:20:41,650
 

1081
00:20:41,650 --> 00:20:44,430
separate buckets and then we have an

1082
00:20:44,430 --> 00:20:44,440
 

1083
00:20:44,440 --> 00:20:45,630
exchange operator says hey when you're

1084
00:20:45,630 --> 00:20:45,640

1085
00:20:45,640 --> 00:20:48,270
done you know you know once all tough

1086
00:20:48,270 --> 00:20:48,280
 

1087
00:20:48,280 --> 00:20:49,770
tests are done then we go complete this

1088
00:20:49,770 --> 00:20:49,780

1089
00:20:49,780 --> 00:20:51,810
so when this exchange operator is done

1090
00:20:51,810 --> 00:20:51,820
 

1091
00:20:51,820 --> 00:20:53,340
we have a hash table when this same

1092
00:20:53,340 --> 00:20:53,350
 

1093
00:20:53,350 --> 00:20:55,170
exchange operator is done we have our

1094
00:20:55,170 --> 00:20:55,180
 

1095
00:20:55,180 --> 00:20:57,960
buckets and then in the once these two

1096
00:20:57,960 --> 00:20:57,970
 

1097
00:20:57,970 --> 00:20:59,640
exchange operators are done together you

1098
00:20:59,640 --> 00:20:59,650
 

1099
00:20:59,650 --> 00:21:03,090
can then actually now do the join and

1100
00:21:03,090 --> 00:21:03,100
 

1101
00:21:03,100 --> 00:21:04,320
again we do this join in parallel

1102
00:21:04,320 --> 00:21:04,330
 

1103
00:21:04,330 --> 00:21:07,560
because we've split the the data up over

1104
00:21:07,560 --> 00:21:07,570
 

1105
00:21:07,570 --> 00:21:09,990
here and we can now do our probe in a

1106
00:21:09,990 --> 00:21:10,000
 

1107
00:21:10,000 --> 00:21:11,250
hash table under different threads and

1108
00:21:11,250 --> 00:21:11,260
 

1109
00:21:11,260 --> 00:21:12,480
priests are Appling the same thing you

1110
00:21:12,480 --> 00:21:12,490
 

1111
00:21:12,490 --> 00:21:14,190
have exchange or operator above that as

1112
00:21:14,190 --> 00:21:14,200
 

1113
00:21:14,200 --> 00:21:15,660
the counter it says when my four

1114
00:21:15,660 --> 00:21:15,670
 

1115
00:21:15,670 --> 00:21:17,490
subtasks complete then I get my final

1116
00:21:17,490 --> 00:21:17,500
 

1117
00:21:17,500 --> 00:21:22,440
result so is this clear right it's just

1118
00:21:22,440 --> 00:21:22,450
 

1119
00:21:22,450 --> 00:21:24,900
it's a construct inside excited the

1120
00:21:24,900 --> 00:21:24,910
 

1121
00:21:24,910 --> 00:21:27,330
execution of this query plan that allows

1122
00:21:27,330 --> 00:21:27,340
 

1123
00:21:27,340 --> 00:21:29,220
us to call us the results from the sub

1124
00:21:29,220 --> 00:21:29,230
 

1125
00:21:29,230 --> 00:21:31,560
task when these workers so that anything

1126
00:21:31,560 --> 00:21:31,570
 

1127
00:21:31,570 --> 00:21:33,300
above it doesn't have to know that it

1128
00:21:33,300 --> 00:21:33,310
 

1129
00:21:33,310 --> 00:21:35,550
was executed in parallel it just knows

1130
00:21:35,550 --> 00:21:35,560
 

1131
00:21:35,560 --> 00:21:37,550
that I got all the data that I needed

1132
00:21:37,550 --> 00:21:37,560
 

1133
00:21:37,560 --> 00:21:40,500
right because without this then this

1134
00:21:40,500 --> 00:21:40,510

1135
00:21:40,510 --> 00:21:42,120
thread might run faster than this thread

1136
00:21:42,120 --> 00:21:42,130
 

1137
00:21:42,130 --> 00:21:43,980
so I might start executing things above

1138
00:21:43,980 --> 00:21:43,990
 

1139
00:21:43,990 --> 00:21:45,690
in my query plan before I process all

1140
00:21:45,690 --> 00:21:45,700
 

1141
00:21:45,700 --> 00:21:48,210
the data that I needed so I may not may

1142
00:21:48,210 --> 00:21:48,220
 

1143
00:21:48,220 --> 00:21:49,500
in a beginning false negatives or false

1144
00:21:49,500 --> 00:21:49,510
 

1145
00:21:49,510 --> 00:22:00,530
positives yes Gracie could you kids

1146
00:22:00,530 --> 00:22:00,540
 

1147
00:22:00,540 --> 00:22:02,400
waiting like this you could split up

1148
00:22:02,400 --> 00:22:02,410
 

1149
00:22:02,410 --> 00:22:07,920
this input so that be all the data that

1150
00:22:07,920 --> 00:22:07,930
 

1151
00:22:07,930 --> 00:22:09,330
this thing would ever have to have to

1152
00:22:09,330 --> 00:22:09,340
 

1153
00:22:09,340 --> 00:22:11,940
access and one of these threads up here

1154
00:22:11,940 --> 00:22:11,950
 

1155
00:22:11,950 --> 00:22:13,530
would be all within a single

1156
00:22:13,530 --> 00:22:13,540
 

1157
00:22:13,540 --> 00:22:15,420
tition so that you're only mostly

1158
00:22:15,420 --> 00:22:15,430
 

1159
00:22:15,430 --> 00:22:16,680
hitting the same part of the hash table

1160
00:22:16,680 --> 00:22:16,690
 

1161
00:22:16,690 --> 00:22:17,790
inside this so you get better cache

1162
00:22:17,790 --> 00:22:17,800
 

1163
00:22:17,800 --> 00:22:26,750
locality it's like the grace hash join a

1164
00:22:26,750 --> 00:22:26,760


1165
00:22:26,760 --> 00:22:30,030
variant of this it's a very double use

1166
00:22:30,030 --> 00:22:30,040
 

1167
00:22:30,040 --> 00:22:36,300
partitioned okay so that that's

1168
00:22:36,300 --> 00:22:36,310
 

1169
00:22:36,310 --> 00:22:38,100
intraoperative parallelism and the idea

1170
00:22:38,100 --> 00:22:38,110
 

1171
00:22:38,110 --> 00:22:39,180
is that we're taking an operator we

1172
00:22:39,180 --> 00:22:39,190
 

1173
00:22:39,190 --> 00:22:40,260
would normally execute on a single

1174
00:22:40,260 --> 00:22:40,270

1175
00:22:40,270 --> 00:22:42,150
thread and is breaking up across

1176
00:22:42,150 --> 00:22:42,160
 

1177
00:22:42,160 --> 00:22:45,690
multiple threads so with interoperative

1178
00:22:45,690 --> 00:22:45,700
 

1179
00:22:45,700 --> 00:22:47,430
parallelism or vertical parallelism

1180
00:22:47,430 --> 00:22:47,440
 

1181
00:22:47,440 --> 00:22:49,620
yeah idea here is that we're going to

1182
00:22:49,620 --> 00:22:49,630
 

1183
00:22:49,630 --> 00:22:52,470
execute our operator in doesn't have to

1184
00:22:52,470 --> 00:22:52,480
 

1185
00:22:52,480 --> 00:22:53,610
be a single thread but for our purposes

1186
00:22:53,610 --> 00:22:53,620
 

1187
00:22:53,620 --> 00:22:56,160
we'll say it is for each operator will

1188
00:22:56,160 --> 00:22:56,170

1189
00:22:56,170 --> 00:22:58,170
be assigned to a single worker that I'll

1190
00:22:58,170 --> 00:22:58,180
 

1191
00:22:58,180 --> 00:23:00,810
just be always running and it'll spit up

1192
00:23:00,810 --> 00:23:00,820

1193
00:23:00,820 --> 00:23:02,460
output to the next you know takes takes

1194
00:23:02,460 --> 00:23:02,470
 

1195
00:23:02,470 --> 00:23:04,230
an input does whatever computation and

1196
00:23:04,230 --> 00:23:04,240
 

1197
00:23:04,240 --> 00:23:05,520
once on it and then it spits it up to

1198
00:23:05,520 --> 00:23:05,530
 

1199
00:23:05,530 --> 00:23:07,470
the next operator when it's done and

1200
00:23:07,470 --> 00:23:07,480
 

1201
00:23:07,480 --> 00:23:09,120
then now we can have these different

1202
00:23:09,120 --> 00:23:09,130
 

1203
00:23:09,130 --> 00:23:10,440
workers running in parallel these

1204
00:23:10,440 --> 00:23:10,450
 

1205
00:23:10,450 --> 00:23:13,170
different operators and then make your

1206
00:23:13,170 --> 00:23:13,180
 

1207
00:23:13,180 --> 00:23:14,510
textbook calls this pipeline parallelism

1208
00:23:14,510 --> 00:23:14,520
 

1209
00:23:14,520 --> 00:23:17,220
so we just take our example from before

1210
00:23:17,220 --> 00:23:17,230
 

1211
00:23:17,230 --> 00:23:18,960
the same query and say we take this

1212
00:23:18,960 --> 00:23:18,970

1213
00:23:18,970 --> 00:23:21,150
joint operator we don't care what comes

1214
00:23:21,150 --> 00:23:21,160
 

1215
00:23:21,160 --> 00:23:22,920
below us was actually feeding data into

1216
00:23:22,920 --> 00:23:22,930
 

1217
00:23:22,930 --> 00:23:24,720
thus we'll just assign this to a single

1218
00:23:24,720 --> 00:23:24,730
 

1219
00:23:24,730 --> 00:23:26,700
worker as this can again iterate over

1220
00:23:26,700 --> 00:23:26,710
 

1221
00:23:26,710 --> 00:23:28,230
the inner table and the outer table

1222
00:23:28,230 --> 00:23:28,240
 

1223
00:23:28,240 --> 00:23:29,910
however it gets it and then when it has

1224
00:23:29,910 --> 00:23:29,920
 

1225
00:23:29,920 --> 00:23:32,850
a result it admits it as as the output

1226
00:23:32,850 --> 00:23:32,860
 

1227
00:23:32,860 --> 00:23:35,310
up above and then in another worker

1228
00:23:35,310 --> 00:23:35,320
 

1229
00:23:35,320 --> 00:23:39,240
we're gonna have a you know thread

1230
00:23:39,240 --> 00:23:39,250
 

1231
00:23:39,250 --> 00:23:41,460
spinning over and doing our projection

1232
00:23:41,460 --> 00:23:41,470
 

1233
00:23:41,470 --> 00:23:44,490
on any data that comes out of this so

1234
00:23:44,490 --> 00:23:44,500
 

1235
00:23:44,500 --> 00:23:46,950
again while one thread spin down here

1236
00:23:46,950 --> 00:23:46,960
 

1237
00:23:46,960 --> 00:23:48,690
another thread spin down here and

1238
00:23:48,690 --> 00:23:48,700
 

1239
00:23:48,700 --> 00:23:50,340
anything that gets its input it is just

1240
00:23:50,340 --> 00:23:50,350
 

1241
00:23:50,350 --> 00:23:51,630
the computation and it's listed as the

1242
00:23:51,630 --> 00:23:51,640
 

1243
00:23:51,640 --> 00:23:55,620
output all right and then again for

1244
00:23:55,620 --> 00:23:55,630
 

1245
00:23:55,630 --> 00:23:56,940
every single operator my query planner I

1246
00:23:56,940 --> 00:23:56,950
 

1247
00:23:56,950 --> 00:23:59,390
could assign them to a different worker

1248
00:23:59,390 --> 00:23:59,400
 

1249
00:23:59,400 --> 00:24:08,470
so what's the obvious problem with this

1250
00:24:08,470 --> 00:24:08,480


1251
00:24:08,480 --> 00:24:13,730
yes exactly says two can only go fast as

1252
00:24:13,730 --> 00:24:13,740
 

1253
00:24:13,740 --> 00:24:17,270
one so this top guy here he's gonna sit

1254
00:24:17,270 --> 00:24:17,280
 

1255
00:24:17,280 --> 00:24:21,130
and wait until he gets data to crunch on

1256
00:24:21,130 --> 00:24:21,140
 

1257
00:24:21,140 --> 00:24:23,360
right so we're sort of assigning a

1258
00:24:23,360 --> 00:24:23,370
 

1259
00:24:23,370 --> 00:24:26,000
worker to this task but it doesn't have

1260
00:24:26,000 --> 00:24:26,010
 

1261
00:24:26,010 --> 00:24:28,100
anything to do it's not gonna do you

1262
00:24:28,100 --> 00:24:28,110
 

1263
00:24:28,110 --> 00:24:29,960
know hopefully not doing a busy loop and

1264
00:24:29,960 --> 00:24:29,970
 

1265
00:24:29,970 --> 00:24:31,940
just burning cycles that way but it's

1266
00:24:31,940 --> 00:24:31,950
 

1267
00:24:31,950 --> 00:24:32,990
essentially we've allocated resources

1268
00:24:32,990 --> 00:24:33,000

1269
00:24:33,000 --> 00:24:38,150
that can't be used so as far as they

1270
00:24:38,150 --> 00:24:38,160
 

1271
00:24:38,160 --> 00:24:40,370
know no sir traditional relational

1272
00:24:40,370 --> 00:24:40,380
 

1273
00:24:40,380 --> 00:24:42,980
database minute system does vertical

1274
00:24:42,980 --> 00:24:42,990

1275
00:24:42,990 --> 00:24:45,110
parallelism right everyone always does

1276
00:24:45,110 --> 00:24:45,120
 

1277
00:24:45,120 --> 00:24:48,170
the the horizontal parallelism where you

1278
00:24:48,170 --> 00:24:48,180

1279
00:24:48,180 --> 00:24:50,830
see this kind of parallelism show up is

1280
00:24:50,830 --> 00:24:50,840
 

1281
00:24:50,840 --> 00:24:53,270
in what are called either stream

1282
00:24:53,270 --> 00:24:53,280
 

1283
00:24:53,280 --> 00:24:55,250
processing systems or continuous query

1284
00:24:55,250 --> 00:24:55,260

1285
00:24:55,260 --> 00:24:58,330
systems think of something like I have a

1286
00:24:58,330 --> 00:24:58,340
 

1287
00:24:58,340 --> 00:25:00,920
have a sequel query I gave it to my

1288
00:25:00,920 --> 00:25:00,930
 

1289
00:25:00,930 --> 00:25:03,110
system and it's just always running

1290
00:25:03,110 --> 00:25:03,120
 

1291
00:25:03,120 --> 00:25:04,850
listening on the stream of stream of

1292
00:25:04,850 --> 00:25:04,860
 

1293
00:25:04,860 --> 00:25:06,890
updates from some outside source like

1294
00:25:06,890 --> 00:25:06,900
 

1295
00:25:06,900 --> 00:25:09,140
think of like caca or something and it's

1296
00:25:09,140 --> 00:25:09,150
 

1297
00:25:09,150 --> 00:25:11,360
just always running and any time a new

1298
00:25:11,360 --> 00:25:11,370
 

1299
00:25:11,370 --> 00:25:12,920
query comes in then it run runs it

1300
00:25:12,920 --> 00:25:12,930
 

1301
00:25:12,930 --> 00:25:16,520
through the pipeline and process it so

1302
00:25:16,520 --> 00:25:16,530
 

1303
00:25:16,530 --> 00:25:19,400
you see his approach used in spark

1304
00:25:19,400 --> 00:25:19,410
 

1305
00:25:19,410 --> 00:25:21,590
streaming knife i cough go storm flank

1306
00:25:21,590 --> 00:25:21,600
 

1307
00:25:21,600 --> 00:25:26,720
and heroine it doesn't make sense in

1308
00:25:26,720 --> 00:25:26,730
 

1309
00:25:26,730 --> 00:25:29,540
sort of an ad-hoc query system because

1310
00:25:29,540 --> 00:25:29,550
 

1311
00:25:29,550 --> 00:25:31,670
the exact thing he said because you're

1312
00:25:31,670 --> 00:25:31,680
 

1313
00:25:31,680 --> 00:25:34,070
the operators above in the tree don't

1314
00:25:34,070 --> 00:25:34,080
 

1315
00:25:34,080 --> 00:25:35,300
are can have any work to do so you're

1316
00:25:35,300 --> 00:25:35,310
 

1317
00:25:35,310 --> 00:25:37,310
basically wasting resources but in a

1318
00:25:37,310 --> 00:25:37,320
 

1319
00:25:37,320 --> 00:25:38,630
continuous query system in a streaming

1320
00:25:38,630 --> 00:25:38,640
 

1321
00:25:38,640 --> 00:25:40,220
system there's data coming in all the

1322
00:25:40,220 --> 00:25:40,230
 

1323
00:25:40,230 --> 00:25:41,630
time so you're always gonna have some

1324
00:25:41,630 --> 00:25:41,640
 

1325
00:25:41,640 --> 00:25:48,220
something to do okay all right so the

1326
00:25:48,220 --> 00:25:48,230
 

1327
00:25:48,230 --> 00:25:50,810
everything we talked about so far has

1328
00:25:50,810 --> 00:25:50,820
 

1329
00:25:50,820 --> 00:25:52,970
been all about how do we take our query

1330
00:25:52,970 --> 00:25:52,980
 

1331
00:25:52,980 --> 00:25:55,940
plan and break it up into subtasks and

1332
00:25:55,940 --> 00:25:55,950
 

1333
00:25:55,950 --> 00:25:57,560
run those subtasks on an additional

1334
00:25:57,560 --> 00:25:57,570
 

1335
00:25:57,570 --> 00:25:59,170
workers additional computational

1336
00:25:59,170 --> 00:25:59,180

1337
00:25:59,180 --> 00:26:01,720
horsepower that we have available to us

1338
00:26:01,720 --> 00:26:01,730
 

1339
00:26:01,730 --> 00:26:04,370
but the obvious problem is gonna be that

1340
00:26:04,370 --> 00:26:04,380
 

1341
00:26:04,380 --> 00:26:06,230
if we had the aggregate data from disk

1342
00:26:06,230 --> 00:26:06,240
 

1343
00:26:06,240 --> 00:26:09,320
then it doesn't matter how many CP cores

1344
00:26:09,320 --> 00:26:09,330
 

1345
00:26:09,330 --> 00:26:11,240
we have the disk always gonna be the

1346
00:26:11,240 --> 00:26:11,250

1347
00:26:11,250 --> 00:26:12,440
main bottleneck because this mean way

1348
00:26:12,440 --> 00:26:12,450
 

1349
00:26:12,450 --> 00:26:15,710
slower than then you know then

1350
00:26:15,710 --> 00:26:15,720

1351
00:26:15,720 --> 00:26:17,570
everything else and actually in some

1352
00:26:17,570 --> 00:26:17,580
 

1353
00:26:17,580 --> 00:26:19,520
cases if we have a lot of threads trying

1354
00:26:19,520 --> 00:26:19,530
 

1355
00:26:19,530 --> 00:26:20,090
to read data

1356
00:26:20,090 --> 00:26:20,100

1357
00:26:20,100 --> 00:26:22,190
disk at the same time then we actually

1358
00:26:22,190 --> 00:26:22,200
 

1359
00:26:22,200 --> 00:26:24,290
get even worse performance because if we

1360
00:26:24,290 --> 00:26:24,300
 

1361
00:26:24,300 --> 00:26:26,390
have a mechanical drive and there's arm

1362
00:26:26,390 --> 00:26:26,400
 

1363
00:26:26,400 --> 00:26:27,530
dripping around these different points

1364
00:26:27,530 --> 00:26:27,540
 

1365
00:26:27,540 --> 00:26:30,020
in the platter and that's gonna be even

1366
00:26:30,020 --> 00:26:30,030
 

1367
00:26:30,030 --> 00:26:34,100
slower so we need to figure out how

1368
00:26:34,100 --> 00:26:34,110
 

1369
00:26:34,110 --> 00:26:38,030
parallel lies our input data or the

1370
00:26:38,030 --> 00:26:38,040
 

1371
00:26:38,040 --> 00:26:39,430
access methods to get data from

1372
00:26:39,430 --> 00:26:39,440
 

1373
00:26:39,440 --> 00:26:41,330
non-volatile storage and bring them to

1374
00:26:41,330 --> 00:26:41,340
 

1375
00:26:41,340 --> 00:26:42,800
our buffer pool as quickly as possible

1376
00:26:42,800 --> 00:26:42,810
 

1377
00:26:42,810 --> 00:26:45,470
so this is what IO parallelism is

1378
00:26:45,470 --> 00:26:45,480
 

1379
00:26:45,480 --> 00:26:47,900
attempting to solve the idea here is

1380
00:26:47,900 --> 00:26:47,910
 

1381
00:26:47,910 --> 00:26:50,050
that we're going to take our database

1382
00:26:50,050 --> 00:26:50,060
 

1383
00:26:50,060 --> 00:26:53,090
management system installation right not

1384
00:26:53,090 --> 00:26:53,100
 

1385
00:26:53,100 --> 00:26:54,890
database itself but actually the system

1386
00:26:54,890 --> 00:26:54,900
 

1387
00:26:54,900 --> 00:26:57,920
installation itself and split up its

1388
00:26:57,920 --> 00:26:57,930
 

1389
00:26:57,930 --> 00:26:59,390
data that is storing across multiple

1390
00:26:59,390 --> 00:26:59,400
 

1391
00:26:59,400 --> 00:27:01,640
storage devices so that we can issue

1392
00:27:01,640 --> 00:27:01,650
 

1393
00:27:01,650 --> 00:27:04,460
these requests in parallel as much

1394
00:27:04,460 --> 00:27:04,470
 

1395
00:27:04,470 --> 00:27:05,540
different ways you can approach this

1396
00:27:05,540 --> 00:27:05,550
 

1397
00:27:05,550 --> 00:27:08,270
right you can take a single database and

1398
00:27:08,270 --> 00:27:08,280
 

1399
00:27:08,280 --> 00:27:09,350
have it be stored on across multiple

1400
00:27:09,350 --> 00:27:09,360

1401
00:27:09,360 --> 00:27:11,990
disks you have one one database per disk

1402
00:27:11,990 --> 00:27:12,000
 

1403
00:27:12,000 --> 00:27:13,790
you could have one relation per disk or

1404
00:27:13,790 --> 00:27:13,800
 

1405
00:27:13,800 --> 00:27:15,350
you can split up the same relation

1406
00:27:15,350 --> 00:27:15,360
 

1407
00:27:15,360 --> 00:27:16,370
across this multiple disk using

1408
00:27:16,370 --> 00:27:16,380
 

1409
00:27:16,380 --> 00:27:21,340
partitioning or sharding alright so the

1410
00:27:21,340 --> 00:27:21,350
 

1411
00:27:21,350 --> 00:27:23,690
easiest way to do this without changing

1412
00:27:23,690 --> 00:27:23,700
 

1413
00:27:23,700 --> 00:27:25,190
any code in our data system is to do

1414
00:27:25,190 --> 00:27:25,200
 

1415
00:27:25,200 --> 00:27:27,410
multi-disc parallelism and this is we

1416
00:27:27,410 --> 00:27:27,420
 

1417
00:27:27,420 --> 00:27:29,150
just configured the hardware or the

1418
00:27:29,150 --> 00:27:29,160
 

1419
00:27:29,160 --> 00:27:31,910
operating system to take multiple

1420
00:27:31,910 --> 00:27:31,920
 

1421
00:27:31,920 --> 00:27:34,190
drawers and also disks and then have

1422
00:27:34,190 --> 00:27:34,200
 

1423
00:27:34,200 --> 00:27:38,630
them appear as a single logical disk to

1424
00:27:38,630 --> 00:27:38,640
 

1425
00:27:38,640 --> 00:27:40,850
the database system so the data set our

1426
00:27:40,850 --> 00:27:40,860
 

1427
00:27:40,860 --> 00:27:42,620
data system Co doesn't know that we're

1428
00:27:42,620 --> 00:27:42,630
 

1429
00:27:42,630 --> 00:27:46,040
doing that were when we do a write or a

1430
00:27:46,040 --> 00:27:46,050
 

1431
00:27:46,050 --> 00:27:48,140
read to Ardis device that it's actually

1432
00:27:48,140 --> 00:27:48,150
 

1433
00:27:48,150 --> 00:27:49,340
multiple use devices that could be

1434
00:27:49,340 --> 00:27:49,350
 

1435
00:27:49,350 --> 00:27:51,530
servicing our request just to also looks

1436
00:27:51,530 --> 00:27:51,540
 

1437
00:27:51,540 --> 00:27:54,830
like a single device so we can get this

1438
00:27:54,830 --> 00:27:54,840
 

1439
00:27:54,840 --> 00:27:56,270
through our storage appliance right if

1440
00:27:56,270 --> 00:27:56,280
 

1441
00:27:56,280 --> 00:27:57,560
you buy sends a box that has multiple

1442
00:27:57,560 --> 00:27:57,570
 

1443
00:27:57,570 --> 00:28:00,260
drives together and do this for you or

1444
00:28:00,260 --> 00:28:00,270
 

1445
00:28:00,270 --> 00:28:02,480
you can do this through using raid right

1446
00:28:02,480 --> 00:28:02,490
 

1447
00:28:02,490 --> 00:28:04,340
every everyone here should have heard of

1448
00:28:04,340 --> 00:28:04,350
 

1449
00:28:04,350 --> 00:28:07,190
raid before right good ok so the basic

1450
00:28:07,190 --> 00:28:07,200
 

1451
00:28:07,200 --> 00:28:10,610
idea raid is is is you want to make a

1452
00:28:10,610 --> 00:28:10,620
 

1453
00:28:10,620 --> 00:28:12,470
bunch of cheap devices or not cheap much

1454
00:28:12,470 --> 00:28:12,480
 

1455
00:28:12,480 --> 00:28:14,090
much of independent storage devices

1456
00:28:14,090 --> 00:28:14,100
 

1457
00:28:14,100 --> 00:28:17,030
appear as a single single device and the

1458
00:28:17,030 --> 00:28:17,040
 

1459
00:28:17,040 --> 00:28:18,950
two most common ways to do this are raid

1460
00:28:18,950 --> 00:28:18,960
 

1461
00:28:18,960 --> 00:28:21,380
0 which is striping where this is we

1462
00:28:21,380 --> 00:28:21,390
 

1463
00:28:21,390 --> 00:28:24,500
have three different devices and six

1464
00:28:24,500 --> 00:28:24,510
 

1465
00:28:24,510 --> 00:28:26,180
different pages and each device is just

1466
00:28:26,180 --> 00:28:26,190
 

1467
00:28:26,190 --> 00:28:30,800
in charge of abstruse so now what my

1468
00:28:30,800 --> 00:28:30,810
 

1469
00:28:30,810 --> 00:28:32,030
request shows up from a database

1470
00:28:32,030 --> 00:28:32,040
 

1471
00:28:32,040 --> 00:28:33,980
estimate says give me page 1

1472
00:28:33,980 --> 00:28:33,990
 

1473
00:28:33,990 --> 00:28:35,749
there's some controller or the operating

1474
00:28:35,749 --> 00:28:35,759
 

1475
00:28:35,759 --> 00:28:37,340
system knows that here's the device that

1476
00:28:37,340 --> 00:28:37,350
 

1477
00:28:37,350 --> 00:28:38,720
actually has the data that you want to

1478
00:28:38,720 --> 00:28:38,730
 

1479
00:28:38,730 --> 00:28:42,259
go get it all right the alternative is

1480
00:28:42,259 --> 00:28:42,269
 

1481
00:28:42,269 --> 00:28:44,779
to do raid raid 1 or mirroring where

1482
00:28:44,779 --> 00:28:44,789
 

1483
00:28:44,789 --> 00:28:47,060
each now device has a complete copy of

1484
00:28:47,060 --> 00:28:47,070
 

1485
00:28:47,070 --> 00:28:49,340
the database and so now when I want to

1486
00:28:49,340 --> 00:28:49,350
 

1487
00:28:49,350 --> 00:28:51,710
do a read for page 1 any one of these

1488
00:28:51,710 --> 00:28:51,720
 

1489
00:28:51,720 --> 00:28:54,230
three devices can service me so now if

1490
00:28:54,230 --> 00:28:54,240
 

1491
00:28:54,240 --> 00:28:55,879
you have you know one guys reading page

1492
00:28:55,879 --> 00:28:55,889
 

1493
00:28:55,889 --> 00:28:58,039
one well guys reading page two you can

1494
00:28:58,039 --> 00:28:58,049
 

1495
00:28:58,049 --> 00:29:00,619
have one device you hit a one request

1496
00:29:00,619 --> 00:29:00,629
 

1497
00:29:00,629 --> 00:29:02,320
one device Hannah or another request

1498
00:29:02,320 --> 00:29:02,330
 

1499
00:29:02,330 --> 00:29:04,399
again the key thing here is that this is

1500
00:29:04,399 --> 00:29:04,409
 

1501
00:29:04,409 --> 00:29:06,409
all transparent to the database system

1502
00:29:06,409 --> 00:29:06,419
 

1503
00:29:06,419 --> 00:29:08,359
we don't know anything about these

1504
00:29:08,359 --> 00:29:08,369
 

1505
00:29:08,369 --> 00:29:09,109
things being stored in different

1506
00:29:09,109 --> 00:29:09,119
 

1507
00:29:09,119 --> 00:29:10,879
locations we just know that there's this

1508
00:29:10,879 --> 00:29:10,889
 

1509
00:29:10,889 --> 00:29:13,039
one file or one one table heap we can

1510
00:29:13,039 --> 00:29:13,049

1511
00:29:13,049 --> 00:29:17,330
read and write from if we now start

1512
00:29:17,330 --> 00:29:17,340
 

1513
00:29:17,340 --> 00:29:18,769
moving each our data system and say well

1514
00:29:18,769 --> 00:29:18,779
 

1515
00:29:18,779 --> 00:29:20,149
what can we actually do to make things

1516
00:29:20,149 --> 00:29:20,159
 

1517
00:29:20,159 --> 00:29:21,560
run faster by controlling where this

1518
00:29:21,560 --> 00:29:21,570
 

1519
00:29:21,570 --> 00:29:23,330
data is actually stored right this is

1520
00:29:23,330 --> 00:29:23,340
 

1521
00:29:23,340 --> 00:29:26,840
called data as partitioning and the idea

1522
00:29:26,840 --> 00:29:26,850
 

1523
00:29:26,850 --> 00:29:27,950
here memory talk about the page

1524
00:29:27,950 --> 00:29:27,960
 

1525
00:29:27,960 --> 00:29:29,600
directory would maintain information

1526
00:29:29,600 --> 00:29:29,610
 

1527
00:29:29,610 --> 00:29:32,570
about for given page or a table heap

1528
00:29:32,570 --> 00:29:32,580
 

1529
00:29:32,580 --> 00:29:34,970
what file or what directory would that

1530
00:29:34,970 --> 00:29:34,980
 

1531
00:29:34,980 --> 00:29:36,919
was that data actually being stored this

1532
00:29:36,919 --> 00:29:36,929
 

1533
00:29:36,929 --> 00:29:38,090
is where we can start to do this you

1534
00:29:38,090 --> 00:29:38,100
 

1535
00:29:38,100 --> 00:29:39,680
know take advantage of different devices

1536
00:29:39,680 --> 00:29:39,690
 

1537
00:29:39,690 --> 00:29:43,190
at that level all right so the idea here

1538
00:29:43,190 --> 00:29:43,200
 

1539
00:29:43,200 --> 00:29:47,779
is that we when we go fit to page we do

1540
00:29:47,779 --> 00:29:47,789
 

1541
00:29:47,789 --> 00:29:50,239
some lookup and figure out what what

1542
00:29:50,239 --> 00:29:50,249

1543
00:29:50,249 --> 00:29:53,269
device actually has our page and then we

1544
00:29:53,269 --> 00:29:53,279
 

1545
00:29:53,279 --> 00:29:54,529
can multiplex them and be smart about

1546
00:29:54,529 --> 00:29:54,539

1547
00:29:54,539 --> 00:29:56,210
storing different data that's maybe used

1548
00:29:56,210 --> 00:29:56,220
 

1549
00:29:56,220 --> 00:29:58,070
together often on different pages so

1550
00:29:58,070 --> 00:29:58,080
 

1551
00:29:58,080 --> 00:29:59,419
that we're not trying to saturate this

1552
00:29:59,419 --> 00:29:59,429
 

1553
00:29:59,429 --> 00:30:02,029
single duplex there are some tricky

1554
00:30:02,029 --> 00:30:02,039
 

1555
00:30:02,039 --> 00:30:03,169
things we have to handle in this

1556
00:30:03,169 --> 00:30:03,179
 

1557
00:30:03,179 --> 00:30:04,609
environment we won't talk about logging

1558
00:30:04,609 --> 00:30:04,619
 

1559
00:30:04,619 --> 00:30:07,970
just just yet but now we have the

1560
00:30:07,970 --> 00:30:07,980
 

1561
00:30:07,980 --> 00:30:10,279
problem of say I'm modifying data on two

1562
00:30:10,279 --> 00:30:10,289
 

1563
00:30:10,289 --> 00:30:11,989
different storage devices where do I

1564
00:30:11,989 --> 00:30:11,999
 

1565
00:30:11,999 --> 00:30:13,430
actually put the log keep track of what

1566
00:30:13,430 --> 00:30:13,440

1567
00:30:13,440 --> 00:30:16,100
those changes are and there's a bunch of

1568
00:30:16,100 --> 00:30:16,110
 

1569
00:30:16,110 --> 00:30:17,509
are things we can cover let me talk

1570
00:30:17,509 --> 00:30:17,519
 

1571
00:30:17,519 --> 00:30:20,720
about logging later in the semester so

1572
00:30:20,720 --> 00:30:20,730
 

1573
00:30:20,730 --> 00:30:22,879
partitioning or table partitioning the

1574
00:30:22,879 --> 00:30:22,889
 

1575
00:30:22,889 --> 00:30:25,340
idea here is that we're going to split a

1576
00:30:25,340 --> 00:30:25,350
 

1577
00:30:25,350 --> 00:30:27,590
single logical table into these disjoint

1578
00:30:27,590 --> 00:30:27,600
 

1579
00:30:27,600 --> 00:30:29,659
subsets or segments that we can then

1580
00:30:29,659 --> 00:30:29,669
 

1581
00:30:29,669 --> 00:30:31,639
store and manage separately in different

1582
00:30:31,639 --> 00:30:31,649
 

1583
00:30:31,649 --> 00:30:32,930
locations on different disks

1584
00:30:32,930 --> 00:30:32,940
 

1585
00:30:32,940 --> 00:30:35,450
so again ideally we want this be

1586
00:30:35,450 --> 00:30:35,460
 

1587
00:30:35,460 --> 00:30:37,879
transparent to the application we don't

1588
00:30:37,879 --> 00:30:37,889
 

1589
00:30:37,889 --> 00:30:40,310
want that right we don't this have the

1590
00:30:40,310 --> 00:30:40,320
 

1591
00:30:40,320 --> 00:30:42,320
user rights equal statements that that

1592
00:30:42,320 --> 00:30:42,330

1593
00:30:42,330 --> 00:30:44,060
are designed to go to the door device

1594
00:30:44,060 --> 00:30:44,070
 

1595
00:30:44,070 --> 00:30:45,590
because that way we can move things

1596
00:30:45,590 --> 00:30:45,600
 

1597
00:30:45,600 --> 00:30:46,669
around or Neath the covers without

1598
00:30:46,669 --> 00:30:46,679
 

1599
00:30:46,679 --> 00:30:47,720
anything

1600
00:30:47,720 --> 00:30:47,730

1601
00:30:47,730 --> 00:30:50,090
making any changes to our application so

1602
00:30:50,090 --> 00:30:50,100
 

1603
00:30:50,100 --> 00:30:52,010
most the time when people like this pie

1604
00:30:52,010 --> 00:30:52,020
 

1605
00:30:52,020 --> 00:30:53,630
still common but a lot of times people

1606
00:30:53,630 --> 00:30:53,640
 

1607
00:30:53,640 --> 00:30:55,550
start off using my sequel and they hit

1608
00:30:55,550 --> 00:30:55,560
 

1609
00:30:55,560 --> 00:30:56,480
the limit what they can do with my

1610
00:30:56,480 --> 00:30:56,490

1611
00:30:56,490 --> 00:30:58,340
sequel in a single box so they end up

1612
00:30:58,340 --> 00:30:58,350
 

1613
00:30:58,350 --> 00:30:59,660
doing what is called sharding where they

1614
00:30:59,660 --> 00:30:59,670
 

1615
00:30:59,670 --> 00:31:01,460
have this middleware layer that can

1616
00:31:01,460 --> 00:31:01,470

1617
00:31:01,470 --> 00:31:02,990
route queries to the actual storage

1618
00:31:02,990 --> 00:31:03,000
 

1619
00:31:03,000 --> 00:31:04,700
device that has the data they want to my

1620
00:31:04,700 --> 00:31:04,710
 

1621
00:31:04,710 --> 00:31:05,720
sequel installation that has what they

1622
00:31:05,720 --> 00:31:05,730
 

1623
00:31:05,730 --> 00:31:06,110
want

1624
00:31:06,110 --> 00:31:06,120

1625
00:31:06,120 --> 00:31:07,910
like Facebook is the most famous one for

1626
00:31:07,910 --> 00:31:07,920
 

1627
00:31:07,920 --> 00:31:10,040
doing this Google used to do this as

1628
00:31:10,040 --> 00:31:10,050
 

1629
00:31:10,050 --> 00:31:13,130
well ideally we don't want to have to

1630
00:31:13,130 --> 00:31:13,140
 

1631
00:31:13,140 --> 00:31:14,780
have that application code or middleware

1632
00:31:14,780 --> 00:31:14,790
 

1633
00:31:14,790 --> 00:31:16,460
of write ourselves we want the data

1634
00:31:16,460 --> 00:31:16,470
 

1635
00:31:16,470 --> 00:31:18,310
system to do this for us automatically

1636
00:31:18,310 --> 00:31:18,320
 

1637
00:31:18,320 --> 00:31:20,870
right and some some systems can actually

1638
00:31:20,870 --> 00:31:20,880
 

1639
00:31:20,880 --> 00:31:23,570
do this other ones cannot so there's two

1640
00:31:23,570 --> 00:31:23,580
 

1641
00:31:23,580 --> 00:31:25,760
types of partitioning we can do again

1642
00:31:25,760 --> 00:31:25,770
 

1643
00:31:25,770 --> 00:31:27,260
we'll cover this more in detail when we

1644
00:31:27,260 --> 00:31:27,270
 

1645
00:31:27,270 --> 00:31:29,150
talk about des tributed databases but

1646
00:31:29,150 --> 00:31:29,160
 

1647
00:31:29,160 --> 00:31:31,790
the high level idea is still the same so

1648
00:31:31,790 --> 00:31:31,800
 

1649
00:31:31,800 --> 00:31:33,320
this first called vertical partitioning

1650
00:31:33,320 --> 00:31:33,330

1651
00:31:33,330 --> 00:31:35,840
is that we're gonna split the tables

1652
00:31:35,840 --> 00:31:35,850
 

1653
00:31:35,850 --> 00:31:38,600
attributes into different locations or

1654
00:31:38,600 --> 00:31:38,610
 

1655
00:31:38,610 --> 00:31:40,430
different files in different storage

1656
00:31:40,430 --> 00:31:40,440
 

1657
00:31:40,440 --> 00:31:43,490
devices and whenever we need to get all

1658
00:31:43,490 --> 00:31:43,500
 

1659
00:31:43,500 --> 00:31:44,870
the data we need to reconstruct the

1660
00:31:44,870 --> 00:31:44,880
 

1661
00:31:44,880 --> 00:31:46,610
tuple we know how to do fetches through

1662
00:31:46,610 --> 00:31:46,620
 

1663
00:31:46,620 --> 00:31:48,980
to those different locations all right

1664
00:31:48,980 --> 00:31:48,990
 

1665
00:31:48,990 --> 00:31:51,080
so say in this case here accurate before

1666
00:31:51,080 --> 00:31:51,090
 

1667
00:31:51,090 --> 00:31:53,060
is really big and the other three

1668
00:31:53,060 --> 00:31:53,070
 

1669
00:31:53,070 --> 00:31:55,040
attributes are small so maybe what we'll

1670
00:31:55,040 --> 00:31:55,050
 

1671
00:31:55,050 --> 00:31:57,770
do is have all this data here stored in

1672
00:31:57,770 --> 00:31:57,780
 

1673
00:31:57,780 --> 00:31:59,750
one partition and then the remaining

1674
00:31:59,750 --> 00:31:59,760
 

1675
00:31:59,760 --> 00:32:00,800
three attributes are stored in another

1676
00:32:00,800 --> 00:32:00,810
 

1677
00:32:00,810 --> 00:32:02,870
partition and then any query that I

1678
00:32:02,870 --> 00:32:02,880
 

1679
00:32:02,880 --> 00:32:05,150
write against this table knows how to

1680
00:32:05,150 --> 00:32:05,160

1681
00:32:05,160 --> 00:32:07,850
stitch these things back together what

1682
00:32:07,850 --> 00:32:07,860
 

1683
00:32:07,860 --> 00:32:11,630
does this sound like we talked about

1684
00:32:11,630 --> 00:32:11,640
 

1685
00:32:11,640 --> 00:32:15,350
this before columnstore right same idea

1686
00:32:15,350 --> 00:32:15,360
 

1687
00:32:15,360 --> 00:32:19,130
right this is actually a very common

1688
00:32:19,130 --> 00:32:19,140
 

1689
00:32:19,140 --> 00:32:20,960
approach actually Wikipedia uses this

1690
00:32:20,960 --> 00:32:20,970
 

1691
00:32:20,970 --> 00:32:22,940
right Wikipedia has the for all your

1692
00:32:22,940 --> 00:32:22,950
 

1693
00:32:22,950 --> 00:32:24,740
revisions you have the text the revision

1694
00:32:24,740 --> 00:32:24,750
 

1695
00:32:24,750 --> 00:32:26,030
you have the metadata about the

1696
00:32:26,030 --> 00:32:26,040
 

1697
00:32:26,040 --> 00:32:27,800
provision they actually store them and

1698
00:32:27,800 --> 00:32:27,810

1699
00:32:27,810 --> 00:32:29,300
actually separate tables and essentially

1700
00:32:29,300 --> 00:32:29,310
 

1701
00:32:29,310 --> 00:32:31,100
it is doing vertical partition it's sort

1702
00:32:31,100 --> 00:32:31,110
 

1703
00:32:31,110 --> 00:32:35,060
of like a poor man's column store what

1704
00:32:35,060 --> 00:32:35,070
 

1705
00:32:35,070 --> 00:32:36,440
most people think about when we talk

1706
00:32:36,440 --> 00:32:36,450
 

1707
00:32:36,450 --> 00:32:39,080
about partitioning is usually what is

1708
00:32:39,080 --> 00:32:39,090
 

1709
00:32:39,090 --> 00:32:40,760
called horizontal partitioning or if

1710
00:32:40,760 --> 00:32:40,770
 

1711
00:32:40,770 --> 00:32:41,930
you're coming from a no sequel system

1712
00:32:41,930 --> 00:32:41,940
 

1713
00:32:41,940 --> 00:32:43,940
this is what they call charting the idea

1714
00:32:43,940 --> 00:32:43,950
 

1715
00:32:43,950 --> 00:32:46,640
is that we're going to take all the

1716
00:32:46,640 --> 00:32:46,650
 

1717
00:32:46,650 --> 00:32:48,260
attributes of a single tuple and store

1718
00:32:48,260 --> 00:32:48,270
 

1719
00:32:48,270 --> 00:32:49,730
them in a single location but we're

1720
00:32:49,730 --> 00:32:49,740
 

1721
00:32:49,740 --> 00:32:51,920
going to split up what you know what

1722
00:32:51,920 --> 00:32:51,930
 

1723
00:32:51,930 --> 00:32:53,900
tuples are stored in what location right

1724
00:32:53,900 --> 00:32:53,910
 

1725
00:32:53,910 --> 00:32:55,340
so in this case here we have four tuples

1726
00:32:55,340 --> 00:32:55,350
 

1727
00:32:55,350 --> 00:32:57,890
we'll put two tuples in partition two

1728
00:32:57,890 --> 00:32:57,900
 

1729
00:32:57,900 --> 00:33:00,520
and two tuples in partition one and

1730
00:33:00,520 --> 00:33:00,530
 

1731
00:33:00,530 --> 00:33:02,110
then we have some additional information

1732
00:33:02,110 --> 00:33:02,120
 

1733
00:33:02,120 --> 00:33:04,030
inside our system when a query shows up

1734
00:33:04,030 --> 00:33:04,040
 

1735
00:33:04,040 --> 00:33:07,030
and says oh I want data at for this key

1736
00:33:07,030 --> 00:33:07,040
 

1737
00:33:07,040 --> 00:33:09,880
I know how to go to the right partition

1738
00:33:09,880 --> 00:33:09,890
 

1739
00:33:09,890 --> 00:33:11,920
to get that data that I want again we

1740
00:33:11,920 --> 00:33:11,930
 

1741
00:33:11,930 --> 00:33:13,480
can store these two different partitions

1742
00:33:13,480 --> 00:33:13,490

1743
00:33:13,490 --> 00:33:15,820
on different files on disk and different

1744
00:33:15,820 --> 00:33:15,830

1745
00:33:15,830 --> 00:33:17,380
storage devices or even different

1746
00:33:17,380 --> 00:33:17,390
 

1747
00:33:17,390 --> 00:33:21,730
machines right and so the way you can

1748
00:33:21,730 --> 00:33:21,740
 

1749
00:33:21,740 --> 00:33:23,950
split this up will come out later is you

1750
00:33:23,950 --> 00:33:23,960
 

1751
00:33:23,960 --> 00:33:25,540
can just do simple things like take a

1752
00:33:25,540 --> 00:33:25,550
 

1753
00:33:25,550 --> 00:33:27,460
single attribute and hash it and that

1754
00:33:27,460 --> 00:33:27,470
 

1755
00:33:27,470 --> 00:33:28,750
decides what partition you're gonna go

1756
00:33:28,750 --> 00:33:28,760

1757
00:33:28,760 --> 00:33:30,850
to you can do range partitioning or

1758
00:33:30,850 --> 00:33:30,860
 

1759
00:33:30,860 --> 00:33:32,200
predicate partitioning or more

1760
00:33:32,200 --> 00:33:32,210
 

1761
00:33:32,210 --> 00:33:34,120
complicated things different data

1762
00:33:34,120 --> 00:33:34,130
 

1763
00:33:34,130 --> 00:33:35,890
systems do different things and

1764
00:33:35,890 --> 00:33:35,900
 

1765
00:33:35,900 --> 00:33:36,970
different workloads want different

1766
00:33:36,970 --> 00:33:36,980
 

1767
00:33:36,980 --> 00:33:37,540
things

1768
00:33:37,540 --> 00:33:37,550
 

1769
00:33:37,550 --> 00:33:39,160
so for OLTP when you're doing like

1770
00:33:39,160 --> 00:33:39,170
 

1771
00:33:39,170 --> 00:33:40,510
single key lookups hash partitioning

1772
00:33:40,510 --> 00:33:40,520
 

1773
00:33:40,520 --> 00:33:42,310
works great because you just take

1774
00:33:42,310 --> 00:33:42,320
 

1775
00:33:42,320 --> 00:33:43,480
whatever key they're looking up hasha

1776
00:33:43,480 --> 00:33:43,490
 

1777
00:33:43,490 --> 00:33:44,620
and that tells you what partition of go

1778
00:33:44,620 --> 00:33:44,630
 

1779
00:33:44,630 --> 00:33:47,470
to for doing oh that queries then that

1780
00:33:47,470 --> 00:33:47,480
 

1781
00:33:47,480 --> 00:33:50,980
may not be the right thing to do ok I'm

1782
00:33:50,980 --> 00:33:50,990
 

1783
00:33:50,990 --> 00:33:52,150
sort of rushing for this but I think a

1784
00:33:52,150 --> 00:33:52,160
 

1785
00:33:52,160 --> 00:33:54,100
high-level idea it should be pretty

1786
00:33:54,100 --> 00:33:54,110
 

1787
00:33:54,110 --> 00:33:57,340
straightforward right so parallel

1788
00:33:57,340 --> 00:33:57,350
 

1789
00:33:57,350 --> 00:33:59,110
execution is important almost every

1790
00:33:59,110 --> 00:33:59,120
 

1791
00:33:59,120 --> 00:34:00,430
single davison will actually do this and

1792
00:34:00,430 --> 00:34:00,440
 

1793
00:34:00,440 --> 00:34:03,730
all the stuff I glossed over in a big

1794
00:34:03,730 --> 00:34:03,740
 

1795
00:34:03,740 --> 00:34:05,290
way like how to coordinate different

1796
00:34:05,290 --> 00:34:05,300
 

1797
00:34:05,300 --> 00:34:07,180
thread has scheduled their operations

1798
00:34:07,180 --> 00:34:07,190
 

1799
00:34:07,190 --> 00:34:09,460
well some of this will cover in next

1800
00:34:09,460 --> 00:34:09,470
 

1801
00:34:09,470 --> 00:34:10,570
week we talked about convergence retool

1802
00:34:10,570 --> 00:34:10,580
 

1803
00:34:10,580 --> 00:34:12,760
and some of us will cover in the

1804
00:34:12,760 --> 00:34:12,770
 

1805
00:34:12,770 --> 00:34:18,399
advanced class alright so next class on

1806
00:34:18,399 --> 00:34:18,409
 

1807
00:34:18,409 --> 00:34:20,560
Wednesday it's sort of a potpourri

1808
00:34:20,560 --> 00:34:20,570
 

1809
00:34:20,570 --> 00:34:22,659
lecture we'll talk about different ways

1810
00:34:22,659 --> 00:34:22,669
 

1811
00:34:22,669 --> 00:34:24,340
to embed logic inside our database

1812
00:34:24,340 --> 00:34:24,350
 

1813
00:34:24,350 --> 00:34:26,649
system to make it do more complicated

1814
00:34:26,649 --> 00:34:26,659
 

1815
00:34:26,659 --> 00:34:28,600
things than we can do just through

1816
00:34:28,600 --> 00:34:28,610
 

1817
00:34:28,610 --> 00:34:30,669
sequel so talk about stored procedures

1818
00:34:30,669 --> 00:34:30,679

1819
00:34:30,679 --> 00:34:31,810
used around function whose triggers

1820
00:34:31,810 --> 00:34:31,820
 

1821
00:34:31,820 --> 00:34:34,360
views are the idea here is that going to

1822
00:34:34,360 --> 00:34:34,370
 

1823
00:34:34,370 --> 00:34:36,730
be instead of having all the logic for

1824
00:34:36,730 --> 00:34:36,740
 

1825
00:34:36,740 --> 00:34:37,630
our application inside of our

1826
00:34:37,630 --> 00:34:37,640
 

1827
00:34:37,640 --> 00:34:39,460
application we can push some of this

1828
00:34:39,460 --> 00:34:39,470
 

1829
00:34:39,470 --> 00:34:41,560
inside our database system and have that

1830
00:34:41,560 --> 00:34:41,570
 

1831
00:34:41,570 --> 00:34:42,850
run more efficiently there because we're

1832
00:34:42,850 --> 00:34:42,860

1833
00:34:42,860 --> 00:34:44,200
closer to the data I mean we don't have

1834
00:34:44,200 --> 00:34:44,210
 

1835
00:34:44,210 --> 00:34:48,159
to go back and forth ok all right so in

1836
00:34:48,159 --> 00:34:48,169
 

1837
00:34:48,169 --> 00:34:49,600
the last three minutes I want to talk

1838
00:34:49,600 --> 00:34:49,610
 

1839
00:34:49,610 --> 00:34:53,050
about the extra credit assignment so yes

1840
00:34:53,050 --> 00:34:53,060

1841
00:34:53,060 --> 00:34:54,430
you're doing for extra credit is that

1842
00:34:54,430 --> 00:34:54,440
 

1843
00:34:54,440 --> 00:34:58,210
you can earn 10% and in your final grade

1844
00:34:58,210 --> 00:34:58,220
 

1845
00:34:58,220 --> 00:35:01,300
if you write an article for a online

1846
00:35:01,300 --> 00:35:01,310
 

1847
00:35:01,310 --> 00:35:03,030
encyclopedia that we been working on

1848
00:35:03,030 --> 00:35:03,040
 

1849
00:35:03,040 --> 00:35:07,660
called the databases of databases so the

1850
00:35:07,660 --> 00:35:07,670
 

1851
00:35:07,670 --> 00:35:09,790
idea is that we want to write a sort of

1852
00:35:09,790 --> 00:35:09,800
 

1853
00:35:09,800 --> 00:35:12,850
an academic style technical article

1854
00:35:12,850 --> 00:35:12,860
 

1855
00:35:12,860 --> 00:35:14,290
about one particular

1856
00:35:14,290 --> 00:35:14,300
 

1857
00:35:14,300 --> 00:35:18,270
a system pick whatever one you want and

1858
00:35:18,270 --> 00:35:18,280
 

1859
00:35:18,280 --> 00:35:21,430
you revise citations about you know how

1860
00:35:21,430 --> 00:35:21,440
 

1861
00:35:21,440 --> 00:35:23,020
to explain how it's actually implemented

1862
00:35:23,020 --> 00:35:23,030
 

1863
00:35:23,030 --> 00:35:24,670
what's going on on the inside all right

1864
00:35:24,670 --> 00:35:24,680
 

1865
00:35:24,680 --> 00:35:26,380
so I don't care about you know sort of

1866
00:35:26,380 --> 00:35:26,390
 

1867
00:35:26,390 --> 00:35:28,630
marketing things to say oh it's fast I

1868
00:35:28,630 --> 00:35:28,640
 

1869
00:35:28,640 --> 00:35:29,890
really care about how does it actually

1870
00:35:29,890 --> 00:35:29,900

1871
00:35:29,900 --> 00:35:31,690
implement converged scroll has it

1872
00:35:31,690 --> 00:35:31,700
 

1873
00:35:31,700 --> 00:35:33,670
actually implement logging or indexes or

1874
00:35:33,670 --> 00:35:33,680
 

1875
00:35:33,680 --> 00:35:35,560
buffer pool management the things we

1876
00:35:35,560 --> 00:35:35,570

1877
00:35:35,570 --> 00:35:37,360
talked about in some course that's the

1878
00:35:37,360 --> 00:35:37,370
 

1879
00:35:37,370 --> 00:35:39,630
kind of stuff I want in in this article

1880
00:35:39,630 --> 00:35:39,640
 

1881
00:35:39,640 --> 00:35:43,840
so the website is DB d DB DB IO

1882
00:35:43,840 --> 00:35:43,850
 

1883
00:35:43,850 --> 00:35:46,570
right so I'm currently aware of five

1884
00:35:46,570 --> 00:35:46,580
 

1885
00:35:46,580 --> 00:35:47,710
hundred and sixty different database

1886
00:35:47,710 --> 00:35:47,720
 

1887
00:35:47,720 --> 00:35:49,990
systems and there's like a search panel

1888
00:35:49,990 --> 00:35:50,000

1889
00:35:50,000 --> 00:35:51,250
to say you know show me all the

1890
00:35:51,250 --> 00:35:51,260

1891
00:35:51,260 --> 00:35:53,020
different database systems that are that

1892
00:35:53,020 --> 00:35:53,030
 

1893
00:35:53,030 --> 00:35:55,090
use two phase locking or use B plus

1894
00:35:55,090 --> 00:35:55,100
 

1895
00:35:55,100 --> 00:35:57,280
trees and then for each of them though

1896
00:35:57,280 --> 00:35:57,290
 

1897
00:35:57,290 --> 00:35:58,780
we an article that sort of summarizes

1898
00:35:58,780 --> 00:35:58,790
 

1899
00:35:58,790 --> 00:36:01,420
the major points about about their

1900
00:36:01,420 --> 00:36:01,430
 

1901
00:36:01,430 --> 00:36:05,620
implementation right so the way this is

1902
00:36:05,620 --> 00:36:05,630
 

1903
00:36:05,630 --> 00:36:06,910
going to work is I'm going to post on

1904
00:36:06,910 --> 00:36:06,920
 

1905
00:36:06,920 --> 00:36:11,010
Piazza a sign up page a spreadsheet on

1906
00:36:11,010 --> 00:36:11,020
 

1907
00:36:11,020 --> 00:36:14,020
um Google Docs pick whatever gave you

1908
00:36:14,020 --> 00:36:14,030
 

1909
00:36:14,030 --> 00:36:16,240
some you want to write about I'll have a

1910
00:36:16,240 --> 00:36:16,250
 

1911
00:36:16,250 --> 00:36:17,350
list of ones where we already have

1912
00:36:17,350 --> 00:36:17,360
 

1913
00:36:17,360 --> 00:36:18,730
articles from previous years so you

1914
00:36:18,730 --> 00:36:18,740
 

1915
00:36:18,740 --> 00:36:22,840
can't choose those and then you know if

1916
00:36:22,840 --> 00:36:22,850
 

1917
00:36:22,850 --> 00:36:25,060
it's I'll help you sort of guide you to

1918
00:36:25,060 --> 00:36:25,070
 

1919
00:36:25,070 --> 00:36:27,490
say here's here's what I expect for what

1920
00:36:27,490 --> 00:36:27,500
 

1921
00:36:27,500 --> 00:36:28,870
you need to fill out for a complete

1922
00:36:28,870 --> 00:36:28,880
 

1923
00:36:28,880 --> 00:36:30,160
article right if you pick something

1924
00:36:30,160 --> 00:36:30,170
 

1925
00:36:30,170 --> 00:36:34,060
super common like Oracle then there's

1926
00:36:34,060 --> 00:36:34,070
 

1927
00:36:34,070 --> 00:36:35,350
been a ton of information about this so

1928
00:36:35,350 --> 00:36:35,360
 

1929
00:36:35,360 --> 00:36:36,750
I expect the article to be very

1930
00:36:36,750 --> 00:36:36,760
 

1931
00:36:36,760 --> 00:36:39,520
comprehensive and complete if you pick

1932
00:36:39,520 --> 00:36:39,530
 

1933
00:36:39,530 --> 00:36:42,010
an obscure one that no one's ever heard

1934
00:36:42,010 --> 00:36:42,020
 

1935
00:36:42,020 --> 00:36:45,010
of that's defunct then you may have a

1936
00:36:45,010 --> 00:36:45,020
 

1937
00:36:45,020 --> 00:36:46,210
hard time finding information and that's

1938
00:36:46,210 --> 00:36:46,220
 

1939
00:36:46,220 --> 00:36:49,690
okay but you know we want to know this

1940
00:36:49,690 --> 00:36:49,700
 

1941
00:36:49,700 --> 00:36:51,340
ahead of time Savina you know set your

1942
00:36:51,340 --> 00:36:51,350
 

1943
00:36:51,350 --> 00:36:54,130
expectations for how much work is gonna

1944
00:36:54,130 --> 00:36:54,140
 

1945
00:36:54,140 --> 00:36:58,390
take you to do this so it's it's up to

1946
00:36:58,390 --> 00:36:58,400
 

1947
00:36:58,400 --> 00:37:00,220
you to pick whatever database system you

1948
00:37:00,220 --> 00:37:00,230
 

1949
00:37:00,230 --> 00:37:03,160
want right as I said I am personally

1950
00:37:03,160 --> 00:37:03,170
 

1951
00:37:03,170 --> 00:37:05,260
aware of five hundred and sixty

1952
00:37:05,260 --> 00:37:05,270
 

1953
00:37:05,270 --> 00:37:06,970
different database systems so you will

1954
00:37:06,970 --> 00:37:06,980
 

1955
00:37:06,980 --> 00:37:08,530
have no problem finding a database

1956
00:37:08,530 --> 00:37:08,540
 

1957
00:37:08,540 --> 00:37:09,760
system that a hat that will be

1958
00:37:09,760 --> 00:37:09,770
 

1959
00:37:09,770 --> 00:37:11,740
interesting to you right do you care

1960
00:37:11,740 --> 00:37:11,750
 

1961
00:37:11,750 --> 00:37:13,240
about graph databases do you care about

1962
00:37:13,240 --> 00:37:13,250
 

1963
00:37:13,250 --> 00:37:14,440
distributed databases do you care about

1964
00:37:14,440 --> 00:37:14,450
 

1965
00:37:14,450 --> 00:37:15,940
in-memory databases do you care about

1966
00:37:15,940 --> 00:37:15,950
 

1967
00:37:15,950 --> 00:37:18,310
databases written in China do you care

1968
00:37:18,310 --> 00:37:18,320
 

1969
00:37:18,320 --> 00:37:20,680
about databases that are in the US right

1970
00:37:20,680 --> 00:37:20,690
 

1971
00:37:20,690 --> 00:37:22,240
I try to annotate all these different

1972
00:37:22,240 --> 00:37:22,250
 

1973
00:37:22,250 --> 00:37:24,310
systems you can just go and pick

1974
00:37:24,310 --> 00:37:24,320
 

1975
00:37:24,320 --> 00:37:25,990
whatever one is actually interesting to

1976
00:37:25,990 --> 00:37:26,000
 

1977
00:37:26,000 --> 00:37:27,810
you okay

1978
00:37:27,810 --> 00:37:27,820
 

1979
00:37:27,820 --> 00:37:30,160
so if you find a Devi system that I am

1980
00:37:30,160 --> 00:37:30,170
 

1981
00:37:30,170 --> 00:37:31,480
not aware of please look please let me

1982
00:37:31,480 --> 00:37:31,490
 

1983
00:37:31,490 --> 00:37:33,730
know because we want to add it to to the

1984
00:37:33,730 --> 00:37:33,740
 

1985
00:37:33,740 --> 00:37:34,090
list

1986
00:37:34,090 --> 00:37:34,100

1987
00:37:34,100 --> 00:37:36,940
I spent the summer looking at old like

1988
00:37:36,940 --> 00:37:36,950

1989
00:37:36,950 --> 00:37:39,970
using like news nick posts for like

1990
00:37:39,970 --> 00:37:39,980
 

1991
00:37:39,980 --> 00:37:41,800
1990s to find like guys in their

1992
00:37:41,800 --> 00:37:41,810

1993
00:37:41,810 --> 00:37:43,300
basement writing a TV system and we had

1994
00:37:43,300 --> 00:37:43,310
 

1995
00:37:43,310 --> 00:37:46,900
them listed in the system ok so if you

1996
00:37:46,900 --> 00:37:46,910
 

1997
00:37:46,910 --> 00:37:48,490
can't buy a system that interest you

1998
00:37:48,490 --> 00:37:48,500
 

1999
00:37:48,500 --> 00:37:52,000
something's wrong with you all right all

2000
00:37:52,000 --> 00:37:52,010
 

2001
00:37:52,010 --> 00:37:52,870
right and again it goes without saying

2002
00:37:52,870 --> 00:37:52,880
 

2003
00:37:52,880 --> 00:37:54,820
please do not steal please do not

2004
00:37:54,820 --> 00:37:54,830
 

2005
00:37:54,830 --> 00:37:56,200
plagiarize do not take their

2006
00:37:56,200 --> 00:37:56,210

2007
00:37:56,210 --> 00:37:58,300
documentation and copy and paste it

2008
00:37:58,300 --> 00:37:58,310
 

2009
00:37:58,310 --> 00:38:00,550
directly into their into the article

2010
00:38:00,550 --> 00:38:00,560
 

2011
00:38:00,560 --> 00:38:02,920
right you have to provide citations for

2012
00:38:02,920 --> 00:38:02,930
 

2013
00:38:02,930 --> 00:38:04,150
all the information you add to this

2014
00:38:04,150 --> 00:38:04,160
 

2015
00:38:04,160 --> 00:38:05,980
right you say in this date of a sudden

2016
00:38:05,980 --> 00:38:05,990
 

2017
00:38:05,990 --> 00:38:06,790
use two phase locking

2018
00:38:06,790 --> 00:38:06,800
 

2019
00:38:06,800 --> 00:38:09,040
I need a citation to the documentation

2020
00:38:09,040 --> 00:38:09,050
 

2021
00:38:09,050 --> 00:38:12,370
that says they actually do this okay all

2022
00:38:12,370 --> 00:38:12,380
 

2023
00:38:12,380 --> 00:38:13,870
right so I'll post the signup sheet on

2024
00:38:13,870 --> 00:38:13,880
 

2025
00:38:13,880 --> 00:38:16,359
Piazza it's first-come first-serve for

2026
00:38:16,359 --> 00:38:16,369
 

2027
00:38:16,369 --> 00:38:18,040
the different aliases did you know what

2028
00:38:18,040 --> 00:38:18,050

2029
00:38:18,050 --> 00:38:19,480
daters do you want to pick and okay now

2030
00:38:19,480 --> 00:38:19,490
 

2031
00:38:19,490 --> 00:38:20,920
how the list of ones and you know not a

2032
00:38:20,920 --> 00:38:20,930
 

2033
00:38:20,930 --> 00:38:21,940
lot of pic because we've already done

2034
00:38:21,940 --> 00:38:21,950
 

2035
00:38:21,950 --> 00:38:26,740
them and then we will post on the

2036
00:38:26,740 --> 00:38:26,750
 

2037
00:38:26,750 --> 00:38:28,570
website you know further instructions

2038
00:38:28,570 --> 00:38:28,580
 

2039
00:38:28,580 --> 00:38:30,070
with information about how you actually

2040
00:38:30,070 --> 00:38:30,080
 

2041
00:38:30,080 --> 00:38:31,840
you know which should be expected in the

2042
00:38:31,840 --> 00:38:31,850
 

2043
00:38:31,850 --> 00:38:33,310
article and what the different

2044
00:38:33,310 --> 00:38:33,320
 

2045
00:38:33,320 --> 00:38:37,450
categories of features mean okay any

2046
00:38:37,450 --> 00:38:37,460
 

2047
00:38:37,460 --> 00:38:57,180
questions I'll play the game

2048
00:38:57,180 --> 00:38:57,190
 

2049
00:38:57,190 --> 00:38:59,319
homeys on the cutter y'all will goof

2050
00:38:59,319 --> 00:38:59,329
 

2051
00:38:59,329 --> 00:39:01,599
about drink bro quit the bus a cap on

2052
00:39:01,599 --> 00:39:01,609
 

2053
00:39:01,609 --> 00:39:02,770
the ice road

2054
00:39:02,770 --> 00:39:02,780

2055
00:39:02,780 --> 00:39:12,339
on the bow with a blow to the and thank

2056
00:39:12,339 --> 00:39:12,349
 

2057
00:39:12,349 --> 00:39:15,609
eyes when I party by the 12-pack case of

2058
00:39:15,609 --> 00:39:15,619
 

2059
00:39:15,619 --> 00:39:17,799
a bar six-pack for the act against the

2060
00:39:17,799 --> 00:39:17,809

2061
00:39:17,809 --> 00:39:20,950
Real ID replete with your drinking by

2062
00:39:20,950 --> 00:39:20,960
 

2063
00:39:20,960 --> 00:39:23,680
4:12 they say we'll make some flat out

2064
00:39:23,680 --> 00:39:23,690
 

2065
00:39:23,690 --> 00:39:26,020
but sane eyes are straight so it really

2066
00:39:26,020 --> 00:39:26,030
 

2067
00:39:26,030 --> 00:39:28,450
don't matter

